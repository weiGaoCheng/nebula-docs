{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to NebulaGraph 3.8.0 Documentation","text":"<p>Note</p> <p>This manual is revised on 2024-8-15, with GitHub commit 6e2fe03d74.</p> <p>NebulaGraph is a distributed, scalable, and lightning-fast graph database. It is the optimal solution in the world capable of hosting graphs with dozens of billions of vertices (nodes) and trillions of edges (relationships) with millisecond latency.</p>"},{"location":"#getting_started","title":"Getting started","text":"<ul> <li>Quick start</li> <li>Preparations before deployment</li> <li>nGQL cheatsheet</li> <li>FAQ</li> <li>Ecosystem Tools</li> <li>Live Demo</li> </ul>"},{"location":"#release_notes","title":"Release notes","text":"<ul> <li>NebulaGraph Community Edition 3.8.0</li> <li>NebulaGraph Dashboard Community</li> <li>NebulaGraph Studio</li> </ul>"},{"location":"#other_sources","title":"Other Sources","text":"<ul> <li>To cite NebulaGraph</li> <li>Forum</li> <li>NebulaGraph Homepage</li> <li>Blogs</li> <li>Videos</li> <li>Chinese Docs</li> </ul>"},{"location":"#symbols_used_in_this_manual","title":"Symbols used in this manual","text":"<p>Note</p> <p>Additional information or operation-related notes.</p> <p>Caution</p> <p>May have adverse effects, such as causing performance degradation or triggering known minor problems.</p> <p>Warning</p> <p>May lead to serious issues, such as data loss or system crash.</p> <p>Danger</p> <p>May lead to extremely serious issues, such as system damage or information leakage.</p> <p>Compatibility</p> <p>The compatibility notes between nGQL and openCypher, or between the current version of nGQL and its prior ones. </p> <p>Enterpriseonly</p> <p>Differences between the NebulaGraph Community and Enterprise editions.</p>"},{"location":"#modify_errors","title":"Modify errors","text":"<p>This NebulaGraph manual is written in the Markdown language. Users can click the pencil sign on the upper right side of each document title and modify errors.</p>"},{"location":"nebula-bench/","title":"NebulaGraph Bench","text":"<p>NebulaGraph Bench is a performance test tool for NebulaGraph using the LDBC data set.</p>"},{"location":"nebula-bench/#scenario","title":"Scenario","text":"<ul> <li>Generate test data and import NebulaGraph.</li> </ul> <ul> <li>Performance testing in the NebulaGraph cluster.</li> </ul>"},{"location":"nebula-bench/#release_note","title":"Release note","text":"<p>Release</p>"},{"location":"nebula-bench/#test_process","title":"Test process","text":"<p>For detailed usage instructions, see NebulaGraph Bench.</p>"},{"location":"nebula-console/","title":"NebulaGraph Console","text":"<p>NebulaGraph Console is a native CLI client for NebulaGraph. It can be used to connect a NebulaGraph cluster and execute queries. It also supports special commands to manage parameters, export query results, import test datasets, etc.</p>"},{"location":"nebula-console/#compatibility_with_nebulagraph","title":"Compatibility with NebulaGraph","text":"<p>See github.</p>"},{"location":"nebula-console/#obtain_nebulagraph_console","title":"Obtain NebulaGraph Console","text":"<p>You can obtain NebulaGraph Console in the following ways:</p> <ul> <li>Download the binary file from the GitHub releases page.</li> </ul> <ul> <li>Compile the source code to obtain the binary file. For more information, see Install from source code.</li> </ul>"},{"location":"nebula-console/#nebulagraph_console_functions","title":"NebulaGraph Console functions","text":""},{"location":"nebula-console/#connect_to_nebulagraph","title":"Connect to NebulaGraph","text":"<p>To connect to NebulaGraph with the <code>nebula-console</code> file, use the following syntax:</p> <pre><code>&lt;path_of_console&gt; -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <ul> <li><code>path_of_console</code> indicates the storage path of the NebulaGraph Console binary file.</li> <li>When two-way authentication is required after SSL encryption is enabled, you need to specify SSL-related parameters when connecting.</li> </ul> <p>For example:</p> <ul> <li> <p>Connect to NebulaGraph over HTTP/1.1</p> <pre><code>./nebula-console -addr 192.168.8.100 -port 9669 -u root -p nebula\n</code></pre> </li> </ul> <ul> <li> <p>Enable SSL encryption with a private CA certificate</p> <pre><code>./nebula-console -addr 192.168.8.100 -port 9669 -u root  -p nebula -enable_ssl -ssl_root_ca_path /home/xxx/cert/root.crt -ssl_cert_path /home/xxx/cert/client.crt -ssl_private_key_path /home/xxx/cert/client.key\n</code></pre> </li> </ul> <ul> <li> <p>Enable SSL encryption with a trusted CA certificate</p> <pre><code>./nebula-console -addr nebula-graph-ncnj7ss1ssfnnb4eqq88g.aws.dev.cloud.nebula-graph.io -port 9669 -u root -p nebula -enable_ssl \n</code></pre> </li> </ul> <p>Parameter descriptions are as follows:</p> Parameter Description <code>-h/-help</code> Shows the help menu. <code>-addr/-address</code> Sets the IP or hostname of the Graph service. The default address is 127.0.0.1.  <code>-P/-port</code> Sets the port number of the graphd service. The default port number is 9669. <code>-u/-user</code> Sets the username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is <code>root</code>. <code>-p/-password</code> Sets the password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password. If not specified, a prompt appears requesting the password. <code>-t/-timeout</code> Sets an integer-type timeout threshold of the connection. The unit is millisecond. The default value is 120. <code>-e/-eval</code> Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned. <code>-f/-file</code> Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. The result will be returned and the connection stops then. <code>-enable_ssl</code> Enables SSL encryption when connecting to NebulaGraph. <code>-ssl_root_ca_path</code> Sets the path to the root cerificate signed by a private Certifcate Authority (CA). <code>-ssl_cert_path</code> Sets the path to the certificate of the client. <code>-ssl_private_key_path</code> Sets the path to the private key of the client. <code>-ssl_insecure_skip_verify</code> Specifies whether the client skips verifying the server's certificate chain and hostname. The default is <code>false</code>. If set to <code>true</code>, any certificate chain and hostname provided by the server is accepted. <p>For information on more parameters, see the project repository.</p>"},{"location":"nebula-console/#manage_parameters","title":"Manage parameters","text":"<p>You can save parameters for parameterized queries.</p> <p>Note</p> <ul> <li>Setting a parameter as a VID in a query is not supported.</li> </ul> <ul> <li>Parameters are not supported in <code>SAMPLE</code> clauses.</li> </ul> <ul> <li>Parameters are deleted when their sessions are released.</li> </ul> <ul> <li> <p>The command to save a parameter is as follows:</p> <pre><code>nebula&gt; :param &lt;param_name&gt; =&gt; &lt;param_value&gt;;\n</code></pre> <p>The example is as follows:</p> <pre><code>nebula&gt; :param p1 =&gt; \"Tim Duncan\";\nnebula&gt; MATCH (v:player{name:$p1})-[:follow]-&gt;(n)  RETURN v,n;\n+----------------------------------------------------+-------------------------------------------------------+\n| v                                                  | n                                                     |\n+----------------------------------------------------+-------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | (\"player125\" :player{age: 41, name: \"Manu Ginobili\"}) |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | (\"player101\" :player{age: 36, name: \"Tony Parker\"})   |\n+----------------------------------------------------+-------------------------------------------------------+\nnebula&gt; :param p2 =&gt; {\"a\":3,\"b\":false,\"c\":\"Tim Duncan\"};\nnebula&gt; RETURN $p2.b AS b;\n+-------+\n| b     |\n+-------+\n| false |\n+-------+\n</code></pre> </li> </ul> <ul> <li> <p>The command to view the saved parameters is as follows:</p> <pre><code>nebula&gt; :params;\n</code></pre> </li> </ul> <ul> <li> <p>The command to view the specified parameters is as follows:</p> <pre><code>nebula&gt; :params &lt;param_name&gt;;\n</code></pre> </li> </ul> <ul> <li> <p>The command to delete a specified parameter is as follows:</p> <pre><code>nebula&gt; :param &lt;param_name&gt; =&gt;;\n</code></pre> </li> </ul>"},{"location":"nebula-console/#export_query_results","title":"Export query results","text":"<p>Export query results,  which can be saved as a CSV file, DOT file, and a format of Profile or Explain.</p> <p>Note</p> <ul> <li>The exported file is stored in the working directory, i.e., what the linux command <code>pwd</code> shows.</li> </ul> <ul> <li>This command only works for the next query statement.</li> </ul> <ul> <li>You can copy the contents of the DOT file and paste them in GraphvizOnline to generate a visualized execution plan.</li> </ul> <ul> <li> <p>The command to export a csv file is as follows:</p> <pre><code>nebula&gt; :CSV &lt;file_name.csv&gt;;\n</code></pre> </li> </ul> <ul> <li> <p>The command to export a DOT file is as follows:</p> <pre><code>nebula&gt; :dot &lt;file_name.dot&gt;\n</code></pre> <p>The example is as follows:</p> <pre><code>nebula&gt; :dot a.dot\nnebula&gt; PROFILE FORMAT=\"dot\" GO FROM \"player100\" OVER follow;\n</code></pre> </li> </ul> <ul> <li> <p>The command to export a PROFILE or EXPLAIN format is as follows: </p> <p><pre><code>nebula&gt; :profile &lt;file_name&gt;;\n</code></pre> or</p> <pre><code>nebula&gt; :explain &lt;file_name&gt;;\n</code></pre> <p>Note</p> <p>The text file output by the above command is the preferred way to report issues in GitHub and execution plans in forums, and for graph query tuning because it has more information and is more readable than a screenshot or CSV file in Studio.</p> <p>The example is as follows:</p> <pre><code>nebula&gt; :profile profile.log\nnebula&gt; PROFILE GO FROM \"player102\" OVER serve YIELD dst(edge);\nnebula&gt; :profile profile.dot\nnebula&gt; PROFILE FORMAT=\"dot\" GO FROM \"player102\" OVER serve YIELD dst(edge);\nnebula&gt; :explain explain.log\nnebula&gt; EXPLAIN GO FROM \"player102\" OVER serve YIELD dst(edge);\n</code></pre> </li> </ul>"},{"location":"nebula-console/#import_a_testing_dataset","title":"Import a testing dataset","text":"<p>The testing dataset is named <code>basketballplayer</code>. To view details about the schema and data, use the corresponding <code>SHOW</code> command.</p> <p>The command to import a testing dataset is as follows:</p> <pre><code>nebula&gt; :play basketballplayer\n</code></pre>"},{"location":"nebula-console/#run_a_command_multiple_times","title":"Run a command multiple times","text":"<p>To run a command multiple times, use the following command:</p> <pre><code>nebula&gt; :repeat N\n</code></pre> <p>The example is as follows:</p> <pre><code>nebula&gt; :repeat 3\nnebula&gt; GO FROM \"player100\" OVER follow YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player101\" |\n| \"player125\" |\n+-------------+\nGot 2 rows (time spent 2602/3214 us)\n\nFri, 20 Aug 2021 06:36:05 UTC\n\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player101\" |\n| \"player125\" |\n+-------------+\nGot 2 rows (time spent 583/849 us)\n\nFri, 20 Aug 2021 06:36:05 UTC\n\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player101\" |\n| \"player125\" |\n+-------------+\nGot 2 rows (time spent 496/671 us)\n\nFri, 20 Aug 2021 06:36:05 UTC\n\nExecuted 3 times, (total time spent 3681/4734 us), (average time spent 1227/1578 us)\n</code></pre>"},{"location":"nebula-console/#sleep","title":"Sleep","text":"<p>This command will make NebulaGraph Console sleep for N seconds. The schema is altered in an async way and takes effect in the next heartbeat cycle. Therefore, this command is usually used when altering schema. The command is as follows:</p> <pre><code>nebula&gt; :sleep N\n</code></pre>"},{"location":"nebula-console/#disconnect_nebulagraph_console_from_nebulagraph","title":"Disconnect NebulaGraph Console from NebulaGraph","text":"<p>You can use <code>:EXIT</code> or <code>:QUIT</code> to disconnect from NebulaGraph. For convenience, NebulaGraph Console supports using these commands in lower case without the colon (\":\"), such as <code>quit</code>.</p> <p>The example is as follows:</p> <pre><code>nebula&gt; :QUIT\n\nBye root!\n</code></pre>"},{"location":"1.introduction/1.what-is-nebula-graph/","title":"What is NebulaGraph","text":"<p>NebulaGraph is an open-source, distributed, easily scalable, and native graph database. It is capable of hosting graphs with hundreds of billions of vertices and trillions of edges, and serving queries with millisecond-latency. </p> <p></p>"},{"location":"1.introduction/1.what-is-nebula-graph/#what_is_a_graph_database","title":"What is a graph database","text":"<p>A graph database, such as NebulaGraph, is a database that specializes in storing vast graph networks and retrieving information from them. It efficiently stores data as vertices (nodes) and edges (relationships) in labeled property graphs. Properties can be attached to both vertices and edges. Each vertex can have one or multiple tags (labels).</p> <p></p> <p>Graph databases are well suited for storing most kinds of data models abstracted from reality. Things are connected in almost all fields in the world. Modeling systems like relational databases extract the relationships between entities and squeeze them into table columns alone, with their types and properties stored in other columns or even other tables. This makes data management time-consuming and cost-ineffective.</p> <p>NebulaGraph, as a typical native graph database, allows you to store the rich relationships as edges with edge types and properties directly attached to them.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#advantages_of_nebulagraph","title":"Advantages of NebulaGraph","text":""},{"location":"1.introduction/1.what-is-nebula-graph/#open_source","title":"Open source","text":"<p>NebulaGraph is open under the Apache 2.0 License. More and more people such as database developers, data scientists, security experts, and algorithm engineers are participating in the designing and development of NebulaGraph. To join the opening of source code and ideas, surf the NebulaGraph GitHub page.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#outstanding_performance","title":"Outstanding performance","text":"<p>Written in C++ and born for graphs, NebulaGraph handles graph queries in milliseconds. Among most databases, NebulaGraph shows superior performance in providing graph data services. The larger the data size, the greater the superiority of NebulaGraph.For more information, see NebulaGraph benchmarking.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#high_scalability","title":"High scalability","text":"<p>NebulaGraph is designed in a shared-nothing architecture and supports scaling in and out without interrupting the database service.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#developer_friendly","title":"Developer friendly","text":"<p>NebulaGraph supports clients in popular programming languages like Java, Python, C++, and Go, and more are under development. For more information, see NebulaGraph clients.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#reliable_access_control","title":"Reliable access control","text":"<p>NebulaGraph supports strict role-based access control and external authentication servers such as LDAP (Lightweight Directory Access Protocol) servers to enhance data security. For more information, see Authentication and authorization.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#diversified_ecosystem","title":"Diversified ecosystem","text":"<p>More and more native tools of NebulaGraph have been released, such as NebulaGraph Studio, NebulaGraph Console, and NebulaGraph Exchange. For more ecosystem tools, see Ecosystem tools overview.</p> <p>Besides, NebulaGraph has the ability to be integrated with many cutting-edge technologies, such as Spark, Flink, and HBase, for the purpose of mutual strengthening in a world of increasing challenges and chances.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#opencypher-compatible_query_language","title":"OpenCypher-compatible query language","text":"<p>The native NebulaGraph Query Language, also known as nGQL, is a declarative, openCypher-compatible textual query language. It is easy to understand and easy to use. For more information, see nGQL guide.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#future-oriented_hardware_with_balanced_reading_and_writing","title":"Future-oriented hardware with balanced reading and writing","text":"<p>Solid-state drives have extremely high performance and they are getting cheaper. NebulaGraph is a product based on SSD. Compared with products based on HDD and large memory, it is more suitable for future hardware trends and easier to achieve balanced reading and writing.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#easy_data_modeling_and_high_flexibility","title":"Easy data modeling and high flexibility","text":"<p>You can easily model the connected data into NebulaGraph for your business without forcing them into a structure such as a relational table, and properties can be added, updated, and deleted freely. For more information, see Data modeling.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#high_popularity","title":"High popularity","text":"<p>NebulaGraph is being used by tech leaders such as Tencent, Vivo, Meituan, and JD Digits. For more information, visit the NebulaGraph official website.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#use_cases","title":"Use cases","text":"<p>NebulaGraph can be used to support various graph-based scenarios. To spare the time spent on pushing the kinds of data mentioned in this section into relational databases and on bothering with join queries, use NebulaGraph.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#fraud_detection","title":"Fraud detection","text":"<p>Financial institutions have to traverse countless transactions to piece together potential crimes and understand how combinations of transactions and devices might be related to a single fraud scheme. This kind of scenario can be modeled in graphs, and with the help of NebulaGraph, fraud rings and other sophisticated scams can be easily detected.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#real-time_recommendation","title":"Real-time recommendation","text":"<p>NebulaGraph offers the ability to instantly process the real-time information produced by a visitor and make accurate recommendations on articles, videos, products, and services.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#intelligent_question-answer_system","title":"Intelligent question-answer system","text":"<p>Natural languages can be transformed into knowledge graphs and stored in NebulaGraph. A question organized in a natural language can be resolved by a semantic parser in an intelligent question-answer system and re-organized. Then, possible answers to the question can be retrieved from the knowledge graph and provided to the one who asked the question.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#social_networking","title":"Social networking","text":"<p>Information on people and their relationships is typical graph data. NebulaGraph can easily handle the social networking information of billions of people and trillions of relationships, and provide lightning-fast queries for friend recommendations and job promotions in the case of massive concurrency.</p>"},{"location":"1.introduction/1.what-is-nebula-graph/#related_links","title":"Related links","text":"<ul> <li>Official website</li> <li>Docs</li> <li>Blogs</li> <li>Forum</li> <li>GitHub</li> </ul>"},{"location":"1.introduction/2.1.path/","title":"Path types","text":"<p>In graph theory, a path in a graph is a finite or infinite sequence of edges which joins a sequence of vertices. Paths are fundamental concepts of graph theory.</p> <p>Paths can be categorized into 3 types: <code>walk</code>, <code>trail</code>, and <code>path</code>. For more information, see Wikipedia.</p> <p>The following figure is an example for a brief introduction.</p> <p></p>"},{"location":"1.introduction/2.1.path/#walk","title":"Walk","text":"<p>A <code>walk</code> is a finite or infinite sequence of edges. Both vertices and edges can be repeatedly visited in graph traversal.</p> <p>In the above figure C, D, and E form a cycle. So, this figure contains infinite paths, such as <code>A-&gt;B-&gt;C-&gt;D-&gt;E</code>, <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>, and <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C-&gt;D</code>.</p> <p>Note</p> <p><code>GO</code> statements use <code>walk</code>.</p>"},{"location":"1.introduction/2.1.path/#trail","title":"Trail","text":"<p>A <code>trail</code> is a finite sequence of edges. Only vertices can be repeatedly visited in graph traversal. The Seven Bridges of K\u00f6nigsberg is a typical <code>trail</code>.</p> <p>In the above figure, edges cannot be repeatedly visited. So, this figure contains finite paths. The longest path in this figure consists of 5 edges: <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>.</p> <p>Note</p> <p><code>MATCH</code>, <code>FIND PATH</code>, and <code>GET SUBGRAPH</code> statements use <code>trail</code>.</p> <p>There are two special cases of trail, <code>cycle</code> and <code>circuit</code>. The following figure is an example for a brief introduction.</p> <p></p> <ul> <li> <p>cycle</p> <p>A <code>cycle</code> refers to a closed <code>trail</code>. Only the terminal vertices can be repeatedly visited. The longest path in this figure consists of 3 edges: <code>A-&gt;B-&gt;C-&gt;A</code> or <code>C-&gt;D-&gt;E-&gt;C</code>.</p> </li> </ul> <ul> <li> <p>circuit</p> <p>A <code>circuit</code> refers to a closed <code>trail</code>. Edges cannot be repeatedly visited in graph traversal. Apart from the terminal vertices, other vertices can also be repeatedly visited. The longest path in this figure: <code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C-&gt;A</code>.</p> </li> </ul>"},{"location":"1.introduction/2.1.path/#path","title":"Path","text":"<p>A <code>path</code> is a finite sequence of edges. Neither vertices nor edges can be repeatedly visited in graph traversal.</p> <p>So, the above figure contains finite paths. The longest path in this figure consists of 4 edges: <code>A-&gt;B-&gt;C-&gt;D-&gt;E</code>.</p>"},{"location":"1.introduction/2.data-model/","title":"Data modeling","text":"<p>A data model is a model that organizes data and specifies how they are related to one another. This topic describes the Nebula\u00a0Graph data model and provides suggestions for data modeling with NebulaGraph.</p>"},{"location":"1.introduction/2.data-model/#data_structures","title":"Data structures","text":"<p>NebulaGraph data model uses six data structures to store data. They are graph spaces, vertices, edges, tags, edge types and properties.</p> <ul> <li>Graph spaces: Graph spaces are used to isolate data from different teams or programs. Data stored in different graph spaces are securely isolated. Storage replications, privileges, and partitions can be assigned.</li> </ul> <ul> <li>Vertices: Vertices are used to store entities.</li> </ul> <ul> <li> <p>In NebulaGraph, vertices are identified with vertex identifiers (i.e. <code>VID</code>). The <code>VID</code> must be unique in the same graph space. VID should be int64, or fixed_string(N).</p> <ul> <li>A vertex has zero to multiple tags.</li> </ul> <p>Compatibility</p> <p>In NebulaGraph 2.x a vertex must have at least one tag. And in NebulaGraph 3.8.0, a tag is not required for a vertex.</p> </li> </ul> <ul> <li>Edges: Edges are used to connect vertices. An edge is a connection or behavior between two vertices.<ul> <li>There can be multiple edges between two vertices.</li> <li>Edges are directed. <code>-&gt;</code> identifies the directions of edges. Edges can be traversed in either direction.</li> <li>An edge is identified uniquely with <code>&lt;a source vertex, an edge type, a rank value, and a destination vertex&gt;</code>. Edges have no EID.</li> <li>An edge must have one and only one edge type.</li> <li>The rank value is an immutable user-assigned 64-bit signed integer. It identifies the edges with the same edge type between two vertices. Edges are sorted by their rank values. The edge with the greatest rank value is listed first. The default rank value is zero.</li> </ul> </li> </ul> <ul> <li>Tags: Tags are used to categorize vertices. Vertices that have the same tag share the same definition of properties.</li> </ul> <ul> <li>Edge types: Edge types are used to categorize edges. Edges that have the same edge type share the same definition of properties.</li> </ul> <ul> <li>Properties: Properties are key-value pairs. Both vertices and edges are containers for properties.</li> </ul> <p>Note</p> <p>Tags and Edge types are similar to \"vertex tables\" and \"edge tables\" in the relational databases.</p>"},{"location":"1.introduction/2.data-model/#directed_property_graph","title":"Directed property graph","text":"<p>NebulaGraph stores data in directed property graphs. A directed property graph has a set of vertices connected by directed edges. Both vertices and edges can have properties. A directed property graph is represented as:</p> <p>G = &lt; V, E, P<sub>V</sub>, P<sub>E</sub> &gt;</p> <ul> <li>V is a set of vertices.</li> <li>E is a set of directed edges.</li> <li>P<sub>V</sub> is the property of vertices.</li> <li>P<sub>E</sub> is the property of edges.</li> </ul> <p>The following table is an example of the structure of the basketball player dataset. We have two types of vertices, that is player and team, and two types of edges, that is serve and follow.</p> Element Name Property name (Data type) Description Tag player name (string) age (int) Represents players in the team. The properties <code>name</code> and <code>age</code> indicate the name and age. Tag team name (string) Represents the teams. The property <code>name</code> indicates the team name. Edge type serve start_year (int)  end_year (int) Represents the action of a player serving a team. The action links the player to the team, and the direction is from the player to the team.The properties <code>start_year</code> and <code>end_year</code> indicate the start year and end year of the service respectively. Edge type follow degree (int) Represents the action of a player following another player on Twitter. The action links one player to the other player, and the direction is from one player to the other player.The property <code>degree</code> indicates the rating on how well the follower liked the followee. <p>Note</p> <p>NebulaGraph supports only directed edges.</p> <p>Compatibility</p> <p>NebulaGraph 3.8.0 allows dangling edges. Therefore, when adding or deleting, you need to ensure the corresponding source vertex and destination vertex of an edge exist. For details, see INSERT VERTEX, DELETE VERTEX, INSERT EDGE, and DELETE EDGE.</p> <p>The MERGE statement in openCypher is not supported.</p>"},{"location":"1.introduction/3.vid/","title":"VID","text":"<p>In a graph space, a vertex is uniquely identified by its ID, which is called a VID or a Vertex ID.</p>"},{"location":"1.introduction/3.vid/#features","title":"Features","text":"<ul> <li>The data types of VIDs are restricted to <code>FIXED_STRING(&lt;N&gt;)</code> or <code>INT64</code>. One graph space can only select one VID type.</li> </ul> <ul> <li>A VID in a graph space is unique. It functions just as a primary key in a relational database. VIDs in different graph spaces are independent.</li> </ul> <ul> <li>The VID generation method must be set by users, because NebulaGraph does not provide auto increasing ID, or UUID.</li> </ul> <ul> <li> <p>Vertices with the same VID will be identified as the same one. For example:</p> <ul> <li>A VID is the unique identifier of an entity, like a person's ID card number. A tag means the type of an entity,  such as driver, and boss. Different tags define two groups of different properties, such as driving license number, driving age, order amount, order taking alt, and job number, payroll, debt ceiling, business phone number.</li> </ul> <ul> <li>When two <code>INSERT</code> statements (neither uses a parameter of <code>IF NOT EXISTS</code>) with the same VID and tag are operated at the same time, the latter <code>INSERT</code> will overwrite the former.</li> </ul> <ul> <li>When two <code>INSERT</code> statements with the same VID but different tags, like <code>TAG A</code> and <code>TAG B</code>, are operated at the same time, the operation of <code>Tag A</code> will not affect <code>Tag B</code>.</li> </ul> </li> </ul> <ul> <li>VIDs will usually be indexed and stored into memory (in the way of LSM-tree). Thus, direct access to VIDs enjoys peak performance.</li> </ul>"},{"location":"1.introduction/3.vid/#vid_operation","title":"VID Operation","text":"<ul> <li>NebulaGraph 1.x only supports <code>INT64</code> while NebulaGraph 2.x supports <code>INT64</code> and <code>FIXED_STRING(&lt;N&gt;)</code>. In <code>CREATE SPACE</code>, VID types can be set via <code>vid_type</code>.</li> </ul> <ul> <li><code>id()</code> function can be used to specify or locate a VID.</li> </ul> <ul> <li><code>LOOKUP</code> or <code>MATCH</code> statements can be used to find a VID via property index.</li> </ul> <ul> <li>Direct access to vertices statements via VIDs enjoys peak performance, such as <code>DELETE xxx WHERE id(xxx) == \"player100\"</code> or <code>GO FROM \"player100\"</code>. Finding VIDs via properties and then operating the graph will cause poor performance, such as <code>LOOKUP | GO FROM $-.ids</code>, which will run both <code>LOOKUP</code> and <code>|</code> one more time.</li> </ul>"},{"location":"1.introduction/3.vid/#vid_generation","title":"VID Generation","text":"<p>VIDs can be generated via applications. Here are some tips:</p> <ul> <li>(Optimal) Directly take a unique primary key or property as a VID. Property access depends on the VID.</li> </ul> <ul> <li>Generate a VID via a unique combination of properties. Property access depends on property index.</li> </ul> <ul> <li>Generate a VID via algorithms like snowflake. Property access depends on property index.</li> </ul> <ul> <li>If short primary keys greatly outnumber long primary keys, do not enlarge the <code>N</code> of <code>FIXED_STRING(&lt;N&gt;)</code> too much. Otherwise, it will occupy a lot of memory and hard disks, and slow down performance. Generate VIDs via BASE64, MD5, hash by encoding and splicing.</li> </ul> <ul> <li>If you generate int64 VID via hash, the probability of collision is about 1/10 when there are 1 billion vertices. The number of edges has no concern with the probability of collision.</li> </ul>"},{"location":"1.introduction/3.vid/#define_and_modify_a_vid_and_its_data_type","title":"Define and modify a VID and its data type","text":"<p>The data type of a VID must be defined when you create the graph space. Once defined, it cannot be modified.</p> <p>A VID is set when you insert a vertex and cannot be modified. </p>"},{"location":"1.introduction/3.vid/#query_start_vid_and_global_scan","title":"Query <code>start vid</code> and global scan","text":"<p>In most cases, the execution plan of query statements in NebulaGraph (<code>MATCH</code>, <code>GO</code>, and <code>LOOKUP</code>) must query the <code>start vid</code> in a certain way.</p> <p>There are only two ways to locate <code>start vid</code>:</p> <ol> <li> <p>For example, <code>GO FROM \"player100\" OVER</code> explicitly indicates in the statement that <code>start vid</code> is \"player100\".</p> </li> <li> <p>For example, <code>LOOKUP ON player WHERE player.name == \"Tony Parker\"</code> or <code>MATCH (v:player {name:\"Tony Parker\"})</code> locates <code>start vid</code> by the index of the property <code>player.name</code>.</p> </li> </ol>"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/","title":"Architecture overview","text":"<p>NebulaGraph consists of three services: the Graph Service, the Storage Service, and the Meta Service. It applies the separation of storage and computing architecture.</p> <p>Each service has its executable binaries and processes launched from the binaries. Users can deploy a NebulaGraph cluster on a single machine or multiple machines using these binaries.</p> <p>The following figure shows the architecture of a typical NebulaGraph cluster.</p> <p></p>"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#the_meta_service","title":"The Meta Service","text":"<p>The Meta Service in the NebulaGraph architecture is run by the nebula-metad processes. It is responsible for metadata management, such as schema operations, cluster administration, and user privilege management.</p> <p>For details on the Meta Service, see Meta Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/1.architecture-overview/#the_graph_service_and_the_storage_service","title":"The Graph Service and the Storage Service","text":"<p>NebulaGraph applies the separation of storage and computing architecture. The Graph Service is responsible for querying. The Storage Service is responsible for storage. They are run by different processes, i.e., nebula-graphd and nebula-storaged. The benefits of the separation of storage and computing architecture are as follows:</p> <ul> <li>Great scalability<p>The separated structure makes both the Graph Service and the Storage Service flexible and easy to scale in or out.</p> </li> </ul> <ul> <li>High availability<p>If part of the Graph Service fails, the data stored by the Storage Service suffers no loss. And if the rest part of the Graph Service is still able to serve the clients, service recovery can be performed quickly, even unfelt by the users.</p> </li> </ul> <ul> <li>Cost-effective<p>The separation of storage and computing architecture provides a higher resource utilization rate, and it enables clients to manage the cost flexibly according to business demands.</p> </li> </ul> <ul> <li>Open to more possibilities<p>With the ability to run separately, the Graph Service may work with multiple types of storage engines, and the Storage Service may also serve more types of computing engines.</p> </li> </ul> <p>For details on the Graph Service and the Storage Service, see Graph Service and Storage Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/","title":"Meta Service","text":"<p>This topic introduces the architecture and functions of the Meta Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#the_architecture_of_the_meta_service","title":"The architecture of the Meta Service","text":"<p>The architecture of the Meta Service is as follows:</p> <p></p> <p>The Meta Service is run by nebula-metad processes. Users can deploy nebula-metad processes according to the scenario:</p> <ul> <li>In a test environment, users can deploy one or three nebula-metad processes on different machines or a single machine.</li> <li>In a production environment, we recommend that users deploy three nebula-metad processes on different machines for high availability.</li> </ul> <p>All the nebula-metad processes form a Raft-based cluster, with one process as the leader and the others as the followers.</p> <p>The leader is elected by the majorities and only the leader can provide service to the clients or other components of NebulaGraph. The followers will be run in a standby way and each has a data replication of the leader. Once the leader fails, one of the followers will be elected as the new leader.</p> <p>Note</p> <p>The data of the leader and the followers will keep consistent through Raft. Thus the breakdown and election of the leader will not cause data inconsistency. For more information on Raft, see Storage service architecture.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#functions_of_the_meta_service","title":"Functions of the Meta Service","text":""},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_user_accounts","title":"Manages user accounts","text":"<p>The Meta Service stores the information of user accounts and the privileges granted to the accounts. When the clients send queries to the Meta Service through an account, the Meta Service checks the account information and whether the account has the right privileges to execute the queries or not.</p> <p>For more information on NebulaGraph access control, see Authentication.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_partitions","title":"Manages partitions","text":"<p>The Meta Service stores and manages the locations of the storage partitions and helps balance the partitions.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_graph_spaces","title":"Manages graph spaces","text":"<p>NebulaGraph supports multiple graph spaces. Data stored in different graph spaces are securely isolated. The Meta Service stores the metadata of all graph spaces and tracks the changes of them, such as adding or dropping a graph space.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_schema_information","title":"Manages schema information","text":"<p>NebulaGraph is a strong-typed graph database. Its schema contains tags (i.e., the vertex types), edge types, tag properties, and edge type properties.</p> <p>The Meta Service stores the schema information. Besides, it performs the addition, modification, and deletion of the schema, and logs the versions of them.</p> <p>For more information on NebulaGraph schema, see Data model.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_ttl_information","title":"Manages TTL information","text":"<p>The Meta Service stores the definition of TTL (Time to Live) options which are used to control data expiration. The Storage Service takes care of the expiring and evicting processes. For more information, see TTL.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/2.meta-service/#manages_jobs","title":"Manages jobs","text":"<p>The Job Management module in the Meta Service is responsible for the creation, queuing, querying, and deletion of jobs.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/","title":"Graph Service","text":"<p>The Graph Service is used to process the query. It has four submodules: Parser, Validator, Planner, and Executor. This topic will describe the Graph Service accordingly.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#the_architecture_of_the_graph_service","title":"The architecture of the Graph Service","text":"<p>After a query is sent to the Graph Service, it will be processed by the following four submodules:</p> <ol> <li> <p>Parser: Performs lexical analysis and syntax analysis.</p> </li> <li> <p>Validator: Validates the statements.</p> </li> <li> <p>Planner: Generates and optimizes the execution plans.</p> </li> <li> <p>Executor: Executes the plans with operators.</p> </li> </ol>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#parser","title":"Parser","text":"<p>After receiving a request, the statements will be parsed by Parser composed of Flex (lexical analysis tool) and Bison (syntax analysis tool), and its corresponding AST will be generated. Statements will be directly intercepted in this stage because of their invalid syntax.</p> <p>For example, the structure of the AST of <code>GO FROM \"Tim\" OVER like WHERE properties(edge).likeness &gt; 8.0 YIELD dst(edge)</code> is shown in the following figure.</p> <p></p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#validator","title":"Validator","text":"<p>Validator performs a series of validations on the AST. It mainly works on these tasks:</p> <ul> <li>Validating metadata<p>Validator will validate whether the metadata is correct or not.</p> <p>When parsing the <code>OVER</code>, <code>WHERE</code>, and <code>YIELD</code> clauses, Validator looks up the Schema and verifies whether the edge type and tag data exist or not. For an <code>INSERT</code> statement, Validator verifies whether the types of the inserted data are the same as the ones defined in the Schema.</p> </li> </ul> <ul> <li>Validating contextual reference<p>Validator will verify whether the cited variable exists or not, or whether the cited property is variable or not.</p> <p>For composite statements, like <code>$var = GO FROM \"Tim\" OVER like YIELD dst(edge) AS ID; GO FROM $var.ID OVER serve YIELD dst(edge)</code>, Validator verifies first to see if <code>var</code> is defined, and then to check if the <code>ID</code> property is attached to the <code>var</code> variable.</p> </li> </ul> <ul> <li>Validating type inference<p>Validator infers what type the result of an expression is and verifies the type against the specified clause.</p> <p>For example, the <code>WHERE</code> clause requires the result to be a <code>bool</code> value, a <code>NULL</code> value, or <code>empty</code>.</p> </li> </ul> <ul> <li>Validating the information of <code>*</code><p>Validator needs to verify all the Schema that involves <code>*</code> when verifying the clause if there is a <code>*</code> in the statement.</p> <p>Take a statement like <code>GO FROM \"Tim\" OVER * YIELD dst(edge), properties(edge).likeness, dst(edge)</code> as an example. When verifying the <code>OVER</code> clause, Validator needs to verify all the edge types. If the edge type includes <code>like</code> and <code>serve</code>, the statement would be <code>GO FROM \"Tim\" OVER like,serve YIELD dst(edge), properties(edge).likeness, dst(edge)</code>.</p> </li> </ul> <ul> <li>Validating input and output<p>Validator will check the consistency of the clauses before and after the <code>|</code>.</p> <p>In the statement <code>GO FROM \"Tim\" OVER like YIELD dst(edge) AS ID | GO FROM $-.ID OVER serve YIELD dst(edge)</code>, Validator will verify whether <code>$-.ID</code> is defined in the clause before the <code>|</code>.</p> </li> </ul> <p>When the validation succeeds, an execution plan will be generated. Its data structure will be stored in the <code>src/planner</code> directory.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#planner","title":"Planner","text":"<p>In the <code>nebula-graphd.conf</code> file, when <code>enable_optimizer</code> is set to be <code>false</code>, Planner will not optimize the execution plans generated by Validator. It will be executed by Executor directly.</p> <p>In the <code>nebula-graphd.conf</code> file, when <code>enable_optimizer</code> is set to be <code>true</code>, Planner will optimize the execution plans generated by Validator. The structure is as follows.</p> <p></p> <ul> <li>Before optimization<p>In the execution plan on the right side of the preceding figure, each node directly depends on other nodes. For example, the root node <code>Project</code> depends on the <code>Filter</code> node, the <code>Filter</code> node depends on the <code>GetNeighbor</code> node, and so on, up to the leaf node <code>Start</code>. Then the execution plan is (not truly) executed.</p> <p>During this stage, every node has its input and output variables, which are stored in a hash table. The execution plan is not truly executed, so the value of each key in the associated hash table is empty (except for the <code>Start</code> node, where the input variables hold the starting data), and the hash table is defined in <code>src/context/ExecutionContext.cpp</code> under the <code>nebula-graph</code> repository.</p> <p>For example, if the hash table is named as <code>ResultMap</code> when creating the <code>Filter</code> node, users can determine that the node takes data from <code>ResultMap[\"GN1\"]</code>, then puts the result into <code>ResultMap[\"Filter2\"]</code>, and so on. All these work as the input and output of each node.</p> </li> </ul> <ul> <li>Process of optimization<p>The optimization rules that Planner has implemented so far are considered RBO (Rule-Based Optimization), namely the pre-defined optimization rules. The CBO (Cost-Based Optimization) feature is under development. The optimized code is in the <code>src/optimizer/</code> directory under the <code>nebula-graph</code> repository.</p> <p>RBO is a \u201cbottom-up\u201d exploration process. For each rule, the root node of the execution plan (in this case, the <code>Project</code> node) is the entry point, and step by step along with the node dependencies, it reaches the node at the bottom to see if it matches the rule.</p> <p>As shown in the preceding figure, when the <code>Filter</code> node is explored, it is found that its children node is <code>GetNeighbors</code>, which matches successfully with the pre-defined rules, so a transformation is initiated to integrate the <code>Filter</code> node into the <code>GetNeighbors</code> node, the <code>Filter</code> node is removed, and then the process continues to the next rule. Therefore, when the <code>GetNeighbor</code> operator calls interfaces of the Storage layer to get the neighboring edges of a vertex during the execution stage, the Storage layer will directly filter out the unqualified edges internally. Such optimization greatly reduces the amount of data transfer, which is commonly known as filter pushdown.</p> </li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#executor","title":"Executor","text":"<p>The Executor module consists of Scheduler and Executor. The Scheduler generates the corresponding execution operators against the execution plan, starting from the leaf nodes and ending at the root node. The structure is as follows.</p> <p></p> <p>Each node of the execution plan has one execution operator node, whose input and output have been determined in the execution plan. Each operator only needs to get the values for the input variables, compute them, and finally put the results into the corresponding output variables. Therefore, it is only necessary to execute step by step from <code>Start</code>, and the result of the last operator is returned to the user as the final result.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/3.graph-service/#source_code_hierarchy","title":"Source code hierarchy","text":"<p>The source code hierarchy under the nebula-graph repository is as follows.</p> <pre><code>|--src\n   |--graph\n      |--context    //contexts for validation and execution\n      |--executor   //execution operators\n      |--gc         //garbage collector\n      |--optimizer  //optimization rules\n      |--planner    //structure of the execution plans\n      |--scheduler  //scheduler\n      |--service    //external service management\n      |--session    //session management\n      |--stats      //monitoring metrics\n      |--util       //basic components\n      |--validator  //validation of the statements\n      |--visitor    //visitor expression\n</code></pre>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/","title":"Storage Service","text":"<p>The persistent data of NebulaGraph have two parts. One is the Meta Service that stores the meta-related data.</p> <p>The other is the Storage Service that stores the data, which is run by the nebula-storaged process. This topic will describe the architecture of the Storage Service.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#advantages","title":"Advantages","text":"<ul> <li>High performance (Customized built-in KVStore)</li> </ul> <ul> <li>Great scalability (Shared-nothing architecture, not rely on NAS/SAN-like devices)</li> </ul> <ul> <li>Strong consistency (Raft)</li> </ul> <ul> <li>High availability (Raft)</li> </ul> <ul> <li>Supports synchronizing with the third party systems, such as Elasticsearch.</li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#the_architecture_of_the_storage_service","title":"The architecture of the Storage Service","text":"<p>The Storage Service is run by the nebula-storaged process. Users can deploy nebula-storaged processes on different occasions. For example, users can deploy 1 nebula-storaged process in a test environment and deploy 3 nebula-storaged processes in a production environment.</p> <p>All the nebula-storaged processes consist of a Raft-based cluster. There are three layers in the Storage Service:</p> <ul> <li> <p>Storage interface</p> <p>The top layer is the storage interface. It defines a set of APIs that are related to the graph concepts. These API requests will be translated into a set of KV operations targeting the corresponding Partition. For example:</p> <ul> <li><code>getNeighbors</code>: queries the in-edge or out-edge of a set of vertices, returns the edges and the corresponding properties, and supports conditional filtering.</li> </ul> <ul> <li><code>insert vertex/edge</code>: inserts a vertex or edge and its properties.</li> </ul> <ul> <li><code>getProps</code>: gets the properties of a vertex or an edge.</li> </ul> <p>It is this layer that makes the Storage Service a real graph storage. Otherwise, it is just a KV storage.</p> </li> </ul> <ul> <li> <p>Consensus</p> <p>Below the storage interface is the consensus layer that implements Multi Group Raft, which ensures the strong consistency and high availability of the Storage Service.</p> </li> </ul> <ul> <li> <p>Store engine</p> <p>The bottom layer is the local storage engine library, providing operations like <code>get</code>, <code>put</code>, and <code>scan</code> on local disks. The related interfaces are stored in <code>KVStore.h</code> and <code>KVEngine.h</code> files. You can develop your own local store plugins based on your needs.</p> </li> </ul> <p>The following will describe some features of the Storage Service based on the above architecture.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#storage_writing_process","title":"Storage writing process","text":""},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#kvstore","title":"KVStore","text":"<p>NebulaGraph develops and customizes its built-in KVStore for the following reasons.</p> <ul> <li>It is a high-performance KVStore.</li> </ul> <ul> <li>It is provided as a (kv) library and can be easily developed for the filter pushdown purpose. As a strong-typed database, how to provide Schema during pushdown is the key to efficiency for NebulaGraph.</li> </ul> <ul> <li>It has strong data consistency.</li> </ul> <p>Therefore, NebulaGraph develops its own KVStore with RocksDB as the local storage engine. The advantages are as follows.</p> <ul> <li>For multiple local hard disks, NebulaGraph can make full use of its concurrent capacities through deploying multiple data directories.</li> </ul> <ul> <li> <p>The Meta Service manages all the Storage servers. All the partition distribution data and current machine status can be found in the meta service. Accordingly, users can execute a manual load balancing plan in meta service.</p> <p>Note</p> <p>NebulaGraph does not support auto load balancing because auto data transfer will affect online business.</p> </li> </ul> <ul> <li>NebulaGraph provides its own WAL mode so one can customize the WAL. Each partition owns its WAL.</li> </ul> <ul> <li>One NebulaGraph KVStore cluster supports multiple graph spaces, and each graph space has its own partition number and replica copies. Different graph spaces are isolated physically from each other in the same cluster.</li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#data_storage_structure","title":"Data storage structure","text":"<p>Graphs consist of vertices and edges. NebulaGraph uses key-value pairs to store vertices, edges, and their properties. Vertices and edges are stored in keys and their properties are stored in values. Such structure enables efficient property filtering.</p> <ul> <li> <p>The storage structure of vertices</p> <p>Different from NebulaGraph version 2.x, version 3.x added a new key for each vertex. Compared to the old key that still exists, the new key has no <code>TagID</code> field and no value. Vertices in NebulaGraph can now live without tags owing to the new key.</p> <p></p> Field Description <code>Type</code> One byte, used to indicate the key type. <code>PartID</code> Three bytes, used to indicate the sharding partition and to scan the partition data based on the prefix when re-balancing the partition. <code>VertexID</code> The vertex ID. For an integer VertexID, it occupies eight bytes. However, for a string VertexID, it is changed to <code>fixed_string</code> of a fixed length which needs to be specified by users when they create the space. <code>TagID</code> Four bytes, used to indicate the tags that vertex relate with. <code>SerializedValue</code> The serialized value of the key. It stores the property information of the vertex. </li> </ul> <ul> <li>The storage structure of edges<p></p> Field Description <code>Type</code> One byte, used to indicate the key type. <code>PartID</code> Three bytes, used to indicate the partition ID. This field can be used to scan the partition data based on the prefix when re-balancing the partition. <code>VertexID</code> Used to indicate vertex ID. The former VID refers to the source VID in the outgoing edge and the dest VID in the incoming edge, while the latter VID refers to the dest VID in the outgoing edge and the source VID in the incoming edge. <code>Edge Type</code> Four bytes, used to indicate the edge type. Greater than zero indicates out-edge, less than zero means in-edge. <code>Rank</code> Eight bytes, used to indicate multiple edges in one edge type. Users can set the field based on needs and store weight, such as transaction time and transaction number. <code>PlaceHolder</code> One byte. Reserved. <code>SerializedValue</code> The serialized value of the key. It stores the property information of the edge. </li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#property_descriptions","title":"Property descriptions","text":"<p>NebulaGraph uses strong-typed Schema.</p> <p>NebulaGraph will store the properties of vertex and edges in order after encoding them. Since the length of fixed-length properties is fixed, queries can be made in no time according to offset. Before decoding, NebulaGraph needs to get (and cache) the schema information in the Meta Service. In addition, when encoding properties, NebulaGraph will add the corresponding schema version to support online schema change.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#data_partitioning","title":"Data partitioning","text":"<p>Since in an ultra-large-scale relational network, vertices can be as many as tens to hundreds of billions, and edges are even more than trillions. Even if only vertices and edges are stored, the storage capacity of both exceeds that of ordinary servers. Therefore, NebulaGraph uses hash to shard the graph elements and store them in different partitions.</p> <p></p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#edge_partitioning_and_storage_amplification","title":"Edge partitioning and storage amplification","text":"<p>In NebulaGraph, an edge corresponds to two key-value pairs on the hard disk. When there are lots of edges and each has many properties, storage amplification will be obvious. The storage format of edges is shown in the figure below.</p> <p></p> <p>In this example, SrcVertex connects DstVertex via EdgeA, forming the path of <code>(SrcVertex)-[EdgeA]-&gt;(DstVertex)</code>. SrcVertex, DstVertex, and EdgeA will all be stored in Partition x and Partition y as four key-value pairs in the storage layer. Details are as follows:</p> <ul> <li>The key value of SrcVertex is stored in Partition x. Key fields include Type, PartID(x), VID(Src), and TagID. SerializedValue, namely Value, refers to serialized vertex properties.</li> </ul> <ul> <li>The first key value of EdgeA, namely EdgeA_Out, is stored in the same partition as the SrcVertex. Key fields include Type, PartID(x), VID(Src), EdgeType(+ means out-edge), Rank(0), VID(Dst), and PlaceHolder. SerializedValue, namely Value, refers to serialized edge properties.</li> </ul> <ul> <li>The key value of DstVertex is stored in Partition y. Key fields include Type, PartID(y), VID(Dst), and TagID. SerializedValue, namely Value, refers to serialized vertex properties.</li> </ul> <ul> <li>The second key value of EdgeA, namely EdgeA_In, is stored in the same partition as the DstVertex. Key fields include Type, PartID(y), VID(Dst), EdgeType(- means in-edge), Rank(0), VID(Src), and PlaceHolder. SerializedValue, namely Value, refers to serialized edge properties, which is exactly the same as that in EdgeA_Out.</li> </ul> <p>EdgeA_Out and EdgeA_In are stored in storage layer with opposite directions, constituting EdgeA logically. EdgeA_Out is used for traversal requests starting from SrcVertex, such as <code>(a)-[]-&gt;()</code>; EdgeA_In is used for traversal requests starting from DstVertex, such as <code>()-[]-&gt;(a)</code>.</p> <p>Like EdgeA_Out and EdgeA_In, NebulaGraph redundantly stores the information of each edge, which doubles the actual capacities needed for edge storage. The key corresponding to the edge occupies a small hard disk space, but the space occupied by Value is proportional to the length and amount of the property value. Therefore, it will occupy a relatively large hard disk space if the property value of the edge is large or there are many edge property values.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#partition_algorithm","title":"Partition algorithm","text":"<p>NebulaGraph uses a static Hash strategy to shard data through a modulo operation on vertex ID. All the out-keys, in-keys, and tag data will be placed in the same partition. In this way, query efficiency is increased dramatically.</p> <p>Note</p> <p>The number of partitions needs to be determined when users are creating a graph space since it cannot be changed afterward. Users are supposed to take into consideration the demands of future business when setting it.</p> <p>When inserting into NebulaGraph, vertices and edges are distributed across different partitions. And the partitions are located on different machines. The number of partitions is set in the CREATE SPACE statement and cannot be changed afterward.</p> <p>If certain vertices need to be placed on the same partition (i.e., on the same machine), see Formula/code.</p> <p>The following code will briefly describe the relationship between VID and partition.</p> <pre><code>// If VertexID occupies 8 bytes, it will be stored in int64 to be compatible with the version 1.0.\nuint64_t vid = 0;\nif (id.size() == 8) {\n    memcpy(static_cast&lt;void*&gt;(&amp;vid), id.data(), 8);\n} else {\n    MurmurHash2 hash;\n    vid = hash(id.data());\n}\nPartitionID pId = vid % numParts + 1;\n</code></pre> <p>Roughly speaking, after hashing a fixed string to int64, (the hashing of int64 is the number itself), do modulo, and then plus one, namely:</p> <pre><code>pId = vid % numParts + 1;\n</code></pre> <p>Parameters and descriptions of the preceding formula are as follows:</p> Parameter Description <code>%</code> The modulo operation. <code>numParts</code> The number of partitions for the graph space where the <code>VID</code> is located, namely the value of <code>partition_num</code> in the CREATE SPACE statement. <code>pId</code> The ID for the partition where the <code>VID</code> is located. <p>Suppose there are 100 partitions, the vertices with <code>VID</code> 1, 101, and 1001 will be stored on the same partition. But, the mapping between the partition ID and the machine address is random. Therefore, we cannot assume that any two partitions are located on the same machine.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#raft","title":"Raft","text":""},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#raft_implementation","title":"Raft implementation","text":"<p>In a distributed system, one data usually has multiple replicas so that the system can still run normally even if a few copies fail. It requires certain technical means to ensure consistency between replicas.</p> <p>Basic principle: Raft is designed to ensure consistency between replicas. Raft uses election between replicas, and the (candidate) replica that wins more than half of the votes will become the Leader, providing external services on behalf of all replicas. The rest Followers will play backups. When the Leader fails (due to communication failure, operation and maintenance commands, etc.), the rest Followers will conduct a new round of elections and vote for a new Leader. The Leader and Followers will detect each other's survival through heartbeats and write them to the hard disk in Raft-wal mode. Replicas that do not respond to more than multiple heartbeats will be considered faulty.</p> <p>Note</p> <p>Raft-wal needs to be written into the hard disk periodically. If hard disk bottlenecks to write, Raft will fail to send a heartbeat and conduct a new round of elections. If the hard disk IO is severely blocked, there will be no Leader for a long time.</p> <p>Read and write: For every writing request of the clients, the Leader will initiate a Raft-wal and synchronize it with the Followers. Only after over half replicas have received the Raft-wal will it return to the clients successfully. For every reading request of the clients, it will get to the Leader directly, while Followers will not be involved.</p> <p>Failure: Scenario 1: Take a (space) cluster of a single replica as an example. If the system has only one replica, the Leader will be itself. If failure happens, the system will be completely unavailable. Scenario 2: Take a (space) cluster of three replicas as an example. If the system has three replicas, one of them will be the Leader and the rest will be the Followers. If the Leader fails, the rest two can still vote for a new Leader (and a Follower), and the system is still available. But if any of the two Followers fails again, the system will be completely unavailable due to inadequate voters.</p> <p>Note</p> <p>Raft and HDFS have different modes of duplication. Raft is based on a quorum vote, so the number of replicas cannot be even.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#multi_group_raft","title":"Multi Group Raft","text":"<p>The Storage Service supports a distributed cluster architecture, so NebulaGraph implements Multi Group Raft according to Raft protocol. Each Raft group stores all the replicas of each partition. One replica is the leader, while others are followers. In this way, NebulaGraph achieves strong consistency and high availability. The functions of Raft are as follows.</p> <p>NebulaGraph uses Multi Group Raft to improve performance when there are many partitions because Raft-wal cannot be NULL. When there are too many partitions, costs will increase, such as storing information in Raft group, WAL files, or batch operation in low load.</p> <p>There are two key points to implement the Multi Raft Group:</p> <ul> <li> <p>To share transport layer</p> <p>Each Raft Group sends messages to its corresponding peers. So if the transport layer cannot be shared, the connection costs will be very high.</p> </li> </ul> <ul> <li> <p>To share thread pool</p> <p>Raft Groups share the same thread pool to prevent starting too many threads and a high context switch cost.</p> </li> </ul>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#batch","title":"Batch","text":"<p>For each partition, it is necessary to do a batch to improve throughput when writing the WAL serially. As NebulaGraph uses WAL to implement some special functions, batches need to be grouped, which is a feature of NebulaGraph.</p> <p>For example, lock-free CAS operations will execute after all the previous WALs are committed. So for a batch, if there are several WALs in CAS type, we need to divide this batch into several smaller groups and make sure they are committed serially.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#transfer_leadership","title":"Transfer Leadership","text":"<p>Transfer leadership is extremely important for balance. When moving a partition from one machine to another, NebulaGraph first checks if the source is a leader. If so, it should be moved to another peer. After data migration is completed, it is important to balance leader distribution again.</p> <p>When a transfer leadership command is committed, the leader will abandon its leadership and the followers will start a leader election.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#peer_changes","title":"Peer changes","text":"<p>To avoid split-brain, when members in a Raft Group change, an intermediate state is required. In such a state, the quorum of the old group and new group always have an overlap. Thus it prevents the old or new group from making decisions unilaterally. To make it even simpler, in his doctoral thesis Diego Ongaro suggests adding or removing a peer once to ensure the overlap between the quorum of the new group and the old group. NebulaGraph also uses this approach, except that the way to add or remove a member is different. For details, please refer to addPeer/removePeer in the Raft Part class.</p>"},{"location":"1.introduction/3.nebula-graph-architecture/4.storage-service/#differences_with_hdfs","title":"Differences with HDFS","text":"<p>The Storage Service is a Raft-based distributed architecture, which has certain differences with that of HDFS. For example:</p> <ul> <li>The Storage Service ensures consistency through Raft. Usually, the number of its replicas is odd to elect a leader. However, DataNode used by HDFS ensures consistency through NameNode, which has no limit on the number of replicas.</li> </ul> <ul> <li>In the Storage Service, only the replicas of the leader can read and write, while in HDFS all the replicas can do so.</li> </ul> <ul> <li>In the Storage Service, the number of replicas needs to be determined when creating a space, since it cannot be changed afterward. But in HDFS, the number of replicas can be changed freely.</li> </ul> <ul> <li>The Storage Service can access the file system directly. While the applications of HDFS (such as HBase) have to access HDFS before the file system, which requires more RPC times.</li> </ul> <p>In a word, the Storage Service is more lightweight with some functions simplified and its architecture is simpler than HDFS, which can effectively improve the read and write performance of a smaller block of data.</p>"},{"location":"14.client/1.nebula-client/","title":"Clients overview","text":"<p>NebulaGraph supports multiple types of clients for users to connect to and manage the NebulaGraph database.</p> <ul> <li>NebulaGraph Console: the native CLI client</li> </ul> <ul> <li>NebulaGraph CPP: the NebulaGraph client for C++</li> </ul> <ul> <li>NebulaGraph Java: the NebulaGraph client for Java</li> </ul> <ul> <li>NebulaGraph Python: the NebulaGraph client for Python</li> </ul> <ul> <li>NebulaGraph Go: the NebulaGraph client for Golang</li> </ul> <p>Note</p> <p>Only the following classes are thread-safe:</p> <ul> <li>NebulaPool and SessionPool in NebulaGraph Java</li> <li>ConnectionPool and SessionPool in NebulaGraph Go</li> </ul>"},{"location":"14.client/3.nebula-cpp-client/","title":"NebulaGraph CPP","text":"<p>NebulaGraph CPP is a C++ client for connecting to and managing the NebulaGraph database.</p>"},{"location":"14.client/3.nebula-cpp-client/#prerequisites","title":"Prerequisites","text":"<p>You have installed C++ and GCC 4.8 or later versions.</p>"},{"location":"14.client/3.nebula-cpp-client/#compatibility_with_nebulagraph","title":"Compatibility with NebulaGraph","text":"<p>See github.</p>"},{"location":"14.client/3.nebula-cpp-client/#install_nebulagraph_cpp","title":"Install NebulaGraph CPP","text":"<p>This document describes how to install NebulaGraph CPP with the source code.</p>"},{"location":"14.client/3.nebula-cpp-client/#prerequisites_1","title":"Prerequisites","text":"<ul> <li>You have prepared the correct resources.</li> <li>You have installed C++ and GCC version is: {10.1.0 | 9.3.0 | 9.2.0 | 9.1.0 | 8.3.0 | 7.5.0 | 7.1.0}. For details, see the gcc_preset_versions parameter.</li> </ul>"},{"location":"14.client/3.nebula-cpp-client/#steps","title":"Steps","text":"<ol> <li> <p>Clone the NebulaGraph CPP source code to the host.</p> <ul> <li> <p>(Recommended) To install a specific version of NebulaGraph CPP, use the Git option <code>--branch</code> to specify the branch. For example, to install v3.8.0, run the following command:</p> <pre><code>$ git clone --branch release-3.8 https://github.com/vesoft-inc/nebula-cpp.git\n</code></pre> </li> </ul> <ul> <li> <p>To install the daily development version, run the following command to download the source code from the <code>master</code> branch:</p> <pre><code>$ git clone https://github.com/vesoft-inc/nebula-cpp.git\n</code></pre> </li> </ul> </li> <li> <p>Change the working directory to <code>nebula-cpp</code>.</p> <pre><code>$ cd nebula-cpp\n</code></pre> </li> <li> <p>Create a directory named <code>build</code> and change the working directory to it.</p> <pre><code>$ mkdir build &amp;&amp; cd build\n</code></pre> </li> <li> <p>Generate the <code>makefile</code> file with CMake.</p> <p>Note</p> <p>The default installation path is <code>/usr/local/nebula</code>. To modify it, add the <code>-DCMAKE_INSTALL_PREFIX=&lt;installation_path&gt;</code> option while running the following command.</p> <pre><code>$ cmake -DCMAKE_BUILD_TYPE=Release ..\n</code></pre> <p>Note</p> <p>If G++ does not support C++ 11, add the option <code>-DDISABLE_CXX11_ABI=ON</code>.</p> </li> <li> <p>Compile NebulaGraph CPP.</p> <p>To speed up the compiling, use the <code>-j</code> option to set a concurrent number <code>N</code>. It should be \\(\\min(\\text{CPU core number},\\frac{\\text{the memory size(GB)}}{2})\\).</p> <pre><code>$ make -j{N}\n</code></pre> </li> <li> <p>Install NebulaGraph CPP.</p> <pre><code>$ sudo make install\n</code></pre> </li> <li> <p>Update the dynamic link library.</p> <pre><code>$ sudo ldconfig\n</code></pre> </li> </ol>"},{"location":"14.client/3.nebula-cpp-client/#use_nebulagraph_cpp","title":"Use NebulaGraph CPP","text":"<p>Compile the CPP file to an executable file, then you can use it. The following steps take using <code>SessionExample.cpp</code> for example.</p> <ol> <li> <p>Use the example code to create the <code>SessionExample.cpp</code> file.</p> </li> <li> <p>Run the following command to compile the file.</p> <pre><code>$ LIBRARY_PATH=&lt;library_folder_path&gt;:$LIBRARY_PATH g++ -std=c++11 SessionExample.cpp -I&lt;include_folder_path&gt; -lnebula_graph_client -o session_example\n</code></pre> <ul> <li><code>library_folder_path</code>: The storage path of the NebulaGraph dynamic libraries. The default path is <code>/usr/local/nebula/lib64</code>.</li> </ul> <ul> <li><code>include_folder_path</code>: The storage of the NebulaGraph header files. The default path is <code>/usr/local/nebula/include</code>.</li> </ul> </li> </ol> <p>For example:</p> <pre><code>$ LIBRARY_PATH=/usr/local/nebula/lib64:$LIBRARY_PATH g++ -std=c++11 SessionExample.cpp -I/usr/local/nebula/include -lnebula_graph_client -o session_example\n</code></pre>"},{"location":"14.client/3.nebula-cpp-client/#api_reference","title":"API reference","text":"<p>Click here to check the classes and functions provided by the CPP Client.</p>"},{"location":"14.client/3.nebula-cpp-client/#core_of_the_example_code","title":"Core of the example code","text":"<p>Nebula CPP clients provide both Session Pool and Connection Pool methods to connect to NebulaGraph. Using the Connection Pool method requires users to manage session instances by themselves.</p> <ul> <li> <p>Session Pool</p> <p>For more details about all the code, see SessionPoolExample.</p> </li> </ul> <ul> <li> <p>Connection Pool</p> <p>For more details about all the code, see SessionExample.</p> </li> </ul>"},{"location":"14.client/4.nebula-java-client/","title":"NebulaGraph Java","text":"<p>NebulaGraph Java is a Java client for connecting to and managing the NebulaGraph database.</p>"},{"location":"14.client/4.nebula-java-client/#prerequisites","title":"Prerequisites","text":"<p>JDK 8 is installed.</p>"},{"location":"14.client/4.nebula-java-client/#compatibility_with_nebulagraph","title":"Compatibility with NebulaGraph","text":"<p>See github.</p>"},{"location":"14.client/4.nebula-java-client/#download_nebulagraph_java","title":"Download NebulaGraph Java","text":"<ul> <li> <p>(Recommended) To install a specific version of NebulaGraph Java, use the Git option <code>--branch</code> to specify the branch. For example, to install v3.8.0, run the following command:</p> <pre><code>$ git clone --branch release-3.8 https://github.com/vesoft-inc/nebula-java.git\n</code></pre> </li> </ul> <ul> <li> <p>To install the daily development version, run the following command to download the source code from the <code>master</code> branch:</p> <pre><code>$ git clone https://github.com/vesoft-inc/nebula-java.git\n</code></pre> </li> </ul>"},{"location":"14.client/4.nebula-java-client/#use_nebulagraph_java","title":"Use NebulaGraph Java","text":"<p>Note</p> <p>We recommend that each thread use one session. If multiple threads use the same session, the performance will be reduced.</p> <p>When importing a Maven project with tools such as IDEA, set the following dependency in <code>pom.xml</code>.</p> <p>Note</p> <p><code>3.0.0-SNAPSHOT</code> indicates the daily development version that may have unknown issues. We recommend that you replace <code>3.0.0-SNAPSHOT</code> with a released version number to use a table version.</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.vesoft&lt;/groupId&gt;\n  &lt;artifactId&gt;client&lt;/artifactId&gt;\n  &lt;version&gt;3.0.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>If you cannot download the dependency for the daily development version, set the following content in <code>pom.xml</code>. Released versions have no such issue.</p> <pre><code>&lt;repositories&gt; \n  &lt;repository&gt; \n    &lt;id&gt;snapshots&lt;/id&gt; \n    &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt; \n  &lt;/repository&gt; \n&lt;/repositories&gt;\n</code></pre> <p>If there is no Maven to manage the project, manually download the JAR file to install NebulaGraph Java.</p>"},{"location":"14.client/4.nebula-java-client/#api_reference","title":"API reference","text":"<p>Click here to check the classes and functions provided by the Java Client.</p>"},{"location":"14.client/4.nebula-java-client/#core_of_the_example_code","title":"Core of the example code","text":"<p>The NebulaGraph Java client provides both Connection Pool and Session Pool modes, using Connection Pool requires the user to manage session instances.</p> <ul> <li> <p>Session Pool</p> <p>For all the code, see GraphSessionPoolExample.</p> </li> </ul> <ul> <li> <p>Connection Pool</p> <p>For all the code, see GraphClientExample.</p> </li> </ul>"},{"location":"14.client/5.nebula-python-client/","title":"NebulaGraph Python","text":"<p>NebulaGraph Python is a Python client for connecting to and managing the NebulaGraph database.</p>"},{"location":"14.client/5.nebula-python-client/#prerequisites","title":"Prerequisites","text":"<p>You have installed Python 3.6 or later versions.</p>"},{"location":"14.client/5.nebula-python-client/#compatibility_with_nebulagraph","title":"Compatibility with NebulaGraph","text":"<p>See github.</p>"},{"location":"14.client/5.nebula-python-client/#install_nebulagraph_python","title":"Install NebulaGraph Python","text":""},{"location":"14.client/5.nebula-python-client/#install_nebulagraph_python_with_pip","title":"Install NebulaGraph Python with pip","text":"<pre><code>$ pip install nebula3-python==&lt;version&gt;\n</code></pre>"},{"location":"14.client/5.nebula-python-client/#install_nebulagraph_python_from_the_source_code","title":"Install NebulaGraph Python from the source code","text":"<ol> <li> <p>Clone the NebulaGraph Python source code to the host.</p> <ul> <li> <p>(Recommended) To install a specific version of NebulaGraph Python, use the Git option <code>--branch</code> to specify the branch. For example, to install v3.8.0, run the following command:</p> <pre><code>$ git clone --branch release-3.8 https://github.com/vesoft-inc/nebula-python.git\n</code></pre> </li> </ul> <ul> <li> <p>To install the daily development version, run the following command to download the source code from the <code>master</code> branch:</p> <pre><code>$ git clone https://github.com/vesoft-inc/nebula-python.git\n</code></pre> </li> </ul> </li> <li> <p>Change the working directory to nebula-python.</p> <pre><code>$ cd nebula-python\n</code></pre> </li> <li> <p>Run the following command to install NebulaGraph Python.</p> <pre><code>$ pip install .\n</code></pre> </li> </ol>"},{"location":"14.client/5.nebula-python-client/#api_reference","title":"API reference","text":"<p>Click here to check the classes and functions provided by the Python Client.</p>"},{"location":"14.client/5.nebula-python-client/#core_of_the_example_code","title":"Core of the example code","text":"<p>NebulaGraph Python clients provides Connection Pool and Session Pool methods to connect to NebulaGraph. Using the Connection Pool method requires users to manage sessions by themselves.</p> <ul> <li> <p>Session Pool</p> <p>For details about all the code, see SessinPoolExample.py.</p> <p>For limitations of using the Session Pool method, see Example of using session pool.</p> </li> </ul> <ul> <li> <p>Connection Pool</p> <p>For details about all the code, see Example.</p> </li> </ul>"},{"location":"14.client/6.nebula-go-client/","title":"NebulaGraph Go","text":"<p>NebulaGraph Go is a Golang client for connecting to and managing the NebulaGraph database.</p>"},{"location":"14.client/6.nebula-go-client/#prerequisites","title":"Prerequisites","text":"<p>You have installed Golang 1.13 or later versions.</p>"},{"location":"14.client/6.nebula-go-client/#compatibility_with_nebulagraph","title":"Compatibility with NebulaGraph","text":"<p>See github.</p>"},{"location":"14.client/6.nebula-go-client/#download_nebulagraph_go","title":"Download NebulaGraph Go","text":"<ul> <li> <p>(Recommended) To install a specific version of NebulaGraph Go, use the Git option <code>--branch</code> to specify the branch. For example, to install v3.8.0, run the following command:</p> <pre><code>$ git clone --branch release-3.8 https://github.com/vesoft-inc/nebula-go.git\n</code></pre> </li> </ul> <ul> <li> <p>To install the daily development version, run the following command to download the source code from the <code>master</code> branch:</p> <pre><code>$ git clone https://github.com/vesoft-inc/nebula-go.git\n</code></pre> </li> </ul>"},{"location":"14.client/6.nebula-go-client/#install_or_update","title":"Install or update","text":"<p>Run the following command to install or update NebulaGraph Go:</p> <pre><code>$ go get -u -v github.com/vesoft-inc/nebula-go/v3@v3.8.0\n</code></pre>"},{"location":"14.client/6.nebula-go-client/#api_reference","title":"API reference","text":"<p>Click here to check the functions and types provided by the GO Client.</p>"},{"location":"14.client/6.nebula-go-client/#core_of_the_example_code","title":"Core of the example code","text":"<p>The NebulaGraph GO client provides both Connection Pool and Session Pool, using Connection Pool requires the user to manage the session instances.</p> <ul> <li> <p>Session Pool  </p> <p>For details about all the code, see session_pool_example.go.</p> <p>For limitations of using Session Pool, see Usage example.</p> </li> </ul> <ul> <li> <p>Connection Pool</p> <p>For all the code, see graph_client_basic_example and graph_client_goroutines_example.</p> </li> </ul>"},{"location":"14.client/contributed-clients/","title":"Community contributed clients","text":"<p>You can use the following clients developed by community users to connect to and manage NebulaGraph:</p> <ul> <li>NebulaGraph Rust</li> <li>NebulaGraph PHP </li> <li>NebulaGraph Node</li> <li>NebulaGraph .NET</li> </ul>"},{"location":"15.contribution/how-to-contribute/","title":"How to Contribute","text":""},{"location":"15.contribution/how-to-contribute/#before_you_get_started","title":"Before you get started","text":""},{"location":"15.contribution/how-to-contribute/#commit_an_issue_on_the_github_or_forum","title":"Commit an issue on the github or forum","text":"<p>You are welcome to contribute any code or files to the project. But firstly we suggest you raise an issue on the github or the forum to start a discussion with the community. Check through the topic for Github.</p>"},{"location":"15.contribution/how-to-contribute/#sign_the_contributor_license_agreement_cla","title":"Sign the Contributor License Agreement CLA","text":"<ol> <li>Open the CLA sign-in page.</li> <li>Click the Sign in with GitHub button to sign in.</li> <li>Read and agree to the vesoft inc. Contributor License Agreement.</li> </ol> <p>If you have any questions, submit an issue.</p>"},{"location":"15.contribution/how-to-contribute/#modify_a_single_document","title":"Modify a single document","text":"<p>This manual is written in the Markdown language. Click the <code>pencil</code> icon on the right of the document title to commit the modification.</p> <p>This method applies to modifying a single document only.</p>"},{"location":"15.contribution/how-to-contribute/#batch_modify_or_add_files","title":"Batch modify or add files","text":"<p>This method applies to contributing code, modifying multiple documents in batches, or adding new documents.</p>"},{"location":"15.contribution/how-to-contribute/#step_1_fork_in_the_githubcom","title":"Step 1: Fork in the github.com","text":"<p>The NebulaGraph project has many repositories. Take the nebul repository for example:</p> <ol> <li> <p>Visit https://github.com/vesoft-inc/nebula.</p> </li> <li> <p>Click the <code>Fork</code> button to establish an online fork.</p> </li> </ol>"},{"location":"15.contribution/how-to-contribute/#step_2_clone_fork_to_local_storage","title":"Step 2: Clone Fork to Local Storage","text":"<ol> <li> <p>Define a local working directory.</p> <pre><code># Define the working directory.\nworking_dir=$HOME/Workspace\n</code></pre> </li> <li> <p>Set <code>user</code> to match the Github profile name.</p> <pre><code>user={the Github profile name}\n</code></pre> </li> <li> <p>Create your clone.</p> <pre><code>mkdir -p $working_dir\ncd $working_dir\ngit clone https://github.com/$user/nebula.git\n# or: git clone git@github.com:$user/nebula.git\n\ncd $working_dir/nebula\ngit remote add upstream https://github.com/vesoft-inc/nebula.git\n# or: git remote add upstream git@github.com:vesoft-inc/nebula.git\n\n# Never push to upstream master since you do not have write access.\ngit remote set-url --push upstream no_push\n\n# Confirm that the remote branch is valid.\n# The correct format is:\n# origin    git@github.com:$(user)/nebula.git (fetch)\n# origin    git@github.com:$(user)/nebula.git (push)\n# upstream  https://github.com/vesoft-inc/nebula (fetch)\n# upstream  no_push (push)\ngit remote -v\n</code></pre> </li> <li> <p>(Optional) Define a pre-commit hook.</p> <p>Please link the NebulaGraph pre-commit hook into the <code>.git</code> directory.</p> <p>This hook checks the commits for formatting, building, doc generation, etc.</p> <pre><code>cd $working_dir/nebula/.git/hooks\nln -s $working_dir/nebula/.linters/cpp/hooks/pre-commit.sh .\n</code></pre> <p>Sometimes, the pre-commit hook cannot be executed. You have to execute it manually.</p> <pre><code>cd $working_dir/nebula/.git/hooks\nchmod +x pre-commit\n</code></pre> </li> </ol>"},{"location":"15.contribution/how-to-contribute/#step_3_branch","title":"Step 3: Branch","text":"<ol> <li> <p>Get your local master up to date.</p> <pre><code>cd $working_dir/nebula\ngit fetch upstream\ngit checkout master\ngit rebase upstream/master\n</code></pre> </li> <li> <p>Checkout a new branch from master.</p> <pre><code>git checkout -b myfeature\n</code></pre> <p>Note</p> <p>Because the PR often consists of several commits, which might be squashed while being merged into upstream. We strongly suggest you to open a separate topic branch to make your changes on. After merged, this topic branch can be just abandoned, thus you could synchronize your master branch with upstream easily with a rebase like above. Otherwise, if you commit your changes directly into master, you need to use a hard reset on the master branch. For example:</p> <pre><code>git fetch upstream\ngit checkout master\ngit reset --hard upstream/master\ngit push --force origin master\n</code></pre> </li> </ol>"},{"location":"15.contribution/how-to-contribute/#step_4_develop","title":"Step 4: Develop","text":"<ul> <li> <p>Code style</p> <p>NebulaGraph adopts <code>cpplint</code> to make sure that the project conforms to Google's coding style guides. The checker will be implemented before the code is committed.</p> </li> </ul> <ul> <li> <p>Unit tests requirements</p> <p>Please add unit tests for the new features or bug fixes.</p> </li> </ul> <ul> <li> <p>Build your code with unit tests enabled</p> <p>For more information, see Install NebulaGraph by compiling the source code.</p> <p>Note</p> <p>Make sure you have enabled the building of unit tests by setting <code>-DENABLE_TESTING=ON</code>.</p> </li> </ul> <ul> <li> <p>Run tests</p> <p>In the root directory of <code>nebula</code>, run the following command:</p> <pre><code>cd nebula/build\nctest -j$(nproc)\n</code></pre> </li> </ul>"},{"location":"15.contribution/how-to-contribute/#step_5_bring_your_branch_update_to_date","title":"Step 5: Bring Your Branch Update to Date","text":"<pre><code># While on your myfeature branch.\ngit fetch upstream\ngit rebase upstream/master\n</code></pre> <p>Users need to bring the head branch up to date after other contributors merge PR to the base branch.</p>"},{"location":"15.contribution/how-to-contribute/#step_6_commit","title":"Step 6: Commit","text":"<p>Commit your changes.</p> <pre><code>git commit -a\n</code></pre> <p>Users can use the command <code>--amend</code> to re-edit the previous code.</p>"},{"location":"15.contribution/how-to-contribute/#step_7_push","title":"Step 7: Push","text":"<p>When ready to review or just to establish an offsite backup, push your branch to your fork on <code>github.com</code>:</p> <pre><code>git push origin myfeature\n</code></pre>"},{"location":"15.contribution/how-to-contribute/#step_8_create_a_pull_request","title":"Step 8: Create a Pull Request","text":"<ol> <li> <p>Visit your fork at <code>https://github.com/$user/nebula</code> (replace <code>$user</code> here).</p> </li> <li> <p>Click the <code>Compare &amp; pull request</code> button next to your <code>myfeature</code> branch.</p> </li> </ol>"},{"location":"15.contribution/how-to-contribute/#step_9_get_a_code_review","title":"Step 9: Get a Code Review","text":"<p>Once your pull request has been created, it will be assigned to at least two reviewers. Those reviewers will do a thorough code review to make sure that the changes meet the repository's contributing guidelines and other quality standards.</p>"},{"location":"15.contribution/how-to-contribute/#add_test_cases","title":"Add test cases","text":"<p>For detailed methods, see How to add test cases.</p>"},{"location":"15.contribution/how-to-contribute/#donation","title":"Donation","text":""},{"location":"15.contribution/how-to-contribute/#step_1_confirm_the_project_donation","title":"Step 1: Confirm the project donation","text":"<p>Contact the official NebulaGraph staff via email, WeChat, Slack, etc. to confirm the donation project. The project will be donated to the NebulaGraph Contrib organization.</p> <p>Email address: info@vesoft.com</p> <p>WeChat: NebulaGraphbot</p> <p>Slack: Join Slack</p>"},{"location":"15.contribution/how-to-contribute/#step_2_get_the_information_of_the_project_recipient","title":"Step 2: Get the information of the project recipient","text":"<p>The NebulaGraph official staff will give the recipient ID of the NebulaGraph Contrib project.</p>"},{"location":"15.contribution/how-to-contribute/#step_3_donate_a_project","title":"Step 3: Donate a project","text":"<p>The user transfers the project to the recipient of this donation, and the recipient transfers the project to the NebulaGraph Contrib organization. After the donation, the user will continue to lead the development of community projects as a Maintainer.</p> <p>For operations of transferring a repository on GitHub, see Transferring a repository owned by your user account.</p>"},{"location":"2.quick-start/1.quick-start-workflow/","title":"Quickly deploy NebulaGraph using Docker","text":"<p>You can quickly get started with NebulaGraph by deploying NebulaGraph with Docker Desktop or Docker Compose. </p> Using Docker DesktopUsing Docker Compose <p>NebulaGraph is available as a Docker Extension that you can easily install and run on your Docker Desktop. You can quickly deploy NebulaGraph using Docker Desktop with just one click.</p> <ol> <li> <p>Install Docker Desktop.</p> <p>Caution</p> <p>We do not recommend you deploy NebulaGraph on Docker Desktop for Windows due to its subpar performance. For details, see #12401. If you must use Docker Desktop for Windows, install WSL 2 first.</p> </li> <li> <p>In the left sidebar of Docker Desktop, click Extensions or Add Extensions.</p> </li> <li> <p>On the Extensions Marketplace, search for NebulaGraph and click Install.</p> <p></p> <p>Click Update to update NebulaGraph to the latest version when a new version is available.</p> <p></p> </li> <li> <p>Click Open to navigate to the NebulaGraph extension page.</p> </li> <li> <p>At the top of the page, click Studio in Browser to use NebulaGraph.</p> </li> </ol> <p>For more information about how to use NebulaGraph with Docker Desktop, see the following video:</p> <p></p> <p>Using Docker Compose can quickly deploy NebulaGraph services based on the prepared configuration file. It is only recommended to use this method when testing the functions of NebulaGraph.</p>"},{"location":"2.quick-start/1.quick-start-workflow/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>You have installed the following applications on your host.</p> Application Recommended version Official installation reference Docker Latest Install Docker Engine Docker Compose Latest Install Docker Compose Git Latest Download Git </li> </ul> <ul> <li>If you are deploying NebulaGraph as a non-root user, grant the user with Docker-related privileges. For detailed instructions, see Manage Docker as a non-root user.</li> </ul> <ul> <li>You have started the Docker service on your host.</li> </ul> <ul> <li>If you have already deployed another version of NebulaGraph with Docker Compose on your host, to avoid compatibility issues, you need to delete the <code>nebula-docker-compose/data</code> directory.</li> </ul>"},{"location":"2.quick-start/1.quick-start-workflow/#deploy_nebulagraph","title":"Deploy NebulaGraph","text":"<ol> <li> <p>Clone the <code>3.8.0</code> branch of the <code>nebula-docker-compose</code> repository to your host with Git.</p> <p>Danger</p> <p>The <code>master</code> branch contains the untested code for the latest NebulaGraph development release. DO NOT use this release in a production environment.</p> <pre><code>$ git clone -b release-3.8 https://github.com/vesoft-inc/nebula-docker-compose.git\n</code></pre> <p>Note</p> <p>The <code>x.y</code> version of Docker Compose aligns to the <code>x.y</code> version of NebulaGraph. For the NebulaGraph <code>z</code> version, Docker Compose does not publish the corresponding <code>z</code> version, but pulls the <code>z</code> version of the NebulaGraph image.</p> </li> <li> <p>Go to the <code>nebula-docker-compose</code> directory.</p> <pre><code>$ cd nebula-docker-compose/\n</code></pre> </li> <li> <p>Run the following command to start all the NebulaGraph services.</p> <p>Note</p> <ul> <li>Update the NebulaGraph images and NebulaGraph Console images first if they are out of date.</li> <li>The return result after executing the command varies depending on the installation directory.</li> </ul> <pre><code>[nebula-docker-compose]$ docker-compose up -d\nCreating nebula-docker-compose_metad0_1 ... done\nCreating nebula-docker-compose_metad2_1 ... done\nCreating nebula-docker-compose_metad1_1 ... done\nCreating nebula-docker-compose_graphd2_1   ... done\nCreating nebula-docker-compose_graphd_1    ... done\nCreating nebula-docker-compose_graphd1_1   ... done\nCreating nebula-docker-compose_storaged0_1 ... done\nCreating nebula-docker-compose_storaged2_1 ... done\nCreating nebula-docker-compose_storaged1_1 ... done\n</code></pre> <p>Compatibility</p> <p>Starting from NebulaGraph version 3.1.0, nebula-docker-compose automatically starts a NebulaGraph Console docker container and adds the storage host to the cluster (i.e. <code>ADD HOSTS</code> command).</p> <p>Note</p> <p>For more information of the preceding services, see NebulaGraph architecture.</p> </li> </ol>"},{"location":"2.quick-start/1.quick-start-workflow/#connect_to_nebulagraph","title":"Connect to NebulaGraph","text":"<p>There are two ways to connect to NebulaGraph:</p> <ul> <li>Connected with Nebula Console outside the container. Because the external mapping port for the Graph service is also fixed as <code>9669</code> in the container's configuration file, you can connect directly through the default port. For details, see Connect to NebulaGraph.</li> </ul> <ul> <li>Log into the container installed NebulaGraph Console, then connect to the Graph service. This section describes this approach.</li> </ul> <ol> <li> <p>Run the following command to view the name of NebulaGraph Console docker container.</p> <pre><code>$ docker-compose ps\n          Name                         Command             State                 Ports\n--------------------------------------------------------------------------------------------\nnebula-docker-compose_console_1     sh -c sleep 3 &amp;&amp;          Up\n                                  nebula-co ...\n......\n</code></pre> </li> <li> <p>Run the following command to enter the NebulaGraph Console docker container.</p> <pre><code>docker exec -it nebula-docker-compose_console_1 /bin/sh\n/ #\n</code></pre> </li> <li> <p>Connect to NebulaGraph with NebulaGraph Console.</p> <pre><code>/ # ./usr/local/bin/nebula-console -u &lt;user_name&gt; -p &lt;password&gt; --address=graphd --port=9669\n</code></pre> <p>Note</p> <p>By default, the authentication is off, you can only log in with an existing username (the default is <code>root</code>) and any password. To turn it on, see Enable authentication.</p> </li> <li> <p>Run the following commands to view the cluster state.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+-------------+------+----------+--------------+----------------------+------------------------+---------+\n| Host        | Port | Status   | Leader count | Leader distribution  | Partition distribution | Version |\n+-------------+------+----------+--------------+----------------------+------------------------+---------+\n| \"storaged0\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n| \"storaged1\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n| \"storaged2\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n+-------------+------+----------+--------------+----------------------+------------------------+---------+\n</code></pre> </li> </ol> <p>Run <code>exit</code> twice to switch back to your terminal (shell).</p>"},{"location":"2.quick-start/1.quick-start-workflow/#check_the_nebulagraph_service_status_and_ports","title":"Check the NebulaGraph service status and ports","text":"<p>Run <code>docker-compose ps</code> to list all the services of NebulaGraph and their status and ports.</p> <p>Note</p> <p>NebulaGraph provides services to the clients through port <code>9669</code> by default. To use other ports, modify the <code>docker-compose.yaml</code> file in the <code>nebula-docker-compose</code> directory and restart the NebulaGraph services.</p> <pre><code>$ docker-compose ps\nnebula-docker-compose_console_1     sh -c sleep 3 &amp;&amp;                 Up\n                                  nebula-co ...\nnebula-docker-compose_graphd1_1     /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49174-&gt;19669/tcp,:::49174-&gt;19669/tcp, 0.0.0.0:49171-&gt;19670/tcp,:::49171-&gt;19670/tcp, 0.0.0.0:49177-&gt;9669/tcp,:::49177-&gt;9669/tcp\nnebula-docker-compose_graphd2_1     /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49175-&gt;19669/tcp,:::49175-&gt;19669/tcp, 0.0.0.0:49172-&gt;19670/tcp,:::49172-&gt;19670/tcp, 0.0.0.0:49178-&gt;9669/tcp,:::49178-&gt;9669/tcp\nnebula-docker-compose_graphd_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49180-&gt;19669/tcp,:::49180-&gt;19669/tcp, 0.0.0.0:49179-&gt;19670/tcp,:::49179-&gt;19670/tcp, 0.0.0.0:9669-&gt;9669/tcp,:::9669-&gt;9669/tcp\nnebula-docker-compose_metad0_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49157-&gt;19559/tcp,:::49157-&gt;19559/tcp, 0.0.0.0:49154-&gt;19560/tcp,:::49154-&gt;19560/tcp, 0.0.0.0:49160-&gt;9559/tcp,:::49160-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_metad1_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49156-&gt;19559/tcp,:::49156-&gt;19559/tcp, 0.0.0.0:49153-&gt;19560/tcp,:::49153-&gt;19560/tcp, 0.0.0.0:49159-&gt;9559/tcp,:::49159-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_metad2_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49158-&gt;19559/tcp,:::49158-&gt;19559/tcp, 0.0.0.0:49155-&gt;19560/tcp,:::49155-&gt;19560/tcp, 0.0.0.0:49161-&gt;9559/tcp,:::49161-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_storaged0_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49166-&gt;19779/tcp,:::49166-&gt;19779/tcp, 0.0.0.0:49163-&gt;19780/tcp,:::49163-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49169-&gt;9779/tcp,:::49169-&gt;9779/tcp, 9780/tcp\nnebula-docker-compose_storaged1_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49165-&gt;19779/tcp,:::49165-&gt;19779/tcp, 0.0.0.0:49162-&gt;19780/tcp,:::49162-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49168-&gt;9779/tcp,:::49168-&gt;9779/tcp, 9780/tcp\nnebula-docker-compose_storaged2_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49167-&gt;19779/tcp,:::49167-&gt;19779/tcp, 0.0.0.0:49164-&gt;19780/tcp,:::49164-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49170-&gt;9779/tcp,:::49170-&gt;9779/tcp, 9780/tcp\n</code></pre> <p>If the service is abnormal, you can first confirm the abnormal container name (such as <code>nebula-docker-compose_graphd2_1</code>).</p> <p>Then you can execute <code>docker ps</code> to view the corresponding <code>CONTAINER ID</code> (such as <code>2a6c56c405f5</code>).</p> <pre><code>[nebula-docker-compose]$ docker ps\nCONTAINER ID   IMAGE                               COMMAND                  CREATED          STATUS                    PORTS                                                                                                  NAMES\n2a6c56c405f5   vesoft/nebula-graphd:nightly     \"/usr/local/nebula/b\u2026\"   36 minutes ago   Up 36 minutes (healthy)   0.0.0.0:49230-&gt;9669/tcp, 0.0.0.0:49229-&gt;19669/tcp, 0.0.0.0:49228-&gt;19670/tcp                            nebula-docker-compose_graphd2_1\n7042e0a8e83d   vesoft/nebula-storaged:nightly   \"./bin/nebula-storag\u2026\"   36 minutes ago   Up 36 minutes (healthy)   9777-9778/tcp, 9780/tcp, 0.0.0.0:49227-&gt;9779/tcp, 0.0.0.0:49226-&gt;19779/tcp, 0.0.0.0:49225-&gt;19780/tcp   nebula-docker-compose_storaged2_1\n18e3ea63ad65   vesoft/nebula-storaged:nightly   \"./bin/nebula-storag\u2026\"   36 minutes ago   Up 36 minutes (healthy)   9777-9778/tcp, 9780/tcp, 0.0.0.0:49219-&gt;9779/tcp, 0.0.0.0:49218-&gt;19779/tcp, 0.0.0.0:49217-&gt;19780/tcp   nebula-docker-compose_storaged0_1\n4dcabfe8677a   vesoft/nebula-graphd:nightly     \"/usr/local/nebula/b\u2026\"   36 minutes ago   Up 36 minutes (healthy)   0.0.0.0:49224-&gt;9669/tcp, 0.0.0.0:49223-&gt;19669/tcp, 0.0.0.0:49222-&gt;19670/tcp                            nebula-docker-compose_graphd1_1\na74054c6ae25   vesoft/nebula-graphd:nightly     \"/usr/local/nebula/b\u2026\"   36 minutes ago   Up 36 minutes (healthy)   0.0.0.0:9669-&gt;9669/tcp, 0.0.0.0:49221-&gt;19669/tcp, 0.0.0.0:49220-&gt;19670/tcp                             nebula-docker-compose_graphd_1\n880025a3858c   vesoft/nebula-storaged:nightly   \"./bin/nebula-storag\u2026\"   36 minutes ago   Up 36 minutes (healthy)   9777-9778/tcp, 9780/tcp, 0.0.0.0:49216-&gt;9779/tcp, 0.0.0.0:49215-&gt;19779/tcp, 0.0.0.0:49214-&gt;19780/tcp   nebula-docker-compose_storaged1_1\n45736a32a23a   vesoft/nebula-metad:nightly      \"./bin/nebula-metad \u2026\"   36 minutes ago   Up 36 minutes (healthy)   9560/tcp, 0.0.0.0:49213-&gt;9559/tcp, 0.0.0.0:49212-&gt;19559/tcp, 0.0.0.0:49211-&gt;19560/tcp                  nebula-docker-compose_metad0_1\n3b2c90eb073e   vesoft/nebula-metad:nightly      \"./bin/nebula-metad \u2026\"   36 minutes ago   Up 36 minutes (healthy)   9560/tcp, 0.0.0.0:49207-&gt;9559/tcp, 0.0.0.0:49206-&gt;19559/tcp, 0.0.0.0:49205-&gt;19560/tcp                  nebula-docker-compose_metad2_1\n7bb31b7a5b3f   vesoft/nebula-metad:nightly      \"./bin/nebula-metad \u2026\"   36 minutes ago   Up 36 minutes (healthy)   9560/tcp, 0.0.0.0:49210-&gt;9559/tcp, 0.0.0.0:49209-&gt;19559/tcp, 0.0.0.0:49208-&gt;19560/tcp                  nebula-docker-compose_metad1_1\n</code></pre> <p>Use the <code>CONTAINER ID</code> to log in the container and troubleshoot.</p> <pre><code>nebula-docker-compose]$ docker exec -it 2a6c56c405f5 bash\n[root@2a6c56c405f5 nebula]#\n</code></pre>"},{"location":"2.quick-start/1.quick-start-workflow/#check_the_service_data_and_logs","title":"Check the service data and logs","text":"<p>All the data and logs of NebulaGraph are stored persistently in the <code>nebula-docker-compose/data</code> and <code>nebula-docker-compose/logs</code> directories.</p> <p>The structure of the directories is as follows:</p> <pre><code>nebula-docker-compose/\n  |-- docker-compose.yaml\n  \u251c\u2500\u2500 data\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta0\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta1\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta2\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 storage0\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 storage1\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 storage2\n  \u2514\u2500\u2500 logs\n      \u251c\u2500\u2500 graph\n      \u251c\u2500\u2500 graph1\n      \u251c\u2500\u2500 graph2\n      \u251c\u2500\u2500 meta0\n      \u251c\u2500\u2500 meta1\n      \u251c\u2500\u2500 meta2\n      \u251c\u2500\u2500 storage0\n      \u251c\u2500\u2500 storage1\n      \u2514\u2500\u2500 storage2\n</code></pre>"},{"location":"2.quick-start/1.quick-start-workflow/#stop_the_nebulagraph_services","title":"Stop the NebulaGraph services","text":"<p>You can run the following command to stop the NebulaGraph services:</p> <pre><code>$ docker-compose down\n</code></pre> <p>The following information indicates you have successfully stopped the NebulaGraph services:</p> <pre><code>Stopping nebula-docker-compose_console_1   ... done\nStopping nebula-docker-compose_graphd1_1   ... done\nStopping nebula-docker-compose_graphd_1    ... done\nStopping nebula-docker-compose_graphd2_1   ... done\nStopping nebula-docker-compose_storaged1_1 ... done\nStopping nebula-docker-compose_storaged0_1 ... done\nStopping nebula-docker-compose_storaged2_1 ... done\nStopping nebula-docker-compose_metad2_1    ... done\nStopping nebula-docker-compose_metad0_1    ... done\nStopping nebula-docker-compose_metad1_1    ... done\nRemoving nebula-docker-compose_console_1   ... done\nRemoving nebula-docker-compose_graphd1_1   ... done\nRemoving nebula-docker-compose_graphd_1    ... done\nRemoving nebula-docker-compose_graphd2_1   ... done\nRemoving nebula-docker-compose_storaged1_1 ... done\nRemoving nebula-docker-compose_storaged0_1 ... done\nRemoving nebula-docker-compose_storaged2_1 ... done\nRemoving nebula-docker-compose_metad2_1    ... done\nRemoving nebula-docker-compose_metad0_1    ... done\nRemoving nebula-docker-compose_metad1_1    ... done\nRemoving network nebula-docker-compose_nebula-net\n</code></pre> <p>Danger</p> <p>The parameter <code>-v</code> in the command <code>docker-compose down -v</code> will delete all your local NebulaGraph storage data. Try this command if you are using the nightly release and having some compatibility issues.</p>"},{"location":"2.quick-start/1.quick-start-workflow/#modify_configurations","title":"Modify configurations","text":"<p>The configuration file of NebulaGraph deployed by Docker Compose is <code>nebula-docker-compose/docker-compose.yaml</code>. To make the new configuration take effect, modify the configuration in this file and restart the service.</p> <p>For more instructions, see Configurations.</p>"},{"location":"2.quick-start/1.quick-start-workflow/#faq","title":"FAQ","text":""},{"location":"2.quick-start/1.quick-start-workflow/#how_to_fix_the_docker_mapping_to_external_ports","title":"How to fix the docker mapping to external ports?","text":"<p>To set the <code>ports</code> of corresponding services as fixed mapping, modify the <code>docker-compose.yaml</code> in the <code>nebula-docker-compose</code> directory. For example:</p> <pre><code>graphd:\n    image: vesoft/nebula-graphd:release-3.6\n    ...\n    ports:\n      - 9669:9669\n      - 19669\n      - 19670\n</code></pre> <p><code>9669:9669</code> indicates the internal port 9669 is uniformly mapped to external ports, while <code>19669</code> indicates the internal port 19669 is randomly mapped to external ports.</p>"},{"location":"2.quick-start/1.quick-start-workflow/#how_to_upgrade_or_update_the_docker_images_of_nebulagraph_services","title":"How to upgrade or update the docker images of NebulaGraph services","text":"<ol> <li> <p>In the <code>nebula-docker-compose/docker-compose.yaml</code> file, change all the <code>image</code> values to the required image version.</p> </li> <li> <p>In the <code>nebula-docker-compose</code> directory, run <code>docker-compose pull</code> to update the images of the Graph Service, Storage Service, Meta Service, and NebulaGraph Console.</p> </li> <li> <p>Run <code>docker-compose up -d</code> to start the NebulaGraph services again.</p> </li> <li> <p>After connecting to NebulaGraph with NebulaGraph Console, run <code>SHOW HOSTS GRAPH</code>, <code>SHOW HOSTS STORAGE</code>, or <code>SHOW HOSTS META</code> to check the version of the responding service respectively.</p> </li> </ol>"},{"location":"2.quick-start/1.quick-start-workflow/#error_toomanyrequests_when_docker-compose_pull","title":"<code>ERROR: toomanyrequests</code> when <code>docker-compose pull</code>","text":"<p>You may meet the following error.</p> <p><code>ERROR: toomanyrequests: You have reached your pull rate limit. You may increase the limit by authenticating and upgrading: https://www.docker.com/increase-rate-limit</code>.</p> <p>You have met the rate limit of Docker Hub. Learn more on Understanding Docker Hub Rate Limiting.</p>"},{"location":"2.quick-start/1.quick-start-workflow/#how_to_update_the_nebulagraph_console_client","title":"How to update the NebulaGraph Console client","text":"<p>The command <code>docker-compose pull</code> updates both the NebulaGraph services and the NebulaGraph Console.</p>"},{"location":"2.quick-start/2.install-nebula-graph/","title":"Step 1: Install NebulaGraph","text":"<p>RPM and DEB are common package formats on Linux systems. This topic shows how to quickly install NebulaGraph with the RPM or DEB package.</p> <p>Note</p> <p>The console is not complied or packaged with NebulaGraph server binaries. You can install nebula-console by yourself.</p>"},{"location":"2.quick-start/2.install-nebula-graph/#prerequisites","title":"Prerequisites","text":"<ul> <li>The tool <code>wget</code> is installed.</li> </ul>"},{"location":"2.quick-start/2.install-nebula-graph/#step_1_download_the_package_from_cloud_service","title":"Step 1: Download the package from cloud service","text":"<p>Note</p> <p>NebulaGraph is currently only supported for installation on Linux systems, and only CentOS 7.x, CentOS 8.x, Ubuntu 16.04, Ubuntu 18.04, and Ubuntu 20.04 operating systems are supported. </p> <ul> <li>Download the released version.<p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the release package <code>3.8.0</code> for <code>Centos 7.5</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>Download the release package <code>3.8.0</code> for <code>Ubuntu 1804</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul> <ul> <li> <p>Download the nightly version.</p> <p>Danger</p> <ul> <li>Nightly versions are usually used to test new features. Do not use it in a production environment.</li> <li>Nightly versions may not be built successfully every night. And the names may change from day to day.</li> </ul> <p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the <code>Centos 7.5</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>For example, download the <code>Ubuntu 1804</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul>"},{"location":"2.quick-start/2.install-nebula-graph/#step_2_install_nebulagraph","title":"Step 2: Install NebulaGraph","text":"<ul> <li> <p>Use the following syntax to install with an RPM package.</p> <pre><code>$ sudo rpm -ivh --prefix=&lt;installation_path&gt; &lt;package_name&gt;\n</code></pre> <p>The option <code>--prefix</code> indicates the installation path. The default path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install an RPM package in the default path for the 3.8.0 version, run the following command.</p> <pre><code>sudo rpm -ivh nebula-graph-3.8.0.el7.x86_64.rpm\n</code></pre> </li> </ul> <ul> <li> <p>Use the following syntax to install with a DEB package.</p> <pre><code>$ sudo dpkg -i &lt;package_name&gt;\n</code></pre> <p>Note</p> <p>Customizing the installation path is not supported when installing NebulaGraph with a DEB package. The default installation path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install a DEB package for the 3.8.0 version, run the following command.</p> <pre><code>sudo dpkg -i nebula-graph-3.8.0.ubuntu1804.amd64.deb\n</code></pre> <p>Note</p> <p>The default installation path is <code>/usr/local/nebula/</code>.</p> </li> </ul>"},{"location":"2.quick-start/2.install-nebula-graph/#next_to_do","title":"Next to do","text":"<ul> <li>Start NebulaGraph </li> </ul> <ul> <li>Connect to NebulaGraph</li> </ul>"},{"location":"2.quick-start/3.1add-storage-hosts/","title":"Register the Storage Service","text":"<p>When connecting to NebulaGraph for the first time, you have to add the Storage hosts, and confirm that all the hosts are online.</p> <p>Compatibility</p> <ul> <li>Starting from NebulaGraph 3.0.0, you have to run <code>ADD HOSTS</code> before reading or writing data into the Storage Service.</li> <li>For NebulaGraph of versions earlier than 3.0.0 and NebulaGraph Cloud clusters, <code>ADD HOSTS</code> is not needed. </li> </ul>"},{"location":"2.quick-start/3.1add-storage-hosts/#prerequisites","title":"Prerequisites","text":"<p>You have connected to NebulaGraph.</p>"},{"location":"2.quick-start/3.1add-storage-hosts/#steps","title":"Steps","text":"<ol> <li> <p>Add the Storage hosts.</p> <p>Run the following command to add hosts:</p> <pre><code>ADD HOSTS &lt;ip&gt;:&lt;port&gt; [,&lt;ip&gt;:&lt;port&gt; ...];\n</code></pre> <p>Example\uff1a</p> <pre><code>nebula&gt; ADD HOSTS 192.168.10.100:9779, 192.168.10.101:9779, 192.168.10.102:9779;\n</code></pre> <p>Caution</p> <p>Make sure that the IP you added is the same as the IP configured for <code>local_ip</code> in the <code>nebula-storaged.conf</code> file. Otherwise, the Storage service will fail to start. For information about configurations, see Configurations.  </p> </li> <li> <p>Check the status of the hosts to make sure that they are all online.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+------------------+------+----------+--------------+----------------------  +------------------------+---------+\n| Host             | Port | Status   | Leader count | Leader distribution  |   Partition distribution | Version |\n+------------------+------+----------+--------------+----------------------  +------------------------+---------+\n| \"192.168.10.100\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No   valid partition\"   | \"3.8.0\" |\n| \"192.168.10.101\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No   valid partition\"   | \"3.8.0\"|\n| \"192.168.10.102\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No   valid partition\"   | \"3.8.0\"|\n+------------------+------+----------+--------------+----------------------  +------------------------+---------+\n</code></pre> <p>The <code>Status</code> column of the result above shows that all Storage hosts are online.</p> </li> </ol>"},{"location":"2.quick-start/3.connect-to-nebula-graph/","title":"Step 3: Connect to NebulaGraph","text":"<p>This topic provides basic instruction on how to use the native CLI client NebulaGraph Console to connect to NebulaGraph.</p> <p>Caution</p> <p>When connecting to NebulaGraph for the first time, you must register the Storage Service before querying data.</p> <p>NebulaGraph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. For more information, see the client list.</p>"},{"location":"2.quick-start/3.connect-to-nebula-graph/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have started NebulaGraph services.</li> </ul> <ul> <li>The machine on which you plan to run NebulaGraph Console has network access to the Graph Service of NebulaGraph.</li> </ul> <ul> <li> <p>The NebulaGraph Console version is compatible with the NebulaGraph version.</p> <p>Note</p> <p>NebulaGraph Console and NebulaGraph of the same version number are the most compatible. There may be compatibility issues when connecting to NebulaGraph with a different version of NebulaGraph Console. The error message <code>incompatible version between client and server</code> is displayed when there is such an issue.</p> </li> </ul>"},{"location":"2.quick-start/3.connect-to-nebula-graph/#steps","title":"Steps","text":"<ol> <li> <p>On the NebulaGraph Console releases page, select a NebulaGraph Console version and click Assets.</p> <p>Note</p> <p>It is recommended to select the latest version.</p> </li> <li> <p>In the Assets area, find the correct binary file for the machine where you want to run NebulaGraph Console and download the file to the machine.</p> </li> <li> <p>(Optional) Rename the binary file to <code>nebula-console</code> for convenience.</p> <p>Note</p> <p>For Windows, rename the file to <code>nebula-console.exe</code>.</p> </li> <li> <p>On the machine to run NebulaGraph Console, grant the execute permission of the nebula-console binary file to the user.</p> <p>Note</p> <p>For Windows, skip this step.</p> <pre><code>$ chmod 111 nebula-console\n</code></pre> </li> <li> <p>In the command line interface, change the working directory to the one where the nebula-console binary file is stored.</p> </li> <li> <p>Run the following command to connect to NebulaGraph.</p> <ul> <li>For Linux or macOS:</li> </ul> <pre><code>$ ./nebula-console -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <ul> <li>For Windows:</li> </ul> <pre><code>&gt; nebula-console.exe -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <p>Parameter descriptions are as follows:</p> Parameter Description <code>-h/-help</code> Shows the help menu. <code>-addr/-address</code> Sets the IP (or hostname) of the Graph service. The default address is 127.0.0.1.  <code>-P/-port</code> Sets the port number of the graphd service. The default port number is 9669. <code>-u/-user</code> Sets the username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is <code>root</code>. <code>-p/-password</code> Sets the password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password. <code>-t/-timeout</code> Sets an integer-type timeout threshold of the connection. The unit is millisecond. The default value is 120. <code>-e/-eval</code> Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned. <code>-f/-file</code> Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. The result will be returned and the connection stops then. <code>-enable_ssl</code> Enables SSL encryption when connecting to NebulaGraph. <code>-ssl_root_ca_path</code> Sets the storage path of the certification authority file. <code>-ssl_cert_path</code> Sets the storage path of the certificate file. <code>-ssl_private_key_path</code> Sets the storage path of the private key file. <p>For information on more parameters, see the project repository.</p> </li> </ol>"},{"location":"2.quick-start/4.nebula-graph-crud/","title":"Step 4: Use nGQL (CRUD)","text":"<p>This topic will describe the basic CRUD operations in NebulaGraph.</p> <p>For more information, see nGQL guide.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#graph_space_and_nebulagraph_schema","title":"Graph space and NebulaGraph schema","text":"<p>A NebulaGraph instance consists of one or more graph spaces. Graph spaces are physically isolated from each other. You can use different graph spaces in the same instance to store different datasets.</p> <p></p> <p>To insert data into a graph space, define a schema for the graph database. NebulaGraph schema is based on the following components.</p> Schema component Description Vertex Represents an entity in the real world. A vertex can have zero to multiple tags. Tag The type of the same group of vertices. It defines a set of properties that describes the types of vertices. Edge Represents a directed relationship between two vertices. Edge type The type of an edge. It defines a group of properties that describes the types of edges. <p>For more information, see Data modeling.</p> <p>In this topic, we will use the following dataset to demonstrate basic CRUD operations.</p> <p></p>"},{"location":"2.quick-start/4.nebula-graph-crud/#async_implementation_of_create_and_alter","title":"Async implementation of <code>CREATE</code> and <code>ALTER</code>","text":"<p>Caution</p> <p>In NebulaGraph, the following <code>CREATE</code> or <code>ALTER</code> commands are implemented in an async way and take effect in the next heartbeat cycle. Otherwise, an error will be returned. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.</p> <ul> <li><code>CREATE SPACE</code></li> <li><code>CREATE TAG</code></li> <li><code>CREATE EDGE</code></li> <li><code>ALTER TAG</code></li> <li><code>ALTER EDGE</code></li> <li><code>CREATE TAG INDEX</code></li> <li><code>CREATE EDGE INDEX</code></li> </ul> <p>Note</p> <p>The default heartbeat interval is 10 seconds. To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#create_and_use_a_graph_space","title":"Create and use a graph space","text":""},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax","title":"nGQL syntax","text":"<ul> <li>Create a graph space:<pre><code>CREATE SPACE [IF NOT EXISTS] &lt;graph_space_name&gt; (\n[partition_num = &lt;partition_number&gt;,]\n[replica_factor = &lt;replica_number&gt;,]\nvid_type = {FIXED_STRING(&lt;N&gt;) | INT64}\n)\n[COMMENT = '&lt;comment&gt;'];\n</code></pre> <p>For more information on parameters, see CREATE SPACE.</p> </li> </ul> <ul> <li>List graph spaces and check if the creation is successful:<pre><code>nebula&gt; SHOW SPACES;\n</code></pre> </li> </ul> <ul> <li>Use a graph space:<pre><code>USE &lt;graph_space_name&gt;;\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples","title":"Examples","text":"<ol> <li> <p>Use the following statement to create a graph space named <code>basketballplayer</code>.</p> <pre><code>nebula&gt; CREATE SPACE basketballplayer(partition_num=15, replica_factor=1, vid_type=fixed_string(30));\n</code></pre> <p>Note</p> <p>If the system returns the error <code>[ERROR (-1005)]: Host not enough!</code>, check whether registered the Storage Service.</p> </li> <li> <p>Check the partition distribution with <code>SHOW HOSTS</code> to make sure that the partitions are distributed in a balanced way.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+-------------+-----------+-----------+--------------+----------------------------------+------------------------+---------+\n| Host        | Port      | Status    | Leader count | Leader distribution              | Partition distribution | Version |\n+-------------+-----------+-----------+--------------+----------------------------------+------------------------+---------+\n| \"storaged0\" | 9779      | \"ONLINE\"  | 5            | \"basketballplayer:5\"             | \"basketballplayer:5\"   | \"3.8.0\"|\n| \"storaged1\" | 9779      | \"ONLINE\"  | 5            | \"basketballplayer:5\"             | \"basketballplayer:5\"   | \"3.8.0\"|\n| \"storaged2\" | 9779      | \"ONLINE\"  | 5            | \"basketballplayer:5\"             | \"basketballplayer:5\"   | \"3.8.0\"|\n+-------------+-----------+-----------+-----------+--------------+----------------------------------+------------------------+---------+\n</code></pre> <p>If the Leader distribution is uneven, use <code>BALANCE LEADER</code> to redistribute the partitions. For more information, see BALANCE.</p> </li> <li> <p>Use the <code>basketballplayer</code> graph space.</p> <pre><code>nebula[(none)]&gt; USE basketballplayer;\n</code></pre> <p>You can use <code>SHOW SPACES</code> to check the graph space you created.</p> <pre><code>nebula&gt; SHOW SPACES;\n+--------------------+\n| Name               |\n+--------------------+\n| \"basketballplayer\" |\n+--------------------+\n</code></pre> </li> </ol>"},{"location":"2.quick-start/4.nebula-graph-crud/#create_tags_and_edge_types","title":"Create tags and edge types","text":""},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_1","title":"nGQL syntax","text":"<pre><code>CREATE {TAG | EDGE} [IF NOT EXISTS] {&lt;tag_name&gt; | &lt;edge_type_name&gt;}\n    (\n      &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']\n      [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] \n    )\n    [TTL_DURATION = &lt;ttl_duration&gt;]\n    [TTL_COL = &lt;prop_name&gt;]\n    [COMMENT = '&lt;comment&gt;'];\n</code></pre> <p>For more information on parameters, see CREATE TAG and CREATE EDGE.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_1","title":"Examples","text":"<p>Create tags <code>player</code> and <code>team</code>, and edge types <code>follow</code> and <code>serve</code>. Descriptions are as follows.</p> Component name Type Property player Tag name (string), age (int) team Tag name (string) follow Edge type degree (int) serve Edge type start_year (int), end_year (int) <pre><code>nebula&gt; CREATE TAG player(name string, age int);\n\nnebula&gt; CREATE TAG team(name string);\n\nnebula&gt; CREATE EDGE follow(degree int);\n\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre>"},{"location":"2.quick-start/4.nebula-graph-crud/#insert_vertices_and_edges","title":"Insert vertices and edges","text":"<p>You can use the <code>INSERT</code> statement to insert vertices or edges based on existing tags or edge types.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_2","title":"nGQL syntax","text":"<ul> <li>Insert vertices:<pre><code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...]\nVALUES &lt;vid&gt;: ([prop_value_list])\n\ntag_props:\n  tag_name ([prop_name_list])\n\nprop_name_list:\n   [prop_name [, prop_name] ...]\n\nprop_value_list:\n   [prop_value [, prop_value] ...]   \n</code></pre> <p><code>vid</code> is short for Vertex ID. A <code>vid</code> must be a unique string value in a graph space. For details, see INSERT VERTEX.</p> </li> </ul> <ul> <li> <p>Insert edges:</p> <pre><code>INSERT EDGE [IF NOT EXISTS] &lt;edge_type&gt; ( &lt;prop_name_list&gt; ) VALUES \n&lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; )\n[, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ), ...];\n&lt;prop_name_list&gt; ::=\n[ &lt;prop_name&gt; [, &lt;prop_name&gt; ] ...]\n&lt;prop_value_list&gt; ::=\n[ &lt;prop_value&gt; [, &lt;prop_value&gt; ] ...]\n</code></pre> <p>For more information on parameters, see INSERT EDGE.</p> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_2","title":"Examples","text":"<ul> <li>Insert vertices representing basketball players and teams:<pre><code>nebula&gt; INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42);\n\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36);\n\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33);\n\nnebula&gt; INSERT VERTEX team(name) VALUES \"team203\":(\"Trail Blazers\"), \"team204\":(\"Spurs\");\n</code></pre> </li> </ul> <ul> <li>Insert edges representing the relations between basketball players and teams:<pre><code>nebula&gt; INSERT EDGE follow(degree) VALUES \"player101\" -&gt; \"player100\":(95);\n\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player101\" -&gt; \"player102\":(90);\n\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player102\" -&gt; \"player100\":(75);\n\nnebula&gt; INSERT EDGE serve(start_year, end_year) VALUES \"player101\" -&gt; \"team204\":(1999, 2018),\"player102\" -&gt; \"team203\":(2006,  2015);\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#read_data","title":"Read data","text":"<ul> <li>The GO statement can traverse the database based on specific conditions. A <code>GO</code> traversal starts from one or more vertices, along one or more edges, and returns information in a form specified in the <code>YIELD</code> clause.</li> </ul> <ul> <li>The FETCH statement is used to get properties from vertices or edges.</li> </ul> <ul> <li>The LOOKUP statement is based on indexes. It is used together with the <code>WHERE</code> clause to search for the data that meet the specific conditions.</li> </ul> <ul> <li>The MATCH statement is the most commonly used statement for graph data querying. It can describe all kinds of graph patterns, but it relies on indexes to match data patterns in NebulaGraph. Therefore, its performance still needs optimization.</li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_3","title":"nGQL syntax","text":"<ul> <li><code>GO</code><pre><code>GO [[&lt;M&gt; TO] &lt;N&gt; {STEP|STEPS} ] FROM &lt;vertex_list&gt;\nOVER &lt;edge_type_list&gt; [{REVERSELY | BIDIRECT}]\n[ WHERE &lt;conditions&gt; ]\nYIELD [DISTINCT] &lt;return_list&gt;\n[{ SAMPLE &lt;sample_list&gt; | &lt;limit_by_list_clause&gt; }]\n[| GROUP BY {&lt;col_name&gt; | expression&gt; | &lt;position&gt;} YIELD &lt;col_name&gt;]\n[| ORDER BY &lt;expression&gt; [{ASC | DESC}]]\n[| LIMIT [&lt;offset&gt;,] &lt;number_rows&gt;];\n</code></pre> </li> </ul> <ul> <li> <p><code>FETCH</code></p> <ul> <li> <p>Fetch properties on tags:</p> <pre><code>FETCH PROP ON {&lt;tag_name&gt;[, tag_name ...] | *}\n&lt;vid&gt; [, vid ...]\nYIELD &lt;return_list&gt; [AS &lt;alias&gt;];\n</code></pre> </li> </ul> <ul> <li> <p>Fetch properties on edges:</p> <pre><code>FETCH PROP ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; ...]\nYIELD &lt;output&gt;;\n</code></pre> </li> </ul> </li> </ul> <ul> <li><code>LOOKUP</code><pre><code>LOOKUP ON {&lt;vertex_tag&gt; | &lt;edge_type&gt;}\n[WHERE &lt;expression&gt; [AND &lt;expression&gt; ...]]\nYIELD &lt;return_list&gt; [AS &lt;alias&gt;];\n&lt;return_list&gt;\n    &lt;prop_name&gt; [AS &lt;col_alias&gt;] [, &lt;prop_name&gt; [AS &lt;prop_alias&gt;] ...];\n</code></pre> </li> </ul> <ul> <li><code>MATCH</code><pre><code>MATCH &lt;pattern&gt; [&lt;clause_1&gt;] RETURN &lt;output&gt; [&lt;clause_2&gt;];\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_of_go_statement","title":"Examples of <code>GO</code> statement","text":"<ul> <li>Search for the players that the player with VID <code>player101</code> follows.<pre><code>nebula&gt; GO FROM \"player101\" OVER follow YIELD id($$);\n+-------------+\n| id($$)      |\n+-------------+\n| \"player100\" |\n| \"player102\" |\n| \"player125\" |\n+-------------+\n</code></pre> </li> </ul> <ul> <li>Filter the players that the player with VID <code>player101</code> follows whose age is equal to or greater than 35. Rename the corresponding columns in the results with <code>Teammate</code> and <code>Age</code>.<pre><code>nebula&gt; GO FROM \"player101\" OVER follow WHERE properties($$).age &gt;= 35 \\\n        YIELD properties($$).name AS Teammate, properties($$).age AS Age;\n+-----------------+-----+\n| Teammate        | Age |\n+-----------------+-----+\n| \"Tim Duncan\"    | 42  |\n| \"Manu Ginobili\" | 41  |\n+-----------------+-----+\n</code></pre> <p>| Clause/Sign | Description                                                         |   |-------------+---------------------------------------------------------------------|   | <code>YIELD</code>     | Specifies what values or results you want to return from the query. |   | <code>$$</code>        | Represents the target vertices.                                     |   | <code>\\</code>         | A line-breaker.                                                     |</p> </li> </ul> <ul> <li> <p>Search for the players that the player with VID <code>player101</code> follows. Then retrieve the teams of the players that the player with VID <code>player100</code> follows. To combine the two queries, use a pipe or a temporary variable.</p> <ul> <li> <p>With a pipe:</p> <pre><code>nebula&gt; GO FROM \"player101\" OVER follow YIELD dst(edge) AS id | \\\n        GO FROM $-.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;\n+-----------------+---------------------+\n| Team            | Player              |\n+-----------------+---------------------+\n| \"Spurs\"         | \"Tim Duncan\"        |\n| \"Trail Blazers\" | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"Manu Ginobili\"     |\n+-----------------+---------------------+\n</code></pre> Clause/Sign Description <code>$^</code> Represents the source vertex of the edge. <code>|</code> A pipe symbol can combine multiple queries. <code>$-</code> Represents the outputs of the query before the pipe symbol. </li> </ul> <ul> <li> <p>With a temporary variable:</p> <p>Note</p> <p>Once a composite statement is submitted to the server as a whole, the life cycle of the temporary variables in the statement ends.</p> <pre><code>nebula&gt; $var = GO FROM \"player101\" OVER follow YIELD dst(edge) AS id; \\\n        GO FROM $var.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;\n+-----------------+---------------------+\n| Team            | Player              |\n+-----------------+---------------------+\n| \"Spurs\"         | \"Tim Duncan\"        |\n| \"Trail Blazers\" | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | \"Manu Ginobili\"     |\n+-----------------+---------------------+\n</code></pre> </li> </ul> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#example_of_fetch_statement","title":"Example of <code>FETCH</code> statement","text":"<p>Use <code>FETCH</code>: Fetch the properties of the player with VID <code>player100</code>.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player100\" YIELD properties(vertex);\n+-------------------------------+\n| properties(VERTEX)            |\n+-------------------------------+\n| {age: 42, name: \"Tim Duncan\"} |\n+-------------------------------+\n</code></pre> <p>Note</p> <p>The examples of <code>LOOKUP</code> and <code>MATCH</code> statements are in indexes.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#update_vertices_and_edges","title":"Update vertices and edges","text":"<p>Users can use the <code>UPDATE</code> or the <code>UPSERT</code> statements to update existing data.</p> <p><code>UPSERT</code> is the combination of <code>UPDATE</code> and <code>INSERT</code>. If you update a vertex or an edge with <code>UPSERT</code>, the database will insert a new vertex or edge if it does not exist.</p> <p>Note</p> <p><code>UPSERT</code> operates serially in a partition-based order. Therefore, it is slower than <code>INSERT</code> OR <code>UPDATE</code>. And <code>UPSERT</code> has concurrency only between multiple partitions.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_4","title":"nGQL syntax","text":"<ul> <li><code>UPDATE</code> vertices:<pre><code>UPDATE VERTEX &lt;vid&gt; SET &lt;properties to be updated&gt;\n[WHEN &lt;condition&gt;] [YIELD &lt;columns&gt;];\n</code></pre> </li> </ul> <ul> <li><code>UPDATE</code> edges:<pre><code>UPDATE EDGE ON &lt;edge_type&gt; &lt;source vid&gt; -&gt; &lt;destination vid&gt; [@rank] \nSET &lt;properties to be updated&gt; [WHEN &lt;condition&gt;] [YIELD &lt;columns to be output&gt;];\n</code></pre> </li> </ul> <ul> <li><code>UPSERT</code> vertices or edges:<pre><code>UPSERT {VERTEX &lt;vid&gt; | EDGE &lt;edge_type&gt;} SET &lt;update_columns&gt;\n[WHEN &lt;condition&gt;] [YIELD &lt;columns&gt;];\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_3","title":"Examples","text":"<ul> <li><code>UPDATE</code> the <code>name</code> property of the vertex with VID <code>player100</code> and check the result with the <code>FETCH</code> statement.<pre><code>nebula&gt; UPDATE VERTEX \"player100\" SET player.name = \"Tim\";\n\nnebula&gt; FETCH PROP ON player \"player100\" YIELD properties(vertex);\n+------------------------+\n| properties(VERTEX)     |\n+------------------------+\n| {age: 42, name: \"Tim\"} |\n+------------------------+\n</code></pre> </li> </ul> <ul> <li><code>UPDATE</code> the <code>degree</code> property of an edge and check the result with the <code>FETCH</code> statement.<pre><code>nebula&gt; UPDATE EDGE ON follow \"player101\" -&gt; \"player100\" SET degree = 96;\n\nnebula&gt; FETCH PROP ON follow \"player101\" -&gt; \"player100\" YIELD properties(edge);\n+------------------+\n| properties(EDGE) |\n+------------------+\n| {degree: 96}     |\n+------------------+\n</code></pre> </li> </ul> <ul> <li>Insert a vertex with VID <code>player111</code> and <code>UPSERT</code> it.<pre><code>nebula&gt; INSERT VERTEX player(name,age) VALUES \"player111\":(\"David West\", 38);\n\nnebula&gt; UPSERT VERTEX \"player111\" SET player.name = \"David\", player.age = $^.player.age + 11 \\\n        WHEN $^.player.name == \"David West\" AND $^.player.age &gt; 20 \\\n        YIELD $^.player.name AS Name, $^.player.age AS Age;\n+---------+-----+\n| Name    | Age |\n+---------+-----+\n| \"David\" | 49  |\n+---------+-----+\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#delete_vertices_and_edges","title":"Delete vertices and edges","text":""},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_5","title":"nGQL syntax","text":"<ul> <li>Delete vertices:<pre><code>DELETE VERTEX &lt;vid1&gt;[, &lt;vid2&gt;...]\n</code></pre> </li> </ul> <ul> <li>Delete edges:<pre><code>DELETE EDGE &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;]\n[, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;...]\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_4","title":"Examples","text":"<ul> <li>Delete vertices:<pre><code>nebula&gt; DELETE VERTEX \"player111\", \"team203\";\n</code></pre> </li> </ul> <ul> <li>Delete edges:<pre><code>nebula&gt; DELETE EDGE follow \"player101\" -&gt; \"team204\";\n</code></pre> </li> </ul>"},{"location":"2.quick-start/4.nebula-graph-crud/#about_indexes","title":"About indexes","text":"<p>Users can add indexes to tags and edge types with the CREATE INDEX statement.</p> <p>Must-read for using indexes</p> <p>Both <code>MATCH</code> and <code>LOOKUP</code> statements depend on the indexes. But indexes can dramatically reduce the write performance. DO NOT use indexes in production environments unless you are fully aware of their influences on your service.</p> <p>Users MUST rebuild indexes for pre-existing data. Otherwise, the pre-existing data cannot be indexed and therefore cannot be returned in <code>MATCH</code> or <code>LOOKUP</code> statements. For more information, see REBUILD INDEX.</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#ngql_syntax_6","title":"nGQL syntax","text":"<ul> <li>Create an index:<pre><code>CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] &lt;index_name&gt;\nON {&lt;tag_name&gt; | &lt;edge_name&gt;} ([&lt;prop_name_list&gt;]) [COMMENT = '&lt;comment&gt;'];\n</code></pre> </li> </ul> <ul> <li>Rebuild an index:<pre><code>REBUILD {TAG | EDGE} INDEX &lt;index_name&gt;;\n</code></pre> </li> </ul> <p>Note</p> <p>Define the index length when creating an index for a variable-length property. In UTF-8 encoding, a non-ascii character occupies 3 bytes. You should set an appropriate index length according to the variable-length property. For example, the index should be 30 bytes for 10 non-ascii characters. For more information, see CREATE INDEX</p>"},{"location":"2.quick-start/4.nebula-graph-crud/#examples_of_lookup_and_match_index-based","title":"Examples of <code>LOOKUP</code> and <code>MATCH</code> (index-based)","text":"<p>Make sure there is an index for <code>LOOKUP</code> or <code>MATCH</code> to use. If there is not, create an index first.</p> <p>Find the information of the vertex with the tag <code>player</code> and its value of the <code>name</code> property is <code>Tony Parker</code>.</p> <p>This example creates the index <code>player_index_1</code> on the <code>name</code> property.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index_1 ON player(name(20));\n</code></pre> <p>This example rebuilds the index to make sure it takes effect on pre-existing data.</p> <pre><code>nebula&gt; REBUILD TAG INDEX player_index_1\n+------------+\n| New Job Id |\n+------------+\n| 31         |\n+------------+\n</code></pre> <p>This example uses the <code>LOOKUP</code> statement to retrieve the vertex property.</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.name == \"Tony Parker\" \\\n        YIELD properties(vertex).name AS name, properties(vertex).age AS age;\n+---------------+-----+\n| name          | age |\n+---------------+-----+\n| \"Tony Parker\" | 36  |\n+---------------+-----+\n</code></pre> <p>This example uses the <code>MATCH</code> statement to retrieve the vertex property.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tony Parker\"}) RETURN v;\n+-----------------------------------------------------+\n| v                                                   |\n+-----------------------------------------------------+\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"}) |\n+-----------------------------------------------------+\n</code></pre>"},{"location":"2.quick-start/5.start-stop-service/","title":"Step 2: Manage NebulaGraph Service","text":"<p>NebulaGraph supports managing services with scripts. </p>"},{"location":"2.quick-start/5.start-stop-service/#manage_services_with_script","title":"Manage services with script","text":"<p>You can use the <code>nebula.service</code> script to start, stop, restart, terminate, and check the NebulaGraph services.</p> <p>Note</p> <p><code>nebula.service</code> is stored in the <code>/usr/local/nebula/scripts</code> directory by default. If you have customized the path, use the actual path in your environment.</p>"},{"location":"2.quick-start/5.start-stop-service/#syntax","title":"Syntax","text":"<pre><code>$ sudo /usr/local/nebula/scripts/nebula.service\n[-v] [-c &lt;config_file_path&gt;]\n&lt;start | stop | restart | kill | status&gt;\n&lt;metad | graphd | storaged | all&gt;\n</code></pre> Parameter Description <code>-v</code> Display detailed debugging information. <code>-c</code> Specify the configuration file path. The default path is <code>/usr/local/nebula/etc/</code>. <code>start</code> Start the target services. <code>stop</code> Stop the target services. <code>restart</code> Restart the target services. <code>kill</code> Terminate the target services. <code>status</code> Check the status of the target services. <code>metad</code> Set the Meta Service as the target service. <code>graphd</code> Set the Graph Service as the target service. <code>storaged</code> Set the Storage Service as the target service. <code>all</code> Set all the NebulaGraph services as the target services."},{"location":"2.quick-start/5.start-stop-service/#start_nebulagraph","title":"Start NebulaGraph","text":"<p>Run the following command to start NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service start all\n[INFO] Starting nebula-metad...\n[INFO] Done\n[INFO] Starting nebula-graphd...\n[INFO] Done\n[INFO] Starting nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"2.quick-start/5.start-stop-service/#stop_nebulagraph","title":"Stop NebulaGraph","text":"<p>Danger</p> <p>Do not run <code>kill -9</code> to forcibly terminate the processes. Otherwise, there is a low probability of data loss.</p> <p>Run the following command to stop NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service stop all\n[INFO] Stopping nebula-metad...\n[INFO] Done\n[INFO] Stopping nebula-graphd...\n[INFO] Done\n[INFO] Stopping nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"2.quick-start/5.start-stop-service/#check_the_service_status","title":"Check the service status","text":"<p>Run the following command to check the service status of NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service status all\n</code></pre> <ul> <li> <p>NebulaGraph is running normally if the following information is returned.</p> <pre><code>INFO] nebula-metad(33fd35e): Running as 29020, Listening on 9559\n[INFO] nebula-graphd(33fd35e): Running as 29095, Listening on 9669\n[WARN] nebula-storaged after v3.0.0 will not start service until it is added to cluster.\n[WARN] See Manage Storage hosts:ADD HOSTS in https://docs.nebula-graph.io/\n[INFO] nebula-storaged(33fd35e): Running as 29147, Listening on 9779\n</code></pre> <p>Note</p> <p>After starting NebulaGraph, the port of the <code>nebula-storaged</code> process is shown in red. Because the <code>nebula-storaged</code> process waits for the <code>nebula-metad</code> to add the current Storage service during the startup process. The Storage works after it receives the ready signal. Starting from NebulaGraph 3.0.0, the Meta service cannot directly read or write data in the Storage service that you add in the configuration file. The configuration file only registers the Storage service to the Meta service. You must run the <code>ADD HOSTS</code> command to enable the Meta to read and write data in the Storage service. For more information, see Manage Storage hosts.</p> </li> </ul> <ul> <li>If the returned result is similar to the following one, there is a problem. You may also go to the NebulaGraph community for help.<pre><code>[INFO] nebula-metad: Running as 25600, Listening on 9559\n[INFO] nebula-graphd: Exited\n[INFO] nebula-storaged: Running as 25646, Listening on 9779\n</code></pre> </li> </ul> <p>The NebulaGraph services consist of the Meta Service, Graph Service, and Storage Service. The configuration files for all three services are stored in the <code>/usr/local/nebula/etc/</code> directory by default. You can check the configuration files according to the returned result to troubleshoot problems.</p>"},{"location":"2.quick-start/5.start-stop-service/#next_to_do","title":"Next to do","text":"<p>Connect to NebulaGraph</p>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/","title":"nGQL cheatsheet","text":""},{"location":"2.quick-start/6.cheatsheet-for-ngql/#functions","title":"Functions","text":"<ul> <li> <p>Math functions</p> Function Description double abs(double x) Returns the absolute value of the argument. double floor(double x) Returns the largest integer value smaller than or equal to the argument. (Rounds down) double ceil(double x) Returns the smallest integer greater than or equal to the argument. (Rounds up) double round(double x) Returns the integer value nearest to the argument. Returns a number farther away from 0 if the argument is in the middle. double sqrt(double x) Returns the square root of the argument. double cbrt(double x) Returns the cubic root of the argument. double hypot(double x, double y) Returns the hypotenuse of a right-angled triangle. double pow(double x, double y) Returns the result of x<sup>y</sup>. double exp(double x) Returns the result of e<sup>x</sup>. double exp2(double x) Returns the result of 2<sup>x</sup>. double log(double x) Returns the base-e logarithm of the argument. double log2(double x) Returns the base-2 logarithm of the argument. double log10(double x) Returns the base-10 logarithm of the argument. double sin(double x) Returns the sine of the argument. double asin(double x) Returns the inverse sine of the argument. double cos(double x) Returns the cosine of the argument. double acos(double x) Returns the inverse cosine of the argument. double tan(double x) Returns the tangent of the argument. double atan(double x) Returns the inverse tangent of the argument. double rand() Returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e.[0,1). int rand32(int min, int max) Returns a random 32-bit integer in <code>[min, max)</code>.If you set only one argument, it is parsed as <code>max</code> and <code>min</code> is <code>0</code> by default.If you set no argument, the system returns a random signed 32-bit integer. int rand64(int min, int max) Returns a random 64-bit integer in <code>[min, max)</code>.If you set only one argument, it is parsed as <code>max</code> and <code>min</code> is <code>0</code> by default.If you set no argument, the system returns a random signed 64-bit integer. bit_and() Bitwise AND. bit_or() Bitwise OR. bit_xor() Bitwise XOR. int size() Returns the number of elements in a list or a map or the length of a string. int range(int start, int end, int step) Returns a list of integers from <code>[start,end]</code> in the specified steps. <code>step</code> is 1 by default. int sign(double x) Returns the signum of the given number.If the number is <code>0</code>, the system returns <code>0</code>.If the number is negative, the system returns <code>-1</code>.If the number is positive, the system returns <code>1</code>. double e() Returns the base of the natural logarithm, e (2.718281828459045). double pi() Returns the mathematical constant pi (3.141592653589793). double radians() Converts degrees to radians. <code>radians(180)</code> returns <code>3.141592653589793</code>. </li> </ul> <ul> <li> <p>Aggregating functions</p> Function Description avg() Returns the average value of the argument. count() Syntax: <code>count({expr | *})</code> .<code>count()</code>returns the number of rows (including NULL). <code>count(expr)</code>returns the number of non-NULL values that meet the expression. count() and size() are different. max() Returns the maximum value. min() Returns the minimum value. collect() The collect() function returns a list containing the values returned by an expression. Using this function aggregates data by merging multiple records or values into a single list. std() Returns the population standard deviation. sum() Returns the sum value. </li> </ul> <ul> <li> <p>String functions</p> Function Description int strcasecmp(string a, string b) Compares string a and b without case sensitivity. When a = b, the return string lower(string a) Returns the argument in lowercase. string toLower(string a) The same as <code>lower()</code>. string upper(string a) Returns the argument in uppercase. string toUpper(string a) The same as <code>upper()</code>. int length(a) Returns the length of the given string in bytes or the length of a path in hops. string trim(string a) Removes leading and trailing spaces. string ltrim(string a) Removes leading spaces. string rtrim(string a) Removes trailing spaces. string left(string a, int count) Returns a substring consisting of <code>count</code> characters from the left side of string right(string a, int count) Returns a substring consisting of <code>count</code> characters from the right side of string lpad(string a, int size, string letters) Left-pads string a with string <code>letters</code> and returns a string rpad(string a, int size, string letters) Right-pads string a with string <code>letters</code> and returns a string substr(string a, int pos, int count) Returns a substring extracting <code>count</code> characters starting from string substring(string a, int pos, int count) The same as <code>substr()</code>. string reverse(string) Returns a string in reverse order. string replace(string a, string b, string c) Replaces string b in string a with string c. list split(string a, string b) Splits string a at string b and returns a list of strings. concat() The <code>concat()</code> function requires at least two or more strings. All the parameters are concatenated into one string.Syntax: <code>concat(string1,string2,...)</code> concat_ws() The <code>concat_ws()</code> function connects two or more strings with a predefined separator. extract() <code>extract()</code> uses regular expression matching to retrieve a single substring or all substrings from a string. json_extract() The <code>json_extract()</code> function converts the specified JSON string to map. </li> </ul> <ul> <li> <p>Data and time functions</p> Function Description int now() Returns the current timestamp of the system. timestamp timestamp() Returns the current timestamp of the system. date date() Returns the current UTC date based on the current system. time time() Returns the current UTC time based on the current system. datetime datetime() Returns the current UTC date and time based on the current system. </li> </ul> <ul> <li> <p>Schema-related functions</p> <ul> <li> <p>For nGQL statements</p> Function Description id(vertex) Returns the ID of a vertex. The data type of the result is the same as the vertex ID. map properties(vertex) Returns the properties of a vertex. map properties(edge) Returns the properties of an edge. string type(edge) Returns the edge type of an edge. src(edge) Returns the source vertex ID of an edge. The data type of the result is the same as the vertex ID. dst(edge) Returns the destination vertex ID of an edge. The data type of the result is the same as the vertex ID. int rank(edge) Returns the rank value of an edge. vertex Returns the information of vertices, including VIDs, tags, properties, and values. edge Returns the information of edges, including edge types, source vertices, destination vertices, ranks, properties, and values. vertices Returns the information of vertices in a subgraph. For more information, see GET SUBGRAPH. edges Returns the information of edges in a subgraph. For more information, see GET SUBGRAPH. path Returns the information of a path. For more information, see FIND PATH. </li> </ul> <ul> <li> <p>For statements compatible with openCypher</p> Function Description id(&lt;vertex&gt;) Returns the ID of a vertex. The data type of the result is the same as the vertex ID. list tags(&lt;vertex&gt;) Returns the Tag of a vertex, which serves the same purpose as labels(). list labels(&lt;vertex&gt;) Returns the Tag of a vertex, which serves the same purpose as tags(). This function is used for compatibility with openCypher syntax. map properties(&lt;vertex_or_edge&gt;) Returns the properties of a vertex or an edge. string type(&lt;edge&gt;) Returns the edge type of an edge. src(&lt;edge&gt;) Returns the source vertex ID of an edge. The data type of the result is the same as the vertex ID. dst(&lt;edge&gt;) Returns the destination vertex ID of an edge. The data type of the result is the same as the vertex ID. vertex startNode(&lt;path&gt;) Visits an edge or a path and returns its source vertex ID. string endNode(&lt;path&gt;) Visits an edge or a path and returns its destination vertex ID. int rank(&lt;edge&gt;) Returns the rank value of an edge. </li> </ul> </li> </ul> <ul> <li> <p>List functions</p> Function Description keys(expr) Returns a list containing the string representations for all the property names of vertices, edges, or maps. labels(vertex) Returns the list containing all the tags of a vertex. nodes(path) Returns the list containing all the vertices in a path. range(start, end [, step]) Returns the list containing all the fixed-length steps in <code>[start,end]</code>. <code>step</code> is 1 by default. relationships(path) Returns the list containing all the relationships in a path. reverse(list) Returns the list reversing the order of all elements in the original list. tail(list) Returns all the elements of the original list, excluding the first one. head(list) Returns the first element of a list. last(list) Returns the last element of a list. reduce() The <code>reduce()</code> function applies an expression to each element in a list one by one, chains the result to the next iteration by taking it as the initial value, and returns the final result. </li> </ul> <ul> <li> <p>Type conversion functions</p> Function Description bool toBoolean() Converts a string value to a boolean value. float toFloat() Converts an integer or string value to a floating point number. string toString() Converts non-compound types of data, such as numbers, booleans, and so on, to strings. int toInteger() Converts a floating point or string value to an integer value. set toSet() Converts a list or set value to a set value. int hash() The <code>hash()</code> function returns the hash value of the argument. The argument can be a number, a string, a list, a boolean, null, or an expression that evaluates to a value of the preceding data types. </li> </ul> <ul> <li> <p>Predicate functions</p> <p>Predicate functions return <code>true</code> or <code>false</code>. They are most commonly used in <code>WHERE</code> clauses.</p> <pre><code>&lt;predicate&gt;(&lt;variable&gt; IN &lt;list&gt; WHERE &lt;condition&gt;)\n</code></pre> Function Description exists() Returns <code>true</code> if the specified property exists in the vertex, edge or map. Otherwise, returns <code>false</code>. any() Returns <code>true</code> if the specified predicate holds for at least one element in the given list. Otherwise, returns <code>false</code>. all() Returns <code>true</code> if the specified predicate holds for all elements in the given list. Otherwise, returns <code>false</code>. none() Returns <code>true</code> if the specified predicate holds for no element in the given list. Otherwise, returns <code>false</code>. single() Returns <code>true</code> if the specified predicate holds for exactly one of the elements in the given list. Otherwise, returns <code>false</code>. </li> </ul> <ul> <li> <p>Conditional expressions functions</p> Function Description CASE The <code>CASE</code> expression uses conditions to filter the result of an nGQL query statement. It is usually used in the <code>YIELD</code> and <code>RETURN</code> clauses. The <code>CASE</code> expression will traverse all the conditions. When the first condition is met, the <code>CASE</code> expression stops reading the conditions and returns the result. If no conditions are met, it returns the result in the <code>ELSE</code> clause. If there is no <code>ELSE</code> clause and no conditions are met, it returns <code>NULL</code>. coalesce() Returns the first not null value in all expressions. </li> </ul>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/#general_queries_statements","title":"General queries statements","text":"<ul> <li> <p>MATCH</p> <pre><code>MATCH &lt;pattern&gt; [&lt;clause_1&gt;] RETURN &lt;output&gt; [&lt;clause_2&gt;];\n</code></pre> Pattern Example Description Match vertices <code>(v)</code> You can use a user-defined variable in a pair of parentheses to represent a vertex in a pattern. For example: <code>(v)</code>. Match tags <code>MATCH (v:player) RETURN v</code> You can specify a tag with <code>:&lt;tag_name&gt;</code> after the vertex in a pattern. Match multiple tags <code>MATCH (v:player:team) RETURN v</code> To match vertices with multiple tags, use colons (:). Match vertex properties <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN v</code> <code>MATCH (v) WITH v, properties(v) as props, keys(properties(v)) as kk WHERE [i in kk where props[i] == \"Tim Duncan\"] RETURN v</code> You can specify a vertex property with <code>{&lt;prop_name&gt;: &lt;prop_value&gt;}</code> after the tag in a pattern; or use a vertex property value to get vertices directly. Match a VID. <code>MATCH (v) WHERE id(v) == 'player101' RETURN v</code> You can use the VID to match a vertex. The <code>id()</code> function can retrieve the VID of a vertex. Match multiple VIDs. <code>MATCH (v:player { name: 'Tim Duncan' })--(v2) WHERE id(v2) IN [\"player101\", \"player102\"] RETURN v2</code> To match multiple VIDs, use <code>WHERE id(v) IN [vid_list]</code>. Match connected vertices <code>MATCH (v:player{name:\"Tim Duncan\"})--(v2) RETURN v2.player.name AS Name</code> You can use the <code>--</code> symbol to represent edges of both directions and match vertices connected by these edges. You can add a <code>&gt;</code> or <code>&lt;</code> to the <code>--</code> symbol to specify the direction of an edge. Match paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) RETURN p</code> Connected vertices and edges form a path. You can use a user-defined variable to name a path as follows. Match edges <code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-(v2) RETURN e</code><code>MATCH ()&lt;-[e]-() RETURN e</code> Besides using <code>--</code>, <code>--&gt;</code>, or <code>&lt;--</code> to indicate a nameless edge, you can use a user-defined variable in a pair of square brackets to represent a named edge. For example: <code>-[e]-</code>. Match an edge type <code>MATCH ()-[e:follow]-() RETURN e</code> Just like vertices, you can specify an edge type with <code>:&lt;edge_type&gt;</code> in a pattern. For example: <code>-[e:follow]-</code>. Match edge type properties <code>MATCH (v:player{name:\"Tim Duncan\"})-[e:follow{degree:95}]-&gt;(v2) RETURN e</code> <code>MATCH ()-[e]-&gt;() WITH e, properties(e) as props, keys(properties(e)) as kk WHERE [i in kk where props[i] == 90] RETURN e</code> You can specify edge type properties with <code>{&lt;prop_name&gt;: &lt;prop_value&gt;}</code> in a pattern. For example: <code>[e:follow{likeness:95}]</code>; or use an edge type property value to get edges directly. Match multiple edge types <code>MATCH (v:player{name:\"Tim Duncan\"})-[e:follow | :serve]-&gt;(v2) RETURN e</code> The <code>|</code> symbol can help matching multiple edge types. For example: <code>[e:follow|:serve]</code>. The English colon (:) before the first edge type cannot be omitted, but the English colon before the subsequent edge type can be omitted, such as <code>[e:follow|serve]</code>. Match multiple edges <code>MATCH (v:player{name:\"Tim Duncan\"})-[]-&gt;(v2)&lt;-[e:serve]-(v3) RETURN v2, v3</code> You can extend a pattern to match multiple edges in a path. Match fixed-length paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) RETURN DISTINCT v2 AS Friends</code> You can use the <code>:&lt;edge_type&gt;*&lt;hop&gt;</code> pattern to match a fixed-length path. <code>hop</code> must be a non-negative integer. The data type of <code>e</code> is the list. Match variable-length paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..3]-&gt;(v2) RETURN v2 AS Friends</code> <code>minHop</code>: Optional. It represents the minimum length of the path. <code>minHop</code>: must be a non-negative integer. The default value is 1.<code>minHop</code> and <code>maxHop</code> are optional and the default value is 1 and infinity respectively. The data type of <code>e</code> is the list. Match variable-length paths with multiple edge types <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow | serve*2]-&gt;(v2) RETURN DISTINCT v2</code> You can specify multiple edge types in a fixed-length or variable-length pattern. In this case, <code>hop</code>, <code>minHop</code>, and <code>maxHop</code> take effect on all edge types. The data type of <code>e</code> is the list. Retrieve vertex or edge information <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN v</code><code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) RETURN e</code> Use <code>RETURN {&lt;vertex_name&gt; | &lt;edge_name&gt;}</code> to retrieve all the information of a vertex or an edge. Retrieve VIDs <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN id(v)</code> Use the <code>id()</code> function to retrieve VIDs. Retrieve tags <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN labels(v)</code> Use the <code>labels()</code> function to retrieve the list of tags on a vertex.To retrieve the nth element in the <code>labels(v)</code> list, use <code>labels(v)[n-1]</code>. Retrieve a single property on a vertex or an edge <code>MATCH (v:player{name:\"Tim Duncan\"}) RETURN v.player.age</code> Use <code>RETURN {&lt;vertex_name&gt; | &lt;edge_name&gt;}.&lt;property&gt;</code> to retrieve a single property.Use <code>AS</code> to specify an alias for a property. Retrieve all properties on a vertex or an edge <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) RETURN properties(v2)</code> Use the <code>properties()</code> function to retrieve all properties on a vertex or an edge. Retrieve edge types <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[e]-&gt;() RETURN DISTINCT type(e)</code> Use the <code>type()</code> function to retrieve the matched edge types. Retrieve paths <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[*3]-&gt;() RETURN p</code> Use <code>RETURN &lt;path_name&gt;</code> to retrieve all the information of the matched paths. Retrieve vertices in a path <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) RETURN nodes(p)</code> Use the <code>nodes()</code> function to retrieve all vertices in a path. Retrieve edges in a path <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) RETURN relationships(p)</code> Use the <code>relationships()</code> function to retrieve all edges in a path. Retrieve path length <code>MATCH p=(v:player{name:\"Tim Duncan\"})-[*..2]-&gt;(v2) RETURN p AS Paths, length(p) AS Length</code> Use the <code>length()</code> function to retrieve the length of a path. </li> </ul> <ul> <li> <p>OPTIONAL MATCH</p> Pattern Example Description Matches patterns against your graph database, just like <code>MATCH</code> does. <code>MATCH (m)-[]-&gt;(n) WHERE id(m)==\"player100\" OPTIONAL MATCH (n)-[]-&gt;(l) RETURN id(m),id(n),id(l)</code> If no matches are found, <code>OPTIONAL MATCH</code> will use a null for missing parts of the pattern. </li> </ul> <ul> <li> <p>LOOKUP</p> <pre><code>LOOKUP ON {&lt;vertex_tag&gt; | &lt;edge_type&gt;} \n[WHERE &lt;expression&gt; [AND &lt;expression&gt; ...]] \nYIELD &lt;return_list&gt; [AS &lt;alias&gt;]\n</code></pre> Pattern Example Description Retrieve vertices <code>LOOKUP ON player WHERE player.name == \"Tony Parker\" YIELD player.name AS name, player.age AS age</code> The following example returns vertices whose <code>name</code> is <code>Tony Parker</code> and the tag is <code>player</code>. Retrieve edges <code>LOOKUP ON follow WHERE follow.degree == 90 YIELD follow.degree</code> Returns edges whose <code>degree</code> is <code>90</code> and the edge type is <code>follow</code>. List vertices with a tag <code>LOOKUP ON player YIELD properties(vertex),id(vertex)</code> Shows how to retrieve the VID of all vertices tagged with <code>player</code>. List edges with an edge types <code>LOOKUP ON follow YIELD edge AS e</code> Shows how to retrieve the source Vertex IDs, destination vertex IDs, and ranks of all edges of the <code>follow</code> edge type. Count the numbers of vertices or edges <code>LOOKUP ON player YIELD id(vertex)| YIELD COUNT(*) AS Player_Count</code> Shows how to count the number of vertices tagged with <code>player</code>. Count the numbers of edges <code>LOOKUP ON follow YIELD edge as e| YIELD COUNT(*) AS Like_Count</code> Shows how to count the number of edges of the <code>follow</code> edge type. </li> </ul> <ul> <li> <p>GO</p> <pre><code>GO [[&lt;M&gt; TO] &lt;N&gt; {STEP|STEPS} ] FROM &lt;vertex_list&gt;\nOVER &lt;edge_type_list&gt; [{REVERSELY | BIDIRECT}]\n[ WHERE &lt;conditions&gt; ]\nYIELD [DISTINCT] &lt;return_list&gt;\n[{SAMPLE &lt;sample_list&gt; | LIMIT &lt;limit_list&gt;}]\n[| GROUP BY {col_name | expr | position} YIELD &lt;col_name&gt;]\n[| ORDER BY &lt;expression&gt; [{ASC | DESC}]]\n[| LIMIT [&lt;offset_value&gt;,] &lt;number_rows&gt;]\n</code></pre> Example Description <code>GO FROM \"player102\" OVER serve YIELD dst(edge)</code> Returns the teams that player 102 serves. <code>GO 2 STEPS FROM \"player102\" OVER follow YIELD dst(edge)</code> Returns the friends of player 102 with 2 hops. <code>GO FROM \"player100\", \"player102\" OVER serve WHERE properties(edge).start_year &gt; 1995 YIELD DISTINCT properties($$).name AS team_name, properties(edge).start_year AS start_year, properties($^).name AS player_name</code> Adds a filter for the traversal. <code>GO FROM \"player100\" OVER follow, serve YIELD properties(edge).degree, properties(edge).start_year</code> The following example traverses along with multiple edge types. If there is no value for a property, the output is <code>NULL</code>. <code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS destination</code> The following example returns the neighbor vertices in the incoming direction of player 100. <code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS id | GO FROM $-.id OVER serve WHERE properties($^).age &gt; 20 YIELD properties($^).name AS FriendOf, properties($$).name AS Team</code> The following example retrieves the friends of player 100 and the teams that they serve. <code>GO FROM \"player102\" OVER follow YIELD dst(edge) AS both</code> The following example returns all the neighbor vertices of player 102. <code>GO 2 STEPS FROM \"player100\" OVER follow YIELD src(edge) AS src, dst(edge) AS dst, properties($$).age AS age | GROUP BY $-.dst YIELD $-.dst AS dst, collect_set($-.src) AS src, collect($-.age) AS age</code> The following example the outputs according to age. </li> </ul> <ul> <li> <p>FETCH</p> <ul> <li> <p>Fetch vertex properties</p> <pre><code>FETCH PROP ON {&lt;tag_name&gt;[, tag_name ...] | *} \n&lt;vid&gt; [, vid ...] \nYIELD &lt;return_list&gt; [AS &lt;alias&gt;]\n</code></pre> Example Description <code>FETCH PROP ON player \"player100\" YIELD properties(vertex)</code> Specify a tag in the <code>FETCH</code> statement to fetch the vertex properties by that tag. <code>FETCH PROP ON player \"player100\" YIELD player.name AS name</code> Use a <code>YIELD</code> clause to specify the properties to be returned. <code>FETCH PROP ON player \"player101\", \"player102\", \"player103\" YIELD properties(vertex)</code> Specify multiple VIDs (vertex IDs) to fetch properties of multiple vertices. Separate the VIDs with commas. <code>FETCH PROP ON player, t1 \"player100\", \"player103\" YIELD properties(vertex)</code> Specify multiple tags in the <code>FETCH</code> statement to fetch the vertex properties by the tags. Separate the tags with commas. <code>FETCH PROP ON * \"player100\", \"player106\", \"team200\" YIELD properties(vertex)</code> Set an asterisk symbol <code>*</code> to fetch properties by all tags in the current graph space. </li> </ul> <ul> <li> <p>Fetch edge properties</p> <pre><code>FETCH PROP ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; ...]\nYIELD &lt;output&gt;;\n</code></pre> Example Description <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\" YIELD properties(edge)</code> The following statement fetches all the properties of the <code>serve</code> edge that connects vertex <code>\"player100\"</code> and vertex <code>\"team204\"</code>. <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\" YIELD serve.start_year</code> Use a <code>YIELD</code> clause to fetch specific properties of an edge. <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\", \"player133\" -&gt; \"team202\" YIELD properties(edge)</code> Specify multiple edge patterns (<code>&lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;]</code>) to fetch properties of multiple edges. Separate the edge patterns with commas. <code>FETCH PROP ON serve \"player100\" -&gt; \"team204\"@1 YIELD properties(edge)</code> To fetch on an edge whose rank is not 0, set its rank in the FETCH statement. <code>GO FROM \"player101\" OVER follow YIELD follow._src AS s, follow._dst AS d | FETCH PROP ON follow $-.s -&gt; $-.d YIELD follow.degree</code> The following statement returns the <code>degree</code> values of the <code>follow</code> edges that start from vertex <code>\"player101\"</code>. <code>$var = GO FROM \"player101\" OVER follow YIELD follow._src AS s, follow._dst AS d; FETCH PROP ON follow $var.s -&gt; $var.d YIELD follow.degree</code> You can use user-defined variables to construct similar queries. </li> </ul> </li> </ul> <ul> <li> <p>SHOW</p> Statement Syntax Example Description SHOW CHARSET <code>SHOW CHARSET</code> <code>SHOW CHARSET</code> Shows the available character sets. SHOW COLLATION <code>SHOW COLLATION</code> <code>SHOW COLLATION</code> Shows the collations supported by NebulaGraph. SHOW CREATE SPACE <code>SHOW CREATE SPACE &lt;space_name&gt;</code> <code>SHOW CREATE SPACE basketballplayer</code> Shows the creating statement of the specified graph space. SHOW CREATE TAG/EDGE <code>SHOW CREATE {TAG &lt;tag_name&gt; | EDGE &lt;edge_name&gt;}</code> <code>SHOW CREATE TAG player</code> Shows the basic information of the specified tag. SHOW HOSTS <code>SHOW HOSTS [GRAPH | STORAGE | META]</code> <code>SHOW HOSTS</code><code>SHOW HOSTS GRAPH</code> Shows the host and version information of Graph Service, Storage Service, and Meta Service. SHOW INDEX STATUS <code>SHOW {TAG | EDGE} INDEX STATUS</code> <code>SHOW TAG INDEX STATUS</code> Shows the status of jobs that rebuild native indexes, which helps check whether a native index is successfully rebuilt or not. SHOW INDEXES <code>SHOW {TAG | EDGE} INDEXES</code> <code>SHOW TAG INDEXES</code> Shows the names of existing native indexes. SHOW PARTS <code>SHOW PARTS [&lt;part_id&gt;]</code> <code>SHOW PARTS</code> Shows the information of a specified partition or all partitions in a graph space. SHOW ROLES <code>SHOW ROLES IN &lt;space_name&gt;</code> <code>SHOW ROLES in basketballplayer</code> Shows the roles that are assigned to a user account. SHOW SNAPSHOTS <code>SHOW SNAPSHOTS</code> <code>SHOW SNAPSHOTS</code> Shows the information of all the snapshots. SHOW SPACES <code>SHOW SPACES</code> <code>SHOW SPACES</code> Shows existing graph spaces in NebulaGraph. SHOW STATS <code>SHOW STATS</code> <code>SHOW STATS</code> Shows the statistics of the graph space collected by the latest <code>STATS</code> job. SHOW TAGS/EDGES <code>SHOW TAGS | EDGES</code> <code>SHOW TAGS</code>,<code>SHOW EDGES</code> Shows all the tags in the current graph space. SHOW USERS <code>SHOW USERS</code> <code>SHOW USERS</code> Shows the user information. SHOW SESSIONS <code>SHOW SESSIONS</code> <code>SHOW SESSIONS</code> Shows the information of all the sessions. SHOW SESSIONS <code>SHOW SESSION &lt;Session_Id&gt;</code> <code>SHOW SESSION 1623304491050858</code> Shows a specified session with its ID. SHOW QUERIES <code>SHOW [ALL] QUERIES</code> <code>SHOW QUERIES</code> Shows the information of working queries in the current session. SHOW META LEADER <code>SHOW META LEADER</code> <code>SHOW META LEADER</code> Shows the information of the leader in the current Meta cluster. </li> </ul>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/#clauses_and_options","title":"Clauses and options","text":"Clause Syntax Example Description GROUP BY <code>GROUP BY &lt;var&gt; YIELD &lt;var&gt;, &lt;aggregation_function(var)&gt;</code> <code>GO FROM \"player100\" OVER follow BIDIRECT YIELD $$.player.name as Name | GROUP BY $-.Name YIELD $-.Name as Player, count(*) AS Name_Count</code> Finds all the vertices connected directly to vertex <code>\"player100\"</code>, groups the result set by player names, and counts how many times the name shows up in the result set. LIMIT <code>YIELD &lt;var&gt; [| LIMIT [&lt;offset_value&gt;,] &lt;number_rows&gt;]</code> <code>GO FROM \"player100\" OVER follow REVERSELY YIELD $$.player.name AS Friend, $$.player.age AS Age | ORDER BY $-.Age, $-.Friend | LIMIT 1, 3</code> Returns the 3 rows of data starting from the second row of the sorted output. SKIP <code>RETURN &lt;var&gt; [SKIP &lt;offset&gt;] [LIMIT &lt;number_rows&gt;]</code> <code>MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) RETURN v2.player.name AS Name, v2.player.age AS Age ORDER BY Age DESC SKIP 1</code> <code>SKIP</code> can be used alone to set the offset and return the data after the specified position. SAMPLE <code>&lt;go_statement&gt; SAMPLE &lt;sample_list&gt;;</code> <code>GO 3 STEPS FROM \"player100\" OVER * YIELD properties($$).name AS NAME, properties($$).age AS Age SAMPLE [1,2,3];</code> Takes samples evenly in the result set and returns the specified amount of data. ORDER BY <code>&lt;YIELD clause&gt; ORDER BY &lt;expression&gt; [ASC | DESC] [, &lt;expression&gt; [ASC | DESC] ...]</code> <code>FETCH PROP ON player \"player100\", \"player101\", \"player102\", \"player103\" YIELD player.age AS age, player.name AS name | ORDER BY $-.age ASC, $-.name DESC</code> The <code>ORDER BY</code> clause specifies the order of the rows in the output. RETURN <code>RETURN {&lt;vertex_name&gt;|&lt;edge_name&gt;|&lt;vertex_name&gt;.&lt;property&gt;|&lt;edge_name&gt;.&lt;property&gt;|...}</code> <code>MATCH (v:player) RETURN v.player.name, v.player.age LIMIT 3</code> Returns the first three rows with values of the vertex properties <code>name</code> and <code>age</code>. TTL <code>CREATE TAG &lt;tag_name&gt;(&lt;property_name_1&gt; &lt;property_value_1&gt;, &lt;property_name_2&gt; &lt;property_value_2&gt;, ...) ttl_duration= &lt;value_int&gt;, ttl_col = &lt;property_name&gt;</code> <code>CREATE TAG t2(a int, b int, c string) ttl_duration= 100, ttl_col = \"a\"</code> Create a tag and set the TTL options. WHERE <code>WHERE {&lt;vertex|edge_alias&gt;.&lt;property_name&gt; {&gt;|==|&lt;|...} &lt;value&gt;...}</code> <code>MATCH (v:player) WHERE v.player.name == \"Tim Duncan\" XOR (v.player.age &lt; 30 AND v.player.name == \"Yao Ming\") OR NOT (v.player.name == \"Yao Ming\" OR v.player.name == \"Tim Duncan\") RETURN v.player.name, v.player.age</code> The <code>WHERE</code> clause filters the output by conditions. The <code>WHERE</code> clause usually works in Native nGQL <code>GO</code> and <code>LOOKUP</code> statements, and OpenCypher <code>MATCH</code> and <code>WITH</code> statements. YIELD <code>YIELD [DISTINCT] &lt;col&gt; [AS &lt;alias&gt;] [, &lt;col&gt; [AS &lt;alias&gt;] ...] [WHERE &lt;conditions&gt;];</code> <code>GO FROM \"player100\" OVER follow YIELD dst(edge) AS ID | FETCH PROP ON player $-.ID YIELD player.age AS Age | YIELD AVG($-.Age) as Avg_age, count(*)as Num_friends</code> Finds the players that \"player100\" follows and calculates their average age. WITH <code>MATCH $expressions WITH {nodes()|labels()|...}</code> <code>MATCH p=(v:player{name:\"Tim Duncan\"})--() WITH nodes(p) AS n UNWIND n AS n1 RETURN DISTINCT n1</code> The <code>WITH</code> clause can retrieve the output from a query part, process it, and pass it to the next query part as the input. UNWIND <code>UNWIND &lt;list&gt; AS &lt;alias&gt; &lt;RETURN clause&gt;</code> <code>UNWIND [1,2,3] AS n RETURN n</code> Splits a list into rows."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#space_statements","title":"Space statements","text":"Statement Syntax Example Description CREATE SPACE <code>CREATE SPACE [IF NOT EXISTS] &lt;graph_space_name&gt; ( [partition_num = &lt;partition_number&gt;,] [replica_factor = &lt;replica_number&gt;,] vid_type = {FIXED_STRING(&lt;N&gt;) | INT[64]} ) [COMMENT = '&lt;comment&gt;']</code> <code>CREATE SPACE my_space_1 (vid_type=FIXED_STRING(30))</code> Creates a graph space with CREATE SPACE <code>CREATE SPACE &lt;new_graph_space_name&gt; AS &lt;old_graph_space_name&gt;</code> <code>CREATE SPACE my_space_4 as my_space_3</code> Clone a graph. space. USE <code>USE &lt;graph_space_name&gt;</code> <code>USE space1</code> Specifies a graph space as the current working graph space for subsequent queries. SHOW SPACES <code>SHOW SPACES</code> <code>SHOW SPACES</code> Lists all the graph spaces in the NebulaGraph examples. DESCRIBE SPACE <code>DESC[RIBE] SPACE &lt;graph_space_name&gt;</code> <code>DESCRIBE SPACE basketballplayer</code> Returns the information about the specified graph space. CLEAR SPACE <code>CLEAR SPACE [IF EXISTS] &lt;graph_space_name&gt;</code> Deletes the vertices and edges in a graph space, but does not delete the graph space itself and the schema information. DROP SPACE <code>DROP SPACE [IF EXISTS] &lt;graph_space_name&gt;</code> <code>DROP SPACE basketballplayer</code> Deletes everything in the specified graph space."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#tag_statements","title":"TAG statements","text":"Statement Syntax Example Description CREATE TAG <code>CREATE TAG [IF NOT EXISTS] &lt;tag_name&gt; ( &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;'] [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL |  NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] ) [TTL_DURATION = &lt;ttl_duration&gt;] [TTL_COL = &lt;prop_name&gt;] [COMMENT = '&lt;comment&gt;']</code> <code>CREATE TAG woman(name string, age int, married bool, salary double, create_time timestamp) TTL_DURATION = 100, TTL_COL = \"create_time\"</code> Creates a tag with the given name in a graph space. DROP TAG <code>DROP TAG [IF EXISTS] &lt;tag_name&gt;</code> <code>DROP TAG test;</code> Drops a tag with the given name in the current working graph space. ALTER TAG <code>ALTER TAG &lt;tag_name&gt;    &lt;alter_definition&gt; [, alter_definition] ...]    [ttl_definition [, ttl_definition] ... ]    [COMMENT = '&lt;comment&gt;']</code> <code>ALTER TAG t1 ADD (p3 int, p4 string)</code> Alters the structure of a tag with the given name in a graph space. You can add or drop properties, and change the data type of an existing property. You can also set a TTL (Time-To-Live) on a property, or change its TTL duration. SHOW TAGS <code>SHOW TAGS</code> <code>SHOW TAGS</code> Shows the name of all tags in the current graph space. DESCRIBE TAG <code>DESC[RIBE] TAG &lt;tag_name&gt;</code> <code>DESCRIBE TAG player</code> Returns the information about a tag with the given name in a graph space, such as field names, data type, and so on. DELETE TAG <code>DELETE TAG &lt;tag_name_list&gt; FROM &lt;VID&gt;</code> <code>DELETE TAG test1 FROM \"test\"</code> Deletes a tag with the given name on a specified vertex."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#edge_type_statements","title":"Edge type statements","text":"Statement Syntax Example Description CREATE EDGE <code>CREATE EDGE [IF NOT EXISTS] &lt;edge_type_name&gt;    ( &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;'] [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] ) [TTL_DURATION = &lt;ttl_duration&gt;] [TTL_COL = &lt;prop_name&gt;] [COMMENT = '&lt;comment&gt;']</code> <code>CREATE EDGE e1(p1 string, p2 int, p3 timestamp) TTL_DURATION = 100, TTL_COL = \"p2\"</code> Creates an edge type with the given name in a graph space. DROP EDGE <code>DROP EDGE [IF EXISTS] &lt;edge_type_name&gt;</code> <code>DROP EDGE e1</code> Drops an edge type with the given name in a graph space. ALTER EDGE <code>ALTER EDGE &lt;edge_type_name&gt;    &lt;alter_definition&gt; [, alter_definition] ...]    [ttl_definition [, ttl_definition] ... ]    [COMMENT = '&lt;comment&gt;']</code> <code>ALTER EDGE e1 ADD (p3 int, p4 string)</code> Alters the structure of an edge type with the given name in a graph space. SHOW EDGES <code>SHOW EDGES</code> <code>SHOW EDGES</code> Shows all edge types in the current graph space. DESCRIBE EDGE <code>DESC[RIBE] EDGE &lt;edge_type_name&gt;</code> <code>DESCRIBE EDGE follow</code> Returns the information about an edge type with the given name in a graph space, such as field names, data type, and so on."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#vertex_statements","title":"Vertex statements","text":"Statement Syntax Example Description INSERT VERTEX <code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...] VALUES &lt;vid&gt;: ([prop_value_list])</code> <code>INSERT VERTEX t2 (name, age) VALUES \"13\":(\"n3\", 12), \"14\":(\"n4\", 8)</code> Inserts one or more vertices into a graph space in NebulaGraph. DELETE VERTEX <code>DELETE VERTEX &lt;vid&gt; [, &lt;vid&gt; ...]</code> <code>DELETE VERTEX \"team1\"</code> Deletes vertices and the related incoming and outgoing edges of the vertices. UPDATE VERTEX <code>UPDATE VERTEX ON &lt;tag_name&gt; &lt;vid&gt; SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;output&gt;]</code> <code>UPDATE VERTEX ON player \"player101\" SET age = age + 2</code> Updates properties on tags of a vertex. UPSERT VERTEX <code>UPSERT VERTEX ON &lt;tag&gt; &lt;vid&gt; SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;output&gt;]</code> <code>UPSERT VERTEX ON player \"player667\" SET age = 31</code> The <code>UPSERT</code> statement is a combination of <code>UPDATE</code> and <code>INSERT</code>. You can use <code>UPSERT VERTEX</code> to update the properties of a vertex if it exists or insert a new vertex if it does not exist."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#edge_statements","title":"Edge statements","text":"Statement Syntax Example Description INSERT EDGE <code>INSERT EDGE [IF NOT EXISTS] &lt;edge_type&gt; ( &lt;prop_name_list&gt; ) VALUES &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ) [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ), ...]</code> <code>INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 1)</code> Inserts an edge or multiple edges into a graph space from a source vertex (given by src_vid) to a destination vertex (given by dst_vid) with a specific rank in NebulaGraph. DELETE EDGE <code>DELETE EDGE &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] ...]</code> <code>DELETE EDGE serve \"player100\" -&gt; \"team204\"@0</code> Deletes one edge or multiple edges at a time. UPDATE EDGE <code>UPDATE EDGE ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; [@&lt;rank&gt;] SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;output&gt;]</code> <code>UPDATE EDGE ON serve \"player100\" -&gt; \"team204\"@0 SET start_year = start_year + 1</code> Updates properties on an edge. UPSERT EDGE <code>UPSERT EDGE ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; [@rank] SET &lt;update_prop&gt; [WHEN &lt;condition&gt;] [YIELD &lt;properties&gt;]</code> <code>UPSERT EDGE on serve \"player666\" -&gt; \"team200\"@0 SET end_year = 2021</code> The <code>UPSERT</code> statement is a combination of <code>UPDATE</code> and <code>INSERT</code>. You can use <code>UPSERT EDGE</code> to update the properties of an edge if it exists or insert a new edge if it does not exist."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#index","title":"Index","text":"<ul> <li> <p>Native index</p> <p>You can use native indexes together with <code>LOOKUP</code> and <code>MATCH</code> statements.</p> Statement Syntax Example Description CREATE INDEX <code>CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] &lt;index_name&gt; ON {&lt;tag_name&gt; | &lt;edge_name&gt;} ([&lt;prop_name_list&gt;]) [COMMENT = '&lt;comment&gt;']</code> <code>CREATE TAG INDEX player_index on player()</code> Add native indexes for the existing tags, edge types, or properties. SHOW CREATE INDEX <code>SHOW CREATE {TAG | EDGE} INDEX &lt;index_name&gt;</code> <code>show create tag index index_2</code> Shows the statement used when creating a tag or an edge type. It contains detailed information about the index, such as its associated properties. SHOW INDEXES <code>SHOW {TAG | EDGE} INDEXES</code> <code>SHOW TAG INDEXES</code> Shows the defined tag or edge type indexes names in the current graph space. DESCRIBE INDEX <code>DESCRIBE {TAG | EDGE} INDEX &lt;index_name&gt;</code> <code>DESCRIBE TAG INDEX player_index_0</code> Gets the information about the index with a given name, including the property name (Field) and the property type (Type) of the index. REBUILD INDEX <code>REBUILD {TAG | EDGE} INDEX [&lt;index_name_list&gt;]</code> <code>REBUILD TAG INDEX single_person_index</code> Rebuilds the created tag or edge type index. If data is updated or inserted before the creation of the index, you must rebuild the indexes manually to make sure that the indexes contain the previously added data. SHOW INDEX STATUS <code>SHOW {TAG | EDGE} INDEX STATUS</code> <code>SHOW TAG INDEX STATUS</code> Returns the name of the created tag or edge type index and its status. DROP INDEX <code>DROP {TAG | EDGE} INDEX [IF EXISTS] &lt;index_name&gt;</code> <code>DROP TAG INDEX player_index_0</code> Removes an existing index from the current graph space. </li> </ul> <ul> <li> <p>Full-text index</p> Syntax Example Description <code>SIGN IN TEXT SERVICE [(&lt;elastic_ip:port&gt; [,&lt;username&gt;, &lt;password&gt;]), (&lt;elastic_ip:port&gt;), ...]</code> <code>SIGN IN TEXT SERVICE (127.0.0.1:9200)</code> The full-text indexes is implemented based on Elasticsearch. After deploying an Elasticsearch cluster, you can use the <code>SIGN IN</code> statement to log in to the Elasticsearch client. <code>SHOW TEXT SEARCH CLIENTS</code> <code>SHOW TEXT SEARCH CLIENTS</code> Shows text search clients. <code>SIGN OUT TEXT SERVICE</code> <code>SIGN OUT TEXT SERVICE</code> Signs out to the text search clients. <code>CREATE FULLTEXT {TAG | EDGE} INDEX &lt;index_name&gt; ON {&lt;tag_name&gt; | &lt;edge_name&gt;} (&lt;prop_name&gt; [,&lt;prop_name&gt;]...) [ANALYZER=\"&lt;analyzer_name&gt;\"]</code> <code>CREATE FULLTEXT TAG INDEX nebula_index_1 ON player(name)</code> Creates full-text indexes. <code>SHOW FULLTEXT INDEXES</code> <code>SHOW FULLTEXT INDEXES</code> Show full-text indexes. <code>REBUILD FULLTEXT INDEX</code> <code>REBUILD FULLTEXT INDEX</code> Rebuild full-text indexes. <code>DROP FULLTEXT INDEX &lt;index_name&gt;</code> <code>DROP FULLTEXT INDEX nebula_index_1</code> Drop full-text indexes. <code>LOOKUP ON {&lt;tag&gt; | &lt;edge_type&gt;} WHERE ES_QUERY(&lt;index_name&gt;, \"&lt;text&gt;\") YIELD &lt;return_list&gt; [| LIMIT [&lt;offset&gt;,] &lt;number_rows&gt;]</code> <code>LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"Chris\") YIELD id(vertex)</code> Use query options. </li> </ul>"},{"location":"2.quick-start/6.cheatsheet-for-ngql/#subgraph_and_path_statements","title":"Subgraph and path statements","text":"Type Syntax Example Description GET SUBGRAPH <code>GET SUBGRAPH [WITH PROP] [&lt;step_count&gt; {STEP|STEPS}] FROM {&lt;vid&gt;, &lt;vid&gt;...} [{IN | OUT | BOTH} &lt;edge_type&gt;, &lt;edge_type&gt;...] YIELD [VERTICES AS &lt;vertex_alias&gt;] [,EDGES AS &lt;edge_alias&gt;]</code> <code>GET SUBGRAPH 1 STEPS FROM \"player100\" YIELD VERTICES AS nodes, EDGES AS relationships</code> Retrieves information of vertices and edges reachable from the source vertices of the specified edge types and returns information of the subgraph. FIND PATH <code>FIND { SHORTEST | ALL | NOLOOP } PATH [WITH PROP] FROM &lt;vertex_id_list&gt; TO &lt;vertex_id_list&gt; OVER &lt;edge_type_list&gt; [REVERSELY | BIDIRECT] [&lt;WHERE clause&gt;] [UPTO &lt;N&gt; {STEP|STEPS}] YIELD path as &lt;alias&gt; [| ORDER BY $-.path] [| LIMIT &lt;M&gt;]</code> <code>FIND SHORTEST PATH FROM \"player102\" TO \"team204\" OVER * YIELD path as p</code> Finds the paths between the selected source vertices and destination vertices. A returned path is like <code>(&lt;vertex_id&gt;)-[:&lt;edge_type_name&gt;@&lt;rank&gt;]-&gt;(&lt;vertex_id)</code>."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#query_tuning_statements","title":"Query tuning statements","text":"Type Syntax Example Description EXPLAIN <code>EXPLAIN [format=\"row\" | \"dot\"] &lt;your_nGQL_statement&gt;</code> <code>EXPLAIN format=\"row\" SHOW TAGS</code><code>EXPLAIN format=\"dot\" SHOW TAGS</code> Helps output the execution plan of an nGQL statement without executing the statement. PROFILE <code>PROFILE [format=\"row\" | \"dot\"] &lt;your_nGQL_statement&gt;</code> <code>PROFILE format=\"row\" SHOW TAGS</code><code>PROFILE format=\"dot\" SHOW TAGS</code> Executes the statement, then outputs the execution plan as well as the execution profile."},{"location":"2.quick-start/6.cheatsheet-for-ngql/#operation_and_maintenance_statements","title":"Operation and maintenance statements","text":"<ul> <li> <p>SUBMIT JOB BALANCE</p> Syntax Description <code>BALANCE LEADER</code> Starts a job to balance the distribution of all the storage leaders in graph spaces. It returns the job ID. </li> </ul> <ul> <li> <p>Job statements</p> Syntax Description <code>SUBMIT JOB COMPACT</code> Triggers the long-term RocksDB <code>compact</code> operation. <code>SUBMIT JOB FLUSH</code> Writes the RocksDB memfile in the memory to the hard disk. <code>SUBMIT JOB STATS</code> Starts a job that makes the statistics of the current graph space. Once this job succeeds, you can use the <code>SHOW STATS</code> statement to list the statistics. <code>SHOW JOB &lt;job_id&gt;</code> Shows the information about a specific job and all its tasks in the current graph space. The Meta Service parses a <code>SUBMIT JOB</code> request into multiple tasks and assigns them to the nebula-storaged processes. <code>SHOW JOBS</code> Lists all the unexpired jobs in the current graph space. <code>STOP JOB</code> Stops jobs that are not finished in the current graph space. <code>RECOVER JOB</code> Re-executes the failed jobs in the current graph space and returns the number of recovered jobs. </li> </ul> <ul> <li> <p>Kill queries</p> Syntax Example Description <code>KILL QUERY (session=&lt;session_id&gt;, plan=&lt;plan_id&gt;)</code> <code>KILL QUERY(SESSION=1625553545984255,PLAN=163)</code> Terminates the query being executed, and is often used to terminate slow queries. </li> </ul> <ul> <li> <p>Kill sessions</p> Syntax Example Description <code>KILL {SESSION|SESSIONS} &lt;SessionId&gt;</code> <code>KILL SESSION 1672887983842984</code> Terminates a single session. <code>SHOW SESSIONS | YIELD $-.SessionId AS sid [WHERE &lt;filter_clause&gt;] | KILL {SESSION|SESSIONS} $-.sid</code> <code>SHOW SESSIONS | YIELD $-.SessionId AS sid, $-.CreateTime as CreateTime | ORDER BY $-.CreateTime ASC | LIMIT 2 | KILL SESSIONS $-.sid</code> Terminates multiple sessions based on specified criteria. <code>SHOW SESSIONS | KILL SESSIONS $-.SessionId</code> <code>SHOW SESSIONS | KILL SESSIONS $-.SessionId</code> Terminates all sessions. </li> </ul>"},{"location":"20.appendix/0.FAQ/","title":"FAQ","text":"<p>This topic lists the frequently asked questions for using NebulaGraph 3.8.0. You can use the search box in the help center or the search function of the browser to match the questions you are looking for.</p> <p>If the solutions described in this topic cannot solve your problems, ask for help on the NebulaGraph forum or submit an issue on GitHub issue.</p>"},{"location":"20.appendix/0.FAQ/#about_manual_updates","title":"About manual updates","text":""},{"location":"20.appendix/0.FAQ/#why_is_the_behavior_in_the_manual_not_consistent_with_the_system","title":"\"Why is the behavior in the manual not consistent with the system?\"","text":"<p>NebulaGraph is still under development. Its behavior changes from time to time. Users can submit an issue to inform the team if the manual and the system are not consistent.</p> <p>Note</p> <p>If you find some errors in this topic:</p> <ol> <li>Click the <code>pencil</code> button at the top right side of this page.</li> <li>Use markdown to fix this error. Then click \"Commit changes\" at the bottom, which will start a Github pull request.</li> <li>Sign the CLA. This pull request will be merged after the acceptance of at least two reviewers.</li> </ol>"},{"location":"20.appendix/0.FAQ/#about_legacy_version_compatibility","title":"About legacy version compatibility","text":"<p>Compatibility</p> <p>Neubla Graph 3.8.0 is not compatible with NebulaGraph 1.x nor 2.0-RC in both data formats and RPC-protocols, and vice versa. The service process may quit if using an lower version client to connect to a higher version server.</p> <p>To upgrade data formats, see Upgrade NebulaGraph to the current version. Users must upgrade all clients.</p>"},{"location":"20.appendix/0.FAQ/#about_execution_errors","title":"About execution errors","text":""},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_-1005graphmemoryexceeded_-2600","title":"\"How to resolve the error <code>-1005:GraphMemoryExceeded: (-2600)</code>?\"","text":"<p>This error is issued by the Memory Tracker when it observes that memory usage has exceeded a set threshold. This mechanism can help avoid service processes from being terminated by the system's OOM (Out of Memory) killer. Steps to resolve:</p> <ol> <li> <p>Check memory usage: First, you need to check the memory usage during the execution of the command. If the memory usage is indeed high, then this error might be expected.</p> </li> <li> <p>Check the configuration of the Memory Tracker: If the memory usage is not high, check the relevant configurations of the Memory Tracker. These include <code>memory_tracker_untracked_reserved_memory_mb</code> (untracked reserved memory in MB), <code>memory_tracker_limit_ratio</code> (memory limit ratio), and <code>memory_purge_enabled</code> (whether memory purge is enabled). For the configuration of the Memory Tracker, see memory tracker configuration.</p> </li> <li> <p>Optimize configurations: Adjust these configurations according to the actual situation. For example, if the available memory limit is too low, you can increase the value of <code>memory_tracker_limit_ratio</code>.</p> </li> </ol>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_semanticerror_missing_yield_clause","title":"\"How to resolve the error <code>SemanticError: Missing yield clause.</code>?\"","text":"<p>Starting with NebulaGraph 3.0.0, the statements <code>LOOKUP</code>, <code>GO</code>, and <code>FETCH</code> must output results with the <code>YIELD</code> clause. For more information, see YIELD.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_host_not_enough","title":"\"How to resolve the error <code>Host not enough!</code>?\"","text":"<p>From NebulaGraph version 3.0.0, the Storage services added in the configuration files CANNOT be read or written directly. The configuration files only register the Storage services into the Meta services. You must run the <code>ADD HOSTS</code> command to read and write data on Storage servers. For more information, see Manage Storage hosts.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_to_get_the_property_of_the_vertex_in_vage_should_use_the_format_vartagprop","title":"\"How to resolve the error <code>To get the property of the vertex in 'v.age', should use the format 'var.tag.prop'</code>?\"","text":"<p>From NebulaGraph version 3.0.0, patterns support matching multiple tags at the same time, so you need to specify a tag name when querying properties. The original statement <code>RETURN variable_name.property_name</code> is changed to <code>RETURN variable_name.&lt;tag_name&gt;.property_name</code>.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_used_memory_hits_the_high_watermark0800000_of_total_system_memory","title":"\"How to resolve <code>Used memory hits the high watermark(0.800000) of total system memory.</code>?\"","text":"<p>The error may be caused if the system memory usage is higher than the threshold specified by<code>system_memory_high_watermark_ratio</code>, which defaults to <code>0.8</code>. When the threshold is exceeded, an alarm is triggered and NebulaGraph stops processing queries.</p> <p>Possible solutions are as follows:</p> <ul> <li>Clean the system memory to make it below the threshold.</li> <li>Modify the Graph configuration. Add the <code>system_memory_high_watermark_ratio</code> parameter to the configuration files of all Graph servers, and set it greater than <code>0.8</code>, such as <code>0.9</code>.</li> </ul> <p>However, the <code>system_memory_high_watermark_ratio</code> parameter is deprecated. It is recommended that you use the Memory Tracker feature instead to limit the memory usage of Graph and Storage services. For more information, see Memory Tracker for Graph service and Memory Tracker for Storage service.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_storage_error_e_rpc_failure","title":"\"How to resolve the error <code>Storage Error E_RPC_FAILURE</code>?\"","text":"<p>The reason for this error is usually that the storaged process returns too many data back to the graphd process. Possible solutions are as follows:</p> <ul> <li>Modify configuration files: Modify the value of <code>--storage_client_timeout_ms</code> in the <code>nebula-graphd.conf</code> file to extend the connection timeout of the Storage client. This configuration is measured in milliseconds (ms). For example, set <code>--storage_client_timeout_ms=60000</code>. If this parameter is not specified in the <code>nebula-graphd.conf</code> file, specify it manually. Tip: Add <code>--local_config=true</code> at the beginning of the configuration file and restart the service.</li> <li>Optimize the query statement: Reduce queries that scan the entire database. No matter whether <code>LIMIT</code> is used to limit the number of returned results, use the <code>GO</code> statement to rewrite the <code>MATCH</code> statement (the former is optimized, while the latter is not).</li> <li>Check whether the Storaged process has OOM. (<code>dmesg |grep nebula</code>).</li> <li>Use better SSD or memory for the Storage Server.</li> <li>Retry.</li> </ul>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_the_leader_has_changed_try_again_later","title":"\"How to resolve the error <code>The leader has changed. Try again later</code>?\"","text":"<p>It is a known issue. Just retry 1 to N times, where N is the partition number. The reason is that the meta client needs some heartbeats to update or errors to trigger the new leader information.</p> <p>If this error occurs when logging in to NebulaGraph, you can consider using <code>df -h</code> to view the disk space and check whether the local disk is full.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_schema_not_exist_xxx","title":"\"How to resolve <code>Schema not exist: xxx</code>?\"","text":"<p>If the system returns <code>Schema not exist</code> when querying, make sure that:</p> <ul> <li>Whether there is a tag or an edge type in the Schema.</li> </ul> <ul> <li>Whether the name of the tag or the edge type is a keyword. If it is a keyword, enclose them with backquotes (`). For more information, see Keywords.</li> </ul>"},{"location":"20.appendix/0.FAQ/#unable_to_download_snapshot_packages_when_compiling_exchange_connectors_or_algorithm","title":"Unable to download SNAPSHOT packages when compiling Exchange, Connectors, or Algorithm","text":"<p>Problem description: The system reports <code>Could not find artifact com.vesoft:client:jar:xxx-SNAPSHOT</code> when compiling.</p> <p>Cause: There is no local Maven repository for storing or downloading SNAPSHOT packages. The default central repository in Maven only stores official releases, not development versions (SNAPSHOTs).</p> <p>Solution: Add the following configuration in the <code>profiles</code> scope of Maven's <code>setting.xml</code> file:</p> <pre><code>  &lt;profile&gt;\n     &lt;activation&gt;\n        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\n     &lt;/activation&gt;\n     &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;snapshots&lt;/id&gt;\n            &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;\n            &lt;snapshots&gt;\n               &lt;enabled&gt;true&lt;/enabled&gt;\n            &lt;/snapshots&gt;\n      &lt;/repository&gt;\n     &lt;/repositories&gt;\n  &lt;/profile&gt;\n</code></pre>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_error_-1004_syntaxerror_syntax_error_near","title":"\"How to resolve <code>[ERROR (-1004)]: SyntaxError: syntax error near</code>?\"","text":"<p>In most cases, a query statement requires a <code>YIELD</code> or a <code>RETURN</code>. Check your query statement to see if <code>YIELD</code> or <code>RETURN</code> is provided.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_cant_solve_the_start_vids_from_the_sentence","title":"\"How to resolve the error <code>can\u2019t solve the start vids from the sentence</code>?\"","text":"<p>The graphd process requires <code>start vids</code> to begin a graph traversal. The <code>start vids</code> can be specified by the user. For example:</p> <pre><code>&gt; GO FROM ${vids} ...\n&gt; MATCH (src) WHERE id(src) == ${vids}\n# The \"start vids\" are explicitly given by ${vids}.\n</code></pre> <p>It can also be found from a property index. For example:</p> <pre><code># CREATE TAG INDEX IF NOT EXISTS i_player ON player(name(20));\n# REBUILD TAG INDEX i_player;\n\n&gt; LOOKUP ON player WHERE player.name == \"abc\" | ... YIELD ...\n&gt; MATCH (src) WHERE src.name == \"abc\" ...\n# The \"start vids\" are found from the property index \"name\".\n</code></pre> <p>Otherwise, an error like <code>can\u2019t solve the start vids from the sentence</code> will be returned.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_wrong_vertex_id_type_1001","title":"\"How to resolve the error <code>Wrong vertex id type: 1001</code>?\"","text":"<p>Check whether the VID is <code>INT64</code> or <code>FIXED_STRING(N)</code> set by <code>create space</code>. For more information, see create space.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_the_vid_must_be_a_64-bit_integer_or_a_string_fitting_space_vertex_id_length_limit","title":"\"How to resolve the error <code>The VID must be a 64-bit integer or a string fitting space vertex id length limit.</code>?\"","text":"<p>Check whether the length of the VID exceeds the limitation. For more information, see create space.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_edge_conflict_or_vertex_conflict","title":"\"How to resolve the error <code>edge conflict</code> or <code>vertex conflict</code>?\"","text":"<p>NebulaGraph may return such errors when the Storage service receives multiple requests to insert or update the same vertex or edge within milliseconds. Try the failed requests again later.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_rpc_failure_in_metaclient_connection_refused","title":"\"How to resolve the error <code>RPC failure in MetaClient: Connection refused</code>?\"","text":"<p>The reason for this error is usually that the metad service status is unusual, or the network of the machine where the metad and graphd services are located is disconnected. Possible solutions are as follows:</p> <ul> <li>Check the metad service status on the server where the metad is located. If the service status is unusual, restart the metad service.</li> </ul> <ul> <li>Use <code>telnet meta-ip:port</code> to check the network status under the server that returns an error.</li> </ul> <ul> <li>Check the port information in the configuration file. If the port is different from the one used when connecting, use the port in the configuration file or modify the configuration.</li> </ul>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_storageclientbaseinl214_request_to_xxxx9779_failed_n6apache6thrift9transport19ttransportexceptione_timed_out_in_nebula-graphinfo","title":"\"How to resolve the error <code>StorageClientBase.inl:214] Request to \"x.x.x.x\":9779 failed: N6apache6thrift9transport19TTransportExceptionE: Timed Out</code> in <code>nebula-graph.INFO</code>?\"","text":"<p>The reason for this error may be that the amount of data to be queried is too large, and the storaged process has timed out. Possible solutions are as follows:</p> <ul> <li>When importing data, set Compaction manually to make read faster.</li> </ul> <ul> <li>Extend the RPC connection timeout of the Graph service and the Storage service. Modify the value of <code>--storage_client_timeout_ms</code> in the <code>nebula-graphd.conf</code> file. This configuration is measured in milliseconds (ms). The default value is 60000ms.</li> </ul>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_metaclientcpp65_heartbeat_failed_statuswrong_cluster_in_nebula-storagedinfo_or_hbprocessorcpp54_reject_wrong_cluster_host_xxxx9771_in_nebula-metadinfo","title":"\"How to resolve the error <code>MetaClient.cpp:65] Heartbeat failed, status:Wrong cluster!</code> in <code>nebula-storaged.INFO</code>, or <code>HBProcessor.cpp:54] Reject wrong cluster host \"x.x.x.x\":9771!</code> in <code>nebula-metad.INFO</code>?\"","text":"<p>The reason for this error may be that the user has modified the IP or the port information of the metad process, or the storage service has joined other clusters before. Possible solutions are as follows:</p> <p>Delete the <code>cluster.id</code> file in the installation directory where the storage machine is deployed (the default installation directory is <code>/usr/local/nebula</code>), and restart the storaged service.</p>"},{"location":"20.appendix/0.FAQ/#how_to_resolve_the_error_storage_error_more_than_one_request_trying_to_addupdatedelete_one_edgevertex_at_he_same_time","title":"\"How to resolve the error <code>Storage Error: More than one request trying to add/update/delete one edge/vertex at he same time.</code>?\"","text":"<p>The reason for this error is that the current NebulaGraph version does not support concurrent requests to the same vertex or edge at the same time. To solve this error, re-execute your commands.</p>"},{"location":"20.appendix/0.FAQ/#about_design_and_functions","title":"About design and functions","text":""},{"location":"20.appendix/0.FAQ/#how_is_the_time_spent_value_at_the_end_of_each_return_message_calculated","title":"\"How is the <code>time spent</code> value at the end of each return message calculated?\"","text":"<p>Take the returned message of <code>SHOW SPACES</code> as an example:</p> <pre><code>nebula&gt; SHOW SPACES;\n+--------------------+\n| Name               |\n+--------------------+\n| \"basketballplayer\" |\n+--------------------+\nGot 1 rows (time spent 1235/1934 us)\n</code></pre> <ul> <li>The first number <code>1235</code> shows the time spent by the database itself, that is, the time it takes for the query engine to receive a query from the client, fetch the data from the storage server, and perform a series of calculations.</li> </ul> <ul> <li>The second number <code>1934</code> shows the time spent from the client's perspective, that is, the time it takes for the client from sending a request, receiving a response, and displaying the result on the screen.</li> </ul>"},{"location":"20.appendix/0.FAQ/#why_does_the_port_number_of_the_nebula-storaged_process_keep_showing_red_after_connecting_to_nebulagraph","title":"\"Why does the port number of the <code>nebula-storaged</code> process keep showing red after connecting to NebulaGraph?\"","text":"<p>Because the <code>nebula-storaged</code> process waits for <code>nebula-metad</code> to add the current Storage service during the startup process. The Storage works after it receives the ready signal. Starting from NebulaGraph 3.0.0, the Meta service cannot directly read or write data in the Storage service that you add in the configuration file. The configuration file only registers the Storage service to the Meta service. You must run the <code>ADD HOSTS</code> command to enable the Meta to read and write data in the Storage service. For more information, see Manage Storage hosts.</p>"},{"location":"20.appendix/0.FAQ/#why_is_there_no_line_separating_each_row_in_the_returned_result_of_nebulagraph_260","title":"\"Why is there no line separating each row in the returned result of NebulaGraph 2.6.0?\"","text":"<p>This is caused by the release of NebulaGraph Console 2.6.0, not the change of NebulaGraph core. And it will not affect the content of the returned data itself.</p>"},{"location":"20.appendix/0.FAQ/#about_dangling_edges","title":"About dangling edges","text":"<p>A dangling edge is an edge that only connects to a single vertex and only one part of the edge connects to the vertex.</p> <p>Dangling edges may appear in NebulaGraph 3.8.0 as the design. And there is no <code>MERGE</code> statements of openCypher. The guarantee for dangling edges depends entirely on the application level. For more information, see INSERT VERTEX, DELETE VERTEX, INSERT EDGE, DELETE EDGE.</p>"},{"location":"20.appendix/0.FAQ/#can_i_set_replica_factor_as_an_even_number_in_create_space_statements_eg_replica_factor_2","title":"\"Can I set <code>replica_factor</code> as an even number in <code>CREATE SPACE</code> statements, e.g., <code>replica_factor = 2</code>?\"","text":"<p>NO.</p> <p>The Storage service guarantees its availability based on the Raft consensus protocol. The number of failed replicas must not exceed half of the total replica number.</p> <p>When the number of machines is 1, <code>replica_factor</code> can only be set to<code>1</code>.</p> <p>When there are enough machines and <code>replica_factor=2</code>, if one replica fails, the Storage service fails. No matter <code>replica_factor=3</code> or <code>replica_factor=4</code>, if more than one replica fails, the Storage Service fails. To prevent unnecessary waste of resources, we recommend that you set an odd replica number.</p> <p>We suggest that you set <code>replica_factor=3</code> for a production environment and <code>replica_factor=1</code> for a test environment. Do not use an even number.</p>"},{"location":"20.appendix/0.FAQ/#is_stopping_or_killing_slow_queries_supported","title":"\"Is stopping or killing slow queries supported?\"","text":"<p>Yes. For more information, see Kill query.</p>"},{"location":"20.appendix/0.FAQ/#why_are_the_query_results_different_when_using_go_and_match_to_execute_the_same_semantic_query","title":"\"Why are the query results different when using <code>GO</code> and <code>MATCH</code> to execute the same semantic query?\"","text":"<p>The possible reasons are listed as follows.</p> <ul> <li><code>GO</code> statements find the dangling edges.</li> </ul> <ul> <li><code>RETURN</code> commands do not specify the sequence.</li> </ul> <ul> <li>The dense vertex truncation limitation defined by <code>max_edge_returned_per_vertex</code> in the Storage service is triggered.</li> </ul> <ul> <li> <p>Using different types of paths may cause different query results.</p> <ul> <li><code>GO</code> statements use <code>walk</code>. Both vertices and edges can be repeatedly visited in graph traversal.</li> </ul> <ul> <li><code>MATCH</code> statements are compatible with openCypher and use <code>trail</code>. Only vertices can be repeatedly visited in graph traversal.</li> </ul> </li> </ul> <p>The example is as follows.</p> <p></p> <p>All queries that start from <code>A</code> with 5 hops will end at <code>C</code> (<code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C</code>). If it is 6 hops, the <code>GO</code> statement will end at <code>D</code> (<code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;C-&gt;D</code>), because the edge <code>C-&gt;D</code> can be visited repeatedly. However, the <code>MATCH</code> statement returns empty, because edges cannot be visited repeatedly.</p> <p>Therefore, using <code>GO</code> and <code>MATCH</code> to execute the same semantic query may cause different query results.</p> <p>For more information, see Wikipedia.</p>"},{"location":"20.appendix/0.FAQ/#how_to_count_the_verticesedges_number_of_each_tagedge_type","title":"\"How to count the vertices/edges number of each tag/edge type?\"","text":"<p>See show-stats.</p>"},{"location":"20.appendix/0.FAQ/#how_to_get_all_the_verticesedge_of_each_tagedge_type","title":"\"How to get all the vertices/edge of each tag/edge type?\"","text":"<ol> <li> <p>Create and rebuild the index.</p> <pre><code>&gt; CREATE TAG INDEX IF NOT EXISTS i_player ON player();\n&gt; REBUILD TAG INDEX IF NOT EXISTS i_player;\n</code></pre> </li> <li> <p>Use <code>LOOKUP</code> or <code>MATCH</code>. For example:</p> <pre><code>&gt; LOOKUP ON player;\n&gt; MATCH (n:player) RETURN n;\n</code></pre> </li> </ol> <p>For more information, see <code>INDEX</code>, <code>LOOKUP</code>, and <code>MATCH</code>.</p>"},{"location":"20.appendix/0.FAQ/#can_non-english_characters_be_used_as_identifiers_such_as_the_names_of_graph_spaces_tags_edge_types_properties_and_indexes","title":"\"Can non-English characters be used as identifiers, such as the names of graph spaces, tags, edge types, properties, and indexes?\"","text":"<p>Yes, for more information, see Keywords and reserved words.</p>"},{"location":"20.appendix/0.FAQ/#how_to_get_the_out-degreethe_in-degree_of_a_given_vertex","title":"\"How to get the out-degree/the in-degree of a given vertex?\"","text":"<p>The out-degree of a vertex refers to the number of edges starting from that vertex, while the in-degree refers to the number of edges pointing to that vertex.</p> <pre><code>nebula &gt; MATCH (s)-[e]-&gt;() WHERE id(s) == \"given\" RETURN count(e); #Out-degree\nnebula &gt; MATCH (s)&lt;-[e]-() WHERE id(s) == \"given\" RETURN count(e); #In-degree\n</code></pre> <p>This is a very slow operation to get the out/in degree since no accelaration can be applied (no indices or caches). It also could be out-of-memory when hitting a supper-node.</p>"},{"location":"20.appendix/0.FAQ/#how_to_quickly_get_the_out-degree_and_in-degree_of_all_vertices","title":"\"How to quickly get the out-degree and in-degree of all vertices?\"","text":"<p>There is no such command.</p> <p>You can use NebulaGraph Algorithm.</p>"},{"location":"20.appendix/0.FAQ/#about_operation_and_maintenance","title":"About operation and maintenance","text":""},{"location":"20.appendix/0.FAQ/#the_runtime_log_files_are_too_large_how_to_recycle_the_logs","title":"\"The runtime log files are too large. How to recycle the logs?\"","text":"<p>NebulaGraph uses glog for log printing, which does not support log recycling. You can manage runtime logs by using cron jobs or the log management tool logrotate. For operational details, see Log recycling.</p>"},{"location":"20.appendix/0.FAQ/#how_to_check_the_nebulagraph_version","title":"\"How to check the NebulaGraph version?\"","text":"<p>If the service is running: run command <code>SHOW HOSTS META</code> in <code>nebula-console</code>. See SHOW HOSTS.</p> <p>If the service is not running:</p> <p>Different installation methods make the method of checking the version different. The instructions are as follows:</p> <p>If the service is not running, run the command <code>./&lt;binary_name&gt; --version</code> to get the version and the Git commit IDs of the NebulaGraph binary files. For example:</p> <pre><code>$ ./nebula-graphd --version\n</code></pre> <ul> <li> <p>If you deploy NebulaGraph with Docker Compose</p> <p>Check the version of NebulaGraph deployed by Docker Compose. The method is similar to the previous method, except that you have to enter the container first. The commands are as follows:</p> <pre><code>docker exec -it nebula-docker-compose_graphd_1 bash\ncd bin/\n./nebula-graphd --version\n</code></pre> </li> </ul> <ul> <li> <p>If you install NebulaGraph with RPM/DEB package</p> <p>Run <code>rpm -qa |grep nebula</code> to check the version of NebulaGraph.</p> </li> </ul>"},{"location":"20.appendix/0.FAQ/#how_to_scale_my_cluster_updown_or_outin","title":"\"How to scale my cluster up/down or out/in?\"","text":"<p>Warning</p> <p>The cluster scaling function has not been officially released in the community edition. The operations involving <code>SUBMIT JOB BALANCE DATA REMOVE</code> and <code>SUBMIT JOB BALANCE DATA</code> are experimental features in the community edition and the functionality is not stable. Before using it in the community edition, make sure to back up your data first and set <code>enable_experimental_feature</code> and <code>enable_data_balance</code> to <code>true</code> in the Graph configuration file.</p>"},{"location":"20.appendix/0.FAQ/#increase_or_decrease_the_number_of_meta_graph_or_storage_nodes","title":"Increase or decrease the number of Meta, Graph, or Storage nodes","text":"<ul> <li> <p>NebulaGraph 3.8.0 does not provide any commands or tools to support automatic scale out/in. You can refer to the following steps:</p> <ul> <li> <p>Scale out and scale in metad: The metad process can not be scaled out or scale in. The process cannot be moved to a new machine. You cannot add a new metad process to the service.</p> <p>Note</p> <p>You can use the Meta transfer script tool to migrate Meta services. Note that the Meta-related settings in the configuration files of Storage and Graph services need to be modified correspondingly.</p> </li> </ul> <ul> <li>Scale in graphd: Remove the IP of the graphd process from the code in the client. Close this graphd process.</li> </ul> <ul> <li>Scale out graphd: Prepare the binary and config files of the graphd process in the new host. Modify the config files and add all existing addresses of the metad processes. Then start the new graphd process.</li> </ul> <ul> <li> <p>Scale in storaged: See Balance remove command. After the command is finished, stop this storaged process.</p> <p>Caution</p> <ul> <li>Before executing this command to migrate the data in the specified Storage node, make sure that the number of other Storage nodes is sufficient to meet the set replication factor. For example, if the replication factor is set to 3, then before executing this command, make sure that the number of other Storage nodes is greater than or equal to 3.</li> </ul> <ul> <li>If there are multiple space partitions in the Storage node to be migrated, execute this command in each space to migrate all space partitions in the Storage node.</li> </ul> </li> </ul> <ul> <li> <p>Scale out storaged: Prepare the binary and config files of the storaged process in the new host, modify the config files and add all existing addresses of the metad processes. Then register the storaged process to the metad, and then start the new storaged process. For details, see Register storaged services.</p> <p>You also need to run Balance Data and Balance leader after scaling in/out storaged.</p> </li> </ul> </li> </ul>"},{"location":"20.appendix/0.FAQ/#add_or_remove_disks_in_the_storage_nodes","title":"Add or remove disks in the Storage nodes","text":"<p>Currently, Storage cannot dynamically recognize new added disks. You can add or remove disks in the Storage nodes of the distributed cluster by following these steps:</p> <ol> <li> <p>Execute <code>SUBMIT JOB BALANCE DATA REMOVE &lt;ip:port&gt;</code> to migrate data in the Storage node with the disk to be added or removed to other Storage nodes.</p> <p>Caution</p> <ul> <li>Before executing this command to migrate the data in the specified Storage node, make sure that the number of other Storage nodes is sufficient to meet the set replication factor. For example, if the replication factor is set to 3, then before executing this command, make sure that the number of other Storage nodes is greater than or equal to 3.</li> </ul> <ul> <li>If there are multiple space partitions in the Storage node to be migrated, execute this command in each space to migrate all space partitions in the Storage node.</li> </ul> </li> <li> <p>Execute <code>DROP HOSTS &lt;ip:port&gt;</code> to remove the Storage node with the disk to be added or removed.</p> </li> <li> <p>In the configuration file of all Storage nodes, configure the path of the new disk to be added or removed through <code>--data_path</code>, see Storage configuration file for details.</p> </li> <li>Execute <code>ADD HOSTS &lt;ip:port&gt;</code> to re-add the Storage node with the disk to be added or removed.</li> <li>As needed, execute <code>SUBMIT JOB BALANCE DATA</code> to evenly distribute the shards of the current space to all Storage nodes and execute <code>SUBMIT JOB BALANCE LEADER</code> command to balance the leaders in all spaces. Before running the command, select a space.</li> </ol>"},{"location":"20.appendix/0.FAQ/#after_changing_the_name_of_the_host_the_old_one_keeps_displaying_offline_what_should_i_do","title":"\"After changing the name of the host, the old one keeps displaying <code>OFFLINE</code>. What should I do?\"","text":"<p>Hosts with the status of <code>OFFLINE</code> will be automatically deleted after one day.</p>"},{"location":"20.appendix/0.FAQ/#how_do_i_view_the_dmp_file","title":"\"How do I view the dmp file?\"","text":"<p>The dmp file is an error report file detailing the exit of the process and can be viewed with the gdb utility. the Coredump file is saved in the directory of the startup binary (by default it is <code>/usr/local/nebula</code>) and is generated automatically when the NebulaGraph service crashes.</p> <ol> <li>Check the Core file process name, pid is usually a numeric value.    <pre><code>$ file core.&lt;pid&gt;\n</code></pre></li> <li>Use gdb to debug.    <pre><code>$ gdb &lt;process.name&gt; core.&lt;pid&gt;\n</code></pre></li> <li>View the contents of the file.    <pre><code>$(gdb) bt\n</code></pre></li> </ol> <p>For example:    <pre><code>$ file core.1316027\ncore.1316027: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from '/home/workspace/fork/nebula-debug/bin/nebula-metad --flagfile /home/k', real uid: 1008, effective uid: 1008, real gid: 1008, effective gid: 1008, execfn: '/home/workspace/fork/nebula-debug/bin/nebula-metad', platform: 'x86_64'\n\n$ gdb /home/workspace/fork/nebula-debug/bin/nebula-metad core.1316027\n\n$(gdb) bt\n#0  0x00007f9de58fecf5 in __memcpy_ssse3_back () from /lib64/libc.so.6\n#1  0x0000000000eb2299 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct&lt;char*&gt;(char*, char*, std::forward_iterator_tag) ()\n#2  0x0000000000ef71a7 in nebula::meta::cpp2::QueryDesc::QueryDesc(nebula::meta::cpp2::QueryDesc const&amp;) ()\n...\n</code></pre></p> <p>If you are not clear about the information that dmp prints out, you can post the printout with the OS version, hardware configuration, error logs before and after the Core file was created and actions that may have caused the error on the NebulaGraph forum.</p>"},{"location":"20.appendix/0.FAQ/#how_can_i_set_the_nebulagraph_service_to_start_automatically_on_boot_via_systemctl","title":"How can I set the NebulaGraph service to start automatically on boot via systemctl?","text":"<ol> <li> <p>Execute <code>systemctl enable</code> to start the metad, graphd and storaged services.</p> <pre><code>[root]# systemctl enable nebula-metad.service\nCreated symlink from /etc/systemd/system/multi-user.target.wants/nebula-metad.service to /usr/lib/systemd/system/nebula-metad.service.\n[root]# systemctl enable nebula-graphd.service\nCreated symlink from /etc/systemd/system/multi-user.target.wants/nebula-graphd.service to /usr/lib/systemd/system/nebula-graphd.service.\n[root]# systemctl enable nebula-storaged.service\nCreated symlink from /etc/systemd/system/multi-user.target.wants/nebula-storaged.service to /usr/lib/systemd/system/nebula-storaged.service.\n</code></pre> </li> <li> <p>Configure the service files for metad, graphd and storaged to set the service to pull up automatically.</p> <p>Caution</p> <p>The following points need to be noted when configuring the service file.    - The paths of the PIDFile, ExecStart, ExecReload and ExecStop parameters need to be the same as those on the server.    - RestartSec is the length of time (in seconds) to wait before restarting, which can be modified according to the actual situation.    - (Optional) StartLimitInterval is the unlimited restart, the default is 10 seconds if the restart exceeds 5 times, and set to 0 means unlimited restart.    - (Optional) LimitNOFILE is the maximum number of open files for the service, the default is 1024 and can be changed according to the actual situation.</p> <p>Configure the service file for the metad service.</p> <pre><code>$ vi /usr/lib/systemd/system/nebula-metad.service\n\n[Unit]\nDescription=Nebula Graph Metad Service\nAfter=network.target\n\n[Service ]\nType=forking\nRestart=always\nRestartSec=15s\nPIDFile=/usr/local/nebula/pids/nebula-metad.pid\nExecStart=/usr/local/nebula/scripts/nebula.service start metad\nExecReload=/usr/local/nebula/scripts/nebula.service restart metad\nExecStop=/usr/local/nebula/scripts/nebula.service stop metad\nPrivateTmp=true\nStartLimitInterval=0\nLimitNOFILE=1024\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Configure the service file for the graphd service.</p> <p><pre><code>$ vi /usr/lib/systemd/system/nebula-graphd.service\n[Unit]\nDescription=Nebula Graph Graphd Service\nAfter=network.target\n\n[Service]\nType=forking\nRestart=always\nRestartSec=15s\nPIDFile=/usr/local/nebula/pids/nebula-graphd.pid\nExecStart=/usr/local/nebula/scripts/nebula.service start graphd\nExecReload=/usr/local/nebula/scripts/nebula.service restart graphd\nExecStop=/usr/local/nebula/scripts/nebula.service stop graphd\nPrivateTmp=true\nStartLimitInterval=0\nLimitNOFILE=1024\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>  Configure the service file for the storaged service.</p> <pre><code>$ vi /usr/lib/systemd/system/nebula-storaged.service\n[Unit]\nDescription=Nebula Graph Storaged Service\nAfter=network.target\n\n[Service]\nType=forking\nRestart=always\nRestartSec=15s\nPIDFile=/usr/local/nebula/pids/nebula-storaged.pid\nExecStart=/usr/local/nebula/scripts/nebula.service start storaged\nExecReload=/usr/local/nebula/scripts/nebula.service restart storaged\nExecStop=/usr/local/nebula/scripts/nebula.service stop storaged\nPrivateTmp=true\nStartLimitInterval=0\nLimitNOFILE=1024\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> </li> <li> <p>Reload the configuration file.</p> <pre><code>[root]# sudo systemctl daemon-reload\n</code></pre> </li> <li> <p>Restart the service.</p> <pre><code>$ systemctl restart nebula-metad.service\n$ systemctl restart nebula-graphd.service\n$ systemctl restart nebula-storaged.service\n</code></pre> </li> </ol>"},{"location":"20.appendix/0.FAQ/#about_connections","title":"About connections","text":""},{"location":"20.appendix/0.FAQ/#which_ports_should_be_opened_on_the_firewalls","title":"\"Which ports should be opened on the firewalls?\"","text":"<p>If you have not modified the predefined ports in the Configurations, open the following ports for the NebulaGraph services:</p> Service Port Meta 9559, 9560, 19559 Graph 9669, 19669 Storage 9777 ~ 9780, 19779 <p>If you have customized the configuration files and changed the predefined ports, find the port numbers in your configuration files and open them on the firewalls.</p> <p>For more port information, see Port Guide for Company Products.</p>"},{"location":"20.appendix/0.FAQ/#how_to_test_whether_a_port_is_open_or_closed","title":"\"How to test whether a port is open or closed?\"","text":"<p>You can use telnet as follows to check for port status.</p> <pre><code>telnet &lt;ip&gt; &lt;port&gt;\n</code></pre> <p>Note</p> <p>If you cannot use the telnet command, check if telnet is installed or enabled on your host.</p> <p>For example:</p> <pre><code>// If the port is open:\n$ telnet 192.168.1.10 9669\nTrying 192.168.1.10...\nConnected to 192.168.1.10.\nEscape character is '^]'.\n\n// If the port is closed or blocked:\n$ telnet 192.168.1.10 9777\nTrying 192.168.1.10...\ntelnet: connect to address 192.168.1.10: Connection refused\n</code></pre>"},{"location":"20.appendix/6.eco-tool-version/","title":"Ecosystem tools overview","text":""},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_studio","title":"NebulaGraph Studio","text":"<p>NebulaGraph Studio (Studio for short) is a graph database visualization tool that can be accessed through the Web. It can be used with NebulaGraph DBMS to provide one-stop services such as composition, data import, writing nGQL queries, and graph exploration. For details, see What is NebulaGraph Studio.</p> <p>Note</p> <p>The release of the Studio is independent of NebulaGraph core, and its naming method is also not the same as the core naming rules. </p> NebulaGraph version Studio version v3.8.0 v3.10.0"},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_dashboard_community_edition","title":"NebulaGraph Dashboard Community Edition","text":"<p>NebulaGraph Dashboard Community Edition (Dashboard for short) is a visualization tool for monitoring the status of machines and services in the NebulaGraph cluster. For details, see What is NebulaGraph Dashboard.</p> NebulaGraph version Dashboard Community version v3.8.0 v3.4.0"},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_exchange","title":"NebulaGraph Exchange","text":"<p>NebulaGraph Exchange (Exchange for short) is an Apache Spark&amp;trade application for batch migration of data in a cluster to NebulaGraph in a distributed environment. It can support the migration of batch data and streaming data in a variety of different formats. For details, see What is NebulaGraph Exchange.</p> NebulaGraph version Exchange Community version v3.8.0 v3.8.0"},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_operator","title":"NebulaGraph Operator","text":"<p>NebulaGraph Operator (Operator for short) is a tool to automate the deployment, operation, and maintenance of NebulaGraph clusters on Kubernetes. Building upon the excellent scalability mechanism of Kubernetes, NebulaGraph introduced its operation and maintenance knowledge into the Kubernetes system, which makes NebulaGraph a real cloud-native graph database. For more information, see What is NebulaGraph Operator.</p> NebulaGraph version Operator version v3.8.0 v1.8.0"},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_importer","title":"NebulaGraph Importer","text":"<p>NebulaGraph Importer (Importer for short) is a CSV file import tool for NebulaGraph. The Importer can read the local CSV file, and then import the data into the NebulaGraph database. For details, see What is NebulaGraph Importer.</p> NebulaGraph version Importer version v3.8.0 v4.1.0"},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_spark_connector","title":"NebulaGraph Spark Connector","text":"<p>NebulaGraph Spark Connector is a Spark connector that provides the ability to read and write NebulaGraph data in the Spark standard format. NebulaGraph Spark Connector consists of two parts, Reader and Writer. For details, see What is NebulaGraph Spark Connector.</p> NebulaGraph version Spark Connector version v3.8.0 v3.8.0"},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_flink_connector","title":"NebulaGraph Flink Connector","text":"<p>NebulaGraph Flink Connector is a connector that helps Flink users quickly access NebulaGraph. It supports reading data from the NebulaGraph database or writing data read from other external data sources to the NebulaGraph database. For details, see What is NebulaGraph Flink Connector.</p> NebulaGraph version Flink Connector version v3.8.0 v3.8.0"},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_algorithm","title":"NebulaGraph Algorithm","text":"<p>NebulaGraph Algorithm (Algorithm for short) is a Spark application based on GraphX, which uses a complete algorithm tool to analyze data in the NebulaGraph database by submitting a Spark task To perform graph computing, use the algorithm under the lib repository through programming to perform graph computing for DataFrame. For details, see What is NebulaGraph Algorithm.</p> NebulaGraph version Algorithm version v3.8.0 v3.2.0"},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_console","title":"NebulaGraph Console","text":"<p>NebulaGraph Console is the native CLI client of NebulaGraph. For how to use it, see NebulaGraph Console.</p> NebulaGraph version Console version v3.8.0 v3.8.0"},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_docker_compose","title":"NebulaGraph Docker Compose","text":"<p>Docker Compose can quickly deploy NebulaGraph clusters. For how to use it, please refer to Docker Compose Deployment NebulaGraph.</p> NebulaGraph version Docker Compose version v3.8.0 v3.8.0"},{"location":"20.appendix/6.eco-tool-version/#backup_restore","title":"Backup &amp; Restore","text":"<p>Backup&amp;Restore (BR for short) is a command line interface (CLI) tool that can help back up the graph space data of NebulaGraph, or restore it through a backup file data.</p> NebulaGraph version BR version v3.8.0 v3.6.0"},{"location":"20.appendix/6.eco-tool-version/#nebulagraph_bench","title":"NebulaGraph Bench","text":"<p>NebulaGraph Bench is used to test the baseline performance data of NebulaGraph. It uses the standard data set of LDBC.</p> NebulaGraph version Bench version v3.8.0 v1.2.0"},{"location":"20.appendix/6.eco-tool-version/#api_and_sdk","title":"API and SDK","text":"<p>Compatibility</p> <p>Select the latest version of <code>X.Y.*</code> which is the same as the core version.</p> NebulaGraph version Language v3.8.0 C++ v3.8.0 Go v3.8.0 Python v3.8.0 Java v3.8.0 HTTP"},{"location":"20.appendix/6.eco-tool-version/#community_contributed_tools","title":"Community contributed tools","text":"<p>The following are useful utilities and tools contributed and maintained by community users. </p> <ul> <li>Object Relational Mapping (ORM) frameworks<ul> <li>NGBATIS: An ORM framework that integrates with the Spring Boot ecosystem</li> <li>graph-ocean: An ORM framework developed based on NebulaGraph Java client</li> <li>nebula-jdbc: An ORM framework that supports JDBC  </li> <li>nebula-carina: An ORM framework developed based on NebulaGraph Python client</li> <li>norm: An ORM framework written in Golang</li> </ul> </li> </ul> <ul> <li>Data processing tools<ul> <li>nebula-real-time-exchange: Enables real-time data synchronization from MySQL to NebulaGraph</li> <li>nebula-datax-plugin: Provides NebulaGraph's Reader and Writer plugins based on DataX to enable offline data synchronization</li> </ul> </li> </ul> <ul> <li>Quick deployment<ul> <li>nebulagraph-docker-ext: Starts NebulaGraph in Docker Desktop in 10 seconds</li> <li>nebulagraph-lite: A NebulaGraph sandbox running in the browser</li> </ul> </li> </ul> <ul> <li>Testing<ul> <li>testcontainers-nebula: A lightweight database testing library for Java</li> </ul> </li> </ul> <ul> <li>Clients<ul> <li>zio-nebula: Scala client</li> <li>nebula-node: Node.js client</li> <li>nebula-php: PHP client</li> <li>nebula-net: .NET client</li> <li>nebula-rust: Rust client</li> </ul> </li> </ul> <ul> <li>Terminal tools<ul> <li>nebula-console-intellij-plugin: A Nebula-console plugin for JetBrains IDEs that supports syntax highlighting, function field auto-completion, data table pagination, and relationship graphs.</li> </ul> </li> </ul>"},{"location":"20.appendix/error-code/","title":"Error code","text":"<p>NebulaGraph returns an error code when an error occurs. This topic describes the details of the error code returned.  </p> <p>Note</p> <ul> <li>If an error occurs but no error code is returned, or if the error code description is unclear, we welcome your feedback or suggestions on the forum or GitHub. </li> </ul> <ul> <li>When the code returned is <code>0</code>, it means that the operation is successful.</li> </ul> Error name Error Code Description <code>E_DISCONNECTED</code> <code>-1</code> Lost connection <code>E_FAIL_TO_CONNECT</code> <code>-2</code> Unable to establish connection <code>E_RPC_FAILURE</code> <code>-3</code> RPC failure <code>E_LEADER_CHANGED</code> <code>-4</code> Raft leader has been changed <code>E_SPACE_NOT_FOUND</code> <code>-5</code> Graph space does not exist <code>E_TAG_NOT_FOUND</code> <code>-6</code> Tag does not exist <code>E_EDGE_NOT_FOUND</code> <code>-7</code> Edge type does not exist <code>E_INDEX_NOT_FOUND</code> <code>-8</code> Index does not exist <code>E_EDGE_PROP_NOT_FOUND</code> <code>-9</code> Edge type property does not exist <code>E_TAG_PROP_NOT_FOUND</code> <code>-10</code> Tag property does not exist <code>E_ROLE_NOT_FOUND</code> <code>-11</code> The current role does not exist <code>E_CONFIG_NOT_FOUND</code> <code>-12</code> The current configuration does not exist <code>E_MACHINE_NOT_FOUND</code> <code>-13</code> The current host does not exist <code>E_LISTENER_NOT_FOUND</code> <code>-15</code> Listener does not exist <code>E_PART_NOT_FOUND</code> <code>-16</code> The current partition does not exist <code>E_KEY_NOT_FOUND</code> <code>-17</code> Key does not exist <code>E_USER_NOT_FOUND</code> <code>-18</code> User does not exist <code>E_STATS_NOT_FOUND</code> <code>-19</code> Statistics do not exist <code>E_SERVICE_NOT_FOUND</code> <code>-20</code> No current service found <code>E_DRAINER_NOT_FOUND</code> <code>-21</code> Drainer does not exist <code>E_DRAINER_CLIENT_NOT_FOUND</code> <code>-22</code> Drainer client does not exist <code>E_PART_STOPPED</code> <code>-23</code> The current partition has already been stopped <code>E_BACKUP_FAILED</code> <code>-24</code> Backup failed <code>E_BACKUP_EMPTY_TABLE</code> <code>-25</code> The backed-up table is empty <code>E_BACKUP_TABLE_FAILED</code> <code>-26</code> Table backup failure <code>E_PARTIAL_RESULT</code> <code>-27</code> MultiGet could not get all data <code>E_REBUILD_INDEX_FAILED</code> <code>-28</code> Index rebuild failed <code>E_INVALID_PASSWORD</code> <code>-29</code> Password is invalid <code>E_FAILED_GET_ABS_PATH</code> <code>-30</code> Unable to get absolute path <code>E_BAD_USERNAME_PASSWORD</code> <code>-1001</code> Authentication failed <code>E_SESSION_INVALID</code> <code>-1002</code> Invalid session <code>E_SESSION_TIMEOUT</code> <code>-1003</code> Session timeout <code>E_SYNTAX_ERROR</code> <code>-1004</code> Syntax error <code>E_EXECUTION_ERROR</code> <code>-1005</code> Execution error <code>E_STATEMENT_EMPTY</code> <code>-1006</code> Statement is empty <code>E_BAD_PERMISSION</code> <code>-1008</code> Permission denied <code>E_SEMANTIC_ERROR</code> <code>-1009</code> Semantic error <code>E_TOO_MANY_CONNECTIONS</code> <code>-1010</code> Maximum number of connections exceeded <code>E_PARTIAL_SUCCEEDED</code> <code>-1011</code> Access to storage failed (only some requests succeeded) <code>E_NO_HOSTS</code> <code>-2001</code> Host does not exist <code>E_EXISTED</code> <code>-2002</code> Host already exists <code>E_INVALID_HOST</code> <code>-2003</code> Invalid host <code>E_UNSUPPORTED</code> <code>-2004</code> The current command, statement, or function is not supported <code>E_NOT_DROP</code> <code>-2005</code> Not allowed to drop <code>E_CONFIG_IMMUTABLE</code> <code>-2007</code> Configuration items cannot be changed <code>E_CONFLICT</code> <code>-2008</code> Parameters conflict with meta data <code>E_INVALID_PARM</code> <code>-2009</code> Invalid parameter <code>E_WRONGCLUSTER</code> <code>-2010</code> Wrong cluster <code>E_ZONE_NOT_ENOUGH</code> <code>-2011</code> Listener conflicts <code>E_ZONE_IS_EMPTY</code> <code>-2012</code> Host not exist <code>E_SCHEMA_NAME_EXISTS</code> <code>-2013</code> Schema name already exists <code>E_RELATED_INDEX_EXISTS</code> <code>-2014</code> There are still indexes related to tag or edge, cannot drop it <code>E_RELATED_SPACE_EXISTS</code> <code>-2015</code> There are still some space on the host, cannot drop it <code>E_STORE_FAILURE</code> <code>-2021</code> Failed to store data <code>E_STORE_SEGMENT_ILLEGAL</code> <code>-2022</code> Illegal storage segment <code>E_BAD_BALANCE_PLAN</code> <code>-2023</code> Invalid data balancing plan <code>E_BALANCED</code> <code>-2024</code> The cluster is already in the data balancing status <code>E_NO_RUNNING_BALANCE_PLAN</code> <code>-2025</code> There is no running data balancing plan <code>E_NO_VALID_HOST</code> <code>-2026</code> Lack of valid hosts <code>E_CORRUPTED_BALANCE_PLAN</code> <code>-2027</code> A data balancing plan that has been corrupted <code>E_IMPROPER_ROLE</code> <code>-2030</code> Failed to recover user role <code>E_INVALID_PARTITION_NUM</code> <code>-2031</code> Number of invalid partitions <code>E_INVALID_REPLICA_FACTOR</code> <code>-2032</code> Invalid replica factor <code>E_INVALID_CHARSET</code> <code>-2033</code> Invalid character set <code>E_INVALID_COLLATE</code> <code>-2034</code> Invalid character sorting rules <code>E_CHARSET_COLLATE_NOT_MATCH</code> <code>-2035</code> Character set and character sorting rule mismatch <code>E_SNAPSHOT_FAILURE</code> <code>-2040</code> Failed to generate a snapshot <code>E_BLOCK_WRITE_FAILURE</code> <code>-2041</code> Failed to write block data <code>E_ADD_JOB_FAILURE</code> <code>-2044</code> Failed to add new task <code>E_STOP_JOB_FAILURE</code> <code>-2045</code> Failed to stop task <code>E_SAVE_JOB_FAILURE</code> <code>-2046</code> Failed to save task information <code>E_BALANCER_FAILURE</code> <code>-2047</code> Data balancing failed <code>E_JOB_NOT_FINISHED</code> <code>-2048</code> The current task has not been completed <code>E_TASK_REPORT_OUT_DATE</code> <code>-2049</code> Task report failed <code>E_JOB_NOT_IN_SPACE</code> <code>-2050</code> The current task is not in the graph space <code>E_JOB_NEED_RECOVER</code> <code>-2051</code> The current task needs to be resumed <code>E_JOB_ALREADY_FINISH</code> <code>-2052</code> The job status has already been failed or finished <code>E_JOB_SUBMITTED</code> <code>-2053</code> Job default status <code>E_JOB_NOT_STOPPABLE</code> <code>-2054</code> The given job do not support stop <code>E_JOB_HAS_NO_TARGET_STORAGE</code> <code>-2055</code> The leader distribution has not been reported, so can't send task to storage <code>E_INVALID_JOB</code> <code>-2065</code> Invalid task <code>E_BACKUP_BUILDING_INDEX</code> <code>-2066</code> Backup terminated (index being created) <code>E_BACKUP_SPACE_NOT_FOUND</code> <code>-2067</code> Graph space does not exist at the time of backup <code>E_RESTORE_FAILURE</code> <code>-2068</code> Backup recovery failed <code>E_SESSION_NOT_FOUND</code> <code>-2069</code> Session does not exist <code>E_LIST_CLUSTER_FAILURE</code> <code>-2070</code> Failed to get cluster information <code>E_LIST_CLUSTER_GET_ABS_PATH_FAILURE</code> <code>-2071</code> Failed to get absolute path when getting cluster information <code>E_LIST_CLUSTER_NO_AGENT_FAILURE</code> <code>-2072</code> Unable to get an agent when getting cluster information <code>E_QUERY_NOT_FOUND</code> <code>-2073</code> Query not found <code>E_AGENT_HB_FAILUE</code> <code>-2074</code> Failed to receive heartbeat from agent <code>E_HOST_CAN_NOT_BE_ADDED</code> <code>-2082</code> The host can not be added for it's not a storage host <code>E_ACCESS_ES_FAILURE</code> <code>-2090</code> Failed to access elasticsearch <code>E_GRAPH_MEMORY_EXCEEDED</code> <code>-2600</code> Graph memory exceeded <code>E_CONSENSUS_ERROR</code> <code>-3001</code> Consensus cannot be reached during an election <code>E_KEY_HAS_EXISTS</code> <code>-3002</code> Key already exists <code>E_DATA_TYPE_MISMATCH</code> <code>-3003</code> Data type mismatch <code>E_INVALID_FIELD_VALUE</code> <code>-3004</code> Invalid field value <code>E_INVALID_OPERATION</code> <code>-3005</code> Invalid operation <code>E_NOT_NULLABLE</code> <code>-3006</code> Current value is not allowed to be empty <code>E_FIELD_UNSET</code> <code>-3007</code> Field value must be set if the field value is <code>NOT NULL</code> or has no default value <code>E_OUT_OF_RANGE</code> <code>-3008</code> The value is out of the range of the current type <code>E_DATA_CONFLICT_ERROR</code> <code>-3010</code> Data conflict <code>E_WRITE_STALLED</code> <code>-3011</code> Writes are delayed <code>E_IMPROPER_DATA_TYPE</code> <code>-3021</code> Incorrect data type <code>E_INVALID_SPACEVIDLEN</code> <code>-3022</code> Invalid VID length <code>E_INVALID_FILTER</code> <code>-3031</code> Invalid filter <code>E_INVALID_UPDATER</code> <code>-3032</code> Invalid field update <code>E_INVALID_STORE</code> <code>-3033</code> Invalid KV storage <code>E_INVALID_PEER</code> <code>-3034</code> Peer invalid <code>E_RETRY_EXHAUSTED</code> <code>-3035</code> Out of retries <code>E_TRANSFER_LEADER_FAILED</code> <code>-3036</code> Leader change failed <code>E_INVALID_STAT_TYPE</code> <code>-3037</code> Invalid stat type <code>E_INVALID_VID</code> <code>-3038</code> VID is invalid <code>E_LOAD_META_FAILED</code> <code>-3040</code> Failed to load meta information <code>E_FAILED_TO_CHECKPOINT</code> <code>-3041</code> Failed to generate checkpoint <code>E_CHECKPOINT_BLOCKED</code> <code>-3042</code> Generating checkpoint is blocked <code>E_FILTER_OUT</code> <code>-3043</code> Data is filtered <code>E_INVALID_DATA</code> <code>-3044</code> Invalid data <code>E_MUTATE_EDGE_CONFLICT</code> <code>-3045</code> Concurrent write conflicts on the same edge <code>E_MUTATE_TAG_CONFLICT</code> <code>-3046</code> Concurrent write conflict on the same vertex <code>E_OUTDATED_LOCK</code> <code>-3047</code> Lock is invalid <code>E_INVALID_TASK_PARA</code> <code>-3051</code> Invalid task parameter <code>E_USER_CANCEL</code> <code>-3052</code> The user canceled the task <code>E_TASK_EXECUTION_FAILED</code> <code>-3053</code> Task execution failed <code>E_PLAN_IS_KILLED</code> <code>-3060</code> Execution plan was cleared <code>E_NO_TERM</code> <code>-3070</code> The heartbeat process was not completed when the request was received <code>E_OUTDATED_TERM</code> <code>-3071</code> Out-of-date heartbeat received from the old leader (the new leader has been elected) <code>E_WRITE_WRITE_CONFLICT</code> <code>-3073</code> Concurrent write conflicts with later requests <code>E_RAFT_UNKNOWN_PART</code> <code>-3500</code> Unknown partition <code>E_RAFT_LOG_GAP</code> <code>-3501</code> Raft logs lag behind <code>E_RAFT_LOG_STALE</code> <code>-3502</code> Raft logs are out of date <code>E_RAFT_TERM_OUT_OF_DATE</code> <code>-3503</code> Heartbeat messages are out of date <code>E_RAFT_UNKNOWN_APPEND_LOG</code> <code>-3504</code> Unknown additional logs <code>E_RAFT_WAITING_SNAPSHOT</code> <code>-3511</code> Waiting for the snapshot to complete <code>E_RAFT_SENDING_SNAPSHOT</code> <code>-3512</code> There was an error sending the snapshot <code>E_RAFT_INVALID_PEER</code> <code>-3513</code> Invalid receiver <code>E_RAFT_NOT_READY</code> <code>-3514</code> Raft did not start <code>E_RAFT_STOPPED</code> <code>-3515</code> Raft has stopped <code>E_RAFT_BAD_ROLE</code> <code>-3516</code> Wrong role <code>E_RAFT_WAL_FAIL</code> <code>-3521</code> Write to a WAL failed <code>E_RAFT_HOST_STOPPED</code> <code>-3522</code> The host has stopped <code>E_RAFT_TOO_MANY_REQUESTS</code> <code>-3523</code> Too many requests <code>E_RAFT_PERSIST_SNAPSHOT_FAILED</code> <code>-3524</code> Persistent snapshot failed <code>E_RAFT_RPC_EXCEPTION</code> <code>-3525</code> RPC exception <code>E_RAFT_NO_WAL_FOUND</code> <code>-3526</code> No WAL logs found <code>E_RAFT_HOST_PAUSED</code> <code>-3527</code> Host suspended <code>E_RAFT_WRITE_BLOCKED</code> <code>-3528</code> Writes are blocked <code>E_RAFT_BUFFER_OVERFLOW</code> <code>-3529</code> Cache overflow <code>E_RAFT_ATOMIC_OP_FAILED</code> <code>-3530</code> Atomic operation failed <code>E_LEADER_LEASE_FAILED</code> <code>-3531</code> Leader lease expired <code>E_RAFT_CAUGHT_UP</code> <code>-3532</code> Data has been synchronized on Raft <code>E_STORAGE_MEMORY_EXCEEDED</code> <code>-3600</code> Storage memory exceeded <code>E_LOG_GAP</code> <code>-4001</code> Drainer logs lag behind <code>E_LOG_STALE</code> <code>-4002</code> Drainer logs are out of date <code>E_INVALID_DRAINER_STORE</code> <code>-4003</code> The drainer data storage is invalid <code>E_SPACE_MISMATCH</code> <code>-4004</code> Graph space mismatch <code>E_PART_MISMATCH</code> <code>-4005</code> Partition mismatch <code>E_DATA_CONFLICT</code> <code>-4006</code> Data conflict <code>E_REQ_CONFLICT</code> <code>-4007</code> Request conflict <code>E_DATA_ILLEGAL</code> <code>-4008</code> Illegal data <code>E_CACHE_CONFIG_ERROR</code> <code>-5001</code> Cache configuration error <code>E_NOT_ENOUGH_SPACE</code> <code>-5002</code> Insufficient space <code>E_CACHE_MISS</code> <code>-5003</code> No cache hit <code>E_CACHE_WRITE_FAILURE</code> <code>-5005</code> Write cache failed <code>E_NODE_NUMBER_EXCEED_LIMIT</code> <code>-7001</code> Number of machines exceeded the limit <code>E_PARSING_LICENSE_FAILURE</code> <code>-7002</code> Failed to resolve certificate <code>E_UNKNOWN</code> <code>-8000</code> Unknown error"},{"location":"20.appendix/history/","title":"History timeline for NebulaGraph","text":"<ol> <li> <p>2018.9: dutor wrote and submitted the first line of NebulaGraph database code. </p> <p></p> </li> <li> <p>2019.5: NebulaGraph v0.1.0-alpha was released as open-source.</p> <p> </p> <p>NebulaGraph v1.0.0-beta, v1.0.0-rc1, v1.0.0-rc2, v1.0.0-rc3, and v1.0.0-rc4 were released one after another within a year thereafter.</p> <p></p> </li> <li> <p>2019.7: NebulaGraph's debut at HBaseCon<sup>1</sup>. @dangleptr</p> <p></p> </li> <li> <p>2020.3: NebulaGraph v2.0 was starting developed in the final stage of v1.0 development. </p> </li> <li> <p>2020.6: The first major version of NebulaGraph v1.0.0 GA was released.</p> <p></p> </li> <li> <p>2021.3: The second major version of NebulaGraph v2.0 GA was released.</p> <p></p> </li> <li> <p>2021.8: NebulaGraph v2.5.0 was released.</p> </li> <li> <p>2021.10: NebulaGraph v2.6.0 was released.</p> </li> <li> <p>2022.2: NebulaGraph v3.0.0 was released.</p> </li> <li> <p>2022.4: NebulaGraph v3.1.0 was released.</p> </li> <li> <p>2022.7: NebulaGraph v3.2.0 was released.</p> </li> <li> <p>2022.10: NebulaGraph v3.3.0 was released.</p> </li> <li> <p>2023.2: NebulaGraph v3.4.0 was released.</p> </li> <li> <p>2023.5: NebulaGraph v3.5.0 was released.</p> </li> <li> <p>2023.8: NebulaGraph v3.6.0 was released.</p> </li> </ol> <ol> <li> <p>NebulaGraph v1.x supports both RocksDB and HBase as its storage engines. NebulaGraph v2.x removes HBase supports.\u00a0\u21a9</p> </li> </ol>"},{"location":"20.appendix/port-guide/","title":"Port guide for company products","text":"<p>The following are the default ports used by NebulaGraph core and peripheral tools.</p> No. Product / Service Type Default Description 1 NebulaGraph TCP 9669 Graph service RPC daemon listening port. Commonly used for client connections to the Graph service. 2 NebulaGraph TCP 19669 Graph service HTTP port. 3 NebulaGraph TCP 19670 Graph service HTTP/2 port. (Deprecated after version 3.x) 4 NebulaGraph TCP 9559, 9560 <code>9559</code> is the RPC daemon listening port for Meta service. Commonly used by Graph and Storage services for querying and updating metadata in the graph database. The neighboring <code>+1</code> (<code>9560</code>) port is used for Raft communication between Meta services. 5 NebulaGraph TCP 19559 Meta service HTTP port. 6 NebulaGraph TCP 19560 Meta service HTTP/2 port. (Deprecated after version 3.x) 7 NebulaGraph TCP 9779, 9778, 9780 <code>9779</code> is the RPC daemon listening port for Storage service. Commonly used by Graph services for data storage-related operations, such as reading, writing, or deleting data. The neighboring ports <code>-1</code> (<code>9778</code>) and <code>+1</code> (<code>9780</code>) are also used. <code>9778</code>: The port used by the Admin service, which receives Meta commands for Storage. <code>9780</code>: The port used for Raft communication between Storage services. 8 NebulaGraph TCP 19779 Storage service HTTP port. 9 NebulaGraph TCP 19780 Storage service HTTP/2 port. (Deprecated after version 3.x) 10 NebulaGraph TCP 8888 Backup and restore Agent service port. The Agent is a daemon running on each machine in the cluster, responsible for starting and stopping NebulaGraph services and uploading and downloading backup files. 11 NebulaGraph TCP 9789, 9788, 9790 <code>9789</code> is the Raft Listener port for Full-text index, which reads data from Storage services and writes it to the Elasticsearch cluster.Also the port for Storage Listener in inter-cluster data synchronization, used for synchronizing Storage data from the primary cluster. The neighboring ports <code>-1</code> (<code>9788</code>) and <code>+1</code> (<code>9790</code>) are also used.<code>9788</code>: An internal port.<code>9790</code>: The port used for Raft communication. 12 NebulaGraph TCP 9200 NebulaGraph uses this port for HTTP communication with Elasticsearch to perform full-text search queries and manage full-text indexes. 13 NebulaGraph TCP 9569, 9568, 9570 <code>9569</code> is the Meta Listener port in inter-cluster data synchronization, used for synchronizing Meta data from the primary cluster. The neighboring ports <code>-1</code> (<code>9568</code>) and <code>+1</code> (<code>9570</code>) are also used.<code>9568</code>: An internal port.<code>9570</code>: The port used for Raft communication. 14 NebulaGraph TCP 9889, 9888, 9890 Drainer service port in inter-cluster data synchronization, used for synchronizing Storage and Meta data to the primary cluster. The neighboring ports <code>-1</code> (<code>9888</code>) and <code>+1</code> (<code>9890</code>) are also used.<code>9888</code>: An internal port.<code>9890</code>: The port used for Raft communication. 15 NebulaGraph Studio TCP 7001 Studio web service port. 16 NebulaGraph Dashboard TCP 8090 Nebula HTTP Gateway dependency service port. Provides an HTTP interface for cluster services to interact with the NebulaGraph database using nGQL statements.0 17 NebulaGraph Dashboard TCP 9200 Nebula Stats Exporter dependency service port. Collects cluster performance metrics, including service IP addresses, versions, and monitoring metrics (such as query count, query latency, heartbeat latency, etc.). 18 NebulaGraph Dashboard TCP 9100 Node Exporter dependency service port. Collects resource information for machines in the cluster, including CPU, memory, load, disk, and traffic. 19 NebulaGraph Dashboard TCP 9090 Prometheus service port. Time-series database for storing monitoring data. 20 NebulaGraph Dashboard TCP 7003 Dashboard Community Edition web service port."},{"location":"20.appendix/release-notes/dashboard-comm-release-note/","title":"NebulaGraph Dashboard Community Edition release notes","text":""},{"location":"20.appendix/release-notes/dashboard-comm-release-note/#community_edition_340","title":"Community Edition 3.4.0","text":"<ul> <li>Feature<ul> <li>Support the built-in dashboard.service script to manage the Dashboard services with one-click and view the Dashboard version.</li> <li>Support viewing the configuration of Meta services.</li> </ul> </li> </ul> <ul> <li>Enhancement<ul> <li>Adjust the directory structure and simplify the deployment steps.</li> <li>Display the names of the monitoring metrics on the overview page of <code>machine</code>.</li> <li>Optimize the calculation of monitoring metrics such as <code>num_queries</code>, and adjust the display to time series aggregation.</li> </ul> </li> </ul>"},{"location":"20.appendix/release-notes/nebula-comm-release-note/","title":"NebulaGraph 3.8.0 release notes","text":"<ul> <li> <p>Features:</p> <ul> <li>Introduced the SINGLE SHORTEST PATH statement. #5664</li> </ul> <ul> <li>Introduced the INNER JOIN statement. #5664</li> </ul> <ul> <li>The ROUND() function now supports various rounding modes. #5680</li> </ul> </li> </ul> <ul> <li> <p>Enhancements:</p> <ul> <li> <p>Performance:</p> <ul> <li>The SHORTEST PATH statement now supports LIMIT pushdown to improve performance. #5657</li> </ul> <ul> <li>Optimized certain logic to mitigate the impact on write performance after a follower crashes. #5673</li> </ul> <ul> <li>Optimized session management in the Meta service to reduce latency in high concurrency scenarios. #5762</li> </ul> <ul> <li>Optmized LIMIT pushdown rules to improve performance. #5883</li> </ul> </li> </ul> <ul> <li> <p>Usability:</p> <ul> <li>Optimized the process of graph space deletion to reduce blocking time. #5754</li> </ul> </li> </ul> <ul> <li> <p>Stability:</p> <ul> <li>Optimized the LEADER BALANCE algorithm for a more balanced load distribution. #5670</li> </ul> <ul> <li>Introduced a limit on the maximum number of statements to enhance system protection mechanisms. #5790</li> </ul> </li> </ul> </li> </ul> <ul> <li> <p>Bug Fixes:</p> <ul> <li> <p>DQL:</p> <ul> <li>Fixed inconsistent results when executing the LOOKUP statement multiple times. #5662</li> </ul> <ul> <li>Fixed the syntax error when UNION ALL was used. #5674</li> </ul> <ul> <li>Fixed incorrect LIMIT results and crashes in SHORTEST PATH, ALL PATH, and NOLOOP PATH scenarios. #5679, #5699, #5787, #5789</li> </ul> <ul> <li>Fixed the crash issue when executing the SHORTEST PATH statement multiple times with a memory tracker set. #5720</li> </ul> <ul> <li>Fixed a filtering error to prevent the Graph service from crashing. #5740</li> </ul> <ul> <li>Fixed execution failure in multi-variable scenarios. #5734</li> </ul> <ul> <li>Fixed the issue that MATCH SHORTEST PATH did not support self-loop detection. #5738</li> </ul> <ul> <li>Fixed the crash issue in some scenarios when the filter condition is never met. #5740</li> </ul> <ul> <li>Fixed the crash issue with the ROUND function. #5773</li> </ul> <ul> <li>Fixed the incorrect result issue when executing FIND PATH WITH PROP in a one-hop query. #5759</li> </ul> <ul> <li>Fixed the performance degradation issue when the USE SPACE clause was included in a query statement. #5793</li> </ul> <ul> <li>Fixed the issue that FIND NOLOOP PATH did not exclude self-loops. #5805</li> </ul> </li> </ul> <ul> <li> <p>Others:</p> <ul> <li>Fixed errors when executing the CLONE SPACE statement. #3005, #5781</li> </ul> <ul> <li>Fixed the issue that no data was collected by the num_vertices_inserted metric when an index existed. #5756</li> </ul> <ul> <li>Fixed a potential crash issue when queries and schema changes were performed simultaneously. #5855</li> </ul> </li> </ul> </li> </ul>"},{"location":"20.appendix/release-notes/studio-release-note/","title":"NebulaGraph Studio release notes","text":""},{"location":"20.appendix/release-notes/studio-release-note/#v3100_20245","title":"v3.10.0 (2024.5)","text":"<ul> <li> <p>Enhancements</p> <ul> <li>Adjusted the default maximum length of the context for AI Assistant.</li> <li>Adjusted some UI copywriting and styles.</li> </ul> </li> </ul> <ul> <li>Bug fixes<ul> <li>Fixed the error in the example file that was provided in the Import Template section.</li> <li>Fixed the bug where the default value was non-null when creating tags or edge types.</li> <li>Fixed the page crash when editing a large number of properties on the import task page.</li> </ul> </li> </ul>"},{"location":"20.appendix/release-notes/studio-release-note/#v391_20242","title":"v3.9.1 (2024.2)","text":"<ul> <li>Bug fixes<ul> <li>Fixed the bug where the parameter <code>NOT NULL</code> was used as property values in schema drafting. Replaced it with the default parameter <code>NULL</code>.</li> </ul> </li> </ul>"},{"location":"20.appendix/release-notes/studio-release-note/#v390_20241","title":"v3.9.0 (2024.1)","text":"<ul> <li>Features<ul> <li>Supported importing data using AI.</li> <li>Supported the generation of nGQL statements using the AI Assistant.</li> </ul> </li> </ul> <ul> <li>Enhancements<ul> <li>Optimized the console feature, including automatic completion of a tag or edge type, quick selection of the historical statements, quick viewing of the schema, etc.</li> <li>Optimized the presentation style of the execution plan.</li> </ul> </li> </ul>"},{"location":"3.ngql-guide/4.job-statements/","title":"Job manager and the JOB statements","text":"<p>The long-term tasks run by the Storage Service are called jobs, such as <code>COMPACT</code>, <code>FLUSH</code>, and <code>STATS</code>. These jobs can be time-consuming if the data amount in the graph space is large. The job manager helps you run, show, stop, and recover jobs.</p> <p>Note</p> <p>All job management commands can be executed only after selecting a graph space.</p>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_balance_leader","title":"SUBMIT JOB BALANCE LEADER","text":"<p>Starts a job to balance the distribution of all the storage leaders in all graph spaces. It returns the job ID.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB BALANCE LEADER;\n+------------+\n| New Job Id |\n+------------+\n| 33         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_compact","title":"SUBMIT JOB COMPACT","text":"<p>The <code>SUBMIT JOB COMPACT</code> statement triggers the long-term RocksDB <code>compact</code> operation in the current graph space.</p> <p>For more information about <code>compact</code> configuration, see Storage Service configuration.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB COMPACT;\n+------------+\n| New Job Id |\n+------------+\n| 40         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_flush","title":"SUBMIT JOB FLUSH","text":"<p>The <code>SUBMIT JOB FLUSH</code> statement writes the RocksDB memfile in the memory to the hard disk in the current graph space.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB FLUSH;\n+------------+\n| New Job Id |\n+------------+\n| 96         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_stats","title":"SUBMIT JOB STATS","text":"<p>The <code>SUBMIT JOB STATS</code> statement starts a job that makes the statistics of the current graph space. Once this job succeeds, you can use the <code>SHOW STATS</code> statement to list the statistics. For more information, see SHOW STATS.</p> <p>Note</p> <p>If the data stored in the graph space changes, in order to get the latest statistics, you have to run <code>SUBMIT JOB STATS</code> again.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB STATS;\n+------------+\n| New Job Id |\n+------------+\n| 9          |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#submit_job_downloadingest","title":"SUBMIT JOB DOWNLOAD/INGEST","text":"<p>The <code>SUBMIT JOB DOWNLOAD HDFS</code> and <code>SUBMIT JOB INGEST</code> commands are used to import the SST file into NebulaGraph. For detail, see Import data from SST files.</p> <p>The <code>SUBMIT JOB DOWNLOAD HDFS</code> command will download the SST file on the specified HDFS.</p> <p>The <code>SUBMIT JOB INGEST</code> command will import the downloaded SST file into NebulaGraph.</p> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB DOWNLOAD HDFS \"hdfs://192.168.10.100:9000/sst\";\n+------------+\n| New Job Id |\n+------------+\n| 10         |\n+------------+\nnebula&gt; SUBMIT JOB INGEST;\n+------------+\n| New Job Id |\n+------------+\n| 11         |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#show_job","title":"SHOW JOB","text":"<p>The Meta Service parses a <code>SUBMIT JOB</code> request into multiple tasks and assigns them to the nebula-storaged processes. The <code>SHOW JOB &lt;job_id&gt;</code> statement shows the information about a specific job and all its tasks in the current graph space.</p> <p><code>job_id</code> is returned when you run the <code>SUBMIT JOB</code> statement.</p> <p>For example:</p> <pre><code>nebula&gt; SHOW JOB 8;\n+----------------+-----------------+------------+----------------------------+----------------------------+-------------+\n| Job Id(TaskId) | Command(Dest)   | Status     | Start Time                 | Stop Time                  | Error Code  |\n+----------------+-----------------+------------+----------------------------+----------------------------+-------------+\n| 8              | \"STATS\"         | \"FINISHED\" | 2022-10-18T08:14:45.000000 | 2022-10-18T08:14:45.000000 | \"SUCCEEDED\" |\n| 0              | \"192.168.8.129\" | \"FINISHED\" | 2022-10-18T08:14:45.000000 | 2022-10-18T08:15:13.000000 | \"SUCCEEDED\" |\n| \"Total:1\"      | \"Succeeded:1\"   | \"Failed:0\" | \"In Progress:0\"            | \"\"                         | \"\"          |\n+----------------+-----------------+------------+----------------------------+----------------------------+-------------+\n</code></pre> <p>The descriptions are as follows.</p> Parameter Description <code>Job Id(TaskId)</code> The first row shows the job ID and the other rows show the task IDs and the last row shows the total number of job-related tasks. <code>Command(Dest)</code> The first row shows the command executed and the other rows show on which storaged processes the task is running. The last row shows the number of successful tasks related to the job. <code>Status</code> Shows the status of the job or task. The last row shows the number of failed tasks related to the job. For more information, see Job status. <code>Start Time</code> Shows a timestamp indicating the time when the job or task enters the <code>RUNNING</code> phase. The last row shows the number of ongoing tasks related to the job. <code>Stop Time</code> Shows a timestamp indicating the time when the job or task gets <code>FINISHED</code>, <code>FAILED</code>, or <code>STOPPED</code>. <code>Error Code</code> The error code of job."},{"location":"3.ngql-guide/4.job-statements/#job_status","title":"Job status","text":"<p>The descriptions are as follows.</p> Status Description QUEUE The job or task is waiting in a queue. The <code>Start Time</code> is empty in this phase. RUNNING The job or task is running. The <code>Start Time</code> shows the beginning time of this phase. FINISHED The job or task is successfully finished. The <code>Stop Time</code> shows the time when the job or task enters this phase. FAILED The job or task has failed. The <code>Stop Time</code> shows the time when the job or task enters this phase. STOPPED The job or task is stopped without running. The <code>Stop Time</code> shows the time when the job or task enters this phase. REMOVED The job or task is removed. <p>The description of switching the status is described as follows.</p> <pre><code>Queue -- running -- finished -- removed\n     \\          \\                /\n      \\          \\ -- failed -- /\n       \\          \\            /\n        \\ ---------- stopped -/\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#show_jobs","title":"SHOW JOBS","text":"<p>The <code>SHOW JOBS</code> statement lists all the unexpired jobs in the current graph space.</p> <p>The default job expiration interval is one week. You can change it by modifying the <code>job_expired_secs</code> parameter of the Meta Service. For how to modify <code>job_expired_secs</code>, see Meta Service configuration.</p> <p>For example:</p> <pre><code>nebula&gt; SHOW JOBS;\n+--------+---------------------+------------+----------------------------+----------------------------+\n| Job Id | Command             | Status     | Start Time                 | Stop Time                  |\n+--------+---------------------+------------+----------------------------+----------------------------+\n| 34     | \"STATS\"             | \"FINISHED\" | 2021-11-01T03:32:27.000000 | 2021-11-01T03:32:27.000000 |\n| 33     | \"FLUSH\"             | \"FINISHED\" | 2021-11-01T03:32:15.000000 | 2021-11-01T03:32:15.000000 |\n| 32     | \"COMPACT\"           | \"FINISHED\" | 2021-11-01T03:32:06.000000 | 2021-11-01T03:32:06.000000 |\n| 31     | \"REBUILD_TAG_INDEX\" | \"FINISHED\" | 2021-10-29T05:39:16.000000 | 2021-10-29T05:39:17.000000 |\n| 10     | \"COMPACT\"           | \"FINISHED\" | 2021-10-26T02:27:05.000000 | 2021-10-26T02:27:05.000000 |\n+--------+---------------------+------------+----------------------------+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#stop_job","title":"STOP JOB","text":"<p>The <code>STOP JOB &lt;job_id&gt;</code> statement stops jobs that are not finished in the current graph space.</p> <p>For example:</p> <pre><code>nebula&gt; STOP JOB 22;\n+---------------+\n| Result        |\n+---------------+\n| \"Job stopped\" |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#recover_job","title":"RECOVER JOB","text":"<p>The <code>RECOVER JOB [&lt;job_id&gt;]</code> statement re-executes the jobs that status is <code>FAILED</code> or <code>STOPPED</code> in the current graph space and returns the number of recovered jobs. If <code>&lt;job_id&gt;</code> is not specified, re-execution is performed from the earliest job and the number of jobs that have been recovered is returned.</p> <p>For example:</p> <pre><code>nebula&gt; RECOVER JOB;\n+-------------------+\n| Recovered job num |\n+-------------------+\n| 5 job recovered   |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/4.job-statements/#faq","title":"FAQ","text":""},{"location":"3.ngql-guide/4.job-statements/#how_to_troubleshoot_job_problems","title":"How to troubleshoot job problems?","text":"<p>The <code>SUBMIT JOB</code> operations use the HTTP port. Please check if the HTTP ports on the machines where the Storage Service is running are working well. You can use the following command to debug.</p> <pre><code>curl \"http://{storaged-ip}:19779/admin?space={space_name}&amp;op=compact\"\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/","title":"NebulaGraph Query Language (nGQL)","text":"<p>This topic gives an introduction to the query language of NebulaGraph, nGQL.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#what_is_ngql","title":"What is nGQL","text":"<p>nGQL is a declarative graph query language for NebulaGraph. It allows expressive and efficient graph patterns. nGQL is designed for both developers and operations professionals. nGQL is an SQL-like query language, so it's easy to learn.</p> <p>nGQL is a project in progress. New features and optimizations are done steadily. There can be differences between syntax and implementation. Submit an issue to inform the NebulaGraph team if you find a new issue of this type. NebulaGraph 3.0 or later releases will support openCypher 9.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#what_can_ngql_do","title":"What can nGQL do","text":"<ul> <li>Supports graph traversals</li> <li>Supports pattern match</li> <li>Supports aggregation</li> <li>Supports graph mutation</li> <li>Supports access control</li> <li>Supports composite queries</li> <li>Supports index</li> <li>Supports most openCypher 9 graph query syntax (but mutations and controls syntax are not supported)</li> </ul>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#example_data_basketballplayer","title":"Example data Basketballplayer","text":"<p>Users can download the example data Basketballplayer in NebulaGraph. After downloading the example data, you can import it to NebulaGraph by using the <code>-f</code> option in NebulaGraph Console.</p> <p>Note</p> <p>Ensure that you have executed the <code>ADD HOSTS</code> command to add the Storage service to your NebulaGraph cluster before importing the example data. For more information, see Manage Storage hosts.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#placeholder_identifiers_and_values","title":"Placeholder identifiers and values","text":"<p>Refer to the following standards in nGQL:</p> <ul> <li>(Draft) ISO/IEC JTC1 N14279 SC 32 - Database_Languages - GQL</li> </ul> <ul> <li>(Draft) ISO/IEC JTC1 SC32 N3228 - SQL_Property_Graph_Queries - SQLPGQ</li> </ul> <ul> <li>OpenCypher 9</li> </ul> <p>In template code, any token that is not a keyword, a literal value, or punctuation is a placeholder identifier or a placeholder value.</p> <p>For details of the symbols in nGQL syntax, see the following table:</p> Token Meaning &lt; &gt; name of a syntactic element : formula that defines an element [ ] optional elements { } explicitly specified elements | complete alternative elements ... may be repeated any number of times <p>For example, insert vertices in nGQL syntax:</p> <pre><code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...]\nVALUES &lt;vid&gt;: ([prop_value_list])\ntag_props:\n  tag_name ([prop_name_list])\nprop_name_list:\n   [prop_name [, prop_name] ...]\nprop_value_list:\n   [prop_value [, prop_value] ...]  \n</code></pre> <p>Example statement:</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string, age int);\nnebula&gt; INSERT VERTEX IF NOT EXISTS player(name,age) VALUES \"player100\":(\"Tim Duncan\", 42);\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#about_opencypher_compatibility","title":"About openCypher compatibility","text":""},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#native_ngql_and_opencypher","title":"Native nGQL and openCypher","text":"<p>Native nGQL is the part of a graph query language designed and implemented by NebulaGraph. OpenCypher is a graph query language maintained by openCypher Implementers Group.</p> <p>The latest release is openCypher 9. The compatible parts of openCypher in nGQL are called openCypher compatible sentences (short as openCypher).</p> <p>Note</p> <p><code>nGQL</code> = <code>native nGQL</code> + <code>openCypher compatible sentences</code></p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#is_ngql_compatible_with_opencypher_9_completely","title":"Is nGQL compatible with openCypher 9 completely?","text":"<p>NO.</p> <p>Compatibility with openCypher</p> <p>nGQL is designed to be compatible with part of DQL (match, optional match, with, etc.).</p> <ul> <li>It is not planned to be compatible with any DDL, DML, or DCL.</li> <li>It is not planned to be compatible with the Bolt Protocol.</li> <li>It is not planned to be compatible with APOC and GDS.</li> </ul> <p>Users can search in this manual with the keyword <code>compatibility</code> to find major compatibility issues.  </p> <p>Multiple known incompatible items are listed in NebulaGraph Issues. Submit an issue with the <code>incompatible</code> tag if you find a new issue of this type. </p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#what_are_the_major_differences_between_ngql_and_opencypher_9","title":"What are the major differences between nGQL and openCypher 9?","text":"<p>The following are some major differences (by design incompatible) between nGQL and openCypher.</p> Category openCypher 9 nGQL Schema Optional Schema Strong Schema Equality operator <code>=</code> <code>==</code> Math exponentiation <code>^</code> <code>^</code> is not supported. Use pow(x, y) instead. Edge rank No such concept. edge rank (reference by @) Statement - All DMLs (<code>CREATE</code>, <code>MERGE</code>, etc) of openCypher 9. Label and tag A label is used for searching a vertex, namely an index of vertex. A tag defines the type of a vertex and its corresponding properties. It cannot be used as an index. Pre-compiling and parameterized queries Support Parameterized queries are supported, but precompiling is not. <p>Compatibility</p> <p>OpenCypher 9 and Cypher have some differences in grammar and licence. For example,</p> <ol> <li> <p>Cypher requires that All Cypher statements are explicitly run within a transaction. While openCypher has no such requirement. And nGQL does not support transactions.</p> </li> <li> <p>Cypher has a variety of constraints, including Unique node property constraints, Node property existence constraints, Relationship property existence constraints, and Node key constraints. While OpenCypher has no such constraints. As a strong schema system, most of the constraints mentioned above can be solved through schema definitions (including NOT NULL) in nGQL. The only function that cannot be supported is the UNIQUE constraint.</p> </li> <li> <p>Cypher has APoC, while openCypher 9 does not have APoC. Cypher has Blot protocol support requirements, while openCypher 9 does not.</p> </li> </ol>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#where_can_i_find_more_ngql_examples","title":"Where can I find more nGQL examples?","text":"<p>Users can find more than 2500 nGQL examples in the features directory on the NebulaGraph GitHub page.</p> <p>The <code>features</code> directory consists of <code>.feature</code> files. Each file records scenarios that you can use as nGQL examples. Here is an example:</p> <pre><code>Feature: Basic match\n\n  Background:\n    Given a graph with space named \"basketballplayer\"\n\n  Scenario: Single node\n    When executing query:\n      \"\"\"\n      MATCH (v:player {name: \"Yao Ming\"}) RETURN v;\n      \"\"\"\n    Then the result should be, in any order, with relax comparison:\n      | v                                                |\n      | (\"player133\" :player{age: 38, name: \"Yao Ming\"}) |\n\n  Scenario: One step\n    When executing query:\n      \"\"\"\n      MATCH (v1:player{name: \"LeBron James\"}) -[r]-&gt; (v2)\n      RETURN type(r) AS Type, v2.player.name AS Name\n      \"\"\"\n    Then the result should be, in any order:\n\n      | Type     | Name        |\n      | \"follow\" | \"Ray Allen\" |\n      | \"serve\"  | \"Lakers\"    |\n      | \"serve\"  | \"Heat\"      |\n      | \"serve\"  | \"Cavaliers\" |\n\nFeature:  Comparison of where clause\n\n  Background:\n    Given a graph with space named \"basketballplayer\"\n\n    Scenario: push edge props filter down\n      When profiling query:\n        \"\"\"\n        GO FROM \"player100\" OVER follow \n        WHERE properties(edge).degree IN [v IN [95,99] WHERE v &gt; 0] \n        YIELD dst(edge), properties(edge).degree\n        \"\"\"\n      Then the result should be, in any order:\n        | follow._dst | follow.degree |\n        | \"player101\" | 95            |\n        | \"player125\" | 95            |\n      And the execution plan should be:\n        | id | name         | dependencies | operator info                                               |\n        | 0  | Project      | 1            |                                                             |\n        | 1  | GetNeighbors | 2            | {\"filter\": \"(properties(edge).degree IN [v IN [95,99] WHERE (v&gt;0)])\"} |\n        | 2  | Start        |              |                                                             |\n</code></pre> <p>The keywords in the preceding example are described as follows.</p> Keyword Description <code>Feature</code> Describes the topic of the current <code>.feature</code> file. <code>Background</code> Describes the background information of the current <code>.feature</code> file. <code>Given</code> Describes the prerequisites of running the test statements in the current <code>.feature</code> file. <code>Scenario</code> Describes the scenarios. If there is the <code>@skip</code> before one <code>Scenario</code>, this scenario may not work and do not use it as a working example in a production environment. <code>When</code> Describes the nGQL statement to be executed. It can be a <code>executing query</code> or <code>profiling query</code>. <code>Then</code> Describes the expected return results of running the statement in the <code>When</code> clause. If the return results in your environment do not match the results described in the <code>.feature</code> file, submit an issue to inform the NebulaGraph team. <code>And</code> Describes the side effects of running the statement in the <code>When</code> clause. <code>@skip</code> This test case will be skipped. Commonly, the to-be-tested code is not ready. <p>Welcome to add more tck case and return automatically to the using statements in CI/CD.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#does_it_support_tinkerpop_gremlin","title":"Does it support TinkerPop Gremlin?","text":"<p>No. And no plan to support that.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/1.overview/#does_nebulagraph_support_w3c_rdf_sparql_or_graphql","title":"Does NebulaGraph support W3C RDF (SPARQL) or GraphQL?","text":"<p>No. And no plan to support that.</p> <p>The data model of NebulaGraph is the property graph. And as a strong schema system, NebulaGraph does not support RDF.</p> <p>NebulaGraph Query Language does not support <code>SPARQL</code> nor <code>GraphQL</code>.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/","title":"Patterns","text":"<p>Patterns and graph pattern matching are the very heart of a graph query language. This topic will describe the patterns in NebulaGraph, some of which have not yet been implemented.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_vertices","title":"Patterns for vertices","text":"<p>A vertex is described using a pair of parentheses and is typically given a name. For example:</p> <pre><code>(a)\n</code></pre> <p>This simple pattern describes a single vertex and names that vertex using the variable <code>a</code>.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_related_vertices","title":"Patterns for related vertices","text":"<p>A more powerful construct is a pattern that describes multiple vertices and edges between them. Patterns describe an edge by employing an arrow between two vertices. For example:</p> <pre><code>(a)-[]-&gt;(b)\n</code></pre> <p>This pattern describes a very simple data structure: two vertices and a single edge from one to the other. In this example, the two vertices are named as <code>a</code> and <code>b</code> respectively and the edge is <code>directed</code>: it goes from <code>a</code> to <code>b</code>.</p> <p>This manner of describing vertices and edges can be extended to cover an arbitrary number of vertices and the edges between them, for example:</p> <pre><code>(a)-[]-&gt;(b)&lt;-[]-(c)\n</code></pre> <p>Such a series of connected vertices and edges is called a <code>path</code>.</p> <p>Note that the naming of the vertices in these patterns is only necessary when one needs to refer to the same vertex again, either later in the pattern or elsewhere in the query. If not, the name may be omitted as follows:</p> <pre><code>(a)-[]-&gt;()&lt;-[]-(c)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_tags","title":"Patterns for tags","text":"<p>Note</p> <p>The concept of <code>tag</code> in nGQL has a few differences from that of <code>label</code> in openCypher. For example, users must create a <code>tag</code> before using it. And a <code>tag</code> also defines the type of properties.</p> <p>In addition to simply describing the vertices in the graphs, patterns can also describe the tags of the vertices. For example:</p> <pre><code>(a:User)-[]-&gt;(b)\n</code></pre> <p>Patterns can also describe a vertex that has multiple tags. For example:</p> <pre><code>(a:User:Admin)-[]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_properties","title":"Patterns for properties","text":"<p>Vertices and edges are the fundamental elements in a graph. In nGQL, properties are added to them for richer models.</p> <p>In the patterns, the properties can be expressed as follows: some key-value pairs are enclosed in curly brackets and separated by commas, and the tag or edge type to which a property belongs must be specified.</p> <p>For example, a vertex with two properties will be like:</p> <pre><code>(a:player{name: \"Tim Duncan\", age: 42})\n</code></pre> <p>One of the edges that connect to this vertex can be like:</p> <pre><code>(a)-[e:follow{degree: 95}]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#patterns_for_edges","title":"Patterns for edges","text":"<p>The simplest way to describe an edge is by using the arrow between two vertices, as in the previous examples.</p> <p>Users can describe an edge and its direction using the following statement. If users do not care about its direction, the arrowhead can be omitted. For example:</p> <pre><code>(a)-[]-(b)\n</code></pre> <p>Like vertices, edges can also be named. A pair of square brackets will be used to separate the arrow and the variable will be placed between them. For example:</p> <pre><code>(a)-[r]-&gt;(b)\n</code></pre> <p>Like the tags on vertices, edges can also have types. To describe an edge with a specific type, use the pattern as follows:</p> <pre><code>(a)-[r:REL_TYPE]-&gt;(b)\n</code></pre> <p>An edge can only have one edge type. But if we'd like to describe some data such that the edge could have a set of types, then they can all be listed in the pattern, separating them with the pipe symbol <code>|</code> like this:</p> <pre><code>(a)-[r:TYPE1|TYPE2]-&gt;(b)\n</code></pre> <p>Like vertices, the name of an edge can be omitted. For example:</p> <pre><code>(a)-[:REL_TYPE]-&gt;(b)\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#variable-length_pattern","title":"Variable-length pattern","text":"<p>Rather than describing a long path using a sequence of many vertex and edge descriptions in a pattern, many edges (and the intermediate vertices) can be described by specifying a length in the edge description of a pattern. For example:</p> <pre><code>(a)-[*2]-&gt;(b)\n</code></pre> <p>The following pattern describes a graph of three vertices and two edges, all in one path (a path of length 2). It is equivalent to:</p> <pre><code>(a)-[]-&gt;()-[]-&gt;(b)\n</code></pre> <p>The range of lengths can also be specified. Such edge patterns are called <code>variable-length edges</code>. For example:</p> <pre><code>(a)-[*3..5]-&gt;(b)\n</code></pre> <p>The preceding example defines a path with a minimum length of 3 and a maximum length of 5.</p> <p>It describes a graph of either 4 vertices and 3 edges, 5 vertices and 4 edges, or 6 vertices and 5 edges, all connected in a single path.</p> <p>You may specify either the upper limit or lower limit of the length range, or neither of them, for example:</p> <pre><code>(a)-[*..5]-&gt;(b)   // The minimum length is 1 and the maximum length is 5.\n(a)-[*3..]-&gt;(b)   // The minimum length is 3 and the maximum length is infinity.\n(a)-[*]-&gt;(b)      // The minimum length is 1 and the maximum length is infinity.\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/3.graph-patterns/#assigning_to_path_variables","title":"Assigning to path variables","text":"<p>As described above, a series of connected vertices and edges is called a <code>path</code>. nGQL allows paths to be named using variables. For example:</p> <pre><code>p = (a)-[*3..5]-&gt;(b)\n</code></pre> <p>Users can do this in the <code>MATCH</code> statement.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/comments/","title":"Comments","text":"<p>This topic will describe the comments in nGQL.</p> <p>Legacy version compatibility</p> <ul> <li>In NebulaGraph 1.x, there are four comment styles: <code>#</code>, <code>--</code>, <code>//</code>, <code>/* */</code>.</li> <li>Since NebulaGraph 2.x, <code>--</code> cannot be used as comments.</li> </ul>"},{"location":"3.ngql-guide/1.nGQL-overview/comments/#examples","title":"Examples","text":"<pre><code>nebula&gt; RETURN 1+1;     # This comment continues to the end of this line.\nnebula&gt; RETURN 1+1;     // This comment continues to the end of this line.\nnebula&gt; RETURN 1 /* This is an in-line comment. */ + 1 == 2;\nnebula&gt; RETURN 11 +            \\\n/* Multi-line comment.       \\\nUse a backslash as a line break.   \\\n*/ 12;\n</code></pre> <p>Note</p> <ul> <li>In nGQL statements, the backslash <code>\\</code> in a line indicates a line break.</li> <li>If a statement starts with <code>#</code> or <code>//</code>, the statement is not executed and the error <code>StatementEmpty</code> is returned.</li> </ul>"},{"location":"3.ngql-guide/1.nGQL-overview/comments/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<ul> <li>In nGQL, you must add a <code>\\</code> at the end of every line, even in multi-line comments <code>/* */</code>.</li> <li>In openCypher, there is no need to use a <code>\\</code> as a line break.</li> </ul> <pre><code>/* openCypher style:\nThe following comment\nspans more than\none line */\nMATCH (n:label)\nRETURN n;\n</code></pre> <pre><code>/* nGQL style:  \\\nThe following comment       \\\nspans more than     \\\none line */       \\\nMATCH (n:tag) \\\nRETURN n;\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/","title":"Identifier case sensitivity","text":""},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/#identifiers_are_case-sensitive","title":"Identifiers are Case-Sensitive","text":"<p>The following statements will not work because they refer to two different spaces, i.e. <code>my_space</code> and <code>MY_SPACE</code>.</p> <pre><code>nebula&gt; CREATE SPACE IF NOT EXISTS my_space (vid_type=FIXED_STRING(30));\nnebula&gt; use MY_SPACE;\n[ERROR (-1005)]: SpaceNotFound:\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/#keywords_and_reserved_words_are_case-insensitive","title":"Keywords and Reserved Words are Case-Insensitive","text":"<p>The following statements are equivalent since <code>show</code> and <code>spaces</code> are keywords.</p> <pre><code>nebula&gt; show spaces;  \nnebula&gt; SHOW SPACES;\nnebula&gt; SHOW spaces;\nnebula&gt; show SPACES;\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/identifier-case-sensitivity/#functions_are_case-insensitive","title":"Functions are Case-Insensitive","text":"<p>Functions are case-insensitive. For example, <code>count()</code>, <code>COUNT()</code>, and <code>couNT()</code> are equivalent.</p> <pre><code>nebula&gt; WITH [NULL, 1, 1, 2, 2] As a \\\n        UNWIND a AS b \\\n        RETURN count(b), COUNT(*), couNT(DISTINCT b);\n+----------+----------+-------------------+\n| count(b) | COUNT(*) | couNT(distinct b) |\n+----------+----------+-------------------+\n| 4        | 5        | 2                 |\n+----------+----------+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/keywords-and-reserved-words/","title":"Keywords","text":"<p>Keywords in nGQL are words with particular meanings, such as <code>CREATE</code> and <code>TAG</code> in the <code>CREATE TAG</code> statement. Keywords that require special processing to be used as identifiers are referred to as <code>reserved keywords</code>, while the part of keywords that can be used directly as identifiers are called <code>non-reserved keywords</code>.</p> <p>It is not recommended to use keywords to identify schemas. If you must use keywords as identifiers, pay attention to the following restrictions:</p> <ul> <li>To use reserved keywords or special characters as identifiers, you must enclose them with backticks (`), such as `AND`. Otherwise, a syntax error is thrown.</li> </ul> <ul> <li> <p>To use non-reserved keywords as identifiers:</p> <ul> <li>If the identifier contains any uppercase letter, you must enclose them with backticks (`), such as `Comment`. Otherwise, the execution succeeds but the system automatically converts the identifier to all lowercase.</li> <li>If the identifier contains all lowercase letters, you do not need to enclose them with backticks (`).</li> </ul> </li> </ul> <p>Note</p> <p>Keywords are case-insensitive.</p> <pre><code>nebula&gt; CREATE TAG TAG(name string);\n[ERROR (-1004)]: SyntaxError: syntax error near `TAG'\n\nnebula&gt; CREATE TAG `TAG` (name string);\nExecution succeeded\n\nnebula&gt; CREATE TAG SPACE(name string);\nExecution succeeded\n\nnebula&gt; CREATE TAG \u4e2d\u6587(\u7b80\u4f53 string);\nExecution succeeded\n\nnebula&gt; CREATE TAG `\uffe5%special characters&amp;*+-*/` (`q~\uff01\uff08\uff09=  wer` string);\nExecution succeeded\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/keywords-and-reserved-words/#reserved_keywords","title":"Reserved keywords","text":"<pre><code>ACROSS\nADD\nALTER\nAND\nAS\nASC\nASCENDING\nBALANCE\nBOOL\nBY\nCASE\nCHANGE\nCOMPACT\nCREATE\nDATE\nDATETIME\nDELETE\nDESC\nDESCENDING\nDESCRIBE\nDISTINCT\nDOUBLE\nDOWNLOAD\nDROP\nDURATION\nEDGE\nEDGES\nEXISTS\nEXPLAIN\nFALSE\nFETCH\nFIND\nFIXED_STRING\nFLOAT\nFLUSH\nFROM\nGEOGRAPHY\nGET\nGO\nGRANT\nIF\nIGNORE_EXISTED_INDEX\nIN\nINDEX\nINDEXES\nINGEST\nINSERT\nINT\nINT16\nINT32\nINT64\nINT8\nINTERSECT\nIS\nJOIN\nLEFT\nLIST\nLOOKUP\nMAP\nMATCH\nMINUS\nNO\nNOT\nNULL\nOF\nON\nOR\nORDER\nOVER\nOVERWRITE\nPATH\nPROP\nREBUILD\nRECOVER\nREMOVE\nRESTART\nRETURN\nREVERSELY\nREVOKE\nSET\nSHOW\nSTEP\nSTEPS\nSTOP\nSTRING\nSUBMIT\nTAG\nTAGS\nTIME\nTIMESTAMP\nTO\nTRUE\nUNION\nUNWIND\nUPDATE\nUPSERT\nUPTO\nUSE\nVERTEX\nVERTICES\nWHEN\nWHERE\nWITH\nXOR\nYIELD\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/keywords-and-reserved-words/#non-reserved_keywords","title":"Non-reserved keywords","text":"<pre><code>ACCOUNT\nADMIN\nAGENT\nALL\nALLSHORTESTPATHS\nANALYZER\nANY\nATOMIC_EDGE\nAUTO\nBASIC\nBIDIRECT\nBOTH\nCHARSET\nCLEAR\nCLIENTS\nCOLLATE\nCOLLATION\nCOMMENT\nCONFIGS\nCONTAINS\nDATA\nDBA\nDEFAULT\nDIVIDE\nDRAINER\nDRAINERS\nELASTICSEARCH\nELSE\nEND\nENDS\nES_QUERY\nFORCE\nFORMAT\nFULLTEXT\nGOD\nGRANTS\nGRAPH\nGROUP\nGROUPS\nGUEST\nHDFS\nHOST\nHOSTS\nHTTP\nHTTPS\nINTO\nIP\nJOB\nJOBS\nKILL\nLEADER\nLIMIT\nLINESTRING\nLISTENER\nLOCAL\nMERGE\nMETA\nNEW\nNOLOOP\nNONE\nOFFSET\nOPTIONAL\nOUT\nPART\nPARTITION_NUM\nPARTS\nPASSWORD\nPLAN\nPOINT\nPOLYGON\nPROFILE\nQUERIES\nQUERY\nREAD\nREDUCE\nRENAME\nREPLICA_FACTOR\nRESET\nROLE\nROLES\nS2_MAX_CELLS\nS2_MAX_LEVEL\nSAMPLE\nSEARCH\nSERVICE\nSESSION\nSESSIONS\nSHORTEST\nSHORTESTPATH\nSIGN\nSINGLE\nSKIP\nSNAPSHOT\nSNAPSHOTS\nSPACE\nSPACES\nSTARTS\nSTATS\nSTATUS\nSTORAGE\nSUBGRAPH\nSYNC\nTEXT\nTEXT_SEARCH\nTHEN\nTOP\nTTL_COL\nTTL_DURATION\nUSER\nUSERS\nUUID\nVALUE\nVALUES\nVARIABLES\nVID_TYPE\nWHITELIST\nWRITE\nZONE\nZONES\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/","title":"nGQL style guide","text":"<p>nGQL does not have strict formatting requirements, but creating nGQL statements according to an appropriate and uniform style can improve readability and avoid ambiguity. Using the same nGQL style in the same organization or project helps reduce maintenance costs and avoid problems caused by format confusion or misunderstanding. This topic will provide a style guide for writing nGQL statements.</p> <p>Compatibility</p> <p>The styles of nGQL and Cypher Style Guide are different.</p>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#newline","title":"Newline","text":"<ol> <li> <p>Start a new line to write a clause.</p> <p>Not recommended:</p> <pre><code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS id;\n</code></pre> <p>Recommended:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow REVERSELY \\\nYIELD src(edge) AS id;\n</code></pre> </li> <li> <p>Start a new line to write different statements in a composite statement.</p> <p>Not recommended:</p> <pre><code>GO FROM \"player100\" OVER follow REVERSELY YIELD src(edge) AS id | GO FROM $-.id \\\nOVER serve WHERE properties($^).age &gt; 20 YIELD properties($^).name AS FriendOf, properties($$).name AS Team;\n</code></pre> <p>Recommended:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow REVERSELY \\\nYIELD src(edge) AS id | \\\nGO FROM $-.id OVER serve \\\nWHERE properties($^).age &gt; 20 \\\nYIELD properties($^).name AS FriendOf, properties($$).name AS Team;\n</code></pre> </li> <li> <p>If the clause exceeds 80 characters, start a new line at the appropriate place.</p> <p>Not recommended:</p> <pre><code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) \\\nWHERE (v2.player.name STARTS WITH \"Y\" AND v2.player.age &gt; 35 AND v2.player.age &lt; v.player.age) OR (v2.player.name STARTS WITH \"T\" AND v2.player.age &lt; 45 AND v2.player.age &gt; v.player.age) \\\nRETURN v2;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) \\\nWHERE (v2.player.name STARTS WITH \"Y\" AND v2.player.age &gt; 35 AND v2.player.age &lt; v.player.age) \\\nOR (v2.player.name STARTS WITH \"T\" AND v2.player.age &lt; 45 AND v2.player.age &gt; v.player.age) \\\nRETURN v2;\n</code></pre> </li> </ol> <p>Note</p> <p>If needed, you can also start a new line for better understanding, even if the clause does not exceed 80 characters. </p>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#identifier_naming","title":"Identifier naming","text":"<p>In nGQL statements, characters other than keywords, punctuation marks, and blanks are all identifiers. Recommended methods to name the identifiers are as follows.</p> <ol> <li> <p>Use singular nouns to name tags, and use the base form of verbs or verb phrases to form Edge types.</p> <p>Not recommended:</p> <pre><code>MATCH p=(v:players)-[e:are_following]-(v2) \\\nRETURN nodes(p);\n</code></pre> <p>Recommended:</p> <pre><code>MATCH p=(v:player)-[e:follow]-(v2) \\\nRETURN nodes(p);\n</code></pre> </li> <li> <p>Use the snake case to name identifiers, and connect words with underscores (_) with all the letters lowercase.</p> <p>Not recommended:</p> <pre><code>MATCH (v:basketballTeam) \\\nRETURN v;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:basketball_team) \\\nRETURN v;\n</code></pre> </li> <li> <p>Use uppercase keywords and lowercase variables.</p> <p>Not recommended:</p> <pre><code>match (V:player) return V limit 5;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player) RETURN v LIMIT 5;\n</code></pre> </li> </ol>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#pattern","title":"Pattern","text":"<ol> <li> <p>Start a new line on the right side of the arrow indicating an edge when writing patterns.</p> <p>Not recommended:</p> <pre><code>MATCH (v:player{name: \"Tim Duncan\", age: 42}) \\\n-[e:follow]-&gt;()-[e:serve]-&gt;()&lt;--(v2) \\\nRETURN v, e, v2;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player{name: \"Tim Duncan\", age: 42})-[e:follow]-&gt; \\\n()-[e:serve]-&gt;()&lt;--(v2) \\\nRETURN v, e, v2;\n</code></pre> </li> <li> <p>Anonymize the vertices and edges that do not need to be queried.</p> <p>Not recommended:</p> <pre><code>MATCH (v:player)-[e:follow]-&gt;(v2) \\\nRETURN v;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v:player)-[:follow]-&gt;() \\\nRETURN v;\n</code></pre> </li> <li> <p>Place named vertices in front of anonymous vertices.</p> <p>Not recommended:</p> <pre><code>MATCH ()-[:follow]-&gt;(v) \\\nRETURN v;\n</code></pre> <p>Recommended:</p> <pre><code>MATCH (v)&lt;-[:follow]-() \\\nRETURN v;\n</code></pre> </li> </ol>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#string","title":"String","text":"<p>The strings should be surrounded by double quotes.</p> <p>Not recommended:</p> <pre><code>RETURN 'Hello Nebula!';\n</code></pre> <p>Recommended:</p> <pre><code>RETURN \"Hello Nebula!\\\"123\\\"\";\n</code></pre> <p>Note</p> <p>When single or double quotes need to be nested in a string, use a backslash () to escape. For example:</p> <pre><code>RETURN \"\\\"NebulaGraph is amazing,\\\" the user says.\";\n</code></pre>"},{"location":"3.ngql-guide/1.nGQL-overview/ngql-style-guide/#statement_termination","title":"Statement termination","text":"<ol> <li> <p>End the nGQL statements with an English semicolon (;).</p> <p>Not recommended:</p> <pre><code>FETCH PROP ON player \"player100\" YIELD properties(vertex)\n</code></pre> <p>Recommended:</p> <pre><code>FETCH PROP ON player \"player100\" YIELD properties(vertex);\n</code></pre> </li> <li> <p>Use a pipe (|) to separate a composite statement, and end the statement with an English semicolon at the end of the last line. Using an English semicolon before a pipe will cause the statement to fail.</p> <p>Not supported:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow \\\nYIELD dst(edge) AS id; | \\\nGO FROM $-.id \\\nOVER serve \\\nYIELD properties($$).name AS Team, properties($^).name AS Player;\n</code></pre> <p>Supported:</p> <pre><code>GO FROM \"player100\" \\\nOVER follow \\\nYIELD dst(edge) AS id | \\\nGO FROM $-.id \\\nOVER serve \\\nYIELD properties($$).name AS Team, properties($^).name AS Player;\n</code></pre> </li> <li> <p>In a composite statement that contains user-defined variables, use an English semicolon to end the statements that define the variables. If you do not follow the rules to add a semicolon or use a pipe to end the composite statement, the execution will fail.</p> <p>Not supported:</p> <pre><code>$var = GO FROM \"player100\" \\\nOVER follow \\\nYIELD follow._dst AS id \\\nGO FROM $var.id \\\nOVER serve \\\nYIELD $$.team.name AS Team, $^.player.name AS Player;\n</code></pre> <p>Not supported:</p> <pre><code>$var = GO FROM \"player100\" \\\nOVER follow \\\nYIELD follow._dst AS id | \\\nGO FROM $var.id \\\nOVER serve \\\nYIELD $$.team.name AS Team, $^.player.name AS Player;\n</code></pre> <p>Supported:</p> <pre><code>$var = GO FROM \"player100\" \\\nOVER follow \\\nYIELD follow._dst AS id; \\\nGO FROM $var.id \\\nOVER serve \\\nYIELD $$.team.name AS Team, $^.player.name AS Player;\n</code></pre> </li> </ol>"},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/","title":"CREATE TAG","text":"<p><code>CREATE TAG</code> creates a tag with the given name in a graph space.</p>"},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>Tags in nGQL are similar to labels in openCypher. But they are also quite different. For example, the ways to create them are different.</p> <ul> <li>In openCypher, labels are created together with vertices in <code>CREATE</code> statements.</li> <li>In nGQL, tags are created separately using <code>CREATE TAG</code> statements. Tags in nGQL are more like tables in MySQL.</li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>CREATE TAG</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/#syntax","title":"Syntax","text":"<p>To create a tag in a specific graph space, you must specify the current working space with the <code>USE</code> statement.</p> <pre><code>CREATE TAG [IF NOT EXISTS] &lt;tag_name&gt;\n    (\n      &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']\n      [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] \n    )\n    [TTL_DURATION = &lt;ttl_duration&gt;]\n    [TTL_COL = &lt;prop_name&gt;]\n    [COMMENT = '&lt;comment&gt;'];\n</code></pre> Parameter Description <code>IF NOT EXISTS</code> Detects if the tag that you want to create exists. If it does not exist, a new one will be created. The tag existence detection here only compares the tag names (excluding properties). <code>&lt;tag_name&gt;</code> 1. Each tag name in the graph space must be unique. 2. Tag names cannot be modified after they are set. 3. By default, the name only supports 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc. However, it cannot include special characters other than the underscore (_), and cannot start with a number. 4. To use special characters, reserved keywords, or start with a number, quote the entire name with backticks (`) and do not include periods (<code>.</code>) within the pair of backticks (`). For more information, see Keywords and reserved words. Note:1. If you name a tag in Chinese and encounter a <code>SyntaxError</code>, you need to quote the Chinese characters with backticks (`). 2. To include a backtick (`) in a tag name, use a backslash to escape the backtick, such as \\`; to include a backslash, the backslash itself also needs to be escaped, such as \\ . <code>&lt;prop_name&gt;</code> The name of the property. It must be unique for each tag. The rules for permitted property names are the same as those for tag names. <code>&lt;data_type&gt;</code> The data type of the property. The following data types are supported: Numeric, Boolean, String, Date and time, and Geography. <code>NULL | NOT NULL</code> Specifies if the property supports <code>NULL | NOT NULL</code>. The default value is <code>NULL</code>. <code>DEFAULT</code> Specifies a default value for a property. The default value can be a literal value or an expression supported by NebulaGraph. If no value is specified, the default value is used when inserting a new vertex. <code>COMMENT</code> The remarks of a certain property or the tag itself. The maximum length is 256 bytes. By default, there will be no comments on a tag. <code>TTL_DURATION</code> Specifies the life cycle for the property. The property that exceeds the specified TTL expires. The expiration threshold is the <code>TTL_COL</code> value plus the <code>TTL_DURATION</code>. The default value of <code>TTL_DURATION</code> is <code>0</code>. It means the data never expires. <code>TTL_COL</code> Specifies the property to set a timeout on. The data type of the property must be <code>int</code> or <code>timestamp</code>. A tag can only specify one field as <code>TTL_COL</code>. For more information on TTL, see TTL options."},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/#examples","title":"Examples","text":"<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string, age int);\n\n# The following example creates a tag with no properties.\nnebula&gt; CREATE TAG IF NOT EXISTS no_property();\u00a0\n\n# The following example creates a tag with a default value.\nnebula&gt; CREATE TAG IF NOT EXISTS player_with_default(name string, age int DEFAULT 20);\n\n# In the following example, the TTL of the create_time field is set to be 100 seconds.\nnebula&gt; CREATE TAG IF NOT EXISTS woman(name string, age int, \\\n        married bool, salary double, create_time timestamp) \\\n        TTL_DURATION = 100, TTL_COL = \"create_time\";\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/1.create-tag/#implementation_of_the_operation","title":"Implementation of the operation","text":"<p>Trying to use a newly created tag may fail because the creation of the tag is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.</p> <p>To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services.</p>"},{"location":"3.ngql-guide/10.tag-statements/2.drop-tag/","title":"DROP TAG","text":"<p><code>DROP TAG</code> drops a tag with the given name in the current working graph space.</p> <p>A vertex can have one or more tags.</p> <ul> <li>If a vertex has only one tag, the vertex CANNOT be accessed after you drop it. The vertex will be dropped in the next compaction. But its edges are available, this operation will result in dangling edges.</li> </ul> <ul> <li>If a vertex has multiple tags, the vertex is still accessible after you drop one of them. But all the properties defined by this dropped tag CANNOT be accessed.</li> </ul> <p>This operation only deletes the Schema data. All the files or directories in the disk will not be deleted directly until the next compaction.</p> <p>Compatibility</p> <p>In NebulaGraph 3.8.0, inserting vertex without tag is not supported by default. If you want to use the vertex without tags, add <code>--graph_use_vertex_key=true</code> to the configuration files (<code>nebula-graphd.conf</code>) of all Graph services in the cluster, and add <code>--use_vertex_key=true</code> to the configuration files (<code>nebula-storaged.conf</code>) of all Storage services in the cluster.</p>"},{"location":"3.ngql-guide/10.tag-statements/2.drop-tag/#prerequisites","title":"Prerequisites","text":"<ul> <li>Running the <code>DROP TAG</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</li> </ul> <ul> <li>Before you drop a tag, make sure that the tag does not have any indexes. Otherwise, the conflict error (<code>[ERROR (-1005)]: Conflict!</code>) will be returned when you run the <code>DROP TAG</code> statement. To drop an index, see DROP INDEX.</li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/2.drop-tag/#syntax","title":"Syntax","text":"<pre><code>DROP TAG [IF EXISTS] &lt;tag_name&gt;;\n</code></pre> <ul> <li><code>IF NOT EXISTS</code>: Detects if the tag that you want to drop exists. Only when it exists will it be dropped.</li> </ul> <ul> <li><code>tag_name</code>: Specifies the tag name that you want to drop. You can drop only one tag in one statement.</li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/2.drop-tag/#example","title":"Example","text":"<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS test(p1 string, p2 int);\nnebula&gt; DROP TAG test;\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/3.alter-tag/","title":"ALTER TAG","text":"<p><code>ALTER TAG</code> alters the structure of a tag with the given name in a graph space. You can add or drop properties, and change the data type of an existing property. You can also set a TTL (Time-To-Live) on a property, or change its TTL duration.</p>"},{"location":"3.ngql-guide/10.tag-statements/3.alter-tag/#notes","title":"Notes","text":"<ul> <li>Running the <code>ALTER TAG</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</li> </ul> <ul> <li>Before you alter properties for a tag, make sure that the properties are not indexed. If the properties contain any indexes, the conflict error <code>[ERROR (-1005)]: Conflict!</code> will occur when you <code>ALTER TAG</code>. For more information on dropping an index, see DROP INDEX.</li> </ul> <ul> <li>The property name must be unique in a tag. If you add a property with the same name as an existing property or a dropped property, the operation fails.</li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/3.alter-tag/#syntax","title":"Syntax","text":"<pre><code>ALTER TAG &lt;tag_name&gt;\n    &lt;alter_definition&gt; [[, alter_definition] ...]\n    [ttl_definition [, ttl_definition] ... ]\n    [COMMENT '&lt;comment&gt;'];\n\nalter_definition:\n| ADD    (prop_name data_type [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;'])\n| DROP   (prop_name)\n| CHANGE (prop_name data_type [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;'])\n\nttl_definition:\n    TTL_DURATION = ttl_duration, TTL_COL = prop_name\n</code></pre> <ul> <li><code>tag_name</code>: Specifies the tag name that you want to alter. You can alter only one tag in one statement. Before you alter a tag, make sure that the tag exists in the current working graph space. If the tag does not exist, an error will occur when you alter it.</li> </ul> <ul> <li>Multiple <code>ADD</code>, <code>DROP</code>, and <code>CHANGE</code> clauses are permitted in a single <code>ALTER TAG</code> statement, separated by commas.</li> </ul> <ul> <li>When a property value is set to <code>NOT NULL</code> using <code>ADD</code> or <code>CHANGE</code>, a default value must be specified for the property, that is, the value of <code>DEFAULT</code> must be specified.</li> </ul> <ul> <li> <p>When using <code>CHANGE</code> to modify the data type of a property:</p> <ul> <li>Only the length of a <code>FIXED_STRING</code> or an <code>INT</code> can be increased. The length of a <code>STRING</code> or an <code>INT</code> cannot be decreased.</li> </ul> <ul> <li>Only the data type conversions from FIXED_STRING to STRING and from FLOAT to DOUBLE are allowed.</li> </ul> </li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/3.alter-tag/#examples","title":"Examples","text":"<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t1 (p1 string, p2 int);\nnebula&gt; ALTER TAG t1 ADD (p3 int32, fixed_string(10));\nnebula&gt; ALTER TAG t1 TTL_DURATION = 2, TTL_COL = \"p2\";\nnebula&gt; ALTER TAG t1 COMMENT = 'test1';\nnebula&gt; ALTER TAG t1 ADD (p5 double NOT NULL DEFAULT 0.4 COMMENT 'p5') COMMENT='test2';\n// Change the data type of p3 in the TAG t1 from INT32 to INT64, and that of p4 from FIXED_STRING(10) to STRING.\nnebula&gt; ALTER TAG t1 CHANGE (p3 int64, p4 string);\n[ERROR(-1005)]: Unsupported!\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/3.alter-tag/#implementation_of_the_operation","title":"Implementation of the operation","text":"<p>Trying to use a newly altered tag may fail because the alteration of the tag is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.</p> <p>To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services.</p>"},{"location":"3.ngql-guide/10.tag-statements/4.show-tags/","title":"SHOW TAGS","text":"<p>The <code>SHOW TAGS</code> statement shows the name of all tags in the current graph space.</p> <p>You do not need any privileges for the graph space to run the <code>SHOW TAGS</code> statement. But the returned results are different based on role privileges.</p>"},{"location":"3.ngql-guide/10.tag-statements/4.show-tags/#syntax","title":"Syntax","text":"<pre><code>SHOW TAGS;\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/4.show-tags/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW TAGS;\n+----------+\n| Name     |\n+----------+\n| \"player\" |\n| \"team\"   |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/5.describe-tag/","title":"DESCRIBE TAG","text":"<p><code>DESCRIBE TAG</code> returns the information about a tag with the given name in a graph space, such as field names, data type, and so on.</p>"},{"location":"3.ngql-guide/10.tag-statements/5.describe-tag/#prerequisite","title":"Prerequisite","text":"<p>Running the <code>DESCRIBE TAG</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/10.tag-statements/5.describe-tag/#syntax","title":"Syntax","text":"<pre><code>DESC[RIBE] TAG &lt;tag_name&gt;;\n</code></pre> <p>You can use <code>DESC</code> instead of <code>DESCRIBE</code> for short.</p>"},{"location":"3.ngql-guide/10.tag-statements/5.describe-tag/#example","title":"Example","text":"<pre><code>nebula&gt; DESCRIBE TAG player;\n+--------+----------+-------+---------+---------+\n| Field  | Type     | Null  | Default | Comment |\n+--------+----------+-------+---------+---------+\n| \"name\" | \"string\" | \"YES\" |         |         |\n| \"age\"  | \"int64\"  | \"YES\" |         |         |\n+--------+----------+-------+---------+---------+\n</code></pre>"},{"location":"3.ngql-guide/10.tag-statements/6.delete-tag/","title":"DELETE TAG","text":"<p><code>DELETE TAG</code> deletes a tag with the given name on a specified vertex.</p>"},{"location":"3.ngql-guide/10.tag-statements/6.delete-tag/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>DELETE TAG</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/10.tag-statements/6.delete-tag/#syntax","title":"Syntax","text":"<pre><code>DELETE TAG &lt;tag_name_list&gt; FROM &lt;VID_list&gt;;\n</code></pre> <ul> <li><code>tag_name_list</code>: The names of the tags you want to delete. Multiple tags are separated with commas (,). <code>*</code> means all tags.</li> </ul> <ul> <li><code>VID</code>: The VIDs of the vertices from which you want to delete the tags. Multiple VIDs are separated with commas (,). </li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/6.delete-tag/#example","title":"Example","text":"<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS test1(p1 string, p2 int);\nnebula&gt; CREATE TAG IF NOT EXISTS test2(p3 string, p4 int);\nnebula&gt; INSERT VERTEX test1(p1, p2),test2(p3, p4) VALUES \"test\":(\"123\", 1, \"456\", 2);\nnebula&gt; FETCH PROP ON * \"test\" YIELD vertex AS v;\n+------------------------------------------------------------+\n| v                                                          |\n+------------------------------------------------------------+\n| (\"test\" :test1{p1: \"123\", p2: 1} :test2{p3: \"456\", p4: 2}) |\n+------------------------------------------------------------+\nnebula&gt; DELETE TAG test1 FROM \"test\";\nnebula&gt; FETCH PROP ON * \"test\" YIELD vertex AS v;\n+-----------------------------------+\n| v                                 |\n+-----------------------------------+\n| (\"test\" :test2{p3: \"456\", p4: 2}) |\n+-----------------------------------+\nnebula&gt; DELETE TAG * FROM \"test\";\nnebula&gt; FETCH PROP ON * \"test\" YIELD vertex AS v;\n+---+\n| v |\n+---+\n+---+\n</code></pre> <p>Compatibility</p> <ul> <li>In openCypher, you can use the statement <code>REMOVE v:LABEL</code> to delete the tag <code>LABEL</code> of the vertex <code>v</code>.</li> <li><code>DELETE TAG</code> and <code>DROP TAG</code> have the same semantics but different syntax. In nGQL, use <code>DELETE TAG</code>.</li> </ul>"},{"location":"3.ngql-guide/10.tag-statements/improve-query-by-tag-index/","title":"Add and delete tags","text":"<p>OpenCypher has the features of <code>SET label</code> and <code>REMOVE label</code> to speed up the process of querying or labeling.</p> <p>NebulaGraph achieves the same operations by creating and inserting tags to an existing vertex, which can quickly query vertices based on the tag name. Users can also run <code>DELETE TAG</code> to delete some vertices that are no longer needed.</p>"},{"location":"3.ngql-guide/10.tag-statements/improve-query-by-tag-index/#examples","title":"Examples","text":"<p>For example, in the <code>basketballplayer</code> data set, some basketball players are also team shareholders. Users can create an index for the shareholder tag <code>shareholder</code> for quick search. If the player is no longer a shareholder, users can delete the shareholder tag of the corresponding player by <code>DELETE TAG</code>.</p> <pre><code>//This example creates the shareholder tag and index.\nnebula&gt; CREATE TAG IF NOT EXISTS shareholder();\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS shareholder_tag on shareholder();\n\n//This example adds a tag on the vertex.\nnebula&gt; INSERT VERTEX shareholder() VALUES \"player100\":();\nnebula&gt; INSERT VERTEX shareholder() VALUES \"player101\":();\n\n//This example queries all the shareholders.\nnebula&gt; MATCH (v:shareholder) RETURN v;\n+--------------------------------------------------------------------+\n| v                                                                  |\n+--------------------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"} :shareholder{})  |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"} :shareholder{}) |\n+--------------------------------------------------------------------+\n\nnebula&gt; LOOKUP ON shareholder YIELD id(vertex);\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n+-------------+\n\n//In this example, the \"player100\" is no longer a shareholder.\nnebula&gt; DELETE TAG shareholder FROM \"player100\";\nnebula&gt; LOOKUP ON shareholder YIELD id(vertex);\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player101\" |\n+-------------+\n</code></pre> <p>Note</p> <p>If the index is created after inserting the test data, use the <code>REBUILD TAG INDEX &lt;index_name_list&gt;;</code> statement to rebuild the index.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/1.create-edge/","title":"CREATE EDGE","text":"<p><code>CREATE EDGE</code> creates an edge type with the given name in a graph space.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/1.create-edge/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>Edge types in nGQL are similar to relationship types in openCypher. But they are also quite different. For example, the ways to create them are different.</p> <ul> <li>In openCypher, relationship types are created together with vertices in <code>CREATE</code> statements.</li> <li>In nGQL, edge types are created separately using <code>CREATE EDGE</code> statements. Edge types in nGQL are more like tables in MySQL.</li> </ul>"},{"location":"3.ngql-guide/11.edge-type-statements/1.create-edge/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>CREATE EDGE</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/1.create-edge/#syntax","title":"Syntax","text":"<p>To create an edge type in a specific graph space, you must specify the current working space with the <code>USE</code> statement.</p> <pre><code>CREATE EDGE [IF NOT EXISTS] &lt;edge_type_name&gt;\n    (\n      &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']\n      [{, &lt;prop_name&gt; &lt;data_type&gt; [NULL | NOT NULL] [DEFAULT &lt;default_value&gt;] [COMMENT '&lt;comment&gt;']} ...] \n    )\n    [TTL_DURATION = &lt;ttl_duration&gt;]\n    [TTL_COL = &lt;prop_name&gt;]\n    [COMMENT = '&lt;comment&gt;'];\n</code></pre> Parameter Description <code>IF NOT EXISTS</code> Detects if the edge type that you want to create exists. If it does not exist, a new one will be created. The edge type existence detection here only compares the edge type names (excluding properties). <code>&lt;edge_type_name&gt;</code> 1. The edge type name must be unique in a graph space. 2. Once the edge type name is set, it can not be altered. 3. By default, the name only supports 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc. However, it cannot include special characters other than the underscore (_), and cannot start with a number. 4. To use special characters, reserved keywords, or start with a number, quote the entire name with backticks (`) and do not include periods (<code>.</code>) within the pair of backticks (`). For more information, see Keywords and reserved words. Note:1. If you name an edge type in Chinese and encounter a <code>SyntaxError</code>, you need to quote the Chinese characters with backticks (`). 2. To include a backtick (`) in an edge type name, use a backslash to escape the backtick, such as \\`; to include a backslash, the backslash itself also needs to be escaped, such as \\ . <code>&lt;prop_name&gt;</code> The name of the property. It must be unique for each edge type. The rules for permitted property names are the same as those for edge type names. <code>&lt;data_type&gt;</code> The data type of the property. The following data types are supported: Numeric, Boolean, String, Date and time, and Geography. <code>NULL | NOT NULL</code> Specifies if the property supports <code>NULL | NOT NULL</code>. The default value is <code>NULL</code>. <code>DEFAULT</code> must be specified if <code>NOT NULL</code> is set. <code>DEFAULT</code> Specifies a default value for a property. The default value can be a literal value or an expression supported by NebulaGraph. If no value is specified, the default value is used when inserting a new edge. <code>COMMENT</code> The remarks of a certain property or the edge type itself. The maximum length is 256 bytes. By default, there will be no comments on an edge type. <code>TTL_DURATION</code> Specifies the life cycle for the property. The property that exceeds the specified TTL expires. The expiration threshold is the <code>TTL_COL</code> value plus the <code>TTL_DURATION</code>. The default value of <code>TTL_DURATION</code> is <code>0</code>. It means the data never expires. <code>TTL_COL</code> Specifies the property to set a timeout on. The data type of the property must be <code>int</code> or <code>timestamp</code>. An edge type can only specify one field as <code>TTL_COL</code>. For more information on TTL, see TTL options."},{"location":"3.ngql-guide/11.edge-type-statements/1.create-edge/#examples","title":"Examples","text":"<pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS follow(degree int);\n\n# The following example creates an edge type with no properties.\nnebula&gt; CREATE EDGE IF NOT EXISTS no_property();\n\n# The following example creates an edge type with a default value.\nnebula&gt; CREATE EDGE IF NOT EXISTS follow_with_default(degree int DEFAULT 20);\n\n# In the following example, the TTL of the p2 field is set to be 100 seconds.\nnebula&gt; CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int, p3 timestamp) \\\n        TTL_DURATION = 100, TTL_COL = \"p2\";\n</code></pre>"},{"location":"3.ngql-guide/11.edge-type-statements/2.drop-edge/","title":"DROP EDGE","text":"<p><code>DROP EDGE</code> drops an edge type with the given name in a graph space.</p> <p>An edge can have only one edge type. After you drop it, the edge CANNOT be accessed. The edge will be deleted in the next compaction.</p> <p>This operation only deletes the Schema data. All the files or directories in the disk will not be deleted directly until the next compaction.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/2.drop-edge/#prerequisites","title":"Prerequisites","text":"<ul> <li>Running the <code>DROP EDGE</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</li> </ul> <ul> <li>Before you drop an edge type, make sure that the edge type does not have any indexes. Otherwise, the conflict error (<code>[ERROR (-1005)]: Conflict!</code>) will be returned. To drop an index, see DROP INDEX.</li> </ul>"},{"location":"3.ngql-guide/11.edge-type-statements/2.drop-edge/#syntax","title":"Syntax","text":"<pre><code>DROP EDGE [IF EXISTS] &lt;edge_type_name&gt;\n</code></pre> <ul> <li><code>IF NOT EXISTS</code>: Detects if the edge type that you want to drop exists. Only when it exists will it be dropped.</li> </ul> <ul> <li><code>edge_type_name</code>: Specifies the edge type name that you want to drop. You can drop only one edge type in one statement.</li> </ul>"},{"location":"3.ngql-guide/11.edge-type-statements/2.drop-edge/#example","title":"Example","text":"<pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int);\nnebula&gt; DROP EDGE e1;\n</code></pre>"},{"location":"3.ngql-guide/11.edge-type-statements/3.alter-edge/","title":"ALTER EDGE","text":"<p><code>ALTER EDGE</code> alters the structure of an edge type with the given name in a graph space. You can add or drop properties, and change the data type of an existing property. You can also set a TTL (Time-To-Live) on a property, or change its TTL duration.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/3.alter-edge/#notes","title":"Notes","text":"<ul> <li>Running the <code>ALTER EDGE</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</li> </ul> <ul> <li>Before you alter properties for an edge type, make sure that the properties are not indexed. If the properties contain any indexes, the conflict error <code>[ERROR (-1005)]: Conflict!</code> will occur when you <code>ALTER EDGE</code>. For more information on dropping an index, see DROP INDEX.</li> </ul> <ul> <li>The property name must be unique in an edge type. If you add a property with the same name as an existing property or a dropped property, the operation fails.</li> </ul> <ul> <li>Only the length of a <code>FIXED_STRING</code> or an <code>INT</code> can be increased.</li> </ul> <ul> <li>Only the data type conversions from FIXED_STRING to STRING and from FLOAT to DOUBLE are allowed.</li> </ul>"},{"location":"3.ngql-guide/11.edge-type-statements/3.alter-edge/#syntax","title":"Syntax","text":"<pre><code>ALTER EDGE &lt;edge_type_name&gt;\n    &lt;alter_definition&gt; [, alter_definition] ...]\n    [ttl_definition [, ttl_definition] ... ]\n    [COMMENT = '&lt;comment&gt;'];\n\nalter_definition:\n| ADD    (prop_name data_type)\n| DROP   (prop_name)\n| CHANGE (prop_name data_type)\n\nttl_definition:\n    TTL_DURATION = ttl_duration, TTL_COL = prop_name\n</code></pre> <ul> <li><code>edge_type_name</code>: Specifies the edge type name that you want to alter. You can alter only one edge type in one statement. Before you alter an edge type, make sure that the edge type exists in the graph space. If the edge type does not exist, an error occurs when you alter it.</li> </ul> <ul> <li>Multiple <code>ADD</code>, <code>DROP</code>, and <code>CHANGE</code> clauses are permitted in a single <code>ALTER EDGE</code> statement, separated by commas.</li> </ul> <ul> <li>When a property value is set to <code>NOT NULL</code> using <code>ADD</code> or <code>CHANGE</code>, a default value must be specified for the property, that is, the value of <code>DEFAULT</code> must be specified.</li> </ul>"},{"location":"3.ngql-guide/11.edge-type-statements/3.alter-edge/#example","title":"Example","text":"<pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS e1(p1 string, p2 int);\nnebula&gt; ALTER EDGE e1 ADD (p3 int, p4 string);\nnebula&gt; ALTER EDGE e1 TTL_DURATION = 2, TTL_COL = \"p2\";\nnebula&gt; ALTER EDGE e1 COMMENT = 'edge1';\n</code></pre>"},{"location":"3.ngql-guide/11.edge-type-statements/3.alter-edge/#implementation_of_the_operation","title":"Implementation of the operation","text":"<p>Trying to use a newly altered edge type may fail because the alteration of the edge type is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds.</p> <p>To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/4.show-edges/","title":"SHOW EDGES","text":"<p><code>SHOW EDGES</code> shows all edge types in the current graph space.</p> <p>You do not need any privileges for the graph space to run the <code>SHOW EDGES</code> statement. But the returned results are different based on role privileges.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/4.show-edges/#syntax","title":"Syntax","text":"<pre><code>SHOW EDGES;\n</code></pre>"},{"location":"3.ngql-guide/11.edge-type-statements/4.show-edges/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW EDGES;\n+----------+\n| Name     |\n+----------+\n| \"follow\" |\n| \"serve\"  |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/11.edge-type-statements/5.describe-edge/","title":"DESCRIBE EDGE","text":"<p><code>DESCRIBE EDGE</code> returns the information about an edge type with the given name in a graph space, such as field names, data type, and so on.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/5.describe-edge/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>DESCRIBE EDGE</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/5.describe-edge/#syntax","title":"Syntax","text":"<pre><code>DESC[RIBE] EDGE &lt;edge_type_name&gt;\n</code></pre> <p>You can use <code>DESC</code> instead of <code>DESCRIBE</code> for short.</p>"},{"location":"3.ngql-guide/11.edge-type-statements/5.describe-edge/#example","title":"Example","text":"<pre><code>nebula&gt; DESCRIBE EDGE follow;\n+----------+---------+-------+---------+---------+\n| Field    | Type    | Null  | Default | Comment |\n+----------+---------+-------+---------+---------+\n| \"degree\" | \"int64\" | \"YES\" |         |         |\n+----------+---------+-------+---------+---------+\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/","title":"INSERT VERTEX","text":"<p>The <code>INSERT VERTEX</code> statement inserts one or more vertices into a graph space in NebulaGraph.</p>"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>INSERT VERTEX</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/#syntax","title":"Syntax","text":"<pre><code>INSERT VERTEX [IF NOT EXISTS] [tag_props, [tag_props] ...]\nVALUES VID: ([prop_value_list])\n\ntag_props:\n  tag_name ([prop_name_list])\n\nprop_name_list:\n   [prop_name [, prop_name] ...]\n\nprop_value_list:\n   [prop_value [, prop_value] ...] \n</code></pre> <ul> <li> <p><code>IF NOT EXISTS</code> detects if the VID that you want to insert exists. If it does not exist, a new one will be inserted.</p> <p>Note</p> <ul> <li><code>IF NOT EXISTS</code> only compares the names of the VID and the tag (excluding properties).</li> <li><code>IF NOT EXISTS</code> will read to check whether the data exists, which will have a significant impact on performance.</li> </ul> </li> </ul> <ul> <li> <p><code>tag_name</code> denotes the tag (vertex type), which must be created before <code>INSERT VERTEX</code>. For more information, see CREATE TAG.</p> <p>Caution</p> <p>NebulaGraph 3.8.0 supports inserting vertices without tags.</p> <p>Compatibility</p> <p>In NebulaGraph 3.8.0, inserting vertex without tag is not supported by default. If you want to use the vertex without tags, add <code>--graph_use_vertex_key=true</code> to the configuration files (<code>nebula-graphd.conf</code>) of all Graph services in the cluster, add <code>--use_vertex_key=true</code> to the configuration files (<code>nebula-storaged.conf</code>) of all Storage services in the cluster. An example of a command to insert a vertex without tag is <code>INSERT VERTEX VALUES \"1\":();</code>.</p> </li> </ul> <ul> <li><code>prop_name_list</code> contains the names of the properties on the tag.</li> </ul> <ul> <li><code>VID</code> is the vertex ID. In NebulaGraph 2.0, string and integer VID types are supported. The VID type is set when a graph space is created. For more information, see CREATE SPACE.</li> </ul> <ul> <li><code>prop_value_list</code> must provide the property values according to the <code>prop_name_list</code>. When the <code>NOT NULL</code> constraint is set for a given property, an error is returned if no property is given. When the default value for a property is <code>NULL</code>, you can omit to specify the property value. For details, see CREATE TAG.</li> </ul> <p>Caution</p> <p><code>INSERT VERTEX</code> and <code>CREATE</code> have different semantics.</p> <ul> <li>The semantics of <code>INSERT VERTEX</code> is closer to that of INSERT in NoSQL (key-value), or <code>UPSERT</code> (<code>UPDATE</code> or <code>INSERT</code>) in SQL.</li> <li>When two INSERT statements (neither uses <code>IF NOT EXISTS</code>) with the same <code>VID</code> and <code>TAG</code> are operated at the same time, the latter INSERT will overwrite the former.</li> <li>When two INSERT statements with the same <code>VID</code> but different <code>TAGS</code> are operated at the same time, the operation of different tags will not overwrite each other.</li> </ul> <p>Examples are as follows.</p>"},{"location":"3.ngql-guide/12.vertex-statements/1.insert-vertex/#examples","title":"Examples","text":"<pre><code># Insert a vertex without tag.\nnebula&gt; INSERT VERTEX VALUES \"1\":();\n\n# The following examples create tag t1 with no property and inserts vertex \"10\" with no property.\nnebula&gt; CREATE TAG IF NOT EXISTS t1();                   \nnebula&gt; INSERT VERTEX t1() VALUES \"10\":(); \n</code></pre> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t2 (name string, age int);                \nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n1\", 12);\n\n#  In the following example, the insertion fails because \"a13\" is not int.\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"12\":(\"n1\", \"a13\"); \n\n# The following example inserts two vertices at one time.\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"13\":(\"n3\", 12), \"14\":(\"n4\", 8); \n</code></pre> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t3(p1 int);\nnebula&gt; CREATE TAG IF NOT EXISTS t4(p2 string);\n\n# The following example inserts vertex \"21\" with two tags.\nnebula&gt; INSERT VERTEX t3 (p1), t4(p2) VALUES \"21\": (321, \"hello\");\n</code></pre> <p>A vertex can be inserted/written with new values multiple times. Only the last written values can be read.</p> <pre><code># The following examples insert vertex \"11\" with new values for multiple times.\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n2\", 13);\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n3\", 14);\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"11\":(\"n4\", 15);\nnebula&gt; FETCH PROP ON t2 \"11\" YIELD properties(vertex);\n+-----------------------+\n| properties(VERTEX)    |\n+-----------------------+\n| {age: 15, name: \"n4\"} |\n+-----------------------+\n</code></pre> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t5(p1 fixed_string(5) NOT NULL, p2 int, p3 int DEFAULT NULL);\nnebula&gt; INSERT VERTEX t5(p1, p2, p3) VALUES \"001\":(\"Abe\", 2, 3);\n\n# In the following example, the insertion fails because the value of p1 cannot be NULL.\nnebula&gt; INSERT VERTEX t5(p1, p2, p3) VALUES \"002\":(NULL, 4, 5);\n[ERROR (-1009)]: SemanticError: No schema found for `t5'\n\n# In the following example, the value of p3 is the default NULL.\nnebula&gt; INSERT VERTEX t5(p1, p2) VALUES \"003\":(\"cd\", 5);\nnebula&gt; FETCH PROP ON t5 \"003\" YIELD properties(vertex);\n+---------------------------------+\n| properties(VERTEX)              |\n+---------------------------------+\n| {p1: \"cd\", p2: 5, p3: __NULL__} |\n+---------------------------------+\n\n# In the following example, the allowed maximum length of p1 is 5.\nnebula&gt; INSERT VERTEX t5(p1, p2) VALUES \"004\":(\"shalalalala\", 4);\nnebula&gt; FETCH PROP on t5 \"004\" YIELD properties(vertex);\n+------------------------------------+\n| properties(VERTEX)                 |\n+------------------------------------+\n| {p1: \"shala\", p2: 4, p3: __NULL__} |\n+------------------------------------+\n</code></pre> <p>If you insert a vertex that already exists with <code>IF NOT EXISTS</code>, there will be no modification.</p> <pre><code># The following example inserts vertex \"1\".\nnebula&gt; INSERT VERTEX t2 (name, age) VALUES \"1\":(\"n2\", 13);\n# Modify vertex \"1\" with IF NOT EXISTS. But there will be no modification as vertex \"1\" already exists.\nnebula&gt; INSERT VERTEX IF NOT EXISTS t2 (name, age) VALUES \"1\":(\"n3\", 14);\nnebula&gt; FETCH PROP ON t2 \"1\" YIELD properties(vertex);\n+-----------------------+\n| properties(VERTEX)    |\n+-----------------------+\n| {age: 13, name: \"n2\"} |\n+-----------------------+\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/2.update-vertex/","title":"UPDATE VERTEX","text":"<p>The <code>UPDATE VERTEX</code> statement updates properties on tags of a vertex.</p> <p>In NebulaGraph, <code>UPDATE VERTEX</code> supports compare-and-set (CAS).</p> <p>Note</p> <p>An <code>UPDATE VERTEX</code> statement can only update properties on ONE TAG of a vertex.</p>"},{"location":"3.ngql-guide/12.vertex-statements/2.update-vertex/#syntax","title":"Syntax","text":"<pre><code>UPDATE VERTEX ON &lt;tag_name&gt; &lt;vid&gt;\nSET &lt;update_prop&gt;\n[WHEN &lt;condition&gt;]\n[YIELD &lt;output&gt;]\n</code></pre> Parameter Required Description Example <code>ON &lt;tag_name&gt;</code> Yes Specifies the tag of the vertex. The properties to be updated must be on this tag. <code>ON player</code> <code>&lt;vid&gt;</code> Yes Specifies the ID of the vertex to be updated. <code>\"player100\"</code> <code>SET &lt;update_prop&gt;</code> Yes Specifies the properties to be updated and how they will be updated. <code>SET age = age +1</code> <code>WHEN &lt;condition&gt;</code> No Specifies the filter conditions. If <code>&lt;condition&gt;</code> evaluates to <code>false</code>, the <code>SET</code> clause will not take effect. <code>WHEN name == \"Tim\"</code> <code>YIELD &lt;output&gt;</code> No Specifies the output format of the statement. <code>YIELD name AS Name</code>"},{"location":"3.ngql-guide/12.vertex-statements/2.update-vertex/#example","title":"Example","text":"<pre><code>// This query checks the properties of vertex \"player101\".\nnebula&gt; FETCH PROP ON player \"player101\" YIELD properties(vertex);\n+--------------------------------+\n| properties(VERTEX)             |\n+--------------------------------+\n| {age: 36, name: \"Tony Parker\"} |\n+--------------------------------+\n\n// This query updates the age property and returns name and the new age.\nnebula&gt; UPDATE VERTEX ON player \"player101\" \\\n        SET age = age + 2 \\\n        WHEN name == \"Tony Parker\" \\\n        YIELD name AS Name, age AS Age;\n+---------------+-----+\n| Name          | Age |\n+---------------+-----+\n| \"Tony Parker\" | 38  |\n+---------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/","title":"UPSERT VERTEX","text":"<p>The <code>UPSERT</code> statement is a combination of <code>UPDATE</code> and <code>INSERT</code>. You can use <code>UPSERT VERTEX</code> to update the properties of a vertex if it exists or insert a new vertex if it does not exist.</p> <p>Note</p> <p>An <code>UPSERT VERTEX</code> statement can only update the properties on ONE TAG of a vertex.</p> <p>The performance of <code>UPSERT</code> is much lower than that of <code>INSERT</code> because <code>UPSERT</code> is a read-modify-write serialization operation at the partition level.</p> <p>Danger</p> <p>Don't use <code>UPSERT</code> for scenarios with highly concurrent writes. You can use <code>UPDATE</code> or <code>INSERT</code> instead.</p>"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/#syntax","title":"Syntax","text":"<pre><code>UPSERT VERTEX ON &lt;tag&gt; &lt;vid&gt;\nSET &lt;update_prop&gt;\n[WHEN &lt;condition&gt;]\n[YIELD &lt;output&gt;]\n</code></pre> Parameter Required Description Example <code>ON &lt;tag&gt;</code> Yes Specifies the tag of the vertex. The properties to be updated must be on this tag. <code>ON player</code> <code>&lt;vid&gt;</code> Yes Specifies the ID of the vertex to be updated or inserted. <code>\"player100\"</code> <code>SET &lt;update_prop&gt;</code> Yes Specifies the properties to be updated and how they will be updated. <code>SET age = age +1</code> <code>WHEN &lt;condition&gt;</code> No Specifies the filter conditions. <code>WHEN name == \"Tim\"</code> <code>YIELD &lt;output&gt;</code> No Specifies the output format of the statement. <code>YIELD name AS Name</code>"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/#insert_a_vertex_if_it_does_not_exist","title":"Insert a vertex if it does not exist","text":"<p>If a vertex does not exist, it is created no matter the conditions in the <code>WHEN</code> clause are met or not, and the <code>SET</code> clause always takes effect. The property values of the new vertex depend on:</p> <ul> <li>How the <code>SET</code> clause is defined.</li> </ul> <ul> <li>Whether the property has a default value.</li> </ul> <p>For example, if:</p> <ul> <li>The vertex to be inserted will have properties <code>name</code> and <code>age</code> based on the tag <code>player</code>.</li> </ul> <ul> <li>The <code>SET</code> clause specifies that <code>age = 30</code>.</li> </ul> <p>Then the property values in different cases are listed as follows:</p> Are <code>WHEN</code> conditions met If properties have default values Value of <code>name</code> Value of <code>age</code> Yes Yes The default value <code>30</code> Yes No <code>NULL</code> <code>30</code> No Yes The default value <code>30</code> No No <code>NULL</code> <code>30</code> <p>Here are some examples:</p> <pre><code>// This query checks if the following three vertices exist. The result \"Empty set\" indicates that the vertices do not exist.\nnebula&gt; FETCH PROP ON * \"player666\", \"player667\", \"player668\" YIELD properties(vertex);\n+--------------------+\n| properties(VERTEX) |\n+--------------------+\n+--------------------+\nEmpty set\n\nnebula&gt; UPSERT VERTEX ON player \"player666\" \\\n        SET age = 30 \\\n        WHEN name == \"Joe\" \\\n        YIELD name AS Name, age AS Age;\n+----------+----------+\n| Name     | Age      |\n+----------+----------+\n| __NULL__ | 30       |\n+----------+----------+\n\nnebula&gt; UPSERT VERTEX ON player \"player666\" \\\n        SET age = 31 \\\n        WHEN name == \"Joe\" \\\n        YIELD name AS Name, age AS Age;\n+----------+-----+\n| Name     | Age |\n+----------+-----+\n| __NULL__ | 30  |\n+----------+-----+\n\nnebula&gt; UPSERT VERTEX ON player \"player667\" \\\n        SET age = 31 \\\n        YIELD name AS Name, age AS Age;\n+----------+-----+\n| Name     | Age |\n+----------+-----+\n| __NULL__ | 31  |\n+----------+-----+\n\nnebula&gt; UPSERT VERTEX ON player \"player668\" \\\n        SET name = \"Amber\", age = age + 1 \\\n        YIELD name AS Name, age AS Age;\n+---------+----------+\n| Name    | Age      |\n+---------+----------+\n| \"Amber\" | __NULL__ |\n+---------+----------+\n</code></pre> <p>In the last query of the preceding examples, since <code>age</code> has no default value, when the vertex is created, <code>age</code> is <code>NULL</code>, and <code>age = age + 1</code> does not take effect. But if <code>age</code> has a default value, <code>age = age + 1</code> will take effect. For example:</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player_with_default(name string, age int DEFAULT 20);\nExecution succeeded\n\nnebula&gt; UPSERT VERTEX ON player_with_default \"player101\" \\\n        SET age = age + 1 \\\n        YIELD name AS Name, age AS Age;\n\n+----------+-----+\n| Name     | Age |\n+----------+-----+\n| __NULL__ | 21  |\n+----------+-----+\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/3.upsert-vertex/#update_a_vertex_if_it_exists","title":"Update a vertex if it exists","text":"<p>If the vertex exists and the <code>WHEN</code> conditions are met, the vertex is updated.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player101\" YIELD properties(vertex);\n+--------------------------------+\n| properties(VERTEX)             |\n+--------------------------------+\n| {age: 36, name: \"Tony Parker\"} |\n+--------------------------------+\n\nnebula&gt; UPSERT VERTEX ON player \"player101\" \\\n        SET age = age + 2 \\\n        WHEN name == \"Tony Parker\" \\\n        YIELD name AS Name, age AS Age;\n+---------------+-----+\n| Name          | Age |\n+---------------+-----+\n| \"Tony Parker\" | 38  |\n+---------------+-----+\n</code></pre> <p>If the vertex exists and the <code>WHEN</code> conditions are not met, the update does not take effect.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player101\" YIELD properties(vertex);\n+--------------------------------+\n| properties(VERTEX)             |\n+--------------------------------+\n| {age: 38, name: \"Tony Parker\"} |\n+--------------------------------+\n\nnebula&gt; UPSERT VERTEX ON player \"player101\" \\\n        SET age = age + 2 \\\n        WHEN name == \"Someone else\" \\\n        YIELD name AS Name, age AS Age;\n+---------------+-----+\n| Name          | Age |\n+---------------+-----+\n| \"Tony Parker\" | 38  |\n+---------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/","title":"DELETE VERTEX","text":"<p>By default, the <code>DELETE VERTEX</code> statement deletes vertices but the incoming and outgoing edges of the vertices.</p> <p>Compatibility</p> <ul> <li>NebulaGraph 2.x deletes vertices and their incoming and outgoing edges.</li> </ul> <ul> <li>NebulaGraph 3.8.0 only deletes the vertices, and does not delete the related outgoing and incoming edges of the vertices. At this time, there will be dangling edges by default.</li> </ul> <p>The <code>DELETE VERTEX</code> statement deletes one vertex or multiple vertices at a time. You can use <code>DELETE VERTEX</code> together with pipes. For more information about pipe, see Pipe operator.</p> <p>Note</p> <ul> <li><code>DELETE VERTEX</code> deletes vertices directly.</li> </ul> <ul> <li><code>DELETE TAG</code> deletes a tag with the given name on a specified vertex.</li> </ul>"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/#syntax","title":"Syntax","text":"<pre><code>DELETE VERTEX &lt;vid&gt; [, &lt;vid&gt; ...] [WITH EDGE];\n</code></pre> <ul> <li>WITH EDGE: deletes vertices and the related incoming and outgoing edges of the vertices.</li> </ul>"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/#examples","title":"Examples","text":"<p>This query deletes the vertex whose ID is \"team1\".</p> <pre><code># Delete the vertex whose VID is `team1` but the related incoming and outgoing edges are not deleted.\nnebula&gt; DELETE VERTEX \"team1\";\n\n# Delete the vertex whose VID is `team1` and the related incoming and outgoing edges.\nnebula&gt; DELETE VERTEX \"team1\" WITH EDGE;\n</code></pre> <p>This query shows that you can use <code>DELETE VERTEX</code> together with pipe to delete vertices.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER serve WHERE properties(edge).start_year == \"2021\" YIELD dst(edge) AS id | DELETE VERTEX $-.id;\n</code></pre>"},{"location":"3.ngql-guide/12.vertex-statements/4.delete-vertex/#process_of_deleting_vertices","title":"Process of deleting vertices","text":"<p>Once NebulaGraph deletes the vertices, all edges (incoming and outgoing edges) of the target vertex will become dangling edges. When NebulaGraph deletes the vertices <code>WITH EDGE</code>, NebulaGraph traverses the incoming and outgoing edges related to the vertices and deletes them all. Then NebulaGraph deletes the vertices.</p> <p>Caution</p> <ul> <li>Atomic deletion is not supported during the entire process for now. Please retry when a failure occurs to avoid partial deletion, which will cause pendent edges.</li> <li>Deleting a supernode takes a lot of time. To avoid connection timeout before the deletion is complete, you can modify the parameter <code>--storage_client_timeout_ms</code> in <code>nebula-graphd.conf</code> to extend the timeout period.</li> </ul>"},{"location":"3.ngql-guide/13.edge-statements/1.insert-edge/","title":"INSERT EDGE","text":"<p>The <code>INSERT EDGE</code> statement inserts an edge or multiple edges into a graph space from a source vertex (given by src_vid) to a destination vertex (given by dst_vid) with a specific rank in NebulaGraph.</p> <p>When inserting an edge that already exists, <code>INSERT EDGE</code> overrides the edge.</p>"},{"location":"3.ngql-guide/13.edge-statements/1.insert-edge/#syntax","title":"Syntax","text":"<pre><code>INSERT EDGE [IF NOT EXISTS] &lt;edge_type&gt; ( &lt;prop_name_list&gt; ) VALUES \n&lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; )\n[, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] : ( &lt;prop_value_list&gt; ), ...];\n\n&lt;prop_name_list&gt; ::=\n  [ &lt;prop_name&gt; [, &lt;prop_name&gt; ] ...]\n\n&lt;prop_value_list&gt; ::=\n  [ &lt;prop_value&gt; [, &lt;prop_value&gt; ] ...]\n</code></pre> <ul> <li> <p><code>IF NOT EXISTS</code> detects if the edge that you want to insert exists. If it does not exist, a new one will be inserted.</p> <p>Note</p> <ul> <li><code>IF NOT EXISTS</code> only detects whether  exist and does not detect whether the property values overlap. <li><code>IF NOT EXISTS</code> will read to check whether the data exists, which will have a significant impact on performance.</li> <ul> <li><code>&lt;edge_type&gt;</code> denotes the edge type, which must be created before <code>INSERT EDGE</code>. Only one edge type can be specified in this statement.</li> </ul> <ul> <li><code>&lt;prop_name_list&gt;</code> is the property name list in the given <code>&lt;edge_type&gt;</code>.</li> </ul> <ul> <li><code>src_vid</code> is the VID of the source vertex. It specifies the start of an edge.</li> </ul> <ul> <li><code>dst_vid</code> is the VID of the destination vertex. It specifies the end of an edge.</li> </ul> <ul> <li> <p><code>rank</code> is optional. It specifies the edge rank of the same edge type. The data type is <code>int</code>. If not specified, the default value is <code>0</code>. You can insert many edges with the same edge type, source vertex, and destination vertex by using different rank values.</p> <p>OpenCypher compatibility</p> <p>OpenCypher has no such concept as rank.</p> </li> </ul> <ul> <li><code>&lt;prop_value_list&gt;</code> must provide the value list according to <code>&lt;prop_name_list&gt;</code>. If the property values do not match the data type in the edge type, an error is returned. When the <code>NOT NULL</code> constraint is set for a given property, an error is returned if no property is given. When the default value for a property is <code>NULL</code>, you can omit to specify the property value. For details, see CREATE EDGE.</li> </ul>"},{"location":"3.ngql-guide/13.edge-statements/1.insert-edge/#examples","title":"Examples","text":"<pre><code># The following example creates edge type e1 with no property and inserts an edge from vertex \"10\" to vertex \"11\" with no property.\nnebula&gt; CREATE EDGE IF NOT EXISTS e1();                 \nnebula&gt; INSERT EDGE e1 () VALUES \"10\"-&gt;\"11\":();  \n\n# The following example inserts an edge from vertex \"10\" to vertex \"11\" with no property. The edge rank is 1.\nnebula&gt; INSERT EDGE e1 () VALUES \"10\"-&gt;\"11\"@1:(); \n</code></pre> <pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS e2 (name string, age int); \nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 1);\n\n# The following example creates edge type e2 with two properties.\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \\\n        \"12\"-&gt;\"13\":(\"n1\", 1), \"13\"-&gt;\"14\":(\"n2\", 2); \n\n# In the following example, the insertion fails because \"a13\" is not int.\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", \"a13\");\n</code></pre> <p>An edge can be inserted/written with property values multiple times. Only the last written values can be read.</p> <pre><code>The following examples insert edge e2 with the new values for multiple times.\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 12);\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 13);\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 14);\nnebula&gt; FETCH PROP ON e2 \"11\"-&gt;\"13\" YIELD edge AS e;\n+-------------------------------------------+\n| e                                         |\n+-------------------------------------------+\n| [:e2 \"11\"-&gt;\"13\" @0 {age: 14, name: \"n1\"}] |\n+-------------------------------------------+\n</code></pre> <p>If you insert an edge that already exists with <code>IF NOT EXISTS</code>, there will be no modification.</p> <pre><code># The following example inserts edge e2 from vertex \"14\" to vertex \"15\".\nnebula&gt; INSERT EDGE e2 (name, age) VALUES \"14\"-&gt;\"15\"@1:(\"n1\", 12);\n# The following example alters the edge with IF NOT EXISTS. But there will be no alteration because edge e2 already exists.\nnebula&gt; INSERT EDGE IF NOT EXISTS e2 (name, age) VALUES \"14\"-&gt;\"15\"@1:(\"n2\", 13);\nnebula&gt; FETCH PROP ON e2 \"14\"-&gt;\"15\"@1 YIELD edge AS e;\n+-------------------------------------------+\n| e                                         |\n+-------------------------------------------+\n| [:e2 \"14\"-&gt;\"15\" @1 {age: 12, name: \"n1\"}] |\n+-------------------------------------------+\n</code></pre> <p>Note</p> <ul> <li>NebulaGraph 3.8.0 allows dangling edges. Therefore, you can write the edge before the source vertex or the destination vertex exists. At this time, you can get the (not written) vertex VID through <code>&lt;edgetype&gt;._src</code> or <code>&lt;edgetype&gt;._dst</code> (which is not recommended).</li> <li>Atomic operation is not guaranteed during the entire process for now. If it fails, please try again. Otherwise, partial writing will occur. At this time, the behavior of reading the data is undefined. For example, if multiple machines are involved in the write operation, only one of the forward and reverse edges of a single edge is written successfully, or only part of the edge is written successfully when multiple edges are inserted. In this case, an error will be returned, so please execute the command again.</li> <li>Concurrently writing the same edge will cause an <code>edge conflict</code> error, so please try again later.</li> <li>The inserting speed of an edge is about half that of a vertex. Because in the storaged process, the insertion of an edge involves two tasks, while the insertion of a vertex involves only one task.</li> </ul>"},{"location":"3.ngql-guide/13.edge-statements/2.update-edge/","title":"UPDATE EDGE","text":"<p>The <code>UPDATE EDGE</code> statement updates properties on an edge.</p> <p>In NebulaGraph, <code>UPDATE EDGE</code> supports compare-and-swap (CAS).</p>"},{"location":"3.ngql-guide/13.edge-statements/2.update-edge/#syntax","title":"Syntax","text":"<pre><code>UPDATE EDGE ON &lt;edge_type&gt;\n&lt;src_vid&gt; -&gt; &lt;dst_vid&gt; [@&lt;rank&gt;]\nSET &lt;update_prop&gt;\n[WHEN &lt;condition&gt;]\n[YIELD &lt;output&gt;]\n</code></pre> Parameter Required Description Example <code>ON &lt;edge_type&gt;</code> Yes Specifies the edge type. The properties to be updated must be on this edge type. <code>ON serve</code> <code>&lt;src_vid&gt;</code> Yes Specifies the source vertex ID of the edge. <code>\"player100\"</code> <code>&lt;dst_vid&gt;</code> Yes Specifies the destination vertex ID of the edge. <code>\"team204\"</code> <code>&lt;rank&gt;</code> No Specifies the rank of the edge.  The data type is <code>int</code>. <code>10</code> <code>SET &lt;update_prop&gt;</code> Yes Specifies the properties to be updated and how they will be updated. <code>SET start_year = start_year +1</code> <code>WHEN &lt;condition&gt;</code> No Specifies the filter conditions. If <code>&lt;condition&gt;</code> evaluates to <code>false</code>, the <code>SET</code> clause does not take effect. <code>WHEN end_year &lt; 2010</code> <code>YIELD &lt;output&gt;</code> No Specifies the output format of the statement. <code>YIELD start_year AS Start_Year</code>"},{"location":"3.ngql-guide/13.edge-statements/2.update-edge/#example","title":"Example","text":"<p>The following example checks the properties of the edge with the GO statement.</p> <pre><code>nebula&gt; GO FROM \"player100\" \\\n        OVER serve \\\n        YIELD properties(edge).start_year, properties(edge).end_year;\n+-----------------------------+---------------------------+\n| properties(EDGE).start_year | properties(EDGE).end_year |\n+-----------------------------+---------------------------+\n| 1997                        | 2016                      |\n+-----------------------------+---------------------------+\n</code></pre> <p>The following example updates the <code>start_year</code> property and returns the <code>end_year</code> and the new <code>start_year</code>.</p> <pre><code>nebula&gt; UPDATE EDGE on serve \"player100\" -&gt; \"team204\"@0 \\\n        SET start_year = start_year + 1 \\\n        WHEN end_year &gt; 2010 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| 1998       | 2016     |\n+------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/13.edge-statements/3.upsert-edge/","title":"UPSERT EDGE","text":"<p>The <code>UPSERT</code> statement is a combination of <code>UPDATE</code> and <code>INSERT</code>. You can use <code>UPSERT EDGE</code> to update the properties of an edge if it exists or insert a new edge if it does not exist.</p> <p>The performance of <code>UPSERT</code> is much lower than that of <code>INSERT</code> because <code>UPSERT</code> is a read-modify-write serialization operation at the partition level.</p> <p>Danger</p> <p>Do not use <code>UPSERT</code> for scenarios with highly concurrent writes. You can use <code>UPDATE</code> or <code>INSERT</code> instead.</p>"},{"location":"3.ngql-guide/13.edge-statements/3.upsert-edge/#syntax","title":"Syntax","text":"<pre><code>UPSERT EDGE ON &lt;edge_type&gt;\n&lt;src_vid&gt; -&gt; &lt;dst_vid&gt; [@rank]\nSET &lt;update_prop&gt;\n[WHEN &lt;condition&gt;]\n[YIELD &lt;properties&gt;]\n</code></pre> Parameter Required Description Example <code>ON &lt;edge_type&gt;</code> Yes Specifies the edge type. The properties to be updated must be on this edge type. <code>ON serve</code> <code>&lt;src_vid&gt;</code> Yes Specifies the source vertex ID of the edge. <code>\"player100\"</code> <code>&lt;dst_vid&gt;</code> Yes Specifies the destination vertex ID of the edge. <code>\"team204\"</code> <code>&lt;rank&gt;</code> No Specifies the rank of the edge. <code>10</code> <code>SET &lt;update_prop&gt;</code> Yes Specifies the properties to be updated and how they will be updated. <code>SET start_year = start_year +1</code> <code>WHEN &lt;condition&gt;</code> No Specifies the filter conditions. <code>WHEN end_year &lt; 2010</code> <code>YIELD &lt;output&gt;</code> No Specifies the output format of the statement. <code>YIELD start_year AS Start_Year</code>"},{"location":"3.ngql-guide/13.edge-statements/3.upsert-edge/#insert_an_edge_if_it_does_not_exist","title":"Insert an edge if it does not exist","text":"<p>If an edge does not exist, it is created no matter the conditions in the <code>WHEN</code> clause are met or not, and the <code>SET</code> clause takes effect. The property values of the new edge depend on:</p> <ul> <li>How the <code>SET</code> clause is defined.</li> </ul> <ul> <li>Whether the property has a default value.</li> </ul> <p>For example, if:</p> <ul> <li>The edge to be inserted will have properties <code>start_year</code> and <code>end_year</code> based on the edge type <code>serve</code>.</li> </ul> <ul> <li>The <code>SET</code> clause specifies that <code>end_year = 2021</code>.</li> </ul> <p>Then the property values in different cases are listed as follows:</p> Are <code>WHEN</code> conditions met If properties have default values Value of <code>start_year</code> Value of <code>end_year</code> Yes Yes The default value <code>2021</code> Yes No <code>NULL</code> <code>2021</code> No Yes The default value <code>2021</code> No No <code>NULL</code> <code>2021</code> <p>Here are some examples:</p> <pre><code>// This example checks if the following three vertices have any outgoing serve edge. The result \"Empty set\" indicates that such an edge does not exist.\nnebula&gt; GO FROM \"player666\", \"player667\", \"player668\" \\\n        OVER serve \\\n        YIELD properties(edge).start_year, properties(edge).end_year;\n+-----------------------------+---------------------------+\n| properties(EDGE).start_year | properties(EDGE).end_year |\n+-----------------------------+---------------------------+\n+-----------------------------+---------------------------+\nEmpty set\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player666\" -&gt; \"team200\"@0 \\\n        SET end_year = 2021 \\\n        WHEN end_year == 2010 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| __NULL__   | 2021     |\n+------------+----------+\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player666\" -&gt; \"team200\"@0 \\\n        SET end_year = 2022 \\\n        WHEN end_year == 2010 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| __NULL__   | 2021     |\n+------------+----------+\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player667\" -&gt; \"team200\"@0 \\\n        SET end_year = 2022 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| __NULL__   | 2022     |\n+------------+----------+\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player668\" -&gt; \"team200\"@0 \\\n        SET start_year = 2000, end_year = end_year + 1 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| 2000       | __NULL__ |\n+------------+----------+\n</code></pre> <p>In the last query of the preceding example, since <code>end_year</code> has no default value, when the edge is created, <code>end_year</code> is <code>NULL</code>, and <code>end_year = end_year + 1</code> does not take effect. But if <code>end_year</code> has a default value, <code>end_year = end_year + 1</code> will take effect. For example:</p> <pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS serve_with_default(start_year int, end_year int DEFAULT 2010);\nExecution succeeded\n\nnebula&gt; UPSERT EDGE on serve_with_default \\\n        \"player668\" -&gt; \"team200\" \\\n        SET end_year = end_year + 1 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| __NULL__   | 2011     |\n+------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/13.edge-statements/3.upsert-edge/#update_an_edge_if_it_exists","title":"Update an edge if it exists","text":"<p>If the edge exists and the <code>WHEN</code> conditions are met, the edge is updated.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Ben Simmons\"})-[e:serve]-(v2) \\\n        RETURN e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:serve \"player149\"-&gt;\"team219\" @0 {end_year: 2019, start_year: 2016}] |\n+-----------------------------------------------------------------------+\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player149\" -&gt; \"team219\" \\\n        SET end_year = end_year + 1 \\\n        WHEN start_year == 2016 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| 2016       | 2020     |\n+------------+----------+\n</code></pre> <p>If the edge exists and the <code>WHEN</code> conditions are not met, the update does not take effect.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Ben Simmons\"})-[e:serve]-(v2) \\\n        RETURN e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:serve \"player149\"-&gt;\"team219\" @0 {end_year: 2020, start_year: 2016}] |\n+-----------------------------------------------------------------------+\n\n\nnebula&gt; UPSERT EDGE on serve \\\n        \"player149\" -&gt; \"team219\" \\\n        SET end_year = end_year + 1 \\\n        WHEN start_year != 2016 \\\n        YIELD start_year, end_year;\n+------------+----------+\n| start_year | end_year |\n+------------+----------+\n| 2016       | 2020     |\n+------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/13.edge-statements/4.delete-edge/","title":"DELETE EDGE","text":"<p>The <code>DELETE EDGE</code> statement deletes one edge or multiple edges at a time. You can use <code>DELETE EDGE</code> together with pipe operators. For more information, see PIPE OPERATORS.</p> <p>To delete all the outgoing edges for a vertex, please delete the vertex. For more information, see DELETE VERTEX.</p>"},{"location":"3.ngql-guide/13.edge-statements/4.delete-edge/#syntax","title":"Syntax","text":"<pre><code>DELETE EDGE &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] ...]\n</code></pre> <p>Caution</p> <p>If no rank is specified, NebulaGraph only deletes the edge with rank 0. Delete edges with all ranks, as shown in the following example.</p>"},{"location":"3.ngql-guide/13.edge-statements/4.delete-edge/#examples","title":"Examples","text":"<pre><code>nebula&gt; DELETE EDGE serve \"player100\" -&gt; \"team204\"@0;\n</code></pre> <p>The following example shows that you can use <code>DELETE EDGE</code> together with pipe operators to delete edges that meet the conditions.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        WHERE dst(edge) == \"player101\" \\\n        YIELD src(edge) AS src, dst(edge) AS dst, rank(edge) AS rank \\\n        | DELETE EDGE follow $-.src-&gt;$-.dst @ $-.rank;\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/","title":"Index overview","text":"<p>Indexes are built to fast process graph queries. Nebula\u00a0Graph supports two kinds of indexes: native indexes and full-text indexes. This topic introduces the index types and helps choose the right index.</p>"},{"location":"3.ngql-guide/14.native-index-statements/#usage_instructions","title":"Usage Instructions","text":"<ul> <li>Indexes can improve query performance but may reduce write performance.</li> </ul> <ul> <li>An index is a prerequisite for locating data when executing a <code>LOOKUP</code>statement. If there is no index, an error will be reported when executing the <code>LOOKUP</code> statement.</li> </ul> <ul> <li>When using an index, NebulaGraph will automatically select the most optimal index.</li> </ul> <ul> <li>Indexes with high selectivity, that is, when the ratio of the number of records with unique values in the index column to the total number of records is high (for example, the ratio for <code>ID numbers</code> is <code>1</code>), can significantly improve query performance. For indexes with low selectivity (such as <code>country</code>), query performance might not experience a substantial improvement.</li> </ul>"},{"location":"3.ngql-guide/14.native-index-statements/#native_indexes","title":"Native indexes","text":"<p>Native indexes allow querying data based on a given property. Features are as follows.</p> <ul> <li>There are two kinds of native indexes: tag index and edge type index.</li> </ul> <ul> <li>Native indexes must be updated manually. You can use the <code>REBUILD INDEX</code> statement to update native indexes.</li> </ul> <ul> <li>Native indexes support indexing multiple properties on a tag or an edge type (composite indexes), but do not support indexing across multiple tags or edge types.</li> </ul>"},{"location":"3.ngql-guide/14.native-index-statements/#operations_on_native_indexes","title":"Operations on native indexes","text":"<ul> <li>CREATE INDEX</li> </ul> <ul> <li>SHOW CREATE INDEX</li> </ul> <ul> <li>SHOW INDEXES</li> </ul> <ul> <li>DESCRIBE INDEX</li> </ul> <ul> <li>REBUILD INDEX</li> </ul> <ul> <li>SHOW INDEX STATUS</li> </ul> <ul> <li>DROP INDEX</li> </ul> <ul> <li>LOOKUP</li> </ul> <ul> <li>MATCH</li> </ul> <ul> <li>Geography index</li> </ul>"},{"location":"3.ngql-guide/14.native-index-statements/#full-text_indexes","title":"Full-text indexes","text":"<p>Full-text indexes are used to do prefix, wildcard, regexp, and fuzzy search on a string property. Features are as follows.</p> <ul> <li>Full-text indexes allow indexing just one property.</li> </ul> <ul> <li>Full-text indexes do not support logical operations such as <code>AND</code>, <code>OR</code>, and <code>NOT</code>.</li> </ul> <p>Note</p> <p>To do complete string matches, use native indexes.</p>"},{"location":"3.ngql-guide/14.native-index-statements/#null_values","title":"Null values","text":"<p>Indexes do not support indexing null values.</p>"},{"location":"3.ngql-guide/14.native-index-statements/#range_queries","title":"Range queries","text":"<p>In addition to querying single results from native indexes, you can also do range queries. Not all the native indexes support range queries. You can only do range searches for numeric, date, and time type properties.</p>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/","title":"CREATE INDEX","text":""},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#prerequisites","title":"Prerequisites","text":"<p>Before you create an index, make sure that the relative tag or edge type is created. For how to create tags or edge types, see CREATE TAG and CREATE EDGE.</p> <p>For how to create full-text indexes, see Deploy full-text index.</p>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#must-read_for_using_indexes","title":"Must-read for using indexes","text":"<p>The concept and using restrictions of indexes are comparatively complex. Before you use indexes, you must read the following sections carefully.</p> <p>You can use <code>CREATE INDEX</code> to add native indexes for the existing tags, edge types, or properties. They are usually called as tag indexes, edge type indexes, and property indexes.</p> <ul> <li>Tag indexes and edge type indexes apply to queries related to the tag and the edge type, but do not apply to queries that are based on certain properties on the tag. For example, you can use <code>LOOKUP</code> to retrieve all the vertices with the tag <code>player</code>.</li> </ul> <ul> <li>Property indexes apply to property-based queries. For example, you can use the <code>age</code> property to retrieve the VID of all vertices that meet <code>age == 19</code>.</li> </ul> <p>If a property index <code>i_TA</code> is created for the property <code>A</code> of the tag <code>T</code> and <code>i_T</code> for the tag <code>T</code>, the indexes can be replaced as follows (the same for edge type indexes):</p> <ul> <li>The query engine can use <code>i_TA</code> to replace <code>i_T</code>.</li> </ul> <ul> <li> <p>In the <code>MATCH</code> and <code>LOOKUP</code> statements, <code>i_T</code> may replace <code>i_TA</code> for querying properties.</p> <p>Legacy version compatibility</p> <p>In previous releases, the tag or edge type index in the <code>LOOKUP</code> statement cannot replace the property index for property queries.</p> </li> </ul> <p>Although the same results can be obtained by using alternative indexes for queries, the query performance varies according to the selected index.</p> <p>Caution</p> <p>Indexes can dramatically reduce the write performance. The performance can be greatly reduced. DO NOT use indexes in production environments unless you are fully aware of their influences on your service.</p> <p>Long indexes decrease the scan performance of the Storage Service and use more memory. We suggest that you set the indexing length the same as that of the longest string to be indexed. For variable-length string-type properties, the longest index length is 256 bytes; for fixed-length string-type properties, the longest index length is the length of the index itself.</p>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#steps","title":"Steps","text":"<p>If you must use indexes, we suggest that you:</p> <ol> <li> <p>Import the data into NebulaGraph.</p> </li> <li> <p>Create indexes.</p> </li> <li> <p>Rebuild indexes.</p> </li> <li> <p>After the index is created and the data is imported, you can use LOOKUP or MATCH to retrieve the data. You do not need to specify which indexes to use in a query, NebulaGraph figures that out by itself.</p> </li> </ol> <p>Note</p> <p>If you create an index before importing the data, the importing speed will be extremely slow due to the reduction in the write performance.</p> <p>Keep <code>--disable_auto_compaction = false</code> during daily incremental writing.</p> <p>The newly created index will not take effect immediately. Trying to use a newly created index (such as <code>LOOKUP</code> or<code>REBUILD INDEX</code>) may fail and return <code>can't find xxx in the space</code> because the creation is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds. To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> in the configuration files for all services.</p> <p>Danger</p> <p>After creating a new index, or dropping the old index and creating a new one with the same name again, you must <code>REBUILD INDEX</code>. Otherwise, these data cannot be returned in the <code>MATCH</code> and <code>LOOKUP</code> statements.</p>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#syntax","title":"Syntax","text":"<pre><code>CREATE {TAG | EDGE} INDEX [IF NOT EXISTS] &lt;index_name&gt; ON {&lt;tag_name&gt; | &lt;edge_name&gt;} ([&lt;prop_name_list&gt;]) [COMMENT '&lt;comment&gt;'];\n</code></pre> Parameter Description <code>TAG | EDGE</code> Specifies the index type that you want to create. <code>IF NOT EXISTS</code> Detects if the index that you want to create exists. If it does not exist, a new one will be created. <code>&lt;index_name&gt;</code> 1. The name of the index. It must be unique in a graph space. A recommended way of naming is <code>i_tagName_propName</code>. 2. By default, the name only supports 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc. However, it cannot include special characters other than the underscore (_), and cannot start with a number.3. To use special characters, reserved keywords, or start with a number, quote the entire name with backticks (`) and do not include periods (<code>.</code>) within the pair of backticks (`). For more information, see Keywords and reserved words.Note:1. If you name an index in Chinese and encounter a <code>SyntaxError</code>, you need to quote the Chinese characters with backticks (`). 2. To include a backtick (`) in an index name, use a backslash to escape the backtick, such as \\`; to include a backslash, the backslash itself also needs to be escaped, such as \\ . <code>&lt;tag_name&gt; | &lt;edge_name&gt;</code> Specifies the name of the tag or edge associated with the index. <code>&lt;prop_name_list&gt;</code> To index a variable-length string property, you must use <code>prop_name(length)</code> to specify the index length, and the maximum index length is 256. To index a tag or an edge type, ignore the <code>prop_name_list</code>. <code>COMMENT</code> The remarks of the index. The maximum length is 256 bytes. By default, there will be no comments on an index."},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#create_tagedge_type_indexes","title":"Create tag/edge type indexes","text":"<pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index on player();\n</code></pre> <pre><code>nebula&gt; CREATE EDGE INDEX IF NOT EXISTS follow_index on follow();\n</code></pre> <p>After indexing a tag or an edge type, you can use the <code>LOOKUP</code> statement to retrieve the VID of all vertices <code>with the tag</code>, or <code>the source vertex ID, destination vertex ID, and ranks</code> of <code>all edges with the edge type</code>. For more information, see LOOKUP.</p>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#create_single-property_indexes","title":"Create single-property indexes","text":"<pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index_0 on player(name(10));\n</code></pre> <p>The preceding example creates an index for the <code>name</code> property on all vertices carrying the <code>player</code> tag. This example creates an index using the first 10 characters of the <code>name</code> property.</p> <pre><code># To index a variable-length string property, you need to specify the index length.\nnebula&gt; CREATE TAG IF NOT EXISTS var_string(p1 string);\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS var ON var_string(p1(10));\n\n# To index a fixed-length string property, you do not need to specify the index length.\nnebula&gt; CREATE TAG IF NOT EXISTS fix_string(p1 FIXED_STRING(10));\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS fix ON fix_string(p1);\n</code></pre> <pre><code>nebula&gt; CREATE EDGE INDEX IF NOT EXISTS follow_index_0 on follow(degree);\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/1.create-native-index/#create_composite_property_indexes","title":"Create composite property indexes","text":"<p>An index on multiple properties on a tag (or an edge type) is called a composite property index.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index_1 on player(name(10), age);\n</code></pre> <p>Caution</p> <p>Creating composite property indexes across multiple tags or edge types is not supported.</p> <p>Note</p> <p>NebulaGraph follows the left matching principle to select indexes.</p>"},{"location":"3.ngql-guide/14.native-index-statements/2.1.show-create-index/","title":"SHOW CREATE INDEX","text":"<p><code>SHOW CREATE INDEX</code> shows the statement used when creating a tag or an edge type. It contains detailed information about the index, such as its associated properties.</p>"},{"location":"3.ngql-guide/14.native-index-statements/2.1.show-create-index/#syntax","title":"Syntax","text":"<pre><code>SHOW CREATE {TAG | EDGE} INDEX &lt;index_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/2.1.show-create-index/#examples","title":"Examples","text":"<p>You can run <code>SHOW TAG INDEXES</code> to list all tag indexes, and then use <code>SHOW CREATE TAG INDEX</code> to show the information about the creation of the specified index.</p> <pre><code>nebula&gt; SHOW TAG INDEXES;\n+------------------+----------+----------+\n| Index Name       | By Tag   | Columns  |\n+------------------+----------+----------+\n| \"player_index_0\" | \"player\" | []       |\n| \"player_index_1\" | \"player\" | [\"name\"] |\n+------------------+----------+----------+\n\nnebula&gt; SHOW CREATE TAG INDEX player_index_1;\n+------------------+--------------------------------------------------+\n| Tag Index Name   | Create Tag Index                                 |\n+------------------+--------------------------------------------------+\n| \"player_index_1\" | \"CREATE TAG INDEX `player_index_1` ON `player` ( |\n|                  |  `name`(20)                                      |\n|                  | )\"                                               |\n+------------------+--------------------------------------------------+\n</code></pre> <p>Edge indexes can be queried through a similar approach.</p> <pre><code>nebula&gt; SHOW EDGE INDEXES;\n+----------------+----------+---------+\n| Index Name     | By Edge  | Columns |\n+----------------+----------+---------+\n| \"follow_index\" | \"follow\" | []      |\n+----------------+----------+---------+\n\nnebula&gt; SHOW CREATE EDGE INDEX follow_index;\n+-----------------+-------------------------------------------------+\n| Edge Index Name | Create Edge Index                               |\n+-----------------+-------------------------------------------------+\n| \"follow_index\"  | \"CREATE EDGE INDEX `follow_index` ON `follow` ( |\n|                 | )\"                                              |\n+-----------------+-------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/2.show-native-indexes/","title":"SHOW INDEXES","text":"<p><code>SHOW INDEXES</code> shows the defined tag or edge type indexes names in the current graph space.</p>"},{"location":"3.ngql-guide/14.native-index-statements/2.show-native-indexes/#syntax","title":"Syntax","text":"<pre><code>SHOW {TAG | EDGE} INDEXES\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/2.show-native-indexes/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW TAG INDEXES;\n+------------------+--------------+-----------------+\n| Index Name       | By Tag       | Columns         |\n+------------------+--------------+-----------------+\n| \"fix\"            | \"fix_string\" | [\"p1\"]          |\n| \"player_index_0\" | \"player\"     | [\"name\"]        |\n| \"player_index_1\" | \"player\"     | [\"name\", \"age\"] |\n| \"var\"            | \"var_string\" | [\"p1\"]          |\n+------------------+--------------+-----------------+\n\nnebula&gt; SHOW EDGE INDEXES;\n+----------------+----------+---------+\n| Index Name     | By Edge  | Columns |\n| \"follow_index\" | \"follow\" | []      |\n+----------------+----------+---------+\n</code></pre> <p>Legacy version compatibility</p> <p>In NebulaGraph 2.x, the <code>SHOW TAG/EDGE INDEXES</code> statement only returns <code>Names</code>.</p>"},{"location":"3.ngql-guide/14.native-index-statements/3.describe-native-index/","title":"DESCRIBE INDEX","text":"<p><code>DESCRIBE INDEX</code> can get the information about the index with a given name, including the property name (Field) and the property type (Type) of the index.</p>"},{"location":"3.ngql-guide/14.native-index-statements/3.describe-native-index/#syntax","title":"Syntax","text":"<pre><code>DESCRIBE {TAG | EDGE} INDEX &lt;index_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/3.describe-native-index/#examples","title":"Examples","text":"<pre><code>nebula&gt; DESCRIBE TAG INDEX player_index_0;\n+--------+--------------------+\n| Field  | Type               |\n+--------+--------------------+\n| \"name\" | \"fixed_string(30)\" |\n+--------+--------------------+\n\nnebula&gt; DESCRIBE TAG INDEX player_index_1;\n+--------+--------------------+\n| Field  | Type               |\n+--------+--------------------+\n| \"name\" | \"fixed_string(10)\" |\n| \"age\"  | \"int64\"            |\n+--------+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/4.rebuild-native-index/","title":"REBUILD INDEX","text":"<p>Danger</p> <ul> <li>If data is updated or inserted before the creation of the index, you must rebuild the indexes manually to make sure that the indexes contain the previously added data. Otherwise, you cannot use <code>LOOKUP</code> and <code>MATCH</code> to query the data based on the index. If the index is created before any data insertion, there is no need to rebuild the index.</li> <li>When the rebuild of an index is incomplete, queries that rely on the index can use only part of the index and therefore cannot obtain accurate results.</li> </ul> <p>You can use <code>REBUILD INDEX</code> to rebuild the created tag or edge type index. For details on how to create an index, see CREATE INDEX.</p> <p>Caution</p> <p>The speed of rebuilding indexes can be optimized by modifying the <code>rebuild_index_part_rate_limit</code> and <code>snapshot_batch_size</code> parameters in the configuration file. In addition, greater parameter values may result in higher memory and network usage, see Storage Service configurations for details.</p>"},{"location":"3.ngql-guide/14.native-index-statements/4.rebuild-native-index/#syntax","title":"Syntax","text":"<pre><code>REBUILD {TAG | EDGE} INDEX [&lt;index_name_list&gt;];\n\n&lt;index_name_list&gt;::=\n    [index_name [, index_name] ...]\n</code></pre> <ul> <li>Multiple indexes are permitted in a single <code>REBUILD</code> statement, separated by commas. When the index name is not specified, all tag or edge indexes are rebuilt.</li> </ul> <ul> <li>After the rebuilding is complete, you can use the <code>SHOW {TAG | EDGE} INDEX STATUS</code> command to check if the index is successfully rebuilt. For details on index status, see SHOW INDEX STATUS.</li> </ul>"},{"location":"3.ngql-guide/14.native-index-statements/4.rebuild-native-index/#examples","title":"Examples","text":"<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS person(name string, age int, gender string, email string);\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS single_person_index ON person(name(10));\n\n# The following example rebuilds an index and returns the job ID.\nnebula&gt; REBUILD TAG INDEX single_person_index;\n+------------+\n| New Job Id |\n+------------+\n| 31         |\n+------------+\n\n# The following example checks the index status.\nnebula&gt; SHOW TAG INDEX STATUS;\n+-----------------------+--------------+\n| Name                  | Index Status |\n+-----------------------+--------------+\n| \"single_person_index\" | \"FINISHED\"   |\n+-----------------------+--------------+\n\n# You can also use \"SHOW JOB &lt;job_id&gt;\" to check if the rebuilding process is complete.\nnebula&gt; SHOW JOB 31;\n+----------------+---------------------+------------+-------------------------+-------------------------+-------------+\n| Job Id(TaskId) | Command(Dest)       | Status     | Start Time              | Stop Time               | Error Code  |\n+----------------+---------------------+------------+-------------------------+-------------------------+-------------+\n| 31             | \"REBUILD_TAG_INDEX\" | \"FINISHED\" | 2021-07-07T09:04:24.000 | 2021-07-07T09:04:24.000 | \"SUCCEEDED\" |\n| 0              | \"storaged1\"         | \"FINISHED\" | 2021-07-07T09:04:24.000 | 2021-07-07T09:04:28.000 | \"SUCCEEDED\" |\n| 1              | \"storaged2\"         | \"FINISHED\" | 2021-07-07T09:04:24.000 | 2021-07-07T09:04:28.000 | \"SUCCEEDED\" |\n| 2              | \"storaged0\"         | \"FINISHED\" | 2021-07-07T09:04:24.000 | 2021-07-07T09:04:28.000 | \"SUCCEEDED\" |\n| \"Total:3\"      | \"Succeeded:3\"       | \"Failed:0\" | \"In Progress:0\"         | \"\"                      | \"\"          |\n+----------------+---------------------+------------+-------------------------+-------------------------+-------------+\n</code></pre> <p>NebulaGraph creates a job to rebuild the index. The job ID is displayed in the preceding return message. To check if the rebuilding process is complete, use the <code>SHOW JOB &lt;job_id&gt;</code> statement. For more information, see SHOW JOB.</p>"},{"location":"3.ngql-guide/14.native-index-statements/5.show-native-index-status/","title":"SHOW INDEX STATUS","text":"<p><code>SHOW INDEX STATUS</code> returns the name of the created tag or edge type index and its status of job.</p> <p>The status of rebuilding indexes includes:</p> <ul> <li><code>QUEUE</code>: The job is in a queue.</li> <li><code>RUNNING</code>: The job is running.</li> <li><code>FINISHED</code>: The job is finished.</li> <li><code>FAILED</code>: The job has failed.</li> <li><code>STOPPED</code>: The job has stopped.</li> <li><code>INVALID</code>: The job is invalid.</li> </ul> <p>Note</p> <p>For details on how to create an index, see CREATE INDEX.</p>"},{"location":"3.ngql-guide/14.native-index-statements/5.show-native-index-status/#syntax","title":"Syntax","text":"<pre><code>SHOW {TAG | EDGE} INDEX STATUS;\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/5.show-native-index-status/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW TAG INDEX STATUS;\n+----------------------+--------------+\n| Name                 | Index Status |\n+----------------------+--------------+\n| \"player_index_0\"     | \"FINISHED\"   |\n| \"player_index_1\"     | \"FINISHED\"   |\n+----------------------+--------------+\n</code></pre>"},{"location":"3.ngql-guide/14.native-index-statements/6.drop-native-index/","title":"DROP INDEX","text":"<p><code>DROP INDEX</code> removes an existing index from the current graph space.</p>"},{"location":"3.ngql-guide/14.native-index-statements/6.drop-native-index/#prerequisite","title":"Prerequisite","text":"<p>Running the <code>DROP INDEX</code> statement requires some privileges of <code>DROP TAG INDEX</code> and <code>DROP EDGE INDEX</code> in the given graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/14.native-index-statements/6.drop-native-index/#syntax","title":"Syntax","text":"<pre><code>DROP {TAG | EDGE} INDEX [IF EXISTS] &lt;index_name&gt;;\n</code></pre> <p><code>IF EXISTS</code>: Detects whether the index that you want to drop exists. If it exists, it will be dropped.</p>"},{"location":"3.ngql-guide/14.native-index-statements/6.drop-native-index/#example","title":"Example","text":"<pre><code>nebula&gt; DROP TAG INDEX player_index_0;\n</code></pre>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/","title":"Full-text indexes","text":"<p>Full-text indexes are used to do prefix, wildcard, regexp, and fuzzy search on a string property.</p> <p>You can use the <code>WHERE</code> clause to specify the search strings in <code>LOOKUP</code> statements.</p>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#prerequisite","title":"Prerequisite","text":"<p>Before using the full-text index, make sure that you have deployed a Elasticsearch cluster and a Listener cluster. For more information, see Deploy Elasticsearch and Deploy Listener.</p>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#precaution","title":"Precaution","text":"<p>Before using the full-text index, make sure that you know the restrictions.</p>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#full_text_queries","title":"Full Text Queries","text":"<p>Full-text queries enable you to search for parsed text fields, using a parser with strict syntax to return content based on the query string provided. For details, see Query string query.</p>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#syntax","title":"Syntax","text":""},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#create_full-text_indexes","title":"Create full-text indexes","text":"<pre><code>CREATE FULLTEXT {TAG | EDGE} INDEX &lt;index_name&gt; ON {&lt;tag_name&gt; | &lt;edge_name&gt;} (&lt;prop_name&gt; [,&lt;prop_name&gt;]...) [ANALYZER=\"&lt;analyzer_name&gt;\"];\n</code></pre> <ul> <li>Composite indexes with multiple properties are supported when creating full-text indexes.</li> <li><code>&lt;analyzer_name&gt;</code> is the name of the analyzer. The default value is <code>standard</code>. To use other analyzers (e.g. IK Analysis), you need to make sure that the corresponding analyzer is installed in Elasticsearch in advance.</li> </ul>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#show_full-text_indexes","title":"Show full-text indexes","text":"<pre><code>SHOW FULLTEXT INDEXES;\n</code></pre>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#rebuild_full-text_indexes","title":"Rebuild full-text indexes","text":"<pre><code>REBUILD FULLTEXT INDEX;\n</code></pre> <p>Caution</p> <p>When there is a large amount of data, rebuilding full-text index is slow, you can modify <code>snapshot_send_files=false</code> in the configuration file of Storage service(<code>nebula-storaged.conf</code>).</p>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#drop_full-text_indexes","title":"Drop full-text indexes","text":"<pre><code>DROP FULLTEXT INDEX &lt;index_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#use_query_options","title":"Use query options","text":"<pre><code>LOOKUP ON {&lt;tag&gt; | &lt;edge_type&gt;} WHERE ES_QUERY(&lt;index_name&gt;, \"&lt;text&gt;\") YIELD &lt;return_list&gt; [| LIMIT [&lt;offset&gt;,] &lt;number_rows&gt;];\n\n&lt;return_list&gt;\n    &lt;prop_name&gt; [AS &lt;prop_alias&gt;] [, &lt;prop_name&gt; [AS &lt;prop_alias&gt;] ...] [, id(vertex)  [AS &lt;prop_alias&gt;]] [, score() AS &lt;score_alias&gt;]\n</code></pre> <ul> <li><code>index_name</code>: The name of the full-text index.</li> </ul> <ul> <li><code>text</code>: Search conditions. The where can only be followed by the ES_QUERY, and all judgment conditions must be written in the text. For supported syntax, see Query string syntax.</li> </ul> <ul> <li><code>score()</code>: The score calculated by doing N degree expansion for the eligible vertices. The default value is <code>1.0</code>. The higher the score, the higher the degree of match. The return value is sorted by default from highest to lowest score. For details, see Search and Scoring in Lucene.</li> </ul>"},{"location":"3.ngql-guide/15.full-text-index-statements/1.search-with-text-based-index/#examples","title":"Examples","text":"<pre><code>// This example creates the graph space.\nnebula&gt; CREATE SPACE IF NOT EXISTS basketballplayer (partition_num=3,replica_factor=1, vid_type=fixed_string(30));\n\n// This example signs in the text service.\nnebula&gt; SIGN IN TEXT SERVICE (192.168.8.100:9200, HTTP);\n\n// This example checks the text service status.\nnebula&gt; SHOW TEXT SEARCH CLIENTS;\n+-----------------+-----------------+------+\n| Type            | Host            | Port |\n+-----------------+-----------------+------+\n| \"ELASTICSEARCH\" | \"192.168.8.100\" | 9200 |\n+-----------------+-----------------+------+\n\n// This example switches the graph space.\nnebula&gt; USE basketballplayer;\n\n// This example adds the listener to the NebulaGraph cluster.\nnebula&gt; ADD LISTENER ELASTICSEARCH 192.168.8.100:9789;\n\n// This example checks the listener status. When the status is `Online`, the listener is ready.\nnebula&gt; SHOW LISTENER;\n+--------+-----------------+------------------------+-------------+\n| PartId | Type            | Host                   | Host Status |\n+--------+-----------------+------------------------+-------------+\n| 1      | \"ELASTICSEARCH\" | \"\"192.168.8.100\":9789\" | \"ONLINE\"    |\n| 2      | \"ELASTICSEARCH\" | \"\"192.168.8.100\":9789\" | \"ONLINE\"    |\n| 3      | \"ELASTICSEARCH\" | \"\"192.168.8.100\":9789\" | \"ONLINE\"    |\n+--------+-----------------+------------------------+-------------+\n\n// This example creates the tag.\nnebula&gt; CREATE TAG IF NOT EXISTS player(name string, city string);\n\n// This example creates a single-attribute full-text index.\nnebula&gt; CREATE FULLTEXT TAG INDEX fulltext_index_1 ON player(name) ANALYZER=\"standard\";\n\n// This example creates a multi-attribute full-text indexe.\nnebula&gt; CREATE FULLTEXT TAG INDEX fulltext_index_2 ON player(name,city) ANALYZER=\"standard\";\n\n// This example rebuilds the full-text index.\nnebula&gt; REBUILD FULLTEXT INDEX;\n\n// This example shows the full-text index.\nnebula&gt; SHOW FULLTEXT INDEXES;\n+--------------------+-------------+-------------+--------------+------------+\n| Name               | Schema Type | Schema Name | Fields       | Analyzer   |\n+--------------------+-------------+-------------+--------------+------------+\n| \"fulltext_index_1\" | \"Tag\"       | \"player\"    | \"name\"       | \"standard\" |\n| \"fulltext_index_2\" | \"Tag\"       | \"player\"    | \"name, city\" | \"standard\" |\n+--------------------+-------------+-------------+--------------+------------+\n\n// This example inserts the test data.\nnebula&gt; INSERT VERTEX player(name, city) VALUES \\\n    \"Russell Westbrook\": (\"Russell Westbrook\", \"Los Angeles\"), \\\n    \"Chris Paul\": (\"Chris Paul\", \"Houston\"),\\\n    \"Boris Diaw\": (\"Boris Diaw\", \"Houston\"),\\\n    \"David West\": (\"David West\", \"Philadelphia\"),\\\n    \"Danny Green\": (\"Danny Green\", \"Philadelphia\"),\\\n    \"Tim Duncan\": (\"Tim Duncan\", \"New York\"),\\\n    \"James Harden\": (\"James Harden\", \"New York\"),\\\n    \"Tony Parker\": (\"Tony Parker\", \"Chicago\"),\\\n    \"Aron Baynes\": (\"Aron Baynes\", \"Chicago\"),\\\n    \"Ben Simmons\": (\"Ben Simmons\", \"Phoenix\"),\\\n    \"Blake Griffin\": (\"Blake Griffin\", \"Phoenix\");\n\n// These examples run test queries.\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"Chris\") YIELD id(vertex);\n+--------------+\n| id(VERTEX)   |\n+--------------+\n| \"Chris Paul\" |\n+--------------+\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"Harden\") YIELD properties(vertex);\n+----------------------------------------------------------------+\n| properties(VERTEX)                                             |\n+----------------------------------------------------------------+\n| {_vid: \"James Harden\", city: \"New York\", name: \"James Harden\"} |\n+----------------------------------------------------------------+\n\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"Da*\") YIELD properties(vertex);\n+------------------------------------------------------------------+\n| properties(VERTEX)                                               |\n+------------------------------------------------------------------+\n| {_vid: \"David West\", city: \"Philadelphia\", name: \"David West\"}   |\n| {_vid: \"Danny Green\", city: \"Philadelphia\", name: \"Danny Green\"} |\n+------------------------------------------------------------------+\n\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex);\n+---------------------+\n| id(VERTEX)          |\n+---------------------+\n| \"Russell Westbrook\" |\n| \"Boris Diaw\"        |\n| \"Aron Baynes\"       |\n| \"Ben Simmons\"       |\n| \"Blake Griffin\"     |\n+---------------------+\n\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex) | LIMIT 2,3;\n+-----------------+\n| id(VERTEX)      |\n+-----------------+\n| \"Aron Baynes\"   |\n| \"Ben Simmons\"   |\n| \"Blake Griffin\" |\n+-----------------+\n\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex) | YIELD count(*);\n+----------+\n| count(*) |\n+----------+\n| 5        |\n+----------+\n\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*\") YIELD id(vertex), score() AS score;\n+---------------------+-------+\n| id(VERTEX)          | score |\n+---------------------+-------+\n| \"Russell Westbrook\" | 1.0   |\n| \"Boris Diaw\"        | 1.0   |\n| \"Aron Baynes\"       | 1.0   |\n| \"Ben Simmons\"       | 1.0   |\n| \"Blake Griffin\"     | 1.0   |\n+---------------------+-------+\n\n// For documents containing a word `b`, its score will be multiplied by a weighting factor of 4, while for documents containing a word `c`, the default weighting factor of 1 is used.\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_1,\"*b*^4 OR *c*\") YIELD id(vertex), score() AS score;\n+---------------------+-------+\n| id(VERTEX)          | score |\n+---------------------+-------+\n| \"Russell Westbrook\" | 4.0   |\n| \"Boris Diaw\"        | 4.0   |\n| \"Aron Baynes\"       | 4.0   |\n| \"Ben Simmons\"       | 4.0   |\n| \"Blake Griffin\"     | 4.0   |\n| \"Chris Paul\"        | 1.0   |\n| \"Tim Duncan\"        | 1.0   |\n+---------------------+-------+\n\n// When using a multi-attribute full-text index query, the conditions are matched within all properties of the index.\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_2,\"*h*\") YIELD properties(vertex);\n+------------------------------------------------------------------+\n| properties(VERTEX)                                               |\n+------------------------------------------------------------------+\n| {_vid: \"Chris Paul\", city: \"Houston\", name: \"Chris Paul\"}        |\n| {_vid: \"Boris Diaw\", city: \"Houston\", name: \"Boris Diaw\"}        |\n| {_vid: \"David West\", city: \"Philadelphia\", name: \"David West\"}   |\n| {_vid: \"James Harden\", city: \"New York\", name: \"James Harden\"}   |\n| {_vid: \"Tony Parker\", city: \"Chicago\", name: \"Tony Parker\"}      |\n| {_vid: \"Aron Baynes\", city: \"Chicago\", name: \"Aron Baynes\"}      |\n| {_vid: \"Ben Simmons\", city: \"Phoenix\", name: \"Ben Simmons\"}      |\n| {_vid: \"Blake Griffin\", city: \"Phoenix\", name: \"Blake Griffin\"}  |\n| {_vid: \"Danny Green\", city: \"Philadelphia\", name: \"Danny Green\"} |\n+------------------------------------------------------------------+\n\n// When using multi-attribute full-text index queries, you can specify different text for different properties for the query.\nnebula&gt; LOOKUP ON player WHERE ES_QUERY(fulltext_index_2,\"name:*b* AND city:Houston\") YIELD properties(vertex);\n+-----------------------------------------------------------+\n| properties(VERTEX)                                        |\n+-----------------------------------------------------------+\n| {_vid: \"Boris Diaw\", city: \"Houston\", name: \"Boris Diaw\"} |\n+-----------------------------------------------------------+\n\n// Delete single-attribute full-text index.\nnebula&gt; DROP FULLTEXT INDEX fulltext_index_1;\n</code></pre>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/","title":"EXPLAIN and PROFILE","text":"<p><code>EXPLAIN</code> helps output the execution plan of an nGQL statement without executing the statement.</p> <p><code>PROFILE</code> executes the statement, then outputs the execution plan as well as the execution profile. You can optimize the queries for better performance according to the execution plan and profile.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#execution_plan","title":"Execution Plan","text":"<p>The execution plan is determined by the execution planner in the NebulaGraph query engine.</p> <p>The execution planner processes the parsed nGQL statements into <code>actions</code>. An <code>action</code> is the smallest unit that can be executed. A typical <code>action</code> fetches all neighbors of a given vertex, gets the properties of an edge, and filters vertices or edges based on the given conditions. Each <code>action</code> is assigned to an <code>operator</code> that performs the action.</p> <p>For example, a <code>SHOW TAGS</code> statement is processed into two <code>actions</code> and assigned to a <code>Start operator</code> and a <code>ShowTags operator</code>, while a more complex <code>GO</code> statement may be processed into more than 10 <code>actions</code> and assigned to 10 operators.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#syntax","title":"Syntax","text":"<ul> <li><code>EXPLAIN</code><pre><code>EXPLAIN [format= {\"row\" | \"dot\" | \"tck\"}] &lt;your_nGQL_statement&gt;;\n</code></pre> </li> </ul> <ul> <li><code>PROFILE</code><pre><code>PROFILE [format= {\"row\" | \"dot\" | \"tck\"}] &lt;your_nGQL_statement&gt;;\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#output_formats","title":"Output formats","text":"<p>The output of an <code>EXPLAIN</code> or a <code>PROFILE</code> statement has three formats, the default <code>row</code> format, the <code>dot</code> format, and the <code>tck</code> format. You can use the <code>format</code> option to modify the output format. Omitting the <code>format</code> option indicates using the default <code>row</code> format.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#the_row_format","title":"The <code>row</code> format","text":"<p>The <code>row</code> format outputs the return message in a table as follows.</p> <ul> <li><code>EXPLAIN</code><pre><code>nebula&gt; EXPLAIN format=\"row\" SHOW TAGS;\nExecution succeeded (time spent 327/892 us)\n\nExecution Plan\n\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n| id | name     | dependencies | profiling data | operator info                                                       |\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n|  1 | ShowTags | 0            |                | outputVar: [{\"colNames\":[],\"name\":\"__ShowTags_1\",\"type\":\"DATASET\"}] |\n|    |          |              |                | inputVar:                                                           |\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n|  0 | Start    |              |                | outputVar: [{\"colNames\":[],\"name\":\"__Start_0\",\"type\":\"DATASET\"}]    |\n-----+----------+--------------+----------------+----------------------------------------------------------------------\n</code></pre> </li> </ul> <ul> <li><code>PROFILE</code><pre><code>nebula&gt; PROFILE format=\"row\" SHOW TAGS;\n+--------+\n| Name   |\n+--------+\n| player |\n+--------+\n| team   |\n+--------+\nGot 2 rows (time spent 2038/2728 us)\n\nExecution Plan\n\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n| id | name     | dependencies | profiling data                                     | operator info                                                       |\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n|  1 | ShowTags | 0            | ver: 0, rows: 1, execTime: 42us, totalTime: 1177us | outputVar: [{\"colNames\":[],\"name\":\"__ShowTags_1\",\"type\":\"DATASET\"}] |\n|    |          |              |                                                    | inputVar:                                                           |\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n|  0 | Start    |              | ver: 0, rows: 0, execTime: 1us, totalTime: 57us    | outputVar: [{\"colNames\":[],\"name\":\"__Start_0\",\"type\":\"DATASET\"}]    |\n-----+----------+--------------+----------------------------------------------------+----------------------------------------------------------------------\n</code></pre> </li> </ul> <p>The descriptions are as follows.</p> Parameter Description <code>id</code> The ID of the <code>operator</code>. <code>name</code> The name of the <code>operator</code>. <code>dependencies</code> The ID of the <code>operator</code> that the current <code>operator</code> depends on. <code>profiling data</code> The content of the execution profile. <code>ver</code> is the version of the <code>operator</code>. <code>rows</code> shows the number of rows to be output by the <code>operator</code>. <code>execTime</code> shows the execution time of <code>action</code>. <code>totalTime</code> is the sum of the execution time, the system scheduling time, and the queueing time. <code>operator info</code> The detailed information of the <code>operator</code>."},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#the_dot_format","title":"The <code>dot</code> format","text":"<p>You can use the <code>format=\"dot\"</code> option to output the return message in the <code>dot</code> language, and then use Graphviz to generate a graph of the plan.</p> <p>Note</p> <p>Graphviz is open source graph visualization software. Graphviz provides an online tool for previewing DOT language files and exporting them to other formats such as SVG or JSON. For more information, see Graphviz Online.</p> <pre><code>nebula&gt; EXPLAIN format=\"dot\" SHOW TAGS;\nExecution succeeded (time spent 161/665 us)\nExecution Plan\n---------------------------------------------------------------------------------------------------------------------------------------------  -------------\n  plan\n---------------------------------------------------------------------------------------------------------------------------------------------  -------------\n  digraph exec_plan {\n      rankdir=LR;\n      \"ShowTags_0\"[label=\"ShowTags_0|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__ShowTags_0\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar:\\l\",   shape=Mrecord];\n      \"Start_2\"-&gt;\"ShowTags_0\";\n      \"Start_2\"[label=\"Start_2|outputVar: \\[\\{\\\"colNames\\\":\\[\\],\\\"name\\\":\\\"__Start_2\\\",\\\"type\\\":\\\"DATASET\\\"\\}\\]\\l|inputVar: \\l\",   shape=Mrecord];\n  }\n---------------------------------------------------------------------------------------------------------------------------------------------  -------------\n</code></pre> <p>The Graphviz graph transformed from the above DOT statement is as follows.</p> <p></p>"},{"location":"3.ngql-guide/17.query-tuning-statements/1.explain-and-profile/#the_tck_format","title":"The <code>tck</code> format","text":"<p>The tck format is similar to a table, but without borders and dividing lines between rows. You can use the results as test cases for unit testing.  For information on tck format test cases, see TCK cases.</p> <ul> <li><code>EXPLAIN</code><pre><code>nebula&gt; EXPLAIN format=\"tck\" FETCH PROP ON player \"player_1\",\"player_2\",\"player_3\" YIELD properties(vertex).name as name, properties(vertex).age as age;\nExecution succeeded (time spent 261\u00b5s/613.718\u00b5s)\nExecution Plan (optimize time 28 us)\n| id | name        | dependencies | profiling data | operator info |\n|  2 | Project     | 1            |                |               |\n|  1 | GetVertices | 0            |                |               |\n|  0 | Start       |              |                |               |\n\nWed, 22 Mar 2023 23:15:52 CST\n</code></pre> </li> </ul> <ul> <li><code>PROFILE</code><pre><code>nebula&gt; PROFILE format=\"tck\" FETCH PROP ON player \"player_1\",\"player_2\",\"player_3\" YIELD properties(vertex).name as name, properties(vertex).age as age;\n| name         | age |\n| \"Piter Park\" | 24  |\n| \"aaa\"        | 24  |\n| \"ccc\"        | 24  |\nGot 3 rows (time spent 1.474ms/2.19677ms)\nExecution Plan (optimize time 41 us)\n| id | name        | dependencies | profiling data                                                                                                      | operator info |\n|  2 | Project     | 1            | {\"rows\":3,\"version\":0}                                                                                              |               |\n|  1 | GetVertices | 0            | {\"resp[0]\":{\"exec\":\"232(us)\",\"host\":\"127.0.0.1:9779\",\"total\":\"758(us)\"},\"rows\":3,\"total_rpc\":\"875(us)\",\"version\":0} |               |\n|  0 | Start       |              | {\"rows\":0,\"version\":0}                                                                                              |               |\nWed, 22 Mar 2023 23:16:13 CST\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/17.query-tuning-statements/2.kill-session/","title":"Kill sessions","text":"<p>The <code>KILL SESSION</code> command is to terminate running sessions.</p> <p>Note</p> <ul> <li>Only the NebulaGraph <code>root</code> user can terminate sessions.</li> <li>After executing the <code>KILL SESSION</code> command, all Graph services synchronize the latest session information after <code>2* session_reclaim_interval_secs</code> seconds (<code>120</code> seconds by default).</li> </ul>"},{"location":"3.ngql-guide/17.query-tuning-statements/2.kill-session/#syntax","title":"Syntax","text":"<p>You can run the <code>KILL SESSION</code> command to terminate one or multiple sessions. The syntax is as follows:</p> <ul> <li> <p>To terminate one session</p> <pre><code>KILL {SESSION|SESSIONS} &lt;SessionId&gt;\n</code></pre> <ul> <li><code>{SESSION|SESSIONS}</code>: <code>SESSION</code> or <code>SESSIONS</code>, both are supported. </li> <li><code>&lt;SessionId&gt;</code>: Specifies the ID of one session. You can run the SHOW SESSIONS command to view the IDs of sessions.</li> </ul> </li> </ul> <ul> <li> <p>To terminate multiple sessions</p> <pre><code>SHOW SESSIONS \n| YIELD $-.SessionId AS sid [WHERE &lt;filter_clause&gt;]\n| KILL {SESSION|SESSIONS} $-.sid\n</code></pre> <p>Note</p> <p>The <code>KILL SESSION</code> command supports the pipeline operation, combining the <code>SHOW SESSIONS</code> command with the <code>KILL SESSION</code> command to terminate multiple sessions.</p> <ul> <li><code>[WHERE &lt;filter_clause&gt;]</code>\uff1a<ul> <li>Optional, the <code>WHERE</code> clause is used to filter sessions. <code>&lt;filter_expression&gt;</code> specifies a session filtering expression, for example, <code>WHERE $-.CreateTime &lt; datetime(\"2022-12-14T18:00:00\")</code>. If the <code>WHERE</code> clause is not specified, all sessions are terminated.</li> <li>Filtering conditions in a <code>WHERE</code> clause include: <code>SessionId</code>, <code>UserName</code>, <code>SpaceName</code>, <code>CreateTime</code>, <code>UpdateTime</code>, <code>GraphAddr</code>, <code>Timezone</code>, and <code>ClientIp</code>. You can run the SHOW SESSIONS command to view descriptions of these conditions.</li> </ul> </li> </ul> <ul> <li><code>{SESSION|SESSIONS}</code>: <code>SESSION</code> or <code>SESSIONS</code>, both are supported.</li> </ul> <p>Caution</p> <p>Please use filtering conditions with caution to avoid deleting sessions by mistake.</p> </li> </ul>"},{"location":"3.ngql-guide/17.query-tuning-statements/2.kill-session/#examples","title":"Examples","text":"<ul> <li> <p>To terminate one session</p> <pre><code>nebula&gt; KILL SESSION 1672887983842984 \n</code></pre> </li> </ul> <ul> <li> <p>To terminate multiple sessions</p> <ul> <li> <p>Terminate all sessions whose creation time is less than <code>2023-01-05T18:00:00</code>.</p> <pre><code>nebula&gt; SHOW SESSIONS | YIELD $-.SessionId AS sid WHERE $-.CreateTime &lt; datetime(\"2023-01-05T18:00:00\") | KILL SESSIONS $-.sid\n</code></pre> </li> </ul> <ul> <li> <p>Terminates the two sessions with the earliest creation times.</p> <pre><code>nebula&gt; SHOW SESSIONS | YIELD $-.SessionId AS sid, $-.CreateTime as CreateTime | ORDER BY $-.CreateTime ASC | LIMIT 2 | KILL SESSIONS $-.sid\n</code></pre> </li> </ul> <ul> <li> <p>Terminates all sessions created by the username <code>session_user1</code>.</p> <pre><code>nebula&gt; SHOW SESSIONS | YIELD $-.SessionId as sid WHERE $-.UserName == \"session_user1\" | KILL SESSIONS $-.sid\n</code></pre> </li> </ul> <ul> <li> <p>Terminate all sessions.</p> <pre><code>nebula&gt; SHOW SESSIONS | YIELD $-.SessionId as sid | KILL SESSION $-.sid\n\n// Or\nnebula&gt; SHOW SESSIONS | KILL SESSIONS $-.SessionId\n</code></pre> <p>Caution</p> <p>When you terminate all sessions, the current session is terminated. Please use it with caution.</p> </li> </ul> </li> </ul>"},{"location":"3.ngql-guide/17.query-tuning-statements/6.kill-query/","title":"Kill queries","text":"<p><code>KILL QUERY</code> can terminate the query being executed, and is often used to terminate slow queries.</p> <p>Note</p> <p>Users with the God role can kill any query. Other roles can only kill their own queries.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/6.kill-query/#syntax","title":"Syntax","text":"<pre><code>KILL QUERY (session=&lt;session_id&gt;, plan=&lt;plan_id&gt;);\n</code></pre> <ul> <li><code>session_id</code>: The ID of the session.</li> <li><code>plan_id</code>: The ID of the execution plan.</li> </ul> <p>The ID of the session and the ID of the execution plan can uniquely determine a query. Both can be obtained through the SHOW QUERIES statement.</p>"},{"location":"3.ngql-guide/17.query-tuning-statements/6.kill-query/#examples","title":"Examples","text":"<p>This example executes <code>KILL QUERY</code> in one session to terminate the query in another session.</p> <pre><code>nebula&gt; KILL QUERY(SESSION=1625553545984255,PLAN=163);\n</code></pre> <p>The query will be terminated and the following information will be returned.</p> <pre><code>[ERROR (-1005)]: ExecutionPlanId[1001] does not exist in current Session.\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/1.numeric/","title":"Numeric types","text":"<p>nGQL supports both integer and floating-point number.</p>"},{"location":"3.ngql-guide/3.data-types/1.numeric/#integer","title":"Integer","text":"<p>Signed 64-bit integer (INT64), 32-bit integer (INT32), 16-bit integer (INT16), and 8-bit integer (INT8) are supported.</p> Type Declared keywords Range INT64 <code>INT64</code> or<code>INT</code> -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 INT32 <code>INT32</code> -2,147,483,648 ~ 2,147,483,647 INT16 <code>INT16</code> -32,768 ~ 32,767 INT8 <code>INT8</code> -128 ~ 127"},{"location":"3.ngql-guide/3.data-types/1.numeric/#floating-point_number","title":"Floating-point number","text":"<p>Both single-precision floating-point format (FLOAT) and double-precision floating-point format (DOUBLE) are supported.</p> Type Declared keywords Range Precision FLOAT <code>FLOAT</code> 3.4E +/- 38 6~7 bits DOUBLE <code>DOUBLE</code> 1.7E +/- 308 15~16 bits <p>Scientific notation is also supported, such as <code>1e2</code>, <code>1.1e2</code>, <code>.3e4</code>, <code>1.e4</code>, and <code>-1234E-10</code>.</p> <p>Note</p> <p>The data type of DECIMAL in MySQL is not supported.</p>"},{"location":"3.ngql-guide/3.data-types/1.numeric/#reading_and_writing_of_data_values","title":"Reading and writing of data values","text":"<p>When writing and reading different types of data, nGQL complies with the following rules:</p> Data type Set as VID Set as property Resulted data type INT64 Supported Supported INT64 INT32 Not supported Supported INT64 INT16 Not supported Supported INT64 INT8 Not supported Supported INT64 FLOAT Not supported Supported DOUBLE DOUBLE Not supported Supported DOUBLE <p>For example, nGQL does not support setting VID as INT8, but supports setting a certain property type of TAG or Edge type as INT8. When using the nGQL statement to read the property of INT8, the resulted type is INT64.</p> <ul> <li> <p>Multiple formats are supported:</p> <ul> <li>Decimal, such as <code>123456</code>.</li> <li>Hexadecimal, such as <code>0x1e240</code>.</li> <li>Octal, such as <code>0361100</code>.</li> </ul> <p>However, NebulaGraph will parse the written non-decimal value into a decimal value and save it. The value read is decimal.</p> <p>For example, the type of the property <code>score</code> is <code>INT</code>. The value of <code>0xb</code> is assigned to it through the INSERT statement. If querying the property value with statements such as FETCH, you will get the result <code>11</code>, which is the decimal result of the hexadecimal <code>0xb</code>.</p> </li> </ul> <ul> <li>Round a FLOAT/DOUBLE value when inserting it to an INT column.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/10.geography/","title":"Geography","text":"<p>Geography is a data type composed of latitude and longitude that represents geospatial information. NebulaGraph currently supports Point, LineString, and Polygon in Simple Features and some functions in SQL-MM 3, such as part of the core geo parsing, construction, formatting, conversion, predicates, and dimensions.</p>"},{"location":"3.ngql-guide/3.data-types/10.geography/#type_description","title":"Type description","text":"<p>A point is the basic data type of geography, which is determined by a latitude and a longitude. For example, <code>\"POINT(3 8)\"</code> means that the longitude is <code>3\u00b0</code> and the latitude is <code>8\u00b0</code>. Multiple points can form a linestring or a polygon.</p> <p>Note</p> <p>You cannot directly insert geographic data of the following types, such as <code>INSERT VERTEX any_shape(geo) VALUES \"1\":(\"POINT(1 1)\")</code>. Instead, you need to use a geography function to specify the data type before inserting, such as <code>INSERT VERTEX any_shape(geo) VALUES \"1\":(ST_GeogFromText(\"POINT(1 1)\"));</code>.</p> Shape Example Description Point <code>\"POINT(3 8)\"</code> Specifies the data type as a point. LineString <code>\"LINESTRING(3 8, 4.7 73.23)\"</code> Specifies the data type as a linestring. Polygon <code>\"POLYGON((0 1, 1 2, 2 3, 0 1))\"</code> Specifies the data type as a polygon."},{"location":"3.ngql-guide/3.data-types/10.geography/#examples","title":"Examples","text":"<pre><code>//Create a Tag to allow storing any geography data type.\nnebula&gt; CREATE TAG IF NOT EXISTS any_shape(geo geography);\n\n//Create a Tag to allow storing a point only.\nnebula&gt; CREATE TAG IF NOT EXISTS only_point(geo geography(point));\n\n//Create a Tag to allow storing a linestring only.\nnebula&gt; CREATE TAG IF NOT EXISTS only_linestring(geo geography(linestring));\n\n//Create a Tag to allow storing a polygon only.\nnebula&gt; CREATE TAG IF NOT EXISTS only_polygon(geo geography(polygon));\n\n//Create an Edge type to allow storing any geography data type.\nnebula&gt; CREATE EDGE IF NOT EXISTS any_shape_edge(geo geography);\n\n//Create a vertex to store the geography of a polygon.\nnebula&gt; INSERT VERTEX any_shape(geo) VALUES \"103\":(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));\n\n//Create an edge to store the geography of a polygon.\nnebula&gt; INSERT EDGE any_shape_edge(geo) VALUES \"201\"-&gt;\"302\":(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));\n\n//Query the geography of Vertex 103.\nnebula&gt; FETCH PROP ON any_shape \"103\" YIELD ST_ASText(any_shape.geo);\n+---------------------------------+\n| ST_ASText(any_shape.geo)        |\n+---------------------------------+\n| \"POLYGON((0 1, 1 2, 2 3, 0 1))\" |\n+---------------------------------+\n\n//Query the geography of the edge which traverses from Vertex 201 to Vertex 302.\nnebula&gt; FETCH PROP ON any_shape_edge \"201\"-&gt;\"302\" YIELD ST_ASText(any_shape_edge.geo);\n+---------------------------------+\n| ST_ASText(any_shape_edge.geo)   |\n+---------------------------------+\n| \"POLYGON((0 1, 1 2, 2 3, 0 1))\" |\n+---------------------------------+\n\n//Create an index for the geography of the Tag any_shape and run LOOKUP.\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS any_shape_geo_index ON any_shape(geo);\nnebula&gt; REBUILD TAG INDEX any_shape_geo_index;\nnebula&gt; LOOKUP ON any_shape YIELD ST_ASText(any_shape.geo);\n+---------------------------------+\n| ST_ASText(any_shape.geo)        |\n+---------------------------------+\n| \"POLYGON((0 1, 1 2, 2 3, 0 1))\" |\n+---------------------------------+\n</code></pre> <p>When creating an index for geography properties, you can specify the parameters for the index.</p> Parameter Default value Description <code>s2_max_level</code> <code>30</code> The maximum level of S2 cell used in the covering. Allowed values: <code>1</code>~<code>30</code>. Setting it to less than the default means that NebulaGraph will be forced to generate coverings using larger cells. <code>s2_max_cells</code> <code>8</code> The maximum number of S2 cells used in the covering. Provides a limit on how much work is done exploring the possible coverings. Allowed values: <code>1</code>~<code>30</code>. You may want to use higher values for odd-shaped regions such as skinny rectangles. <p>Note</p> <p>Specifying the above two parameters does not affect the Point type of property. The <code>s2_max_level</code> value of the Point type is forced to be <code>30</code>.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS any_shape_geo_index ON any_shape(geo) with (s2_max_level=30, s2_max_cells=8);\n</code></pre> <p>For more index information, see Index overview.</p>"},{"location":"3.ngql-guide/3.data-types/2.boolean/","title":"Boolean","text":"<p>A boolean data type is declared with the <code>bool</code> keyword and can only take the values <code>true</code> or <code>false</code>.</p> <p>nGQL supports using boolean in the following ways:</p> <ul> <li>Define the data type of the property value as a boolean.</li> <li>Use boolean as judgment conditions in the <code>WHERE</code> clause.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/3.string/","title":"String","text":"<p>Fixed-length strings and variable-length strings are supported.</p>"},{"location":"3.ngql-guide/3.data-types/3.string/#declaration_and_literal_representation","title":"Declaration and literal representation","text":"<p>The string type is declared with the keywords of:</p> <ul> <li><code>STRING</code>: Variable-length strings.</li> <li><code>FIXED_STRING(&lt;length&gt;)</code>: Fixed-length strings. <code>&lt;length&gt;</code> is the length of the string, such as <code>FIXED_STRING(32)</code>.</li> </ul> <p>A string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes. For example, <code>\"Hello, Cooper\"</code> or <code>'Hello, Cooper'</code>.</p>"},{"location":"3.ngql-guide/3.data-types/3.string/#string_reading_and_writing","title":"String reading and writing","text":"<p>Nebula\u00a0Graph supports using string types in the following ways:</p> <ul> <li>Define the data type of VID as a fixed-length string.</li> <li>Set the variable-length string as the Schema name, including the names of the graph space, tag, edge type, and property.</li> <li>Define the data type of the property as a fixed-length or variable-length string.</li> </ul> <p>For example:</p> <ul> <li>Define the data type of the property as a fixed-length string<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t1 (p1 FIXED_STRING(10)); \n</code></pre> </li> </ul> <ul> <li>Define the data type of the property as a variable-length string<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS t2 (p2 STRING); \n</code></pre> </li> </ul> <p>When the fixed-length string you try to write exceeds the length limit:</p> <ul> <li>If the fixed-length string is a property, the writing will succeed, and NebulaGraph will truncate the string and only store the part that meets the length limit.</li> <li>If the fixed-length string is a VID, the writing will fail and NebulaGraph will return an error.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/3.string/#escape_characters","title":"Escape Characters","text":"<p>In strings, the backslash (<code>\\</code>) serves as an escape character used to denote special characters.</p> <p>For example, to include a double quote (<code>\"</code>) within a string, you cannot directly write <code>\"Hello \"world\"\"</code> as it leads to a syntax error. Instead, use the backslash (<code>\\</code>) to escape the double quote, such as <code>\"Hello \\\"world\\\"\"</code>.</p> <pre><code>nebula&gt; RETURN \"Hello \\\"world\\\"\"\n+-----------------+\n| \"Hello \"world\"\" |\n+-----------------+\n| \"Hello \"world\"\" |\n+-----------------+\n</code></pre> <p>The backslash itself needs to be escaped as it's a special character. For example, to include a backslash in a string, you need to write <code>\"Hello \\\\ world\"</code>.</p> <pre><code>nebula&gt; RETURN \"Hello \\\\ world\"\n+-----------------+\n| \"Hello \\ world\" |\n+-----------------+\n| \"Hello \\ world\" |\n+-----------------+\n</code></pre> <p>For more examples of escape characters, see Escape character examples.</p>"},{"location":"3.ngql-guide/3.data-types/3.string/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>There are some tiny differences between openCypher and Cypher, as well as nGQL. The following is what openCypher requires. Single quotes cannot be converted to double quotes.</p> <pre><code># File: Literals.feature\nFeature: Literals\n\nBackground:\n    Given any graph\n Scenario: Return a single-quoted string\n    When executing query:\n      \"\"\"\n      RETURN '' AS literal\n      \"\"\"\n    Then the result should be, in any order:\n      | literal |\n      | ''      |    # Note: it should return single-quotes as openCypher required.\n    And no side effects\n</code></pre> <p>While Cypher accepts both single quotes and double quotes as the return results. nGQL follows the Cypher way.</p> <pre><code>nebula &gt; YIELD '' AS quote1, \"\" AS quote2, \"'\" AS quote3, '\"' AS quote4\n+--------+--------+--------+--------+\n| quote1 | quote2 | quote3 | quote4 |\n+--------+--------+--------+--------+\n| \"\"     | \"\"     | \"'\"    | \"\"\"    |\n+--------+--------+--------+--------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/","title":"Date and time types","text":"<p>This topic will describe the <code>DATE</code>, <code>TIME</code>, <code>DATETIME</code>, <code>TIMESTAMP</code>, and <code>DURATION</code> types.</p>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#precautions","title":"Precautions","text":"<ul> <li> <p>While inserting time-type property values with <code>DATE</code>, <code>TIME</code>, and <code>DATETIME</code>, NebulaGraph transforms them to a UTC time according to the timezone specified with the <code>timezone_name</code> parameter in the configuration files. </p> <p>Note</p> <p>To change the timezone, modify the <code>timezone_name</code> value in the configuration files of all NebulaGraph services.</p> </li> </ul> <ul> <li><code>date()</code>, <code>time()</code>, and <code>datetime()</code> can convert a time-type property with a specified timezone. For example, <code>datetime(\"2017-03-04 22:30:40.003000+08:00\")</code> or <code>datetime(\"2017-03-04T22:30:40.003000[Asia/Shanghai]\")</code>.</li> </ul> <ul> <li><code>date()</code>, <code>time()</code>, <code>datetime()</code>, and <code>timestamp()</code> all accept empty parameters to return the current date, time, and datetime.</li> </ul> <ul> <li><code>date()</code>, <code>time()</code>, and <code>datetime()</code> all accept the property name to return a specific property value of itself. For example, <code>date().month</code> returns the current month, while <code>time(\"02:59:40\").minute</code> returns the minutes of the importing time.</li> </ul> <ul> <li>For time operations it is recommended to use <code>duration()</code> to calculate the offset of the moment. Addition and subtraction of <code>date()</code> and <code>date()</code>, <code>timestamp()</code> and <code>timestamp()</code> are also supported.</li> </ul> <ul> <li>When setting the year of the time as a negative number, you need to use Map type data.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>In nGQL:</p> <ul> <li>Year, month, day, hour, minute, second, millisecond, and microsecond are supported, while the nanosecond is not supported.</li> </ul> <ul> <li><code>localdatetime()</code> is not supported.</li> </ul> <ul> <li>Most string time formats are not supported. The exceptions are <code>YYYY-MM-DDThh:mm:ss</code> and <code>YYYY-MM-DD hh:mm:ss</code>.</li> </ul> <ul> <li>The single-digit string time format is supported. For example, <code>time(\"1:1:1\")</code>.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#date","title":"DATE","text":"<p>The <code>DATE</code> type is used for values with a date part but no time part. Nebula\u00a0Graph retrieves and displays <code>DATE</code> values in the <code>YYYY-MM-DD</code> format. The supported range is <code>-32768-01-01</code> to <code>32767-12-31</code>.</p> <p>The properties of <code>date()</code> include <code>year</code>, <code>month</code>, and <code>day</code>. <code>date()</code> supports the input of <code>YYYYY</code>, <code>YYYYY-MM</code> or <code>YYYYY-MM-DD</code>, and defaults to <code>01</code> for an untyped month or day.</p> <pre><code>nebula&gt; RETURN DATE({year:-123, month:12, day:3});\n+------------------------------------+\n| date({year:-(123),month:12,day:3}) |\n+------------------------------------+\n| -123-12-03                         |\n+------------------------------------+\n\nnebula&gt; RETURN DATE(\"23333\");\n+---------------+\n| date(\"23333\") |\n+---------------+\n| 23333-01-01   |\n+---------------+\n\nnebula&gt; RETURN DATE(\"2023-12-12\") - DATE(\"2023-12-11\");\n+-----------------------------------------+\n| (date(\"2023-12-12\")-date(\"2023-12-11\")) |\n+-----------------------------------------+\n| 1                                       |\n+-----------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#time","title":"TIME","text":"<p>The <code>TIME</code> type is used for values with a time part but no date part. Nebula\u00a0Graph retrieves and displays <code>TIME</code> values in <code>hh:mm:ss.msmsmsususus</code> format. The supported range is <code>00:00:00.000000</code> to <code>23:59:59.999999</code>.</p> <p>The properties of <code>time()</code> include <code>hour</code>, <code>minute</code>, and <code>second</code>.</p>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#datetime","title":"DATETIME","text":"<p>The <code>DATETIME</code> type is used for values that contain both date and time parts. Nebula\u00a0Graph retrieves and displays <code>DATETIME</code> values in <code>YYYY-MM-DDThh:mm:ss.msmsmsususus</code> format. The supported range is <code>-32768-01-01T00:00:00.000000</code> to <code>32767-12-31T23:59:59.999999</code>.</p> <ul> <li>The properties of <code>datetime()</code> include <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, and <code>second</code>.</li> </ul> <ul> <li><code>datetime()</code> can convert <code>TIMESTAMP</code> to <code>DATETIME</code>. The value range of <code>TIMESTAMP</code> is <code>0~9223372036</code>.</li> </ul> <ul> <li><code>datetime()</code> supports an <code>int</code> argument. The <code>int</code> argument specifies a timestamp.</li> </ul> <pre><code># To get the current date and time.\nnebula&gt; RETURN datetime();\n+----------------------------+\n| datetime()                 |\n+----------------------------+\n| 2022-08-29T06:37:08.933000 |\n+----------------------------+\n\n# To get the current hour.\nnebula&gt; RETURN datetime().hour;\n+-----------------+\n| datetime().hour |\n+-----------------+\n| 6               |\n+-----------------+\n\n# To get date time from a given timestamp.\nnebula&gt; RETURN datetime(timestamp(1625469277));\n+---------------------------------+\n| datetime(timestamp(1625469277)) |\n+---------------------------------+\n| 2021-07-05T07:14:37.000000      |\n+---------------------------------+\n\nnebula&gt; RETURN datetime(1625469277);\n+----------------------------+\n| datetime(1625469277)       |\n+----------------------------+\n| 2021-07-05T07:14:37.000000 |\n+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#timestamp","title":"TIMESTAMP","text":"<p>The <code>TIMESTAMP</code> data type is used for values that contain both date and time parts. It has a range of <code>1970-01-01T00:00:01</code> UTC to <code>2262-04-11T23:47:16</code> UTC.</p> <p><code>TIMESTAMP</code> has the following features:</p> <ul> <li>Stored and displayed in the form of a timestamp, such as <code>1615974839</code>, which means <code>2021-03-17T17:53:59</code>.</li> </ul> <ul> <li>Supported <code>TIMESTAMP</code> querying methods: timestamp and <code>timestamp()</code> function.</li> </ul> <ul> <li>Supported <code>TIMESTAMP</code> inserting methods: timestamp, <code>timestamp()</code> function, and <code>now()</code> function.</li> </ul> <ul> <li><code>timestamp()</code> function accepts empty arguments to get the current timestamp. It can pass an integer arguments to identify the integer as a timestamp and the range of passed integer is: <code>0~9223372036</code>\u3002</li> </ul> <ul> <li><code>timestamp()</code> function can convert <code>DATETIME</code> to <code>TIMESTAMP</code>, and the data type of <code>DATETIME</code> should be a <code>string</code>. </li> </ul> <ul> <li>The underlying storage data type is int64.</li> </ul> <pre><code># To get the current timestamp.\nnebula&gt; RETURN timestamp();\n+-------------+\n| timestamp() |\n+-------------+\n| 1625469277  |\n+-------------+\n\n# To get a timestamp from given date and time.\nnebula&gt; RETURN timestamp(\"2022-01-05T06:18:43\");\n+----------------------------------+\n| timestamp(\"2022-01-05T06:18:43\") |\n+----------------------------------+\n| 1641363523                       |\n+----------------------------------+\n\n# To get a timestamp using datetime().\nnebula&gt; RETURN timestamp(datetime(\"2022-08-29T07:53:10.939000\"));\n+---------------------------------------------------+\n| timestamp(datetime(\"2022-08-29T07:53:10.939000\")) |\n+---------------------------------------------------+\n| 1661759590                                        |\n+---------------------------------------------------+    \n</code></pre> <p>Note</p> <p>The date and time format string passed into <code>timestamp()</code> cannot include any millisecond and microsecond, but the date and time format string passed into <code>timestamp(datetime())</code> can include a millisecond and a microsecond.</p>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#duration","title":"DURATION","text":"<p>The <code>DURATION</code> data type is used to indicate a period of time. Map data that are freely combined by <code>years</code>, <code>months</code>, <code>days</code>, <code>hours</code>, <code>minutes</code>, and <code>seconds</code> indicates the <code>DURATION</code>.</p> <p><code>DURATION</code> has the following features:</p> <ul> <li>Creating indexes for <code>DURATION</code> is not supported.</li> </ul> <ul> <li><code>DURATION</code> can be used to calculate the specified time.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/4.date-and-time/#examples","title":"Examples","text":"<ol> <li> <p>Create a tag named <code>date1</code> with three properties: <code>DATE</code>, <code>TIME</code>, and <code>DATETIME</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS date1(p1 date, p2 time, p3 datetime);\n</code></pre> </li> <li> <p>Insert a vertex named <code>test1</code>.</p> <pre><code>nebula&gt; INSERT VERTEX date1(p1, p2, p3) VALUES \"test1\":(date(\"2021-03-17\"), time(\"17:53:59\"), datetime(\"2017-03-04T22:30:40.003000[Asia/Shanghai]\"));\n</code></pre> </li> <li> <p>Query whether the value of property <code>p1</code> on the <code>test1</code> tag is <code>2021-03-17</code>.</p> <pre><code>nebula&gt; MATCH (v:date1)  RETURN v.date1.p1 == date(\"2021-03-17\");\n+----------------------------------+\n| (v.date1.p1==date(\"2021-03-17\")) |\n+----------------------------------+\n| true                             |\n+----------------------------------+\n</code></pre> </li> <li> <p>Return the content of the property <code>p1</code> on <code>test1</code>.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS date1_index ON date1(p1);\nnebula&gt; REBUILD TAG INDEX date1_index;\nnebula&gt; MATCH (v:date1) RETURN v.date1.p1;\n+------------------+\n| v.date1.p1.month |\n+------------------+\n| 3                |\n+------------------+\n</code></pre> </li> <li> <p>Search for vertices with <code>p3</code> property values less than <code>2023-01-01T00:00:00.000000</code>, and return the <code>p3</code> values.</p> <pre><code>nebula&gt; MATCH (v:date1)  \\\nWHERE v.date1.p3 &lt; datetime(\"2023-01-01T00:00:00.000000\") \\\nRETURN v.date1.p3;\n+----------------------------+\n| v.date1.p3                 |\n+----------------------------+\n| 2017-03-04T14:30:40.003000 |\n+----------------------------+\n</code></pre> </li> <li> <p>Create a tag named <code>school</code> with the property of <code>TIMESTAMP</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS school(name string , found_time timestamp);\n</code></pre> </li> <li> <p>Insert a vertex named <code>DUT</code> with a found-time timestamp of <code>\"1988-03-01T08:00:00\"</code>.</p> <pre><code># Insert as a timestamp. The corresponding timestamp of 1988-03-01T08:00:00 is 573177600, or 573206400 UTC.\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"DUT\":(\"DUT\", 573206400);\n\n# Insert in the form of date and time.\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"DUT\":(\"DUT\", timestamp(\"1988-03-01T08:00:00\"));\n</code></pre> </li> <li> <p>Insert a vertex named <code>dut</code> and store time with <code>now()</code> or <code>timestamp()</code> functions.</p> <pre><code># Use now() function to store time\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"dut\":(\"dut\", now());\n\n# Use timestamp() function to store time\nnebula&gt; INSERT VERTEX school(name, found_time) VALUES \"dut\":(\"dut\", timestamp());\n</code></pre> </li> </ol> <p>You can also use <code>WITH</code> statement to set a specific date and time, or to perform calculations. For example:</p> <pre><code>nebula&gt; WITH time({hour: 12, minute: 31, second: 14, millisecond:111, microsecond: 222}) AS d RETURN d;\n+-----------------+\n| d               |\n+-----------------+\n| 12:31:14.111222 |\n+-----------------+\n\nnebula&gt; WITH date({year: 1984, month: 10, day: 11}) AS x RETURN x + 1;\n+------------+\n| (x+1)      |\n+------------+\n| 1984-10-12 |\n+------------+\n\nnebula&gt; WITH date('1984-10-11') as x, duration({years: 12, days: 14, hours: 99, minutes: 12}) as d \\\n        RETURN x + d AS sum, x - d AS diff;\n+------------+------------+\n| sum        | diff       |\n+------------+------------+\n| 1996-10-29 | 1972-09-23 |\n+------------+------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/5.null/","title":"NULL","text":"<p>You can set the properties for vertices or edges to <code>NULL</code>. Also, you can set the <code>NOT NULL</code> constraint to make sure that the property values are <code>NOT NULL</code>. If not specified, the property is set to <code>NULL</code> by default.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#logical_operations_with_null","title":"Logical operations with NULL","text":"<p>Here is the truth table for <code>AND</code>, <code>OR</code>, <code>XOR</code>, and <code>NOT</code>.</p> a b a AND b a OR b a XOR b NOT a false false false false false true false null false null null true false true false true true true true false false true true false true null null true null false true true true true false false null false false null null null null null null null null null null true null true null null"},{"location":"3.ngql-guide/3.data-types/5.null/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>The comparisons and operations about NULL are different from openCypher. There may be changes later.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#comparisons_with_null","title":"Comparisons with NULL","text":"<p>The comparison operations with NULL are incompatible with openCypher.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#operations_and_return_with_null","title":"Operations and RETURN with NULL","text":"<p>The NULL operations and RETURN with NULL are incompatible with openCypher.</p>"},{"location":"3.ngql-guide/3.data-types/5.null/#examples","title":"Examples","text":""},{"location":"3.ngql-guide/3.data-types/5.null/#use_not_null","title":"Use NOT NULL","text":"<p>Create a tag named <code>player</code>. Specify the property <code>name</code> as <code>NOT NULL</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string NOT NULL, age int);\n</code></pre> <p>Use <code>SHOW</code> to create tag statements. The property <code>name</code> is <code>NOT NULL</code>. The property <code>age</code> is <code>NULL</code> by default.</p> <pre><code>nebula&gt; SHOW CREATE TAG player;\n+-----------+-----------------------------------+\n| Tag       | Create Tag                        |\n+-----------+-----------------------------------+\n| \"student\" | \"CREATE TAG `player` (            |\n|           |  `name` string NOT NULL,          |\n|           |  `age` int64 NULL                 |\n|           | ) ttl_duration = 0, ttl_col = \"\"\" |\n+-----------+-----------------------------------+\n</code></pre> <p>Insert the vertex <code>Kobe</code>. The property <code>age</code> can be <code>NULL</code>.</p> <pre><code>nebula&gt; INSERT VERTEX player(name, age) VALUES \"Kobe\":(\"Kobe\",null);\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/5.null/#use_not_null_and_set_the_default","title":"Use NOT NULL and set the default","text":"<p>Create a tag named <code>player</code>. Specify the property <code>age</code> as <code>NOT NULL</code>. The default value is <code>18</code>.</p> <pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string, age int NOT NULL DEFAULT 18);\n</code></pre> <p>Insert the vertex <code>Kobe</code>. Specify the property <code>name</code> only.</p> <pre><code>nebula&gt; INSERT VERTEX player(name) VALUES \"Kobe\":(\"Kobe\");\n</code></pre> <p>Query the vertex <code>Kobe</code>. The property <code>age</code> is <code>18</code> by default.</p> <pre><code>nebula&gt; FETCH PROP ON player \"Kobe\" YIELD properties(vertex);\n+--------------------------+\n| properties(VERTEX)       |\n+--------------------------+\n| {age: 18, name: \"Kobe\"}  |\n+--------------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/6.list/","title":"Lists","text":"<p>The list is a composite data type. A list is a sequence of values. Individual elements in a list can be accessed by their positions.</p> <p>A list starts with a left square bracket <code>[</code> and ends with a right square bracket <code>]</code>. A list contains zero, one, or more expressions. List elements are separated from each other with commas (<code>,</code>). Whitespace around elements is ignored in the list, thus line breaks, tab stops, and blanks can be used for formatting.</p>"},{"location":"3.ngql-guide/3.data-types/6.list/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>A composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.</p>"},{"location":"3.ngql-guide/3.data-types/6.list/#list_operations","title":"List operations","text":"<p>You can use the preset list function to operate the list, or use the index to filter the elements in the list.</p>"},{"location":"3.ngql-guide/3.data-types/6.list/#index_syntax","title":"Index syntax","text":"<pre><code>[M]\n[M..N]\n[M..]\n[..N]\n</code></pre> <p>The index of nGQL supports queries from front to back, starting from 0. 0 means the first element, 1 means the second element, and so on. It also supports queries from back to front, starting from -1. -1 means the last element, -2 means the penultimate element, and so on.</p> <ul> <li>[M]: represents the element whose index is M.</li> <li>[M..N]: represents the elements whose indexes are <code>greater or equal to M but smaller than N</code>. Return empty when <code>N</code> is 0.</li> <li>[M..]: represents the elements whose indexes are <code>greater or equal to M</code>.</li> <li>[..N]: represents the elements whose indexes are <code>smaller than N</code>. Return empty when <code>N</code> is 0.</li> </ul> <p>Note</p> <ul> <li>Return empty if the index is out of bounds, while return normally if the index is within the bound.</li> <li>Return empty if <code>M</code>\u2265<code>N</code>.</li> <li>When querying a single element, if <code>M</code> is null, return <code>BAD_TYPE</code>. When conducting a range query, if <code>M</code> or <code>N</code> is null, return <code>null</code>.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/6.list/#examples","title":"Examples","text":"<pre><code># The following query returns the list [1,2,3].\nnebula&gt; RETURN list[1, 2, 3] AS a;\n+-----------+\n| a         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query returns the element whose index is 3 in the list [1,2,3,4,5]. In a list, the index starts from 0, and thus the return element is 4.\nnebula&gt; RETURN range(1,5)[3];\n+---------------+\n| range(1,5)[3] |\n+---------------+\n| 4             |\n+---------------+\n\n# The following query returns the element whose index is -2 in the list [1,2,3,4,5]. The index of the last element in a list is -1, and thus the return element is 4.\nnebula&gt; RETURN range(1,5)[-2];\n+------------------+\n| range(1,5)[-(2)] |\n+------------------+\n| 4                |\n+------------------+\n\n# The following query returns the elements whose indexes are from 0 to 3 (not including 3) in the list [1,2,3,4,5].\nnebula&gt; RETURN range(1,5)[0..3];\n+------------------+\n| range(1,5)[0..3] |\n+------------------+\n| [1, 2, 3]        |\n+------------------+\n\n# The following query returns the elements whose indexes are greater than 2 in the list [1,2,3,4,5].\nnebula&gt; RETURN range(1,5)[3..] AS a;\n+--------+\n| a      |\n+--------+\n| [4, 5] |\n+--------+\n\n# The following query returns the elements whose indexes are smaller than 3.\nnebula&gt; WITH list[1, 2, 3, 4, 5] AS a \\\n        RETURN a[..3] AS r;\n+-----------+\n| r         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query filters the elements whose indexes are greater than 2 in the list [1,2,3,4,5], calculate them respectively, and returns them.\nnebula&gt; RETURN [n IN range(1,5) WHERE n &gt; 2 | n + 10] AS a;\n+--------------+\n| a            |\n+--------------+\n| [13, 14, 15] |\n+--------------+\n\n# The following query returns the elements from the first to the penultimate (inclusive) in the list [1, 2, 3].\nnebula&gt; YIELD list[1, 2, 3][0..-1] AS a;\n+--------+\n| a      |\n+--------+\n| [1, 2] |\n+--------+\n\n# The following query returns the elements from the first (exclusive) to the third backward in the list [1, 2, 3, 4, 5].\nnebula&gt; YIELD list[1, 2, 3, 4, 5][-3..-1] AS a;\n+--------+\n| a      |\n+--------+\n| [3, 4] |\n+--------+\n\n# The following query sets the variables and returns the elements whose indexes are 1 and 2.\nnebula&gt; $var = YIELD 1 AS f, 3 AS t; \\\n        YIELD list[1, 2, 3][$var.f..$var.t] AS a;\n+--------+\n| a      |\n+--------+\n| [2, 3] |\n+--------+\n\n# The following query returns empty because the index is out of bound. It will return normally when the index is within the bound.\nnebula&gt; RETURN list[1, 2, 3, 4, 5] [0..10] AS a;\n+-----------------+\n| a               |\n+-----------------+\n| [1, 2, 3, 4, 5] |\n+-----------------+\n\nnebula&gt; RETURN list[1, 2, 3] [-5..5] AS a;\n+-----------+\n| a         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query returns empty because there is a [0..0].\nnebula&gt; RETURN list[1, 2, 3, 4, 5] [0..0] AS a;\n+----+\n| a  |\n+----+\n| [] |\n+----+\n\n# The following query returns empty because of M \u2265 N.\nnebula&gt; RETURN list[1, 2, 3, 4, 5] [3..1] AS a;\n+----+\n| a  |\n+----+\n| [] |\n+----+\n\n# When conduct a range query, if `M` or `N` is null, return `null`.\nnebula&gt; WITH list[1,2,3] AS a \\\n        RETURN a[0..null] as r;\n+----------+\n| r        |\n+----------+\n| __NULL__ |\n+----------+\n\n# The following query calculates the elements in the list [1,2,3,4,5] respectively and returns them without the list head.\nnebula&gt; RETURN tail([n IN range(1, 5) | 2 * n - 10]) AS a;\n+-----------------+\n| a               |\n+-----------------+\n| [-6, -4, -2, 0] |\n+-----------------+\n\n# The following query takes the elements in the list [1,2,3] as true and return.\nnebula&gt; RETURN [n IN range(1, 3) WHERE true | n] AS r;\n+-----------+\n| r         |\n+-----------+\n| [1, 2, 3] |\n+-----------+\n\n# The following query returns the length of the list [1,2,3].\nnebula&gt; RETURN size(list[1,2,3]);\n+-------------------+\n| size(list[1,2,3]) |\n+-------------------+\n| 3                 |\n+-------------------+\n\n# The following query calculates the elements in the list [92,90] and runs a conditional judgment in a where clause.\nnebula&gt; GO FROM \"player100\" OVER follow WHERE properties(edge).degree NOT IN [x IN [92, 90] | x + $$.player.age] \\\n        YIELD dst(edge) AS id, properties(edge).degree AS degree;\n+-------------+--------+\n| id          | degree |\n+-------------+--------+\n| \"player101\" | 95     |\n| \"player102\" | 90     |\n+-------------+--------+\n\n# The following query takes the query result of the MATCH statement as the elements in a list. Then it calculates and returns them.\nnebula&gt; MATCH p = (n:player{name:\"Tim Duncan\"})-[:follow]-&gt;(m) \\\n        RETURN [n IN nodes(p) | n.player.age + 100] AS r;\n+------------+\n| r          |\n+------------+\n| [142, 136] |\n| [142, 141] |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/6.list/#opencypher_compatibility_1","title":"OpenCypher compatibility","text":"<ul> <li>In openCypher, return <code>null</code> when querying a single out-of-bound element. However, in nGQL, return <code>OUT_OF_RANGE</code> when querying a single out-of-bound element.<pre><code>nebula&gt; RETURN range(0,5)[-12];\n+-------------------+\n| range(0,5)[-(12)] |\n+-------------------+\n| OUT_OF_RANGE      |\n+-------------------+\n</code></pre> </li> </ul> <ul> <li> <p>A composite data type (i.e., set, map, and list) CAN NOT be stored as properties for vertices or edges.</p> <p>It is recommended to modify the graph modeling method. The composite data type should be modeled as an adjacent edge of a vertex, rather than its property. Each adjacent edge can be dynamically added or deleted. The rank values of the adjacent edges can be used for sequencing.</p> </li> </ul> <ul> <li>Patterns are not supported in the list. For example, <code>[(src)-[]-&gt;(m) | m.name]</code>.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/7.set/","title":"Sets","text":"<p>The set is a composite data type. A set is a set of values. Unlike a List, values in a set are unordered and each value must be unique.</p> <p>A set starts with a left curly bracket <code>{</code> and ends with a right curly bracket <code>}</code>. A set contains zero, one, or more expressions. Set elements are separated from each other with commas (<code>,</code>). Whitespace around elements is ignored in the set, thus line breaks, tab stops, and blanks can be used for formatting.</p>"},{"location":"3.ngql-guide/3.data-types/7.set/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<ul> <li>A composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.</li> </ul> <ul> <li>A set is not a data type in openCypher, but in nGQL, users can use the set.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/7.set/#examples","title":"Examples","text":"<pre><code># The following query returns the set {1,2,3}.\nnebula&gt; RETURN set{1, 2, 3} AS a;\n+-----------+\n| a         |\n+-----------+\n| {3, 2, 1} |\n+-----------+\n\n# The following query returns the set {1,2}, Because the set does not allow repeating elements, and the order is unordered.\nnebula&gt; RETURN set{1, 2, 1} AS a;\n+--------+\n| a      |\n+--------+\n| {2, 1} |\n+--------+\n\n# The following query checks whether the set has the specified element 1.\nnebula&gt; RETURN 1 IN set{1, 2} AS a;\n+------+\n| a    |\n+------+\n| true |\n+------+\n\n# The following query counts the number of elements in the set.\nnebula&gt; YIELD size(set{1, 2, 1}) AS a;\n+---+\n| a |\n+---+\n| 2 |\n+---+\n\n# The following query returns a set of target vertex property values.\nnebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD set{properties($$).name,properties($$).age} as a;\n+-----------------------+\n| a                     |\n+-----------------------+\n| {36, \"Tony Parker\"}   |\n| {41, \"Manu Ginobili\"} |\n+-----------------------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/8.map/","title":"Maps","text":"<p>The map is a composite data type. Maps are unordered collections of key-value pairs. In maps, the key is a string. The value can have any data type. You can get the map element by using <code>map['key']</code>.</p> <p>A map starts with a left curly bracket <code>{</code> and ends with a right curly bracket <code>}</code>. A map contains zero, one, or more key-value pairs. Map elements are separated from each other with commas (<code>,</code>). Whitespace around elements is ignored in the map, thus line breaks, tab stops, and blanks can be used for formatting.</p>"},{"location":"3.ngql-guide/3.data-types/8.map/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<ul> <li>A composite data type (i.e. set, map, and list) CANNOT be stored as properties of vertices or edges.</li> </ul> <ul> <li>Map projection is not supported.</li> </ul>"},{"location":"3.ngql-guide/3.data-types/8.map/#examples","title":"Examples","text":"<pre><code># The following query returns the simple map.\nnebula&gt; YIELD map{key1: 'Value1', Key2: 'Value2'} as a;\n+----------------------------------+\n| a                                |\n+----------------------------------+\n| {Key2: \"Value2\", key1: \"Value1\"} |\n+----------------------------------+\n\n# The following query returns the list type map.\nnebula&gt; YIELD map{listKey: [{inner: 'Map1'}, {inner: 'Map2'}]} as a;\n+-----------------------------------------------+\n| a                                             |\n+-----------------------------------------------+\n| {listKey: [{inner: \"Map1\"}, {inner: \"Map2\"}]} |\n+-----------------------------------------------+\n\n# The following query returns the hybrid type map.\nnebula&gt; RETURN map{a: LIST[1,2], b: SET{1,2,1}, c: \"hee\"} as a;\n+----------------------------------+\n| a                                |\n+----------------------------------+\n| {a: [1, 2], b: {2, 1}, c: \"hee\"} |\n+----------------------------------+\n\n# The following query returns the specified element in a map.\nnebula&gt; RETURN map{a: LIST[1,2], b: SET{1,2,1}, c: \"hee\"}[\"b\"] AS b;\n+--------+\n| b      |\n+--------+\n| {2, 1} |\n+--------+\n\n# The following query checks whether the map has the specified key, not support checks whether the map has the specified value yet.\nnebula&gt; RETURN \"a\" IN MAP{a:1, b:2} AS a;\n+------+\n| a    |\n+------+\n| true |\n+------+\n</code></pre>"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/","title":"Type Conversion/Type coercions","text":"<p>Converting an expression of a given type to another type is known as type conversion.</p> <p>NebulaGraph supports converting expressions explicit to other types. For details, see Type conversion functions.</p>"},{"location":"3.ngql-guide/3.data-types/9.type-conversion/#examples","title":"Examples","text":"<pre><code>nebula&gt; UNWIND [true, false, 'true', 'false', NULL] AS b \\\n        RETURN toBoolean(b) AS b;\n+----------+\n| b        |\n+----------+\n| true     |\n| false    |\n| true     |\n| false    |\n| __NULL__ |\n+----------+\n\nnebula&gt; RETURN toFloat(1), toFloat('1.3'), toFloat('1e3'), toFloat('not a number');\n+------------+----------------+----------------+-------------------------+\n| toFloat(1) | toFloat(\"1.3\") | toFloat(\"1e3\") | toFloat(\"not a number\") |\n+------------+----------------+----------------+-------------------------+\n| 1.0        | 1.3            | 1000.0         | __NULL__                |\n+------------+----------------+----------------+-------------------------+\n</code></pre>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/1.composite-queries/","title":"Composite queries (clause structure)","text":"<p>Composite queries put data from different queries together. They then use filters, group-bys, or sorting before returning the combined return results.</p> <p>Nebula\u00a0Graph supports three methods to run composite queries (or sub-queries):</p> <ul> <li>(openCypher) Clauses are chained together, and they feed intermediate result sets between each other.</li> </ul> <ul> <li>(Native nGQL) More than one query can be batched together, separated by semicolons (;). The result of the last query is returned as the result of the batch.</li> </ul> <ul> <li>(Native nGQL) Queries can be piped together by using the pipe (<code>|</code>). The result of the previous query can be used as the input of the next query.</li> </ul>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/1.composite-queries/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>In a composite query, do not put together openCypher and native nGQL clauses in one statement. For example, this statement is undefined: <code>MATCH ... | GO ... | YIELD ...</code>.</p> <ul> <li>If you are in the openCypher way (<code>MATCH</code>, <code>RETURN</code>, <code>WITH</code>, etc), do not introduce any pipe or semicolons to combine the sub-clauses.</li> </ul> <ul> <li>If you are in the native nGQL way (<code>FETCH</code>, <code>GO</code>, <code>LOOKUP</code>, etc), you must use pipe or semicolons to combine the sub-clauses.</li> </ul>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/1.composite-queries/#composite_queries_are_not_transactional_queries_as_in_sqlcypher","title":"Composite queries are not <code>transactional</code> queries (as in SQL/Cypher)","text":"<p>For example, a query is composed of three sub-queries: <code>A B C</code>, <code>A | B | C</code> or <code>A; B; C</code>. In that A is a read operation, B is a computation operation, and C is a write operation. If any part fails in the execution, the whole result will be undefined. There is no rollback. What is written depends on the query executor.</p> <p>Note</p> <p>OpenCypher has no requirement of <code>transaction</code>.</p>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/1.composite-queries/#examples","title":"Examples","text":"<ul> <li>OpenCypher compatibility statement<pre><code># Connect multiple queries with clauses.\nnebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--() \\\n        WITH nodes(p) AS n \\\n        UNWIND n AS n1 \\\n        RETURN DISTINCT n1;\n</code></pre> </li> </ul> <ul> <li>Native nGQL (Semicolon queries)<pre><code># Only return edges.\nnebula&gt; SHOW TAGS; SHOW EDGES;\n\n# Insert multiple vertices.\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42); \\\n        INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36); \\\n        INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33);\n</code></pre> </li> </ul> <ul> <li>Native nGQL (Pipe queries)<pre><code># Connect multiple queries with pipes.\nnebula&gt; GO FROM \"player100\" OVER follow YIELD dst(edge) AS id | \\\n        GO FROM $-.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;\n+-----------+-----------------+\n| Team      | Player          |\n+-----------+-----------------+\n| \"Spurs\"   | \"Tony Parker\"   |\n| \"Hornets\" | \"Tony Parker\"   |\n| \"Spurs\"   | \"Manu Ginobili\" |\n+-----------+-----------------+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/2.user-defined-variables/","title":"User-defined variables","text":"<p>User-defined variables allow passing the result of one statement to another.</p>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/2.user-defined-variables/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>In openCypher, when you refer to the vertex, edge, or path of a variable, you need to name it first. For example:</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) RETURN v;\n+----------------------------------------------------+\n| v                                                  |\n+----------------------------------------------------+\n| (\"player100\" :player{name: \"Tim Duncan\", age: 42}) |\n+----------------------------------------------------+\n</code></pre> <p>The user-defined variable in the preceding query is <code>v</code>.</p> <p>Caution</p> <p>In a pattern of a MATCH statement, you cannot use the same edge variable repeatedly. For example, <code>e</code> cannot be written in the pattern <code>p=(v1)-[e*2..2]-&gt;(v2)-[e*2..2]-&gt;(v3)</code>.</p>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/2.user-defined-variables/#native_ngql","title":"Native nGQL","text":"<p>User-defined variables are written as <code>$var_name</code>. The <code>var_name</code> consists of letters, numbers, or underline characters. Any other characters are not permitted.</p> <p>The user-defined variables are valid only at the current execution (namely, in this composite query). When the execution ends, the user-defined variables will be automatically expired. The user-defined variables in one statement CANNOT be used in any other clients, executions, or sessions.</p> <p>You can use user-defined variables in composite queries. Details about composite queries, see Composite queries.</p> <p>Note</p> <ul> <li>User-defined variables are case-sensitive.</li> <li>To define a user-defined variable in a compound statement, end the statement with a semicolon (;). For details, please refer to the nGQL Style Guide.</li> </ul>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/2.user-defined-variables/#example","title":"Example","text":"<pre><code>nebula&gt; $var = GO FROM \"player100\" OVER follow YIELD dst(edge) AS id; \\\n        GO FROM $var.id OVER serve YIELD properties($$).name AS Team, \\\n        properties($^).name AS Player;\n+-----------+-----------------+\n| Team      | Player          |\n+-----------+-----------------+\n| \"Spurs\"   | \"Tony Parker\"   |\n| \"Hornets\" | \"Tony Parker\"   |\n| \"Spurs\"   | \"Manu Ginobili\" |\n+-----------+-----------------+\n</code></pre>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/2.user-defined-variables/#set_operations_and_scope_of_user-defined_variables","title":"Set operations and scope of user-defined variables","text":"<p>When assigning variables within a compound statement involving set operations, it is important to enclose the scope of the variable assignment in parentheses. In the example below, the source of the <code>$var</code> assignment is the results of the output of two <code>INTERSECT</code> statements. </p> <pre><code>$var = ( \\\n    GO FROM \"player100\" OVER follow \\\n      YIELD dst(edge) AS id \\\n    INTERSECT \\\n    GO FROM \"player100\" OVER follow \\\n      YIELD dst(edge) AS id \\\n       ); \\\n    GO FROM $var.id OVER follow YIELD follow.degree AS degree\n</code></pre>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/","title":"Reference to properties","text":"<p>nGQL provides property references to allow you to refer to the properties of the source vertex, the destination vertex, and the edge in the <code>GO</code> statement, and to refer to the output results of the statement in composite queries. This topic describes how to use these property references in nGQL.</p> <p>Note</p> <p>This function applies to native nGQL only.</p>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#property_references_for_vertexes","title":"Property references for vertexes","text":"Parameter Description <code>$^</code> Used to get the property of the source vertex. <code>$$</code> Used to get the property of the destination vertex."},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#property_reference_syntax","title":"Property reference syntax","text":"<pre><code>$^.&lt;tag_name&gt;.&lt;prop_name&gt;  # Source vertex property reference\n$$.&lt;tag_name&gt;.&lt;prop_name&gt;   # Destination vertex property reference\n</code></pre> <ul> <li><code>tag_name</code>: The tag name of the vertex.</li> <li><code>prop_name</code>: The property name within the tag.</li> </ul>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#property_references_for_edges","title":"Property references for edges","text":"Parameter Description <code>_src</code> The source vertex ID of the edge <code>_dst</code> The destination vertex ID of the edge <code>_type</code> The internal encoding of edge types that uses sign to indicate direction. Positive numbers represent forward edges, while negative numbers represent backward edges. <code>_rank</code> The rank value for the edge"},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#property_reference_syntax_1","title":"Property reference syntax","text":"<p>nGQL allows you to reference edge properties, including user-defined edge properties and four built-in edge properties.</p> <pre><code>&lt;edge_type&gt;.&lt;prop_name&gt;  # User-defined edge property reference\n&lt;edge_type&gt;._src|_dst|_type|_rank  # Built-in edge property reference\n</code></pre> <ul> <li><code>edge_type</code>: The edge type.</li> <li><code>prop_name</code>: The property name within the edge type.</li> </ul>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#property_references_for_composite_queries","title":"Property references for composite queries","text":"Parameter Description <code>$-</code> Used to get the output results of the statement before the pipe in the composite query. For more information, see Pipe."},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#examples","title":"Examples","text":""},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#use_property_references_for_vertexes","title":"Use property references for vertexes","text":"<p>The following query returns the <code>name</code> property of the <code>player</code> tag on the source vertex and the <code>age</code> property of the <code>player</code> tag on the destination vertex.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow YIELD $^.player.name AS startName, $$.player.age AS endAge;\n+--------------+--------+\n| startName    | endAge |\n+--------------+--------+\n| \"Tim Duncan\" | 36     |\n| \"Tim Duncan\" | 41     |\n+--------------+--------+\n</code></pre> <p>Legacy version compatibility</p> <p>Starting from NebulaGraph 2.6.0, Schema-related functions are supported. The preceding example can be rewritten as follows in NebulaGraph 3.8.0 to produce the same results: </p> <pre><code>GO FROM \"player100\" OVER follow YIELD properties($^).name AS startName, properties($$).age AS endAge;\n</code></pre> <p>NebulaGraph 3.8.0 is compatible with both new and old syntax.</p>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#use_property_references_for_edges","title":"Use property references for edges","text":"<p>The following query returns the <code>degree</code> property of the edge type <code>follow</code>.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow YIELD follow.degree;\n+---------------+\n| follow.degree |\n+---------------+\n| 95            |\n+---------------+\n</code></pre> <p>The following query returns the source vertex, the destination vertex, the edge type, and the edge rank value of the edge type <code>follow</code>.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow YIELD follow._src, follow._dst, follow._type, follow._rank;\n+-------------+-------------+--------------+--------------+\n| follow._src | follow._dst | follow._type | follow._rank |\n+-------------+-------------+--------------+--------------+\n| \"player100\" | \"player101\" | 17           | 0            |\n| \"player100\" | \"player125\" | 17           | 0            |\n+-------------+-------------+--------------+--------------+\n</code></pre> <p>Legacy version compatibility</p> <p>Starting from NebulaGraph 2.6.0, Schema-related functions are supported. The preceding example can be rewritten as follows in NebulaGraph 3.8.0 to produce the same results: </p> <pre><code>GO FROM \"player100\" OVER follow YIELD properties(edge).degree;\nGO FROM \"player100\" OVER follow YIELD src(edge), dst(edge), type(edge), rank(edge);\n</code></pre> <p>NebulaGraph 3.8.0 is compatible with both new and old syntax.</p>"},{"location":"3.ngql-guide/4.variable-and-composite-queries/3.property-reference/#use_property_references_for_composite_queries","title":"Use property references for composite queries","text":"<p>The following composite query performs the following actions:</p> <ol> <li>Uses the property reference <code>$-.id</code> to get the results of the statement <code>GO FROM \"player100\" OVER follow YIELD dst(edge) AS id</code>, which returns the destination vertex ID of the <code>follow</code> edge type.</li> <li>Uses the <code>properties($^)</code> function to get the name property of the player tag on the source vertex of the <code>serve</code> edge type.</li> <li>Uses the <code>properties($$)</code> function to get the name property of the team tag on the destination vertex of the <code>serve</code> edge type.</li> </ol> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS id | \\\n        GO FROM $-.id OVER serve \\\n        YIELD properties($^).name AS Player, properties($$).name AS Team;\n+-----------------+-----------+\n| Player          | Team      |\n+-----------------+-----------+\n| \"Tony Parker\"   | \"Spurs\"   |\n| \"Tony Parker\"   | \"Hornets\" |\n| \"Manu Ginobili\" | \"Spurs\"   |\n+-----------------+-----------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/","title":"Comparison operators","text":"<p>NebulaGraph supports the following comparison operators.</p> Name Description <code>==</code> Equal operator <code>!=</code>, <code>&lt;&gt;</code> Not equal operator <code>&gt;</code> Greater than operator <code>&gt;=</code> Greater than or equal operator <code>&lt;</code> Less than operator <code>&lt;=</code> Less than or equal operator <code>IS NULL</code> NULL check <code>IS NOT NULL</code> Not NULL check <code>IS EMPTY</code> EMPTY check <code>IS NOT EMPTY</code> Not EMPTY check <p>The result of the comparison operation is <code>true</code> or <code>false</code>.</p> <p>Note</p> <ul> <li>Comparability between values of different types is often undefined. The result could be <code>NULL</code> or others.</li> </ul> <ul> <li><code>EMPTY</code> is currently used only for checking, and does not support functions or operations such as <code>GROUP BY</code>, <code>count()</code>, <code>sum()</code>, <code>max()</code>, <code>hash()</code>, <code>collect()</code>, <code>+</code> or <code>*</code>.</li> </ul>"},{"location":"3.ngql-guide/5.operators/1.comparison/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>openCypher does not have <code>EMPTY</code>. Thus <code>EMPTY</code> is not supported in MATCH statements.</p>"},{"location":"3.ngql-guide/5.operators/1.comparison/#examples","title":"Examples","text":""},{"location":"3.ngql-guide/5.operators/1.comparison/#_1","title":"<code>==</code>","text":"<p>String comparisons are case-sensitive. Values of different types are not equal.</p> <p>Note</p> <p>The equal operator is <code>==</code> in nGQL, while in openCypher it is <code>=</code>.</p> <pre><code>nebula&gt; RETURN 'A' == 'a', toUpper('A') == toUpper('a'), toLower('A') == toLower('a');\n+------------+------------------------------+------------------------------+\n| (\"A\"==\"a\") | (toUpper(\"A\")==toUpper(\"a\")) | (toLower(\"A\")==toLower(\"a\")) |\n+------------+------------------------------+------------------------------+\n| false      | true                         | true                         |\n+------------+------------------------------+------------------------------+\n\nnebula&gt; RETURN '2' == 2, toInteger('2') == 2;\n+----------+---------------------+\n| (\"2\"==2) | (toInteger(\"2\")==2) |\n+----------+---------------------+\n| false    | true                |\n+----------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#_2","title":"<code>&gt;</code>","text":"<pre><code>nebula&gt; RETURN 3 &gt; 2;\n+-------+\n| (3&gt;2) |\n+-------+\n| true  |\n+-------+\n\nnebula&gt; WITH 4 AS one, 3 AS two \\\n        RETURN one &gt; two AS result;\n+--------+\n| result |\n+--------+\n| true   |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#_3","title":"<code>&gt;=</code>","text":"<pre><code>nebula&gt; RETURN 2 &gt;= \"2\", 2 &gt;= 2;\n+----------+--------+\n| (2&gt;=\"2\") | (2&gt;=2) |\n+----------+--------+\n| __NULL__ | true   |\n+----------+--------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#_4","title":"<code>&lt;</code>","text":"<pre><code>nebula&gt; YIELD 2.0 &lt; 1.9;\n+---------+\n| (2&lt;1.9) |\n+---------+\n| false   |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#_5","title":"<code>&lt;=</code>","text":"<pre><code>nebula&gt; YIELD 0.11 &lt;= 0.11;\n+--------------+\n| (0.11&lt;=0.11) |\n+--------------+\n| true         |\n+--------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#_6","title":"<code>!=</code>","text":"<pre><code>nebula&gt; YIELD 1 != '1';\n+----------+\n| (1!=\"1\") |\n+----------+\n| true     |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#is_not_null","title":"<code>IS [NOT] NULL</code>","text":"<pre><code>nebula&gt; RETURN null IS NULL AS value1, null == null AS value2, null != null AS value3;\n+--------+----------+----------+\n| value1 | value2   | value3   |\n+--------+----------+----------+\n| true   | __NULL__ | __NULL__ |\n+--------+----------+----------+\n\nnebula&gt; RETURN length(NULL), size(NULL), count(NULL), NULL IS NULL, NULL IS NOT NULL, sin(NULL), NULL + NULL, [1, NULL] IS NULL;\n+--------------+------------+-------------+--------------+------------------+-----------+-------------+------------------+\n| length(NULL) | size(NULL) | count(NULL) | NULL IS NULL | NULL IS NOT NULL | sin(NULL) | (NULL+NULL) | [1,NULL] IS NULL |\n+--------------+------------+-------------+--------------+------------------+-----------+-------------+------------------+\n| __NULL__     | __NULL__   | 0           | true         | false            | __NULL__  | __NULL__    | false            |\n+--------------+------------+-------------+--------------+------------------+-----------+-------------+------------------+\n\nnebula&gt; WITH {name: null} AS `map` \\\n        RETURN `map`.name IS NOT NULL;\n+----------------------+\n| map.name IS NOT NULL |\n+----------------------+\n| false                |\n+----------------------+\n\nnebula&gt; WITH {name: 'Mats', name2: 'Pontus'} AS map1, \\\n        {name: null} AS map2, {notName: 0, notName2: null } AS map3 \\\n        RETURN map1.name IS NULL, map2.name IS NOT NULL, map3.name IS NULL;\n+-------------------+-----------------------+-------------------+\n| map1.name IS NULL | map2.name IS NOT NULL | map3.name IS NULL |\n+-------------------+-----------------------+-------------------+\n| false             | false                 | true              |\n+-------------------+-----------------------+-------------------+\n\nnebula&gt; MATCH (n:player) \\\n        RETURN n.player.age IS NULL, n.player.name IS NOT NULL, n.player.empty IS NULL;\n+----------------------+---------------------------+------------------------+\n| n.player.age IS NULL | n.player.name IS NOT NULL | n.player.empty IS NULL |\n+----------------------+---------------------------+------------------------+\n| false                | true                      | true                   |\n| false                | true                      | true                   |\n...\n</code></pre>"},{"location":"3.ngql-guide/5.operators/1.comparison/#is_not_empty","title":"<code>IS [NOT] EMPTY</code>","text":"<pre><code>nebula&gt; RETURN null IS EMPTY;\n+---------------+\n| NULL IS EMPTY |\n+---------------+\n| false         |\n+---------------+\n\nnebula&gt; RETURN \"a\" IS NOT EMPTY;\n+------------------+\n| \"a\" IS NOT EMPTY |\n+------------------+\n| true             |\n+------------------+\n\nnebula&gt; GO FROM \"player100\" OVER * WHERE properties($$).name IS NOT EMPTY YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"team204\"   |\n| \"player101\" |\n| \"player125\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/10.arithmetic/","title":"Arithmetic operators","text":"<p>NebulaGraph supports the following arithmetic operators.</p> Name Description <code>+</code> Addition operator <code>-</code> Minus operator <code>*</code> Multiplication operator <code>/</code> Division operator <code>%</code> Modulo operator <code>-</code> Changes the sign of the argument"},{"location":"3.ngql-guide/5.operators/10.arithmetic/#examples","title":"Examples","text":"<pre><code>nebula&gt; RETURN 1+2 AS result;\n+--------+\n| result |\n+--------+\n| 3      |\n+--------+\n\nnebula&gt; RETURN -10+5 AS result;\n+--------+\n| result |\n+--------+\n| -5     |\n+--------+\n\nnebula&gt; RETURN (3*8)%5 AS result;\n+--------+\n| result |\n+--------+\n| 4      |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/2.boolean/","title":"Boolean operators","text":"<p>NebulaGraph supports the following boolean operators.</p> Name Description AND Logical AND NOT Logical NOT OR Logical OR XOR Logical XOR <p>For the precedence of the operators, refer to Operator Precedence.</p> <p>For the logical operations with <code>NULL</code>, refer to NULL.</p>"},{"location":"3.ngql-guide/5.operators/2.boolean/#legacy_version_compatibility","title":"Legacy version compatibility","text":"<ul> <li>Non-zero numbers cannot be converted to boolean values.</li> </ul>"},{"location":"3.ngql-guide/5.operators/4.pipe/","title":"Pipe operators","text":"<p>Multiple queries can be combined using pipe operators in nGQL.</p>"},{"location":"3.ngql-guide/5.operators/4.pipe/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>Pipe operators apply to native nGQL only.</p>"},{"location":"3.ngql-guide/5.operators/4.pipe/#syntax","title":"Syntax","text":"<p>One major difference between nGQL and SQL is how sub-queries are composed.</p> <ul> <li>In SQL, sub-queries are nested in the query statements.</li> </ul> <ul> <li>In nGQL, the shell style <code>PIPE (|)</code> is introduced into the sub-queries.</li> </ul>"},{"location":"3.ngql-guide/5.operators/4.pipe/#examples","title":"Examples","text":"<pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS dstid, properties($$).name AS Name | \\\n        GO FROM $-.dstid OVER follow YIELD dst(edge);\n\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player100\" |\n| \"player102\" |\n| \"player125\" |\n| \"player100\" |\n+-------------+\n</code></pre> <p>Users must define aliases in the <code>YIELD</code> clause for the reference operator <code>$-</code> to use, just like <code>$-.dstid</code> in the preceding example.</p>"},{"location":"3.ngql-guide/5.operators/4.pipe/#performance_tips","title":"Performance tips","text":"<p>In NebulaGraph, pipes will affect the performance. Take <code>A | B</code> as an example, the effects are as follows:</p> <ol> <li> <p>Pipe operators operate synchronously. That is, the data can enter the pipe clause as a whole after the execution of clause <code>A</code> before the pipe operator is completed.</p> </li> <li> <p>If <code>A</code> sends a large amount of data to <code>|</code>, the entire query request may be very slow. You can try to split this statement.</p> <ol> <li> <p>Send <code>A</code> from the application,</p> </li> <li> <p>Split the return results on the application,</p> </li> <li> <p>Send to multiple graphd processes concurrently,</p> </li> <li> <p>Every graphd process executes part of B.</p> </li> </ol> <p>This is usually much faster than executing a complete <code>A | B</code> with a single graphd process.</p> </li> </ol>"},{"location":"3.ngql-guide/5.operators/6.set/","title":"Set operators","text":"<p>This topic will describe the set operators, including <code>UNION</code>, <code>UNION ALL</code>, <code>INTERSECT</code>, and <code>MINUS</code>. To combine multiple queries, use these set operators.</p> <p>All set operators have equal precedence. If a nGQL statement contains multiple set operators, NebulaGraph will evaluate them from left to right unless parentheses explicitly specify another order.</p> <p>Caution</p> <p>The names and order of the variables defined in the query statements before and after the set operator must be consistent. For example, the names and order of <code>a,b,c</code> in <code>RETURN a,b,c UNION RETURN a,b,c</code> need to be consistent.</p>"},{"location":"3.ngql-guide/5.operators/6.set/#union_union_distinct_and_union_all","title":"UNION, UNION DISTINCT, and UNION ALL","text":"<pre><code>&lt;left&gt; UNION [DISTINCT | ALL] &lt;right&gt; [ UNION [DISTINCT | ALL] &lt;right&gt; ...]\n</code></pre> <ul> <li>Operator <code>UNION DISTINCT</code> (or by short <code>UNION</code>) returns the union of two sets A and B without duplicated elements.</li> </ul> <ul> <li>Operator <code>UNION ALL</code> returns the union of two sets A and B with duplicated elements.</li> </ul> <ul> <li>The <code>&lt;left&gt;</code> and <code>&lt;right&gt;</code> must have the same number of columns and data types. Different data types are converted according to the Type Conversion.</li> </ul>"},{"location":"3.ngql-guide/5.operators/6.set/#examples","title":"Examples","text":"<pre><code># The following statement returns the union of two query results without duplicated elements.\nnebula&gt; GO FROM \"player102\" OVER follow YIELD dst(edge) \\\n        UNION \\\n        GO FROM \"player100\" OVER follow YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n| \"player125\" |\n+-------------+\n\nnebula&gt; MATCH (v:player) \\\n        WITH v.player.name AS v \\\n        RETURN n ORDER BY n LIMIT 3 \\\n        UNION \\\n        UNWIND [\"Tony Parker\", \"Ben Simmons\"] AS n \\\n        RETURN n;\n+---------------------+\n| n                   |\n+---------------------+\n| \"Amar'e Stoudemire\" |\n| \"Aron Baynes\"       |\n| \"Ben Simmons\"       |\n| \"Tony Parker\"       |\n+---------------------+\n\n# The following statement returns the union of two query results with duplicated elements.\nnebula&gt; GO FROM \"player102\" OVER follow YIELD dst(edge) \\\n        UNION ALL \\\n        GO FROM \"player100\" OVER follow YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n| \"player101\" |\n| \"player125\" |\n+-------------+\n\nnebula&gt; MATCH (v:player) \\\n        WITH v.player.name AS n \\\n        RETURN n ORDER BY n LIMIT 3 \\\n        UNION ALL \\\n        UNWIND [\"Tony Parker\", \"Ben Simmons\"] AS n \\\n        RETURN n;\n+---------------------+\n| n                   |\n+---------------------+\n| \"Amar'e Stoudemire\" |\n| \"Aron Baynes\"       |\n| \"Ben Simmons\"       |\n| \"Tony Parker\"       |\n| \"Ben Simmons\"       |\n+---------------------+\n\n# UNION can also work with the YIELD statement. The DISTINCT keyword will check duplication by all the columns for every line, and remove duplicated lines if every column is the same.\nnebula&gt; GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age \\\n        UNION /* DISTINCT */ \\\n        GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age;\n+-------------+--------+-----+\n| id          | Degree | Age |\n+-------------+--------+-----+\n| \"player100\" | 75     | 42  |\n| \"player101\" | 75     | 36  |\n| \"player101\" | 95     | 36  |\n| \"player125\" | 95     | 41  |\n+-------------+--------+-----+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/6.set/#intersect","title":"INTERSECT","text":"<pre><code>&lt;left&gt; INTERSECT &lt;right&gt;\n</code></pre> <ul> <li>Operator <code>INTERSECT</code> returns the intersection of two sets A and B (denoted by A \u22c2 B).</li> </ul> <ul> <li>Similar to <code>UNION</code>, the <code>left</code> and <code>right</code> must have the same number of columns and data types. Different data types are converted according to the Type Conversion.</li> </ul>"},{"location":"3.ngql-guide/5.operators/6.set/#example","title":"Example","text":"<pre><code># The following statement returns the intersection of two query results.\nnebula&gt; GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age \\\n        INTERSECT \\\n        GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS id, properties(edge).degree AS Degree, properties($$).age AS Age;\n+----+--------+-----+\n| id | Degree | Age |\n+----+--------+-----+\n+----+--------+-----+\n\nnebula&gt; MATCH (v:player)-[e:follow]-&gt;(v2) \\\n        WHERE id(v) == \"player102\" \\\n        RETURN id(v2) As id, e.degree As Degree, v2.player.age AS Age \\\n        INTERSECT \\\n        MATCH (v:player)-[e:follow]-&gt;(v2) \\\n        WHERE id(v) == \"player100\" \\\n        RETURN id(v2) As id, e.degree As Degree, v2.player.age AS Age;\n+----+--------+-----+\n| id | Degree | Age |\n+----+--------+-----+\n+----+--------+-----+\n\nnebula&gt; UNWIND [1,2] AS a RETURN a \\\n        INTERSECT \\\n        UNWIND [1,2,3,4] AS a \\\n        RETURN a;\n+---+\n| a |\n+---+\n| 1 |\n| 2 |\n+---+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/6.set/#minus","title":"MINUS","text":"<pre><code>&lt;left&gt; MINUS &lt;right&gt;\n</code></pre> <p>Operator <code>MINUS</code> returns the subtraction (or difference) of two sets A and B (denoted by <code>A-B</code>). Always pay attention to the order of <code>left</code> and <code>right</code>. The set <code>A-B</code> consists of elements that are in A but not in B.</p>"},{"location":"3.ngql-guide/5.operators/6.set/#example_1","title":"Example","text":"<pre><code># The following statement returns the elements in the first query result but not in the second query result.\nnebula&gt; GO FROM \"player100\" OVER follow YIELD dst(edge) \\\n        MINUS \\\n        GO FROM \"player102\" OVER follow YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player125\" |\n+-------------+\n\nnebula&gt; GO FROM \"player102\" OVER follow YIELD dst(edge) AS id\\\n        MINUS \\\n        GO FROM \"player100\" OVER follow YIELD dst(edge) AS id;\n+-------------+\n| id          |\n+-------------+\n| \"player100\" |\n+-------------+\n\nnebula&gt; MATCH (v:player)-[e:follow]-&gt;(v2) \\\n        WHERE id(v) ==\"player102\" \\\n        RETURN id(v2) AS id\\\n        MINUS \\\n        MATCH (v:player)-[e:follow]-&gt;(v2) \\\n        WHERE id(v) ==\"player100\" \\\n        RETURN id(v2) AS id;\n+-------------+\n| id          |\n+-------------+\n| \"player100\" |\n+-------------+\n\nnebula&gt; UNWIND [1,2,3] AS a RETURN a \\\n        MINUS \\\n        WITH 4 AS a \\\n        RETURN a;\n+---+\n| a |\n+---+\n| 1 |\n| 2 |\n| 3 |\n+---+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/6.set/#precedence_of_the_set_operators_and_pipe_operators","title":"Precedence of the set operators and pipe operators","text":"<p>Please note that when a query contains a pipe <code>|</code> and a set operator, the pipe takes precedence. Refer to Pipe for details. The query <code>GO FROM 1 UNION GO FROM 2 | GO FROM 3</code> is the same as the query <code>GO FROM 1 UNION (GO FROM 2 | GO FROM 3)</code>.</p>"},{"location":"3.ngql-guide/5.operators/6.set/#examples_1","title":"Examples","text":"<pre><code>nebula&gt; GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS play_dst  \\\n        UNION \\\n        GO FROM \"team200\" OVER serve REVERSELY \\\n        YIELD src(edge) AS play_src \\\n        | GO FROM $-.play_src OVER follow YIELD dst(edge) AS play_dst;\n\n+-------------+\n| play_dst    |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n| \"player117\" |\n| \"player105\" |\n+-------------+\n</code></pre> <p>The above query executes the statements in the red bar first and then executes the statement in the green box.</p> <p>The parentheses can change the execution priority. For example:</p> <pre><code>nebula&gt; (GO FROM \"player102\" OVER follow \\\n        YIELD dst(edge) AS play_dst  \\\n        UNION \\\n        GO FROM \"team200\" OVER serve REVERSELY \\\n        YIELD src(edge) AS play_dst) \\\n        | GO FROM $-.play_dst OVER follow YIELD dst(edge) AS play_dst;\n</code></pre> <p>In the above query, the statements within the parentheses take precedence. That is, the <code>UNION</code> operation will be executed first, and its output will be executed as the input of the next operation with pipes.</p>"},{"location":"3.ngql-guide/5.operators/7.string/","title":"String operators","text":"<p>You can use the following string operators for concatenating, querying, and matching.</p> Name Description + Concatenates strings. CONTAINS Performs searchings in strings. (NOT) IN Checks whether a value is within a set of values. (NOT) STARTS WITH Performs matchings at the beginning of a string. (NOT) ENDS WITH Performs matchings at the end of a string. Regular expressions Perform string matchings using regular expressions. <p>Note</p> <p>All the string searchings or matchings are case-sensitive.</p>"},{"location":"3.ngql-guide/5.operators/7.string/#examples","title":"Examples","text":""},{"location":"3.ngql-guide/5.operators/7.string/#_1","title":"<code>+</code>","text":"<pre><code>nebula&gt; RETURN 'a' + 'b';\n+-----------+\n| (\"a\"+\"b\") |\n+-----------+\n| \"ab\"      |\n+-----------+\nnebula&gt; UNWIND 'a' AS a UNWIND 'b' AS b RETURN a + b;\n+-------+\n| (a+b) |\n+-------+\n| \"ab\"  |\n+-------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/7.string/#contains","title":"<code>CONTAINS</code>","text":"<p>The <code>CONTAINS</code> operator requires string types on both left and right sides.</p> <pre><code>nebula&gt; MATCH (s:player)-[e:serve]-&gt;(t:team) WHERE id(s) == \"player101\" \\\n        AND t.team.name CONTAINS \"ets\" RETURN s.player.name, e.start_year, e.end_year, t.team.name;\n+---------------+--------------+------------+-------------+\n| s.player.name | e.start_year | e.end_year | t.team.name |\n+---------------+--------------+------------+-------------+\n| \"Tony Parker\" | 2018         | 2019       | \"Hornets\"   |\n+---------------+--------------+------------+-------------+\n\nnebula&gt; GO FROM \"player101\" OVER serve WHERE (STRING)properties(edge).start_year CONTAINS \"19\" AND \\\n        properties($^).name CONTAINS \"ny\" \\\n        YIELD properties($^).name, properties(edge).start_year, properties(edge).end_year, properties($$).name;\n+---------------------+-----------------------------+---------------------------+---------------------+\n| properties($^).name | properties(EDGE).start_year | properties(EDGE).end_year | properties($$).name |\n+---------------------+-----------------------------+---------------------------+---------------------+\n| \"Tony Parker\"       | 1999                        | 2018                      | \"Spurs\"             |\n+---------------------+-----------------------------+---------------------------+---------------------+\n\nnebula&gt; GO FROM \"player101\" OVER serve WHERE !(properties($$).name CONTAINS \"ets\") \\\n        YIELD properties($^).name, properties(edge).start_year, properties(edge).end_year, properties($$).name;\n+---------------------+-----------------------------+---------------------------+---------------------+\n| properties($^).name | properties(EDGE).start_year | properties(EDGE).end_year | properties($$).name |\n+---------------------+-----------------------------+---------------------------+---------------------+\n| \"Tony Parker\"       | 1999                        | 2018                      | \"Spurs\"             |\n+---------------------+-----------------------------+---------------------------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/7.string/#not_in","title":"<code>(NOT) IN</code>","text":"<pre><code>nebula&gt; RETURN  1 IN [1,2,3], \"Yao\" NOT IN [\"Yi\", \"Tim\", \"Kobe\"], NULL IN [\"Yi\", \"Tim\", \"Kobe\"];\n+----------------+------------------------------------+-------------------------------+\n| (1 IN [1,2,3]) | (\"Yao\" NOT IN [\"Yi\",\"Tim\",\"Kobe\"]) | (NULL IN [\"Yi\",\"Tim\",\"Kobe\"]) |\n+----------------+------------------------------------+-------------------------------+\n| true           | true                               | __NULL__                      |\n+----------------+------------------------------------+-------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/7.string/#not_starts_with","title":"<code>(NOT) STARTS WITH</code>","text":"<pre><code>nebula&gt; RETURN 'apple' STARTS WITH 'app', 'apple' STARTS WITH 'a', 'apple' STARTS WITH toUpper('a');\n+-----------------------------+---------------------------+------------------------------------+\n| (\"apple\" STARTS WITH \"app\") | (\"apple\" STARTS WITH \"a\") | (\"apple\" STARTS WITH toUpper(\"a\")) |\n+-----------------------------+---------------------------+------------------------------------+\n| true                        | true                      | false                              |\n+-----------------------------+---------------------------+------------------------------------+\n\nnebula&gt; RETURN 'apple' STARTS WITH 'b','apple' NOT STARTS WITH 'app';\n+---------------------------+---------------------------------+\n| (\"apple\" STARTS WITH \"b\") | (\"apple\" NOT STARTS WITH \"app\") |\n+---------------------------+---------------------------------+\n| false                     | false                           |\n+---------------------------+---------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/7.string/#not_ends_with","title":"<code>(NOT) ENDS WITH</code>","text":"<pre><code>nebula&gt; RETURN 'apple' ENDS WITH 'app', 'apple' ENDS WITH 'e', 'apple' ENDS WITH 'E', 'apple' ENDS WITH 'b';\n+---------------------------+-------------------------+-------------------------+-------------------------+\n| (\"apple\" ENDS WITH \"app\") | (\"apple\" ENDS WITH \"e\") | (\"apple\" ENDS WITH \"E\") | (\"apple\" ENDS WITH \"b\") |\n+---------------------------+-------------------------+-------------------------+-------------------------+\n| false                     | true                    | false                   | false                   |\n+---------------------------+-------------------------+-------------------------+-------------------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/7.string/#regular_expressions","title":"Regular expressions","text":"<p>Note</p> <p>Regular expressions cannot work with native nGQL statements (<code>GO</code>, <code>FETCH</code>, <code>LOOKUP</code>, etc.). Use it in openCypher only (<code>MATCH</code>, <code>WHERE</code>, etc.).</p> <p>NebulaGraph supports filtering by using regular expressions. The regular expression syntax is inherited from <code>std::regex</code>. You can match on regular expressions by using <code>=~ 'regexp'</code>. For example:</p> <pre><code>nebula&gt; RETURN \"384748.39\" =~ \"\\\\d+(\\\\.\\\\d{2})?\";\n+--------------------------------+\n| (\"384748.39\"=~\"\\d+(\\.\\d{2})?\") |\n+--------------------------------+\n| true                           |\n+--------------------------------+\n\nnebula&gt; MATCH (v:player) WHERE v.player.name =~ 'Tony.*' RETURN v.player.name;\n+---------------+\n| v.player.name |\n+---------------+\n| \"Tony Parker\" |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/8.list/","title":"List operators","text":"<p>NebulaGraph supports the following list operators:</p> List operator Description + Concatenates lists. IN Checks if an element exists in a list. [] Accesses an element(s) in a list using the index operator."},{"location":"3.ngql-guide/5.operators/8.list/#examples","title":"Examples","text":"<pre><code>nebula&gt; YIELD [1,2,3,4,5]+[6,7] AS myList;\n+-----------------------+\n| myList                |\n+-----------------------+\n| [1, 2, 3, 4, 5, 6, 7] |\n+-----------------------+\n\nnebula&gt; RETURN size([NULL, 1, 2]);\n+------------------+\n| size([NULL,1,2]) |\n+------------------+\n| 3                |\n+------------------+\n\nnebula&gt; RETURN NULL IN [NULL, 1];\n+--------------------+\n| (NULL IN [NULL,1]) |\n+--------------------+\n| __NULL__           |\n+--------------------+\n\nnebula&gt; WITH [2, 3, 4, 5] AS numberlist \\\n    UNWIND numberlist AS number \\\n    WITH number \\\n    WHERE number IN [2, 3, 8] \\\n    RETURN number;\n+--------+\n| number |\n+--------+\n| 2      |\n| 3      |\n+--------+\n\nnebula&gt; WITH ['Anne', 'John', 'Bill', 'Diane', 'Eve'] AS names RETURN names[1] AS result;\n+--------+\n| result |\n+--------+\n| \"John\" |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/9.precedence/","title":"Operator precedence","text":"<p>The following list shows the precedence of nGQL operators in descending order. Operators that are shown together on a line have the same precedence.</p> <ul> <li><code>-</code> (negative number)</li> <li><code>!</code>, <code>NOT</code></li> <li><code>*</code>, <code>/</code>, <code>%</code></li> <li><code>-</code>, <code>+</code></li> <li><code>==</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&lt;&gt;</code>, <code>!=</code></li> <li><code>AND</code></li> <li><code>OR</code>, <code>XOR</code></li> <li><code>=</code> (assignment)</li> </ul> <p>For operators that occur at the same precedence level within an expression, evaluation proceeds left to right, with the exception that assignments evaluate right to left.</p> <p>The precedence of operators determines the order of evaluation of terms in an expression. To modify this order and group terms explicitly, use parentheses.</p>"},{"location":"3.ngql-guide/5.operators/9.precedence/#examples","title":"Examples","text":"<pre><code>nebula&gt; RETURN 2+3*5;\n+-----------+\n| (2+(3*5)) |\n+-----------+\n| 17        |\n+-----------+\n\nnebula&gt; RETURN (2+3)*5;\n+-----------+\n| ((2+3)*5) |\n+-----------+\n| 25        |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/5.operators/9.precedence/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>In openCypher, comparisons can be chained arbitrarily, e.g., <code>x &lt; y &lt;= z</code> is equivalent to <code>x &lt; y AND y &lt;= z</code> in openCypher.</p> <p>But in nGQL, <code>x &lt; y &lt;= z</code> is equivalent to <code>(x &lt; y) &lt;= z</code>. The result of <code>(x &lt; y)</code> is a boolean. Compare it with an integer <code>z</code>, and you will get the final result <code>NULL</code>.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/","title":"Built-in math functions","text":"<p>This topic describes the built-in math functions supported by NebulaGraph.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#abs","title":"abs()","text":"<p>abs() returns the absolute value of the argument.</p> <p>Syntax: <code>abs(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN abs(-10);\n+------------+\n| abs(-(10)) |\n+------------+\n| 10         |\n+------------+\nnebula&gt; RETURN abs(5-6);\n+------------+\n| abs((5-6)) |\n+------------+\n| 1          |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#floor","title":"floor()","text":"<p>floor() returns the largest integer value smaller than or equal to the argument.(Rounds down)</p> <p>Syntax: <code>floor(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN floor(9.9);\n+------------+\n| floor(9.9) |\n+------------+\n| 9.0        |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#ceil","title":"ceil()","text":"<p>ceil() returns the smallest integer greater than or equal to the argument.(Rounds up)</p> <p>Syntax: <code>ceil(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN ceil(9.1);\n+-----------+\n| ceil(9.1) |\n+-----------+\n| 10.0      |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#round","title":"round()","text":"<p>round() returns the rounded value of the specified number. Pay attention to the floating-point precision when using this function.</p> <p>Syntax: <code>round(&lt;expression&gt;, &lt;precision&gt;, &lt;mode&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li><code>precision</code>: An integer specifying the precision. If <code>precision</code> is less than 0, round at the left of the decimal point.</li> </ul> <ul> <li><code>mode</code>: A string specifying the rounding mode. Optional. The following valid values are supported:<ul> <li><code>DOWN</code>: Round towards zero.</li> <li><code>CEILING</code>: Round towards positive infinity.</li> <li><code>FLOOR</code>: Round towards negative infinity.</li> <li><code>HALF_UP</code>: Round towards the closest value of the given precision, with ties being rounded away from zero.</li> <li><code>HALF_DOWN</code>: Round towards the closest value of the given precision, with ties being rounded towards zero.</li> <li><code>HALF_EVEN</code>: Round towards the closest value of the given precision, with ties being rounded to the nearest even number.</li> </ul> </li> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN round(314.15926, 2);\n+--------------------+\n| round(314.15926,2) |\n+--------------------+\n| 314.16             |\n+--------------------+\n\nnebula&gt; RETURN round(314.15926, -1);\n+-----------------------+\n| round(314.15926,-(1)) |\n+-----------------------+\n| 310.0                 |\n+-----------------------+\n\nnebula&gt; RETURN round(314.15926, 2, \"DOWN\");\n+---------------------------+\n| round(314.15926,2,\"DOWN\") |\n+---------------------------+\n| 314.15                    |\n+---------------------------+\n\nnebula&gt; RETURN round(314.15926, 2, \"CEILING\");\n+------------------------------+\n| round(314.15926,2,\"CEILING\") |\n+------------------------------+\n| 314.16                       |\n+------------------------------+\n\nnebula&gt; RETURN round(314.15926, 2, \"FLOOR\");\n+----------------------------+\n| round(314.15926,2,\"FLOOR\") |\n+----------------------------+\n| 314.15                     |\n+----------------------------+\n\nnebula&gt; RETURN round(314.15, 1, \"HALF_UP\");\n+---------------------------+\n| round(314.15,1,\"HALF_UP\") |\n+---------------------------+\n| 314.2                     |\n+---------------------------+\n\nnebula&gt; RETURN round(314.15, 1, \"HALF_DOWN\");\n+-----------------------------+\n| round(314.15,1,\"HALF_DOWN\") |\n+-----------------------------+\n| 314.1                       |\n+-----------------------------+\n\nnebula&gt; RETURN round(314.15, 1, \"HALF_EVEN\");    \n+-----------------------------+\n| round(314.15,1,\"HALF_EVEN\") |\n+-----------------------------+\n| 314.2                       |\n+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#sqrt","title":"sqrt()","text":"<p>sqrt() returns the square root of the argument.</p> <p>Syntax: <code>sqrt(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN sqrt(9);\n+---------+\n| sqrt(9) |\n+---------+\n| 3.0     |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#cbrt","title":"cbrt()","text":"<p>cbrt() returns the cubic root of the argument.</p> <p>Syntax: <code>cbrt(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN cbrt(8);\n+---------+\n| cbrt(8) |\n+---------+\n| 2.0     |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#hypot","title":"hypot()","text":"<p>hypot() returns the hypotenuse of a right-angled triangle.</p> <p>Syntax: <code>hypot(&lt;expression_x&gt;,&lt;expression_y&gt;)</code></p> <ul> <li><code>expression_x</code>, <code>expression_y</code>: An expression of which the result type is double. They represent the side lengths x and y of a right triangle.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN hypot(3,2*2);\n+----------------+\n| hypot(3,(2*2)) |\n+----------------+\n| 5.0            |\n+----------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#pow","title":"pow()","text":"<p>pow() returns the result of x<sup>y</sup>.</p> <p>Syntax: <code>pow(&lt;expression_x&gt;,&lt;expression_y&gt;,)</code></p> <ul> <li><code>expression_x</code>: An expression of which the result type is double. It represents the base <code>x</code>.</li> </ul> <ul> <li><code>expression_y</code>: An expression of which the result type is double. It represents the exponential <code>y</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN pow(3,3);\n+----------+\n| pow(3,3) |\n+----------+\n| 27       |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#exp","title":"exp()","text":"<p>exp() returns the result of e<sup>x</sup>.</p> <p>Syntax: <code>exp(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double. It represents the exponential <code>x</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN exp(2);\n+------------------+\n| exp(2)           |\n+------------------+\n| 7.38905609893065 |\n+------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#exp2","title":"exp2()","text":"<p>exp2() returns the result of 2<sup>x</sup>.</p> <p>Syntax: <code>exp2(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double. It represents the exponential <code>x</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN exp2(3);\n+---------+\n| exp2(3) |\n+---------+\n| 8.0     |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#log","title":"log()","text":"<p>log() returns the base-e logarithm of the argument. (\\(log_{e}{N}\\))</p> <p>Syntax: <code>log(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double. It represents the antilogarithm <code>N</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN log(8);\n+--------------------+\n| log(8)             |\n+--------------------+\n| 2.0794415416798357 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#log2","title":"log2()","text":"<p>log2() returns the base-2 logarithm of the argument. (\\(log_{2}{N}\\))</p> <p>Syntax: <code>log2(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double. It represents the antilogarithm <code>N</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN log2(8);\n+---------+\n| log2(8) |\n+---------+\n| 3.0     |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#log10","title":"log10()","text":"<p>log10() returns the base-10 logarithm of the argument. (\\(log_{10}{N}\\))</p> <p>Syntax: <code>log10(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double. It represents the antilogarithm <code>N</code>.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN log10(100);\n+------------+\n| log10(100) |\n+------------+\n| 2.0        |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#sin","title":"sin()","text":"<p>sin() returns the sine of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>sin(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN sin(3);\n+--------------------+\n| sin(3)             |\n+--------------------+\n| 0.1411200080598672 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#asin","title":"asin()","text":"<p>asin() returns the inverse sine of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>asin(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN asin(0.5);\n+--------------------+\n| asin(0.5)          |\n+--------------------+\n| 0.5235987755982989 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#cos","title":"cos()","text":"<p>cos() returns the cosine of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>cos(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN cos(0.5);\n+--------------------+\n| cos(0.5)           |\n+--------------------+\n| 0.8775825618903728 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#acos","title":"acos()","text":"<p>acos() returns the inverse cosine of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>acos(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN acos(0.5);\n+--------------------+\n| acos(0.5)          |\n+--------------------+\n| 1.0471975511965979 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#tan","title":"tan()","text":"<p>tan() returns the tangent of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>tan(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN tan(0.5);\n+--------------------+\n| tan(0.5)           |\n+--------------------+\n| 0.5463024898437905 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#atan","title":"atan()","text":"<p>atan() returns the inverse tangent of the argument. Users can convert angles to radians using the function <code>radians()</code>.</p> <p>Syntax: <code>atan(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN atan(0.5);\n+--------------------+\n| atan(0.5)          |\n+--------------------+\n| 0.4636476090008061 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#rand","title":"rand()","text":"<p>rand() returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e.[0,1).</p> <p>Syntax: <code>rand()</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN rand();\n+--------------------+\n| rand()             |\n+--------------------+\n| 0.6545837172298736 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#rand32","title":"rand32()","text":"<p>rand32() returns a random 32-bit integer in <code>[min, max)</code>.</p> <p>Syntax: <code>rand32(&lt;expression_min&gt;,&lt;expression_max&gt;)</code></p> <ul> <li><code>expression_min</code>: An expression of which the result type is int. It represents the minimum <code>min</code>.</li> </ul> <ul> <li><code>expression_max</code>: An expression of which the result type is int. It represents the maximum <code>max</code>.</li> </ul> <ul> <li>Result type: Int</li> </ul> <ul> <li>If you set only one argument, it is parsed as <code>max</code> and <code>min</code> is <code>0</code> by default. If you set no argument, the system returns a random signed 32-bit integer.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN rand32(1,100);\n+---------------+\n| rand32(1,100) |\n+---------------+\n| 63            |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#rand64","title":"rand64()","text":"<p>rand64() returns a random 64-bit integer in <code>[min, max)</code>.</p> <p>Syntax: <code>rand64(&lt;expression_min&gt;,&lt;expression_max&gt;)</code></p> <ul> <li><code>expression_min</code>: An expression of which the result type is int. It represents the minimum <code>min</code>.</li> </ul> <ul> <li><code>expression_max</code>: An expression of which the result type is int. It represents the maximum <code>max</code>.</li> </ul> <ul> <li>Result type: Int</li> </ul> <ul> <li>If you set only one argument, it is parsed as <code>max</code> and <code>min</code> is <code>0</code> by default. If you set no argument, the system returns a random signed 64-bit integer.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN rand64(1,100);\n+---------------+\n| rand64(1,100) |\n+---------------+\n| 34            |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#bit_and","title":"bit_and()","text":"<p>bit_and() returns the result of bitwise AND.</p> <p>Syntax: <code>bit_and(&lt;expression_1&gt;,&lt;expression_2&gt;)</code></p> <ul> <li><code>expression_1</code>, <code>expression_2</code>: An expression of which the result type is int.</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN bit_and(5,6);\n+--------------+\n| bit_and(5,6) |\n+--------------+\n| 4            |\n+--------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#bit_or","title":"bit_or()","text":"<p>bit_or() returns the result of bitwise OR.</p> <p>Syntax: <code>bit_or(&lt;expression_1&gt;,&lt;expression_2&gt;)</code></p> <ul> <li><code>expression_1</code>, <code>expression_2</code>: An expression of which the result type is int.</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN bit_or(5,6);\n+-------------+\n| bit_or(5,6) |\n+-------------+\n| 7           |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#bit_xor","title":"bit_xor()","text":"<p>bit_xor() returns the result of bitwise XOR.</p> <p>Syntax: <code>bit_xor(&lt;expression_1&gt;,&lt;expression_2&gt;)</code></p> <ul> <li><code>expression_1</code>, <code>expression_2</code>: An expression of which the result type is int.</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN bit_xor(5,6);\n+--------------+\n| bit_xor(5,6) |\n+--------------+\n| 3            |\n+--------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#size","title":"size()","text":"<p>size() returns the number of elements in a list or a map, or the length of a string.</p> <p>Syntax: <code>size({&lt;expression&gt;|&lt;string&gt;})</code></p> <ul> <li><code>expression</code>: An expression for a list or map.</li> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN size([1,2,3,4]);\n+-----------------+\n| size([1,2,3,4]) |\n+-----------------+\n| 4               |\n+-----------------+\n</code></pre> <pre><code>nebula&gt; RETURN size(\"basketballplayer\") as size;\n+------+\n| size |\n+------+\n| 16   |\n+------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#range","title":"range()","text":"<p>range() returns a list of integers from <code>[start,end]</code> in the specified steps.</p> <p>Syntax: <code>range(&lt;expression_start&gt;,&lt;expression_end&gt;[,&lt;expression_step&gt;])</code></p> <ul> <li><code>expression_start</code>: An expression of which the result type is int. It represents the starting value <code>start</code>.</li> </ul> <ul> <li><code>expression_end</code>: An expression of which the result type is int. It represents the end value <code>end</code>.</li> </ul> <ul> <li><code>expression_step</code>: An expression of which the result type is int. It represents the step size <code>step</code>, <code>step</code> is 1 by default.</li> </ul> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN range(1,3*3,2);\n+------------------+\n| range(1,(3*3),2) |\n+------------------+\n| [1, 3, 5, 7, 9]  |\n+------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#sign","title":"sign()","text":"<p>sign() returns the signum of the given number. If the number is <code>0</code>, the system returns <code>0</code>. If the number is negative, the system returns <code>-1</code>. If the number is positive, the system returns <code>1</code>.</p> <p>Syntax: <code>sign(&lt;expression&gt;)</code></p> <ul> <li><code>expression</code>: An expression of which the result type is double.</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN sign(10);\n+----------+\n| sign(10) |\n+----------+\n| 1        |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#e","title":"e()","text":"<p>e() returns the base of the natural logarithm, e (2.718281828459045).</p> <p>Syntax: <code>e()</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN e();\n+-------------------+\n| e()               |\n+-------------------+\n| 2.718281828459045 |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#pi","title":"pi()","text":"<p>pi() returns the mathematical constant pi (3.141592653589793).</p> <p>Syntax: <code>pi()</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN pi();\n+-------------------+\n| pi()              |\n+-------------------+\n| 3.141592653589793 |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/1.math/#radians","title":"radians()","text":"<p>radians() converts angles to radians.</p> <p>Syntax: <code>radians(&lt;angle&gt;)</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN radians(180);\n+-------------------+\n| radians(180)      |\n+-------------------+\n| 3.141592653589793 |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/14.geo/","title":"Geography functions","text":"<p>Geography functions are used to generate or perform operations on the value of the geography data type.</p> <p>For descriptions of the geography data types, see Geography.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/14.geo/#descriptions","title":"Descriptions","text":"Function Return Type Description ST_Point(longitude, latitude) <code>GEOGRAPHY</code> Creates the geography that contains a point. ST_GeogFromText(wkt_string) <code>GEOGRAPHY</code> Returns the geography corresponding to the input WKT string. ST_ASText(geography) <code>STRING</code> Returns the WKT string of the input geography. ST_Centroid(geography) <code>GEOGRAPHY</code> Returns the centroid of the input geography in the form of the single point geography. ST_ISValid(geography) <code>BOOL</code> Returns whether the input geography is valid. ST_Intersects(geography_1, geography_2) <code>BOOL</code> Returns whether geography_1 and geography_2 have intersections. ST_Covers(geography_1, geography_2) <code>BOOL</code> Returns whether geography_1 completely contains geography_2. If there is no point outside geography_1 in geography_2, return True. ST_CoveredBy(geography_1, geography_2) <code>BOOL</code> Returns whether geography_2 completely contains geography_1.If there is no point outside geography_2 in geography_1, return True. ST_DWithin(geography_1, geography_2, distance) <code>BOOL</code> If the distance between one point (at least) in geography_1 and one point in geography_2 is less than or equal to the distance specified by the distance parameter (measured by meters), return True. ST_Distance(geography_1, geography_2) <code>FLOAT</code> Returns the smallest possible distance (measured by meters) between two non-empty geographies. S2_CellIdFromPoint(point_geography) <code>INT</code> Returns the S2 Cell ID that covers the point geography. S2_CoveringCellIds(geography) <code>ARRAY&lt;INT64&gt;</code> Returns an array of S2 Cell IDs that cover the input geography."},{"location":"3.ngql-guide/6.functions-and-expressions/14.geo/#examples","title":"Examples","text":"<pre><code>nebula&gt; RETURN ST_ASText(ST_Point(1,1));\n+--------------------------+\n| ST_ASText(ST_Point(1,1)) |\n+--------------------------+\n| \"POINT(1 1)\"             |\n+--------------------------+\n\nnebula&gt; RETURN ST_ASText(ST_GeogFromText(\"POINT(3 8)\"));\n+------------------------------------------+\n| ST_ASText(ST_GeogFromText(\"POINT(3 8)\")) |\n+------------------------------------------+\n| \"POINT(3 8)\"                             |\n+------------------------------------------+\n\nnebula&gt; RETURN ST_ASTEXT(ST_Centroid(ST_GeogFromText(\"LineString(0 1,1 0)\")));\n+----------------------------------------------------------------+\n| ST_ASTEXT(ST_Centroid(ST_GeogFromText(\"LineString(0 1,1 0)\"))) |\n+----------------------------------------------------------------+\n| \"POINT(0.5000380800773782 0.5000190382261059)\"                 |\n+----------------------------------------------------------------+\n\nnebula&gt; RETURN ST_ISValid(ST_GeogFromText(\"POINT(3 8)\"));\n+-------------------------------------------+\n| ST_ISValid(ST_GeogFromText(\"POINT(3 8)\")) |\n+-------------------------------------------+\n| true                                      |\n+-------------------------------------------+\n\nnebula&gt; RETURN ST_Intersects(ST_GeogFromText(\"LineString(0 1,1 0)\"),ST_GeogFromText(\"LineString(0 0,1 1)\"));\n+----------------------------------------------------------------------------------------------+\n| ST_Intersects(ST_GeogFromText(\"LineString(0 1,1 0)\"),ST_GeogFromText(\"LineString(0 0,1 1)\")) |\n+----------------------------------------------------------------------------------------------+\n| true                                                                                         |\n+----------------------------------------------------------------------------------------------+\n\nnebula&gt; RETURN ST_Covers(ST_GeogFromText(\"POLYGON((0 0,10 0,10 10,0 10,0 0))\"),ST_Point(1,2));\n+--------------------------------------------------------------------------------+\n| ST_Covers(ST_GeogFromText(\"POLYGON((0 0,10 0,10 10,0 10,0 0))\"),ST_Point(1,2)) |\n+--------------------------------------------------------------------------------+\n| true                                                                           |\n+--------------------------------------------------------------------------------+\n\nnebula&gt; RETURN ST_CoveredBy(ST_Point(1,2),ST_GeogFromText(\"POLYGON((0 0,10 0,10 10,0 10,0 0))\"));\n+-----------------------------------------------------------------------------------+\n| ST_CoveredBy(ST_Point(1,2),ST_GeogFromText(\"POLYGON((0 0,10 0,10 10,0 10,0 0))\")) |\n+-----------------------------------------------------------------------------------+\n| true                                                                              |\n+-----------------------------------------------------------------------------------+\n\nnebula&gt; RETURN ST_dwithin(ST_GeogFromText(\"Point(0 0)\"),ST_GeogFromText(\"Point(10 10)\"),20000000000.0);\n+---------------------------------------------------------------------------------------+\n| ST_dwithin(ST_GeogFromText(\"Point(0 0)\"),ST_GeogFromText(\"Point(10 10)\"),20000000000) |\n+---------------------------------------------------------------------------------------+\n| true                                                                                  |\n+---------------------------------------------------------------------------------------+\n\nnebula&gt; RETURN ST_Distance(ST_GeogFromText(\"Point(0 0)\"),ST_GeogFromText(\"Point(10 10)\"));\n+----------------------------------------------------------------------------+\n| ST_Distance(ST_GeogFromText(\"Point(0 0)\"),ST_GeogFromText(\"Point(10 10)\")) |\n+----------------------------------------------------------------------------+\n| 1.5685230187677438e+06                                                     |\n+----------------------------------------------------------------------------+\n\nnebula&gt; RETURN S2_CellIdFromPoint(ST_GeogFromText(\"Point(1 1)\"));\n+---------------------------------------------------+\n| S2_CellIdFromPoint(ST_GeogFromText(\"Point(1 1)\")) |\n+---------------------------------------------------+\n| 1153277837650709461                               |\n+---------------------------------------------------+\n\nnebula&gt; RETURN S2_CoveringCellIds(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"));\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| S2_CoveringCellIds(ST_GeogFromText(\"POLYGON((0 1, 1 2, 2 3, 0 1))\"))                                                                                                     |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [1152391494368201343, 1153466862374223872, 1153554823304445952, 1153836298281156608, 1153959443583467520, 1154240918560178176, 1160503736791990272, 1160591697722212352] |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/","title":"Aggregating functions","text":"<p>This topic describes the aggregating functions supported by NebulaGraph.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#avg","title":"avg()","text":"<p>avg() returns the average value of the argument.</p> <p>Syntax: <code>avg(&lt;expression&gt;)</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN avg(v.player.age);\n+--------------------+\n| avg(v.player.age)  |\n+--------------------+\n| 33.294117647058826 |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#count","title":"count()","text":"<p>count() returns the number of records.</p> <ul> <li>(Native nGQL) You can use <code>count()</code> and <code>GROUP BY</code> together to group and count the number of parameters. Use <code>YIELD</code> to return.</li> </ul> <ul> <li>(OpenCypher style) You can use <code>count()</code> and <code>RETURN</code>. <code>GROUP BY</code> is not necessary.</li> </ul> <p>Syntax: <code>count({&lt;expression&gt; | *})</code></p> <ul> <li>count(*) returns the number of rows (including NULL).</li> </ul> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; WITH [NULL, 1, 1, 2, 2] As a UNWIND a AS b \\\n        RETURN count(b), count(*), count(DISTINCT b);\n+----------+----------+-------------------+\n| count(b) | count(*) | count(distinct b) |\n+----------+----------+-------------------+\n| 4        | 5        | 2                 |\n+----------+----------+-------------------+\n</code></pre> <pre><code># The statement in the following example searches for the people whom `player101` follows and people who follow `player101`, i.e. a bidirectional query.\n# Group and count the number of parameters.\nnebula&gt; GO FROM \"player101\" OVER follow BIDIRECT \\\n        YIELD properties($$).name AS Name \\\n        | GROUP BY $-.Name YIELD $-.Name, count(*);\n+---------------------+----------+\n| $-.Name             | count(*) |\n+---------------------+----------+\n| \"LaMarcus Aldridge\" | 2        |\n| \"Tim Duncan\"        | 2        |\n| \"Marco Belinelli\"   | 1        |\n| \"Manu Ginobili\"     | 1        |\n| \"Boris Diaw\"        | 1        |\n| \"Dejounte Murray\"   | 1        |\n+---------------------+----------+\n\n# Count the number of parameters.\nnebula&gt; MATCH (v1:player)-[:follow]-(v2:player) \\\n        WHERE id(v1)== \"player101\" \\\n        RETURN v2.player.name AS Name, count(*) as cnt ORDER BY cnt DESC;\n+---------------------+-----+\n| Name                | cnt |\n+---------------------+-----+\n| \"LaMarcus Aldridge\" | 2   |\n| \"Tim Duncan\"        | 2   |\n| \"Boris Diaw\"        | 1   |\n| \"Manu Ginobili\"     | 1   |\n| \"Dejounte Murray\"   | 1   |\n| \"Marco Belinelli\"   | 1   |\n+---------------------+-----+\n</code></pre> <p>The preceding example retrieves two columns:</p> <ul> <li><code>$-.Name</code>: the names of the people.</li> </ul> <ul> <li><code>count(*)</code>: how many times the names show up.</li> </ul> <p>Because there are no duplicate names in the <code>basketballplayer</code> dataset, the number <code>2</code> in the column <code>count(*)</code> shows that the person in that row and <code>player101</code> have followed each other.</p> <pre><code># a: The statement in the following example retrieves the age distribution of the players in the dataset.\nnebula&gt; LOOKUP ON player \\\n        YIELD player.age As playerage \\\n        | GROUP BY $-.playerage \\\n        YIELD $-.playerage as age, count(*) AS number \\\n        | ORDER BY $-.number DESC, $-.age DESC;\n+-----+--------+\n| age | number |\n+-----+--------+\n| 34  | 4      |\n| 33  | 4      |\n| 30  | 4      |\n| 29  | 4      |\n| 38  | 3      |\n+-----+--------+\n...\n# b: The statement in the following example retrieves the age distribution of the players in the dataset.\nnebula&gt; MATCH (n:player) \\\n        RETURN n.player.age as age, count(*) as number \\\n        ORDER BY number DESC, age DESC;\n+-----+--------+\n| age | number |\n+-----+--------+\n| 34  | 4      |\n| 33  | 4      |\n| 30  | 4      |\n| 29  | 4      |\n| 38  | 3      |\n+-----+--------+\n...\n</code></pre> <pre><code># The statement in the following example counts the number of edges that Tim Duncan relates.\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) -[e]- (v2) \\\n        RETURN count(e);\n+----------+\n| count(e) |\n+----------+\n| 13       |\n+----------+\n\n# The statement in the following example counts the number of edges that Tim Duncan relates and returns two columns (no DISTINCT and DISTINCT) in multi-hop queries.\nnebula&gt; MATCH (n:player {name : \"Tim Duncan\"})-[]-&gt;(friend:player)-[]-&gt;(fof:player) \\\n        RETURN count(fof), count(DISTINCT fof);\n+------------+---------------------+\n| count(fof) | count(distinct fof) |\n+------------+---------------------+\n| 4          | 3                   |\n+------------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#max","title":"max()","text":"<p>max() returns the maximum value.</p> <p>Syntax: <code>max(&lt;expression&gt;)</code></p> <ul> <li>Result type: Same as the original argument.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN max(v.player.age);\n+-------------------+\n| max(v.player.age) |\n+-------------------+\n| 47                |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#min","title":"min()","text":"<p>min() returns the minimum value.</p> <p>Syntax: <code>min(&lt;expression&gt;)</code></p> <ul> <li>Result type: Same as the original argument.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN min(v.player.age);\n+-------------------+\n| min(v.player.age) |\n+-------------------+\n| 20                |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#collect","title":"collect()","text":"<p>collect() returns a list containing the values returned by an expression. Using this function aggregates data by merging multiple records or values into a single list.</p> <p>Syntax: <code>collect(&lt;expression&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; UNWIND [1, 2, 1] AS a \\\n        RETURN a;\n+---+\n| a |\n+---+\n| 1 |\n| 2 |\n| 1 |\n+---+\n\nnebula&gt; UNWIND [1, 2, 1] AS a \\\n        RETURN collect(a);\n+------------+\n| collect(a) |\n+------------+\n| [1, 2, 1]  |\n+------------+\n\nnebula&gt; UNWIND [1, 2, 1] AS a \\\n        RETURN a, collect(a), size(collect(a));\n+---+------------+------------------+\n| a | collect(a) | size(collect(a)) |\n+---+------------+------------------+\n| 2 | [2]        | 1                |\n| 1 | [1, 1]     | 2                |\n+---+------------+------------------+\n\n# The following examples sort the results in descending order, limit output rows to 3, and collect the output into a list.\nnebula&gt; UNWIND [\"c\", \"b\", \"a\", \"d\" ] AS p \\\n        WITH p AS q \\\n        ORDER BY q DESC LIMIT 3 \\\n        RETURN collect(q);\n+-----------------+\n| collect(q)      |\n+-----------------+\n| [\"d\", \"c\", \"b\"] |\n+-----------------+\n\nnebula&gt; WITH [1, 1, 2, 2] AS coll \\\n        UNWIND coll AS x \\\n        WITH DISTINCT x \\\n        RETURN collect(x) AS ss;\n+--------+\n| ss     |\n+--------+\n| [1, 2] |\n+--------+\n\nnebula&gt; MATCH (n:player) \\\n        RETURN collect(n.player.age);\n+---------------------------------------------------------------+\n| collect(n.player.age)                                         |\n+---------------------------------------------------------------+\n| [32, 32, 34, 29, 41, 40, 33, 25, 40, 37, ...\n...\n\n# The following example aggregates all the players' names by their ages.\nnebula&gt; MATCH (n:player) \\\n        RETURN n.player.age AS age, collect(n.player.name);\n+-----+--------------------------------------------------------------------------+\n| age | collect(n.player.name)                                                   |\n+-----+--------------------------------------------------------------------------+\n| 24  | [\"Giannis Antetokounmpo\"]                                                |\n| 20  | [\"Luka Doncic\"]                                                          |\n| 25  | [\"Joel Embiid\", \"Kyle Anderson\"]                                         |\n+-----+--------------------------------------------------------------------------+\n...\n\nnebula&gt; GO FROM \"player100\" OVER serve \\\n        YIELD properties($$).name AS name \\\n        | GROUP BY $-.name \\\n        YIELD collect($-.name) AS name;\n+-----------+\n| name      |\n+-----------+\n| [\"Spurs\"] |\n+-----------+\n\nnebula&gt; LOOKUP ON player \\\n        YIELD player.age As playerage \\\n        | GROUP BY $-.playerage \\\n        YIELD collect($-.playerage) AS playerage;\n+------------------+\n| playerage        |\n+------------------+\n| [22]             |\n| [47]             |\n| [43]             |\n| [25, 25]         |\n+------------------+\n...\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#std","title":"std()","text":"<p>std() returns the population standard deviation.</p> <p>Syntax: <code>std(&lt;expression&gt;)</code></p> <ul> <li>Result type: Double</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN std(v.player.age);\n+-------------------+\n| std(v.player.age) |\n+-------------------+\n| 6.423895701687502 |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#sum","title":"sum()","text":"<p>sum() returns the sum value.</p> <p>Syntax: <code>sum(&lt;expression&gt;)</code></p> <ul> <li>Result type: Same as the original argument.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN sum(v.player.age);\n+-------------------+\n| sum(v.player.age) |\n+-------------------+\n| 1698              |\n+-------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/15.aggregating/#aggregating_example","title":"Aggregating example","text":"<pre><code>nebula&gt;  GO FROM \"player100\" OVER follow YIELD dst(edge) AS dst, properties($$).age AS age \\\n         | GROUP BY $-.dst \\\n         YIELD \\\n         $-.dst AS dst, \\\n         toInteger((sum($-.age)/count($-.age)))+avg(distinct $-.age+1)+1 AS statistics;\n+-------------+------------+\n| dst         | statistics |\n+-------------+------------+\n| \"player125\" | 84.0       |\n| \"player101\" | 74.0       |\n+-------------+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/","title":"Type conversion functions","text":"<p>This topic describes the type conversion functions supported by NebulaGraph.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#toboolean","title":"toBoolean()","text":"<p>toBoolean() converts a string value to a boolean value.</p> <p>Syntax: <code>toBoolean(&lt;value&gt;)</code></p> <ul> <li>Result type: Bool</li> </ul> <p>Example:</p> <pre><code>nebula&gt; UNWIND [true, false, 'true', 'false', NULL] AS b \\\n        RETURN toBoolean(b) AS b;\n+----------+\n| b        |\n+----------+\n| true     |\n| false    |\n| true     |\n| false    |\n| __NULL__ |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#tofloat","title":"toFloat()","text":"<p>toFloat() converts an integer or string value to a floating point number.</p> <p>Syntax: <code>toFloat(&lt;value&gt;)</code></p> <ul> <li>Result type: Float</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN toFloat(1), toFloat('1.3'), toFloat('1e3'), toFloat('not a number');\n+------------+----------------+----------------+-------------------------+\n| toFloat(1) | toFloat(\"1.3\") | toFloat(\"1e3\") | toFloat(\"not a number\") |\n+------------+----------------+----------------+-------------------------+\n| 1.0        | 1.3            | 1000.0         | __NULL__                |\n+------------+----------------+----------------+-------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#tostring","title":"toString()","text":"<p>toString() converts non-compound types of data, such as numbers, booleans, and so on, to strings.</p> <p>Syntax: <code>toString(&lt;value&gt;)</code></p> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN toString(9669) AS int2str, toString(null) AS null2str;\n+---------+----------+\n| int2str | null2str |\n+---------+----------+\n| \"9669\"  | __NULL__ |\n+---------+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#tointeger","title":"toInteger()","text":"<p>toInteger() converts a floating point or string value to an integer value.</p> <p>Syntax: <code>toInteger(&lt;value&gt;)</code></p> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN toInteger(1), toInteger('1'), toInteger('1e3'), toInteger('not a number');\n+--------------+----------------+------------------+---------------------------+\n| toInteger(1) | toInteger(\"1\") | toInteger(\"1e3\") | toInteger(\"not a number\") |\n+--------------+----------------+------------------+---------------------------+\n| 1            | 1              | 1000             | __NULL__                  |\n+--------------+----------------+------------------+---------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#toset","title":"toSet()","text":"<p>toSet() converts a list or set value to a set value.</p> <p>Syntax: <code>toSet(&lt;value&gt;)</code></p> <ul> <li>Result type: Set</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN toSet(list[1,2,3,1,2]) AS list2set;\n+-----------+\n| list2set  |\n+-----------+\n| {3, 1, 2} |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/16.type-conversion/#hash","title":"hash()","text":"<p>hash() returns the hash value of the argument. The argument can be a number, a string, a list, a boolean, null, or an expression that evaluates to a value of the preceding data types.</p> <p>The source code of the <code>hash()</code> function (MurmurHash2), seed (<code>0xc70f6907UL</code>), and other parameters can be found in <code>MurmurHash2.h</code>.</p> <p>For Java, the hash function operates as follows.</p> <pre><code>MurmurHash2.hash64(\"to_be_hashed\".getBytes(),\"to_be_hashed\".getBytes().length, 0xc70f6907)\n</code></pre> <p>Syntax: <code>hash(&lt;string&gt;)</code></p> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN hash(\"abcde\");\n+--------------------+\n| hash(\"abcde\")      |\n+--------------------+\n| 811036730794841393 |\n+--------------------+\nnebula&gt; YIELD hash([1,2,3]);\n+----------------+\n| hash([1,2,3])  |\n+----------------+\n| 11093822460243 |\n+----------------+\nnebula&gt; YIELD hash(NULL);\n+------------+\n| hash(NULL) |\n+------------+\n| -1         |\n+------------+\nnebula&gt; YIELD hash(toLower(\"HELLO NEBULA\"));\n+-------------------------------+\n| hash(toLower(\"HELLO NEBULA\")) |\n+-------------------------------+\n| -8481157362655072082          |\n+-------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/","title":"Built-in string functions","text":"<p>This topic describes the built-in string functions supported by NebulaGraph.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#precautions","title":"Precautions","text":"<ul> <li>A string type is used to store a sequence of characters (text). The literal constant is a sequence of characters of any length surrounded by double or single quotes.</li> </ul> <ul> <li>Like SQL, the position index of nGQL starts from <code>1</code>, while in C language it starts from <code>0</code>.</li> </ul>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#strcasecmp","title":"strcasecmp()","text":"<p>strcasecmp() compares string a and b without case sensitivity.</p> <p>Syntax: <code>strcasecmp(&lt;string_a&gt;,&lt;string_b&gt;)</code></p> <ul> <li><code>string_a</code>, <code>string_b</code>: Strings to compare.</li> </ul> <ul> <li>Result type: Int</li> </ul> <ul> <li>When <code>string_a = string_b</code>, the return value is <code>0</code>. When <code>string_a &gt; string_b</code>, the return value is greater than <code>0</code>. When <code>string_a &lt; string_b</code>, the return value is less than <code>0</code>.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN strcasecmp(\"a\",\"aa\");\n+----------------------+\n| strcasecmp(\"a\",\"aa\") |\n+----------------------+\n| -97                  |\n+----------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#lower_and_tolower","title":"lower() and toLower()","text":"<p>lower() and toLower() can both returns the argument in lowercase.</p> <p>Syntax: <code>lower(&lt;string&gt;)</code>, <code>toLower(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN lower(\"Basketball_Player\");\n+----------------------------+\n| lower(\"Basketball_Player\") |\n+----------------------------+\n| \"basketball_player\"        |\n+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#upper_and_toupper","title":"upper() and toUpper()","text":"<p>upper() and toUpper() can both returns the argument in uppercase.</p> <p>Syntax: <code>upper(&lt;string&gt;)</code>, <code>toUpper(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN upper(\"Basketball_Player\");\n+----------------------------+\n| upper(\"Basketball_Player\") |\n+----------------------------+\n| \"BASKETBALL_PLAYER\"        |\n+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#length","title":"length()","text":"<p>length() returns the length of the given string in bytes.</p> <p>Syntax: <code>length({&lt;string&gt;|&lt;path&gt;})</code></p> <ul> <li><code>string</code>: A specified string.</li> <li><code>path</code>: A specified path represented by a variable.</li> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN length(\"basketball\");\n+----------------------+\n| length(\"basketball\") |\n+----------------------+\n| 10                   |\n+----------------------+\n</code></pre> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) return length(p);\n+-----------+\n| length(p) |\n+-----------+\n| 1         |\n| 1         |\n| 1         |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#trim","title":"trim()","text":"<p>trim() removes the spaces at the leading and trailing of the string.</p> <p>Syntax: <code>trim(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN trim(\" basketball player \");\n+-----------------------------+\n| trim(\" basketball player \") |\n+-----------------------------+\n| \"basketball player\"         |\n+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#ltrim","title":"ltrim()","text":"<p>ltrim() removes the spaces at the leading of the string.</p> <p>Syntax: <code>ltrim(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN ltrim(\" basketball player \");\n+------------------------------+\n| ltrim(\" basketball player \") |\n+------------------------------+\n| \"basketball player \"         |\n+------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#rtrim","title":"rtrim()","text":"<p>rtrim() removes the spaces at the trailing of the string.</p> <p>Syntax: <code>rtrim(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN rtrim(\" basketball player \");\n+------------------------------+\n| rtrim(\" basketball player \") |\n+------------------------------+\n| \" basketball player\"         |\n+------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#left","title":"left()","text":"<p>left() returns a substring consisting of several characters from the leading of a string.</p> <p>Syntax: <code>left(&lt;string&gt;,&lt;count&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>count</code>: The number of characters from the leading of the string. If the string is shorter than <code>count</code>, the system returns the string itself.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN left(\"basketball_player\",6);\n+-----------------------------+\n| left(\"basketball_player\",6) |\n+-----------------------------+\n| \"basket\"                    |\n+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#right","title":"right()","text":"<p>right() returns a substring consisting of several characters from the trailing of a string.</p> <p>Syntax: <code>right(&lt;string&gt;,&lt;count&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>count</code>: The number of characters from the trailing of the string. If the string is shorter than <code>count</code>, the system returns the string itself.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN right(\"basketball_player\",6);\n+------------------------------+\n| right(\"basketball_player\",6) |\n+------------------------------+\n| \"player\"                     |\n+------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#lpad","title":"lpad()","text":"<p>lpad() pads a specified string from the left-side to the specified length and returns the result string.</p> <p>Syntax: <code>lpad(&lt;string&gt;,&lt;count&gt;,&lt;letters&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>count</code>: The length of the string after it has been left-padded. If the length is less than that of <code>string</code>, only the length of <code>string</code> characters from front to back will be returned.</li> </ul> <ul> <li><code>letters</code>: A string to be padding from the leading.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN lpad(\"abcd\",10,\"b\");\n+---------------------+\n| lpad(\"abcd\",10,\"b\") |\n+---------------------+\n| \"bbbbbbabcd\"        |\n+---------------------+\nnebula&gt; RETURN lpad(\"abcd\",3,\"b\");\n+--------------------+\n| lpad(\"abcd\",3,\"b\") |\n+--------------------+\n| \"abc\"              |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#rpad","title":"rpad()","text":"<p>rpad() pads a specified string from the right-side to the specified length and returns the result string.</p> <p>Syntax: <code>rpad(&lt;string&gt;,&lt;count&gt;,&lt;letters&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>count</code>: The length of the string after it has been right-padded. If the length is less than that of <code>string</code>, only the length of <code>string</code> characters from front to back will be returned.</li> </ul> <ul> <li><code>letters</code>: A string to be padding from the trailing.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN rpad(\"abcd\",10,\"b\");\n+---------------------+\n| rpad(\"abcd\",10,\"b\") |\n+---------------------+\n| \"abcdbbbbbb\"        |\n+---------------------+\nnebula&gt; RETURN rpad(\"abcd\",3,\"b\");\n+--------------------+\n| rpad(\"abcd\",3,\"b\") |\n+--------------------+\n| \"abc\"              |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#substr_and_substring","title":"substr() and substring()","text":"<p>substr() and substring() return a substring extracting <code>count</code> characters starting from the specified position <code>pos</code> of a specified string.</p> <p>Syntax: <code>substr(&lt;string&gt;,&lt;pos&gt;,&lt;count&gt;)</code>, <code>substring(&lt;string&gt;,&lt;pos&gt;,&lt;count&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>pos</code>: The position of starting extract (character index). Data type is int.</li> </ul> <ul> <li><code>count</code>: The number of characters extracted from the start position onwards.</li> </ul> <ul> <li>Result type: String</li> </ul>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#explanations_for_the_return_of_substr_and_substring","title":"Explanations for the return of <code>substr()</code> and <code>substring()</code>","text":"<ul> <li>If <code>pos</code> is 0, it extracts from the specified string leading (including the first character).</li> </ul> <ul> <li>If <code>pos</code> is greater than the maximum string index, an empty string is returned.</li> </ul> <ul> <li>If <code>pos</code> is a negative number, <code>BAD_DATA</code> is returned.</li> </ul> <ul> <li>If <code>count</code> is omitted, the function returns the substring starting at the position given by <code>pos</code> and extending to the end of the string.</li> </ul> <ul> <li>If <code>count</code> is 0, an empty string is returned.</li> </ul> <ul> <li>Using <code>NULL</code> as any of the argument of <code>substr()</code> will cause an issue.</li> </ul> <p>OpenCypher compatibility</p> <p>In openCypher, if <code>a</code> is <code>null</code>, <code>null</code> is returned.</p> <p>Example:</p> <pre><code>nebula&gt; RETURN substr(\"abcdefg\",2,4);\n+-----------------------+\n| substr(\"abcdefg\",2,4) |\n+-----------------------+\n| \"cdef\"                |\n+-----------------------+\nnebula&gt; RETURN substr(\"abcdefg\",0,4);\n+-----------------------+\n| substr(\"abcdefg\",0,4) |\n+-----------------------+\n| \"abcd\"                |\n+-----------------------+\nnebula&gt; RETURN substr(\"abcdefg\",2);\n+---------------------+\n| substr(\"abcdefg\",2) |\n+---------------------+\n| \"cdefg\"             |\n+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#reverse","title":"reverse()","text":"<p>reverse() returns a string in reverse order.</p> <p>Syntax: <code>reverse(&lt;string&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN reverse(\"abcdefg\");\n+--------------------+\n| reverse(\"abcdefg\") |\n+--------------------+\n| \"gfedcba\"          |\n+--------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#replace","title":"replace()","text":"<p>replace() replaces string a in a specified string with string b.</p> <p>Syntax: <code>replace(&lt;string&gt;,&lt;substr_a&gt;,&lt;string_b&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>substr_a</code>: String a.</li> </ul> <ul> <li><code>string_b</code>: String b.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN replace(\"abcdefg\",\"cd\",\"AAAAA\");\n+---------------------------------+\n| replace(\"abcdefg\",\"cd\",\"AAAAA\") |\n+---------------------------------+\n| \"abAAAAAefg\"                    |\n+---------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#split","title":"split()","text":"<p>split() splits a specified string at string b and returns a list of strings.</p> <p>Syntax: <code>split(&lt;string&gt;,&lt;substr&gt;)</code></p> <ul> <li><code>string</code>: A specified string.</li> </ul> <ul> <li><code>substr</code>: String b.</li> </ul> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN split(\"basketballplayer\",\"a\");\n+-------------------------------+\n| split(\"basketballplayer\",\"a\") |\n+-------------------------------+\n| [\"b\", \"sketb\", \"llpl\", \"yer\"] |\n+-------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#concat","title":"concat()","text":"<p>concat() returns strings concatenated by all strings.</p> <p>Syntax: <code>concat(&lt;string1&gt;,&lt;string2&gt;,...)</code></p> <ul> <li>The function requires at least two or more strings. If there is only one string, the string itself is returned.</li> </ul> <ul> <li>If any one of the strings is <code>NULL</code>, <code>NULL</code> is returned.</li> </ul> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>//This example concatenates 1, 2, and 3.\nnebula&gt; RETURN concat(\"1\",\"2\",\"3\") AS r;\n+-------+\n| r     |\n+-------+\n| \"123\" |\n+-------+\n\n//In this example, one of the string is NULL.\nnebula&gt; RETURN concat(\"1\",\"2\",NULL) AS r;\n+----------+\n| r        |\n+----------+\n| __NULL__ |\n+----------+\n\nnebula&gt; GO FROM \"player100\" over follow \\\n        YIELD concat(src(edge), properties($^).age, properties($$).name, properties(edge).degree) AS A;\n+------------------------------+\n| A                            |\n+------------------------------+\n| \"player10042Tony Parker95\"   |\n| \"player10042Manu Ginobili95\" |\n+------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#concat_ws","title":"concat_ws()","text":"<p>concat_ws() returns strings concatenated by all strings that are delimited with a separator.</p> <p>Syntax: <code>concat_ws(&lt;separator&gt;,&lt;string1&gt;,&lt;string2&gt;,... )</code></p> <ul> <li>The function requires at least two or more strings.</li> </ul> <ul> <li>If the separator is <code>NULL</code>, the <code>concat_ws()</code> function returns <code>NULL</code>.</li> </ul> <ul> <li>If the separator is not <code>NULL</code> and there is only one string, the string itself is returned.</li> </ul> <ul> <li>If there is a <code>NULL</code> in the strings, <code>NULL</code> is ignored during the concatenation.</li> </ul> <p>Example:</p> <pre><code>//This example concatenates a, b, and c with the separator +.\nnebula&gt; RETURN concat_ws(\"+\",\"a\",\"b\",\"c\") AS r;\n+---------+\n| r       |\n+---------+\n| \"a+b+c\" |\n+---------+\n\n//In this example, the separator is NULL.\nneubla&gt; RETURN concat_ws(NULL,\"a\",\"b\",\"c\") AS r;\n+----------+\n| r        |\n+----------+\n| __NULL__ |\n+----------+\n\n//In this example, the separator is + and there is a NULL in the strings.\nnebula&gt; RETURN concat_ws(\"+\",\"a\",NULL,\"b\",\"c\") AS r;\n+---------+\n| r       |\n+---------+\n| \"a+b+c\" |\n+---------+\n\n//In this example, the separator is + and there is only one string.\nnebula&gt; RETURN concat_ws(\"+\",\"a\") AS r;\n+-----+\n| r   |\n+-----+\n| \"a\" |\n+-----+\nnebula&gt; GO FROM \"player100\" over follow \\\n        YIELD concat_ws(\" \",src(edge), properties($^).age, properties($$).name, properties(edge).degree) AS A;\n+---------------------------------+\n| A                               |\n+---------------------------------+\n| \"player100 42 Tony Parker 95\"   |\n| \"player100 42 Manu Ginobili 95\" |\n+---------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#extract","title":"extract()","text":"<p>extract() uses regular expression matching to retrieve a single substring or all substrings from a string.</p> <p>Syntax: <code>extract(&lt;string&gt;,\"&lt;regular_expression&gt;\")</code></p> <ul> <li><code>string</code>: A specified string</li> <li><code>regular_expression</code>: A regular expression</li> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (a:player)-[b:serve]-(c:team{name: \"Lakers\"}) \\\n        WHERE a.player.age &gt; 45 \\\n        RETURN extract(a.player.name, \"\\\\w+\") AS result;\n+----------------------------+\n| result                     |\n+----------------------------+\n| [\"Shaquille\", \"O\", \"Neal\"] |\n+----------------------------+\n\nnebula&gt; MATCH (a:player)-[b:serve]-(c:team{name: \"Lakers\"}) \\\n        WHERE a.player.age &gt; 45 \\\n        RETURN extract(a.player.name, \"hello\") AS result;\n+--------+\n| result |\n+--------+\n| []     |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/2.string/#json_extract","title":"json_extract()","text":"<p>json_extract() converts the specified JSON string to a map.</p> <p>Syntax: <code>extract(&lt;string&gt;)</code></p> <ul> <li><code>string</code>:A specified string, must be JSON string.</li> <li>Result type: Map</li> </ul> <p>Caution</p> <ul> <li>Only Bool, Double, Int, String value and NULL are supported.</li> <li>Only depth-1 nested Map is supported now. If nested Map depth is greater than 1, the nested item is left as an empty Map().</li> </ul> <p>Example:</p> <pre><code>nebula&gt; YIELD json_extract('{\"a\": 1, \"b\": {}, \"c\": {\"d\": true}}') AS result;\n+-----------------------------+\n| result                      |\n+-----------------------------+\n| {a: 1, b: {}, c: {d: true}} |\n+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/3.date-and-time/","title":"Built-in date and time functions","text":"<p>NebulaGraph supports the following built-in date and time functions:</p> Function Description int now() Returns the current timestamp of the system. timestamp timestamp() Returns the current timestamp of the system. date date() Returns the current UTC date based on the current system. time time() Returns the current UTC time based on the current system. datetime datetime() Returns the current UTC date and time based on the current system. map duration() Returns the period of time. It can be used to calculate the specified time. <p>For more information, see Date and time types.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/3.date-and-time/#examples","title":"Examples","text":"<pre><code>nebula&gt;  RETURN now(), timestamp(), date(), time(), datetime();\n+------------+-------------+------------+-----------------+----------------------------+\n| now()      | timestamp() | date()     | time()          | datetime()                 |\n+------------+-------------+------------+-----------------+----------------------------+\n| 1640057560 | 1640057560  | 2021-12-21 | 03:32:40.351000 | 2021-12-21T03:32:40.351000 |\n+------------+-------------+------------+-----------------+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/","title":"Schema-related functions","text":"<p>This topic describes the schema-related functions supported by NebulaGraph. There are two types of schema-related functions, one for native nGQL statements and the other for openCypher-compatible statements.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#for_ngql_statements","title":"For nGQL statements","text":"<p>The following functions are available in <code>YIELD</code> and <code>WHERE</code> clauses of nGQL statements.</p> <p>Note</p> <p>Since vertex, edge, vertices, edges, and path are keywords, you need to use <code>AS &lt;alias&gt;</code> to set the alias, such as <code>GO FROM \"player100\" OVER follow YIELD edge AS e;</code>.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#idvertex","title":"id(vertex)","text":"<p>id(vertex) returns the ID of a vertex.</p> <p>Syntax: <code>id(vertex)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.age  &gt; 45 YIELD id(vertex);\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player144\" |\n| \"player140\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#propertiesvertex","title":"properties(vertex)","text":"<p>properties(vertex) returns the properties of a vertex.</p> <p>Syntax: <code>properties(vertex)</code></p> <ul> <li>Result type: Map</li> </ul> <p>Example:</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.age  &gt; 45 \\\n        YIELD properties(vertex);\n+-------------------------------------+\n| properties(VERTEX)                  |\n+-------------------------------------+\n| {age: 47, name: \"Shaquille O'Neal\"} |\n| {age: 46, name: \"Grant Hill\"}       |\n+-------------------------------------+\n</code></pre> <p>You can also use the property reference symbols (<code>$^</code> and <code>$$</code>) instead of the <code>vertex</code> field in the <code>properties()</code> function to get all properties of a vertex.</p> <ul> <li><code>$^</code> represents the data of the starting vertex at the beginning of exploration. For example, in <code>GO FROM \"player100\" OVER follow reversely YIELD properties($^)</code>, <code>$^</code> refers to the vertex <code>player100</code>.</li> </ul> <ul> <li><code>$$</code> represents the data of the end vertex at the end of exploration.</li> </ul> <p><code>properties($^)</code> and <code>properties($$)</code> are generally used in <code>GO</code> statements. For more information, see Property reference.</p> <p>Caution</p> <p>You can use <code>properties().&lt;property_name&gt;</code> to get a specific property of a vertex. However, it is not recommended to use this method to obtain specific properties because the <code>properties()</code> function returns all properties, which can decrease query performance.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#propertiesedge","title":"properties(edge)","text":"<p>properties(edge) returns the properties of an edge.</p> <p>Syntax: <code>properties(edge)</code></p> <ul> <li>Result type: Map</li> </ul> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD properties(edge);\n+------------------+\n| properties(EDGE) |\n+------------------+\n| {degree: 95}     |\n| {degree: 95}     |\n+------------------+\n</code></pre> <p>Caution</p> <p>You can use <code>properties(edge).&lt;property_name&gt;</code> to get a specific property of an edge. However, it is not recommended to use this method to obtain specific properties because the <code>properties(edge)</code> function returns all properties, which can decrease query performance.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#typeedge","title":"type(edge)","text":"<p>type(edge) returns the edge type of an edge.</p> <p>Syntax: <code>type(edge)</code></p> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge), type(edge), rank(edge);\n+-------------+-------------+------------+------------+\n| src(EDGE)   | dst(EDGE)   | type(EDGE) | rank(EDGE) |\n+-------------+-------------+------------+------------+\n| \"player100\" | \"player101\" | \"follow\"   | 0          |\n| \"player100\" | \"player125\" | \"follow\"   | 0          |\n+-------------+-------------+------------+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#srcedge","title":"src(edge)","text":"<p>src(edge) returns the source vertex ID of an edge.</p> <p>Syntax: <code>src(edge)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge);\n+-------------+-------------+\n| src(EDGE)   | dst(EDGE)   |\n+-------------+-------------+\n| \"player100\" | \"player101\" |\n| \"player100\" | \"player125\" |\n+-------------+-------------+\n</code></pre> <p>Note</p> <p>The semantics of the query for the starting vertex with src(edge) and properties(<code>$^</code>) are different. src(edge) indicates the starting vertex ID of the edge in the graph database, while properties(<code>$^</code>) indicates the data of the starting vertex where you start to expand the graph, such as the data of the starting vertex <code>player100</code> in the above GO statement. </p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#dstedge","title":"dst(edge)","text":"<p>dst(edge) returns the destination vertex ID of an edge.</p> <p>Syntax: <code>dst(edge)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge);\n+-------------+-------------+\n| src(EDGE)   | dst(EDGE)   |\n+-------------+-------------+\n| \"player100\" | \"player101\" |\n| \"player100\" | \"player125\" |\n+-------------+-------------+\n</code></pre> <p>Note</p> <p>dst(edge) indicates the destination vertex ID of the edge in the graph database.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#rankedge","title":"rank(edge)","text":"<p>rank(edge) returns the rank value of an edge.</p> <p>Syntax: <code>rank(edge)</code></p> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD src(edge), dst(edge), rank(edge);\n+-------------+-------------+------------+\n| src(EDGE)   | dst(EDGE)   | rank(EDGE) |\n+-------------+-------------+------------+\n| \"player100\" | \"player101\" | 0          |\n| \"player100\" | \"player125\" | 0          |\n+-------------+-------------+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#vertex","title":"vertex","text":"<p>vertex returns the information of vertices, including VIDs, tags, properties, and values. You need to use <code>AS &lt;alias&gt;</code> to set the alias.</p> <p>Syntax: <code>vertex</code></p> <p>Example:</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.age &gt; 45 YIELD vertex AS v;\n+----------------------------------------------------------+\n| v                                                        |\n+----------------------------------------------------------+\n| (\"player144\" :player{age: 47, name: \"Shaquille O'Neal\"}) |\n| (\"player140\" :player{age: 46, name: \"Grant Hill\"})       |\n+----------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#edge","title":"edge","text":"<p>edge returns the information of edges, including edge types, source vertices, destination vertices, ranks, properties, and values. You need to use <code>AS &lt;alias&gt;</code> to set the alias.</p> <p>Syntax: <code>edge</code></p> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow YIELD edge AS e;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}] |\n| [:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}] |\n+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#vertices","title":"vertices","text":"<p>vertices returns the information of vertices in a subgraph. For more information, see GET SUBGRAPH.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#edges","title":"edges","text":"<p>edges returns the information of edges in a subgraph. For more information, see GET SUBGRAPH.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#path","title":"path","text":"<p>path returns the information of a path. For more information, see FIND PATH.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#for_statements_compatible_with_opencypher","title":"For statements compatible with openCypher","text":"<p>The following functions are available in <code>RETURN</code> and <code>WHERE</code> clauses of openCypher-compatible statements.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#id","title":"id()","text":"<p>id() returns the ID of a vertex.</p> <p>Syntax: <code>id(&lt;vertex&gt;)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player) RETURN id(v); \n+-------------+\n| id(v)       |\n+-------------+\n| \"player129\" |\n| \"player115\" |\n| \"player106\" |\n| \"player102\" |\n...\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#tags_and_labels","title":"tags() and labels()","text":"<p>tags() and labels() return the Tag of a vertex.</p> <p>Syntax: <code>tags(&lt;vertex&gt;)</code>, <code>labels(&lt;vertex&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v) WHERE id(v) == \"player100\" \\\n        RETURN tags(v);\n+------------+\n| tags(v)    |\n+------------+\n| [\"player\"] |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#properties","title":"properties()","text":"<p>properties() returns the properties of a vertex or an edge.</p> <p>Syntax: <code>properties(&lt;vertex_or_edge&gt;)</code></p> <ul> <li>Result type: Map</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player)-[e:follow]-() RETURN properties(v),properties(e);\n+---------------------------------------+---------------+\n| properties(v)                         | properties(e) |\n+---------------------------------------+---------------+\n| {age: 31, name: \"Stephen Curry\"}      | {degree: 90}  |\n| {age: 47, name: \"Shaquille O'Neal\"}   | {degree: 100} |\n| {age: 34, name: \"LeBron James\"}       | {degree: 13}  |\n...\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#type","title":"type()","text":"<p>type() returns the edge type of an edge.</p> <p>Syntax: <code>type(&lt;edge&gt;)</code></p> <ul> <li>Result type: String</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN type(e);\n+----------+\n| type(e)  |\n+----------+\n| \"serve\"  |\n| \"follow\" |\n| \"follow\" |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#typeid","title":"typeid()","text":"<p>typeid() returns the internal ID value of the Edge type of the edge, which can be used to determine the direction by positive or negative.</p> <p>Syntax: <code>typeid(&lt;edge&gt;)</code></p> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player)-[e:follow]-(v2) RETURN e,typeid(e), \\\n        CASE WHEN typeid(e) &gt; 0 \\\n        THEN \"Forward\" ELSE \"Reverse\" END AS direction \\\n        LIMIT 5;\n+----------------------------------------------------+-----------+-----------+\n| e                                                  | typeid(e) | direction |\n+----------------------------------------------------+-----------+-----------+\n| [:follow \"player127\"-&gt;\"player114\" @0 {degree: 90}] | 5         | \"Forward\" |\n| [:follow \"player127\"-&gt;\"player148\" @0 {degree: 70}] | 5         | \"Forward\" |\n| [:follow \"player148\"-&gt;\"player127\" @0 {degree: 80}] | -5        | \"Reverse\" |\n| [:follow \"player147\"-&gt;\"player136\" @0 {degree: 90}] | 5         | \"Forward\" |\n| [:follow \"player136\"-&gt;\"player147\" @0 {degree: 90}] | -5        | \"Reverse\" |\n+----------------------------------------------------+-----------+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#src","title":"src()","text":"<p>src() returns the source vertex ID of an edge.</p> <p>Syntax: <code>src(&lt;edge&gt;)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH ()-[e]-&gt;(v:player{name:\"Tim Duncan\"}) \\\n        RETURN src(e);\n+-------------+\n| src(e)      |\n+-------------+\n| \"player125\" |\n| \"player113\" |\n| \"player102\" |\n...\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#dst","title":"dst()","text":"<p>dst() returns the destination vertex ID of an edge.</p> <p>Syntax: <code>dst(&lt;edge&gt;)</code></p> <ul> <li>Result type: Same as the vertex ID.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN dst(e);\n+-------------+\n| dst(e)      |\n+-------------+\n| \"team204\"   |\n| \"player101\" |\n| \"player125\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#startnode","title":"startNode()","text":"<p>startNode() visits a path and returns its information of source vertex ID, including VIDs, tags, properties, and values.</p> <p>Syntax: <code>startNode(&lt;path&gt;)</code></p> <p>Example:</p> <pre><code>nebula&gt; MATCH p = (a :player {name : \"Tim Duncan\"})-[r:serve]-(t) \\\n        RETURN startNode(p);\n+----------------------------------------------------+\n| startNode(p)                                       |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#endnode","title":"endNode()","text":"<p>endNode() visits a path and returns its information of destination vertex ID, including VIDs, tags, properties, and values.</p> <p>Syntax: <code>endNode(&lt;path&gt;)</code></p> <p>Example:</p> <pre><code>nebula&gt; MATCH p = (a :player {name : \"Tim Duncan\"})-[r:serve]-(t) \\\n        RETURN endNode(p);\n+----------------------------------+\n| endNode(p)                       |\n+----------------------------------+\n| (\"team204\" :team{name: \"Spurs\"}) |\n+----------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/4.schema/#rank","title":"rank()","text":"<p>rank() returns the rank value of an edge.</p> <p>Syntax: <code>rank(&lt;edge&gt;)</code></p> <ul> <li>Result type: Int</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN rank(e);\n+---------+\n| rank(e) |\n+---------+\n| 0       |\n| 0       |\n| 0       |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/","title":"Conditional expressions","text":"<p>This topic describes the conditional functions supported by NebulaGraph.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/#case","title":"CASE","text":"<p>The <code>CASE</code> expression uses conditions to filter the parameters. nGQL provides two forms of <code>CASE</code> expressions just like openCypher: the simple form and the generic form.</p> <p>The <code>CASE</code> expression will traverse all the conditions. When the first condition is met, the <code>CASE</code> expression stops reading the conditions and returns the result. If no conditions are met, it returns the result in the <code>ELSE</code> clause. If there is no <code>ELSE</code> clause and no conditions are met, it returns <code>NULL</code>.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/#the_simple_form_of_case_expressions","title":"The simple form of CASE expressions","text":"<ul> <li>Syntax</li> </ul> <pre><code>CASE &lt;comparer&gt;\nWHEN &lt;value&gt; THEN &lt;result&gt;\n[WHEN ...]\n[ELSE &lt;default&gt;]\nEND\n</code></pre> <p>Caution</p> <p>Always remember to end the <code>CASE</code> expression with an <code>END</code>.</p> Parameter Description <code>comparer</code> A value or a valid expression that outputs a value. This value is used to compare with the <code>value</code>. <code>value</code> It will be compared with the <code>comparer</code>. If the <code>value</code> matches the <code>comparer</code>, then this condition is met. <code>result</code> The <code>result</code> is returned by the <code>CASE</code> expression if the <code>value</code> matches the <code>comparer</code>. <code>default</code> The <code>default</code> is returned by the <code>CASE</code> expression if no conditions are met. <ul> <li>Examples</li> </ul> <pre><code>nebula&gt; RETURN \\\n        CASE 2+3 \\\n        WHEN 4 THEN 0 \\\n        WHEN 5 THEN 1 \\\n        ELSE -1 \\\n        END \\\n        AS result;\n+--------+\n| result |\n+--------+\n| 1      |\n+--------+\n</code></pre> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD properties($$).name AS Name, \\\n        CASE properties($$).age &gt; 35 \\\n        WHEN true THEN \"Yes\" \\\n        WHEN false THEN \"No\" \\\n        ELSE \"Nah\" \\\n        END \\\n        AS Age_above_35;\n+-----------------+--------------+\n| Name            | Age_above_35 |\n+-----------------+--------------+\n| \"Tony Parker\"   | \"Yes\"        |\n| \"Manu Ginobili\" | \"Yes\"        |\n+-----------------+--------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/#the_generic_form_of_case_expressions","title":"The generic form of CASE expressions","text":"<ul> <li>Syntax</li> </ul> <pre><code>CASE\nWHEN &lt;condition&gt; THEN &lt;result&gt;\n[WHEN ...]\n[ELSE &lt;default&gt;]\nEND\n</code></pre> Parameter Description <code>condition</code> If the <code>condition</code> is evaluated as true, the <code>result</code> is returned by the <code>CASE</code> expression. <code>result</code> The <code>result</code> is returned by the <code>CASE</code> expression if the <code>condition</code> is evaluated as true. <code>default</code> The <code>default</code> is returned by the <code>CASE</code> expression if no conditions are met. <ul> <li>Examples</li> </ul> <pre><code>nebula&gt; YIELD \\\n        CASE WHEN 4 &gt; 5 THEN 0 \\\n        WHEN 3+4==7 THEN 1 \\\n        ELSE 2 \\\n        END \\\n        AS result;\n+--------+\n| result |\n+--------+\n| 1      |\n+--------+\n</code></pre> <pre><code>nebula&gt; MATCH (v:player) WHERE v.player.age &gt; 30 \\\n        RETURN v.player.name AS Name,  \\\n        CASE \\\n        WHEN v.player.name STARTS WITH \"T\" THEN \"Yes\" \\\n        ELSE \"No\" \\\n        END \\\n        AS Starts_with_T;\n+---------------------+---------------+\n| Name                | Starts_with_T |\n+---------------------+---------------+\n| \"Tim Duncan\"        | \"Yes\"         |\n| \"LaMarcus Aldridge\" | \"No\"          |\n| \"Tony Parker\"       | \"Yes\"         |\n+---------------------+---------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/#differences_between_the_simple_form_and_the_generic_form","title":"Differences between the simple form and the generic form","text":"<p>To avoid the misuse of the simple form and the generic form, it is important to understand their differences. The following example can help explain them.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD properties($$).name AS Name, properties($$).age AS Age, \\\n        CASE properties($$).age \\\n        WHEN properties($$).age &gt; 35 THEN \"Yes\" \\\n        ELSE \"No\" \\\n        END \\\n        AS Age_above_35;\n+-----------------+-----+--------------+\n| Name            | Age | Age_above_35 |\n+-----------------+-----+--------------+\n| \"Tony Parker\"   | 36  | \"No\"         |\n| \"Manu Ginobili\" | 41  | \"No\"         |\n+-----------------+-----+--------------+\n</code></pre> <p>The preceding <code>GO</code> query is intended to output <code>Yes</code> when the player's age is above 35. However, in this example, when the player's age is 36, the actual output is not as expected: It is <code>No</code> instead of <code>Yes</code>.</p> <p>This is because the query uses the <code>CASE</code> expression in the simple form, and a comparison between the values of <code>$$.player.age</code> and <code>$$.player.age &gt; 35</code> is made. When the player age is 36:</p> <ul> <li>The value of <code>$$.player.age</code> is <code>36</code>. It is an integer.</li> </ul> <ul> <li><code>$$.player.age &gt; 35</code> is evaluated to be <code>true</code>. It is a boolean.</li> </ul> <p>The values of <code>$$.player.age</code> and <code>$$.player.age &gt; 35</code> do not match. Therefore, the condition is not met and <code>No</code> is returned.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/5.conditional-expressions/#coalesce","title":"coalesce()","text":"<p>coalesce() returns the first not null value in all expressions.</p> <p>Syntax: <code>coalesce(&lt;expression_1&gt;[,&lt;expression_2&gt;...])</code></p> <ul> <li>Result type: Same as the original element.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN coalesce(null,[1,2,3]) as result;\n+-----------+\n| result    |\n+-----------+\n| [1, 2, 3] |\n+-----------+\nnebula&gt; RETURN coalesce(null) as result;\n+----------+\n| result   |\n+----------+\n| __NULL__ |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/","title":"List functions","text":"<p>This topic describes the list functions supported by NebulaGraph. Some of the functions have different syntax in native nGQL statements and openCypher-compatible statements.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#precautions","title":"Precautions","text":"<p>Like SQL, the position index in nGQL starts from <code>1</code>, while in the C language it starts from <code>0</code>.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#general","title":"General","text":""},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#range","title":"range()","text":"<p>range() returns the list containing all the fixed-length steps in <code>[start,end]</code>.</p> <p>Syntax: <code>range(start, end [, step])</code></p> <ul> <li><code>step</code>: Optional parameters. <code>step</code> is 1 by default.</li> </ul> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN range(1,9,2);\n+-----------------+\n| range(1,9,2)    |\n+-----------------+\n| [1, 3, 5, 7, 9] |\n+-----------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#reverse","title":"reverse()","text":"<p>reverse() returns the list reversing the order of all elements in the original list.</p> <p>Syntax: <code>reverse(&lt;list&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN reverse(ids);\n+-----------------------------------+\n| reverse(ids)                      |\n+-----------------------------------+\n| [487, 521, \"abc\", 4923, __NULL__] |\n+-----------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#tail","title":"tail()","text":"<p>tail() returns all the elements of the original list, excluding the first one.</p> <p>Syntax: <code>tail(&lt;list&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN tail(ids);\n+-------------------------+\n| tail(ids)               |\n+-------------------------+\n| [4923, \"abc\", 521, 487] |\n+-------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#head","title":"head()","text":"<p>head() returns the first element of a list.</p> <p>Syntax: <code>head(&lt;list&gt;)</code></p> <ul> <li>Result type: Same as the element in the original list.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN head(ids);\n+-----------+\n| head(ids) |\n+-----------+\n| __NULL__  |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#last","title":"last()","text":"<p>last() returns the last element of a list.</p> <p>Syntax: <code>last(&lt;list&gt;)</code></p> <ul> <li>Result type: Same as the element in the original list.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; WITH [NULL, 4923, 'abc', 521, 487] AS ids \\\n        RETURN last(ids);\n+-----------+\n| last(ids) |\n+-----------+\n| 487       |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#reduce","title":"reduce()","text":"<p>reduce() applies an expression to each element in a list one by one, chains the result to the next iteration by taking it as the initial value, and returns the final result. This function iterates each element <code>e</code> in the given list, runs the expression on <code>e</code>, accumulates the result with the initial value, and store the new result in the accumulator as the initial value of the next iteration. It works like the fold or reduce method in functional languages such as Lisp and Scala.</p> <p>openCypher compatibility</p> <p>In openCypher, the <code>reduce()</code> function is not defined. nGQL will implement the <code>reduce()</code> function in the Cypher way.</p> <p>Syntax: <code>reduce(&lt;accumulator&gt; = &lt;initial&gt;, &lt;variable&gt; IN &lt;list&gt; | &lt;expression&gt;)</code></p> <ul> <li><code>accumulator</code>: A variable that will hold the accumulated results as the list is iterated.</li> </ul> <ul> <li><code>initial</code>: An expression that runs once to give an initial value to the <code>accumulator</code>.</li> </ul> <ul> <li><code>variable</code>: A variable in the list that will be applied to the expression successively.</li> </ul> <ul> <li><code>list</code>: A list or a list of expressions.</li> </ul> <ul> <li><code>expression</code>: This expression will be run on each element in the list once and store the result value in the <code>accumulator</code>.</li> </ul> <ul> <li>Result type: Depends on the parameters provided, along with the semantics of the expression.</li> </ul> <p>Example:</p> <pre><code>nebula&gt; RETURN reduce(totalNum = -4 * 5, n IN [1, 2] | totalNum + n * 2) AS r;\n+-----+\n| r   |\n+-----+\n| -14 |\n+-----+\n\nnebula&gt; MATCH p = (n:player{name:\"LeBron James\"})&lt;-[:follow]-(m) \\\n        RETURN  nodes(p)[0].player.age AS src1,  nodes(p)[1].player.age AS dst2,  \\\n        reduce(totalAge = 100, n IN nodes(p) | totalAge + n.player.age) AS sum;\n+------+------+-----+\n| src1 | dst2 | sum |\n+------+------+-----+\n| 34   | 31   | 165 |\n| 34   | 29   | 163 |\n| 34   | 33   | 167 |\n| 34   | 26   | 160 |\n| 34   | 34   | 168 |\n| 34   | 37   | 171 |\n+------+------+-----+\n\nnebula&gt; LOOKUP ON player WHERE player.name == \"Tony Parker\" YIELD id(vertex) AS VertexID \\\n        |  GO FROM $-.VertexID over follow \\\n        WHERE properties(edge).degree != reduce(totalNum = 5, n IN range(1, 3) | properties($$).age + totalNum + n) \\\n        YIELD properties($$).name AS id, properties($$).age AS age, properties(edge).degree AS degree;\n+---------------------+-----+--------+\n| id                  | age | degree |\n+---------------------+-----+--------+\n| \"Tim Duncan\"        | 42  | 95     |\n| \"LaMarcus Aldridge\" | 33  | 90     |\n| \"Manu Ginobili\"     | 41  | 95     |\n+---------------------+-----+--------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#for_ngql_statements","title":"For nGQL statements","text":""},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#keys","title":"keys()","text":"<p>keys() returns a list containing the string representations for all the property names of vertices or edges.</p> <p>Syntax: <code>keys({vertex | edge})</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; LOOKUP ON player \\\n        WHERE player.age  &gt; 45 \\\n        YIELD keys(vertex);\n+-----------------+\n| keys(VERTEX)    |\n+-----------------+\n| [\"age\", \"name\"] |\n| [\"age\", \"name\"] |\n+-----------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#labels","title":"labels()","text":"<p>labels() returns the list containing all the tags of a vertex.</p> <p>Syntax: <code>labels(verte)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; FETCH PROP ON * \"player101\", \"player102\", \"team204\" \\\n        YIELD labels(vertex);\n+----------------+\n| labels(VERTEX) |\n+----------------+\n| [\"player\"]     |\n| [\"player\"]     |\n| [\"team\"]       |\n+----------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#for_statements_compatible_with_opencypher","title":"For statements compatible with openCypher","text":""},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#keys_1","title":"keys()","text":"<p>keys() returns a list containing the string representations for all the property names of vertices, edges, or maps.</p> <p>Syntax: <code>keys(&lt;vertex_or_edge&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN keys(e);\n+----------------------------+\n| keys(e)                    |\n+----------------------------+\n| [\"end_year\", \"start_year\"] |\n| [\"degree\"]                 |\n| [\"degree\"]                 |\n+----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#labels_1","title":"labels()","text":"<p>labels() returns the list containing all the tags of a vertex.</p> <p>Syntax: <code>labels(&lt;vertex&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH (v)-[e:serve]-&gt;() \\\n        WHERE id(v)==\"player100\" \\\n        RETURN labels(v);\n+------------+\n| labels(v)  |\n+------------+\n| [\"player\"] |\n+------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#nodes","title":"nodes()","text":"<p>nodes() returns the list containing all the vertices in a path.</p> <p>Syntax: <code>nodes(&lt;path&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) \\\n        RETURN nodes(p);\n+-------------------------------------------------------------------------------------------------------------+\n| nodes(p)                                                                                                    |\n+-------------------------------------------------------------------------------------------------------------+\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"team204\" :team{name: \"Spurs\"})]                      |\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"player101\" :player{age: 36, name: \"Tony Parker\"})]   |\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})] |\n+-------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/6.list/#relationships","title":"relationships()","text":"<p>relationships() returns the list containing all the relationships in a path.</p> <p>Syntax: <code>relationships(&lt;path&gt;)</code></p> <ul> <li>Result type: List</li> </ul> <p>Example:</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) \\\n        RETURN relationships(p);\n+-------------------------------------------------------------------------+\n| relationships(p)                                                        |\n+-------------------------------------------------------------------------+\n| [[:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}]] |\n| [[:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}]]                    |\n| [[:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}]]                    |\n+-------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/8.predicate/","title":"Predicate functions","text":"<p>Predicate functions return <code>true</code> or <code>false</code>. They are most commonly used in <code>WHERE</code> clauses.</p> <p>NebulaGraph supports the following predicate functions:</p> Functions Description exists() Returns <code>true</code> if the specified property exists in the vertex, edge or map. Otherwise, returns <code>false</code>. any() Returns <code>true</code> if the specified predicate holds for at least one element in the given list. Otherwise, returns <code>false</code>. all() Returns <code>true</code> if the specified predicate holds for all elements in the given list. Otherwise, returns <code>false</code>. none() Returns <code>true</code> if the specified predicate holds for no element in the given list. Otherwise, returns <code>false</code>. single() Returns <code>true</code> if the specified predicate holds for exactly one of the elements in the given list. Otherwise, returns <code>false</code>. <p>Note</p> <p>NULL is returned if the list is NULL or all of its elements are NULL.</p> <p>Compatibility</p> <p>In openCypher, only function <code>exists()</code> is defined and specified. The other functions are implement-dependent.</p>"},{"location":"3.ngql-guide/6.functions-and-expressions/8.predicate/#syntax","title":"Syntax","text":"<pre><code>&lt;predicate&gt;(&lt;variable&gt; IN &lt;list&gt; WHERE &lt;condition&gt;)\n</code></pre>"},{"location":"3.ngql-guide/6.functions-and-expressions/8.predicate/#examples","title":"Examples","text":"<pre><code>nebula&gt; RETURN any(n IN [1, 2, 3, 4, 5, NULL] \\\n        WHERE n &gt; 2) AS r;\n+------+\n| r    |\n+------+\n| true |\n+------+\n\nnebula&gt; RETURN single(n IN range(1, 5) \\\n        WHERE n == 3) AS r;\n+------+\n| r    |\n+------+\n| true |\n+------+\n\nnebula&gt; RETURN none(n IN range(1, 3) \\\n        WHERE n == 0) AS r;\n+------+\n| r    |\n+------+\n| true |\n+------+\n\nnebula&gt; WITH [1, 2, 3, 4, 5, NULL] AS a \\\n        RETURN any(n IN a WHERE n &gt; 2);\n+-------------------------+\n| any(n IN a WHERE (n&gt;2)) |\n+-------------------------+\n| true                    |\n+-------------------------+\n\nnebula&gt; MATCH p = (n:player{name:\"LeBron James\"})&lt;-[:follow]-(m) \\\n        RETURN nodes(p)[0].player.name AS n1, nodes(p)[1].player.name AS n2, \\\n        all(n IN nodes(p) WHERE n.player.name NOT STARTS WITH \"D\") AS b;\n+----------------+-------------------+-------+\n| n1             | n2                | b     |\n+----------------+-------------------+-------+\n| \"LeBron James\" | \"Danny Green\"     | false |\n| \"LeBron James\" | \"Dejounte Murray\" | false |\n| \"LeBron James\" | \"Chris Paul\"      | true  |\n| \"LeBron James\" | \"Kyrie Irving\"    | true  |\n| \"LeBron James\" | \"Carmelo Anthony\" | true  |\n| \"LeBron James\" | \"Dwyane Wade\"     | false |\n+----------------+-------------------+-------+\n\nnebula&gt; MATCH p = (n:player{name:\"LeBron James\"})-[:follow]-&gt;(m) \\\n        RETURN single(n IN nodes(p) WHERE n.player.age &gt; 40) AS b;\n+------+\n| b    |\n+------+\n| true |\n+------+\n\nnebula&gt; MATCH (n:player) \\\n        RETURN exists(n.player.id), n IS NOT NULL;\n+---------------------+---------------+\n| exists(n.player.id) | n IS NOT NULL |\n+---------------------+---------------+\n| false               | true          |\n...\n\nnebula&gt; MATCH (n:player) \\\n        WHERE exists(n['name']) RETURN n;\n+-------------------------------------------------------------------------------------------------------------+\n| n                                                                                                           |\n+-------------------------------------------------------------------------------------------------------------+\n| (\"Grant Hill\" :player{age: 46, name: \"Grant Hill\"})                                                         |\n| (\"Marc Gasol\" :player{age: 34, name: \"Marc Gasol\"})                                                         |\n+-------------------------------------------------------------------------------------------------------------+\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/","title":"Overview of NebulaGraph general query statements","text":"<p>This topic provides an overview of the general categories of query statements in NebulaGraph and outlines their use cases.</p>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#background","title":"Background","text":"<p>NebulaGraph stores data in the form of vertices and edges. Each vertex can have zero or more tags and each edge has exactly one edge type. Tags define the type of a vertex and describe its properties, while edge types define the type of an edge and describe its properties. When querying, you can limit the scope of the query by specifying the tag of a vertex or the type of an edge. For more information, see Patterns.</p>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#categories","title":"Categories","text":"<p>The primary query statements in NebulaGraph fall into the following categories:</p> <ul> <li>FETCH PROP ON</li> <li>LOOKUP ON</li> <li>GO</li> <li>MATCH</li> <li>FIND PATH</li> <li>GET SUBGRAPH</li> <li>SHOW</li> </ul> <p><code>FETCH PROP ON</code> and <code>LOOKUP ON</code> statements are primarily for basic data queries, <code>GO</code> and <code>MATCH</code> for more intricate queries and graph traversals, <code>FIND PATH</code> and <code>GET SUBGRAPH</code> for path and subgraph queries, and <code>SHOW</code> for retrieving database metadata.</p>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#usage_and_use_cases","title":"Usage and use cases","text":""},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#fetch_prop_on","title":"FETCH PROP ON","text":"<p>Usage: Retrieve properties of a specified vertex or edge.</p> <p>Use case: Knowing the specific vertex or edge ID and wanting to retrieve its properties.</p> <p>Note:</p> <ul> <li>Must specify the ID of the vertex or edge.</li> <li>Must specify the tag of the vertex or the edge type of the edge.</li> <li>Must use the <code>YIELD</code> clause to specify the returned properties.</li> </ul> <p>Example:</p> <pre><code>FETCH PROP ON player \"player100\" YIELD properties(vertex);\n              --+---  ----+-----       -------+----------\n                |         |                   |\n                |         |                   |\n                |         |                   +--------- Returns all properties under the player tag of the vertex.\n                |         |\n                |         +----------------- Retrieves from the vertex \"player100\".\n                |\n                +--------------------------- Retrieves properties under the player tag.\n</code></pre> <p>For more information, see FETCH PROP ON.</p>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#lookup_on","title":"LOOKUP ON","text":"<p>Usage: Index-based querying of vertex or edge IDs.</p> <p>Use case: Finding vertex or edge IDs based on property values.</p> <p>Note: - Must pre-define indexes for the tag, edge type, or property. - Must specify the tag of the vertex or the edge type of the edge. - Must use the <code>YIELD</code> clause to specify the returned IDs.</p> <p>Example:</p> <pre><code>LOOKUP ON player WHERE player.name == \"Tony Parker\" YIELD id(vertex);\n          --+--- ------------------+---------------       ---+------\n            |                      |                         |\n            |                      |                         |\n            |                      |                         +---- Returns the VID of the retrieved vertex.\n            |                      |\n            |                      +------------ Filtering is based on the value of the property name.\n            |\n            +----------------------------------- Queries based on the player tag.\n</code></pre> <p>For more information, see LOOKUP ON.</p>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#go","title":"GO","text":"<p>Usage: Traverse the graph based on a given vertex and return information about the starting vertex, edges, or target vertices as needed. Use case: Complex graph traversals, such as finding friends of a vertex, friends' friends, etc.</p> <p>Note: - Use property reference symbols (<code>$^</code> and <code>$$</code>) to return properties of the starting or target vertices, e.g., <code>YIELD $^.player.name</code>. - Use the functions <code>properties($^)</code> and <code>properties($$)</code> to return all properties of the starting or target vertices. Specify property names in the function to return specific properties, e.g., <code>YIELD properties($^).name</code>. - Use the functions <code>src(edge)</code> and <code>dst(edge)</code> to return the starting or destination vertex ID of an edge, e.g., <code>YIELD src(edge)</code>.</p> <p>Example:</p> <pre><code>GO 3 STEPS FROM \"player102\" OVER follow YIELD dst(edge);\n-----+---       --+-------       -+----       ---+-----\n     |            |               |              |\n     |            |               |              |\n     |            |               |              +--------- Returns the destination vertex of the last hop.\n     |            |               |\n     |            |               +------ Traverses out via the edge follow.\n     |            |\n     |            +--------------------- Starts from \"player102\".\n     |\n     +---------------------------------- Traverses 3 steps.\n</code></pre> <p>For more information, see GO.</p>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#match","title":"MATCH","text":"<p>Usage: Execute complex graph pattern matching queries.</p> <p>Use case: Complex graph pattern matching, such as finding combinations of vertices and edges that satisfy a specific pattern.</p> <p>Note:</p> <p><code>MATCH</code> statements are compatible with the OpenCypher syntax but with some differences:</p> <ul> <li>Use <code>==</code> for equality instead of <code>=</code>, e.g., <code>WHERE player.name == \"Tony Parker\"</code>.</li> <li>When referencing properties of vertices, you need to specify the vertex's tag, e.g., <code>YIELD player.name</code>.</li> <li>Introduces the <code>WHERE id(v) == \"player100\"</code> syntax.</li> <li>Must use the <code>RETURN</code> clause to specify what information to return.</li> </ul> <p>Example:</p> <pre><code>MATCH (v:player{name:\"Tim Duncan\"})--&gt;(v2:player) \\\n        RETURN v2.player.name AS Name;\n</code></pre> <p>For more information, see MATCH.</p>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#find_path","title":"FIND PATH","text":"<p>Usage: Query paths between given starting and target vertices or query properties of vertices and edges along paths.</p> <p>Use case: Querying paths between two vertices.</p> <p>Note: Must use the <code>YIELD</code> clause to specify returned information.</p> <p>Example:</p> <pre><code>FIND SHORTEST PATH FROM \"player102\" TO \"team204\" OVER * YIELD path AS p;\n-------+-----           -------+---------------- ---+--       ----+----\n       |                       |                    |             |\n       |                       |                    |             |\n       |                       |                    |             +---------- Returns the path as 'p'.\n       |                       |                    |\n       |                       |                    +----------- Travels outwards via all types of edges.\n       |                       |    \n       |                       |\n       |                       +------------------ From the given starting and target VIDs.  \n       |\n       +--------------------------- Retrieves the shortest path.\n</code></pre> <p>For more information, see FIND PATH.</p>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#get_subgraph","title":"GET SUBGRAPH","text":"<p>Usage: Extract a portion of the graph that satisfies specific conditions or query properties of vertices and edges in the subgraph.</p> <p>Use case: Analyzing structures of the graph or specific regions, such as extracting the social network subgraph of a person or the transportation network subgraph of an area.</p> <p>Note: Must use the <code>YIELD</code> clause to specify returned information.</p> <p>Example:</p> <pre><code>GET SUBGRAPH 5 STEPS FROM \"player101\" YIELD VERTICES AS nodes, EDGES AS relationships;\n             -----+- -----+--------         ------------------------+----------------\n                  |       |                                         |\n                  |       |                                         |\n                  |       +------- Starts from \"player101\".         +------------ Returns all vertices and edges.\n                  |\n                  +----------------- Gets exploration of 5 steps     \n</code></pre> <p>For more information, see GET SUBGRAPH.</p>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#show","title":"SHOW","text":"<p><code>SHOW</code> statements are mainly used to obtain metadata information from the database, not for retrieving the actual data stored in the database. These statements are typically used to query the structure and configuration of the database.</p> Statement Syntax Example Description SHOW CHARSET <code>SHOW CHARSET</code> <code>SHOW CHARSET</code> Shows the available character sets. SHOW COLLATION <code>SHOW COLLATION</code> <code>SHOW COLLATION</code> Shows the collations supported by NebulaGraph. SHOW CREATE SPACE <code>SHOW CREATE SPACE &lt;space_name&gt;</code> <code>SHOW CREATE SPACE basketballplayer</code> Shows the creating statement of the specified graph space. SHOW CREATE TAG/EDGE <code>SHOW CREATE {TAG &lt;tag_name&gt; | EDGE &lt;edge_name&gt;}</code> <code>SHOW CREATE TAG player</code> Shows the basic information of the specified tag. SHOW HOSTS <code>SHOW HOSTS [GRAPH | STORAGE | META]</code> <code>SHOW HOSTS</code><code>SHOW HOSTS GRAPH</code> Shows the host and version information of Graph Service, Storage Service, and Meta Service. SHOW INDEX STATUS <code>SHOW {TAG | EDGE} INDEX STATUS</code> <code>SHOW TAG INDEX STATUS</code> Shows the status of jobs that rebuild native indexes, which helps check whether a native index is successfully rebuilt or not. SHOW INDEXES <code>SHOW {TAG | EDGE} INDEXES</code> <code>SHOW TAG INDEXES</code> Shows the names of existing native indexes. SHOW PARTS <code>SHOW PARTS [&lt;part_id&gt;]</code> <code>SHOW PARTS</code> Shows the information of a specified partition or all partitions in a graph space. SHOW ROLES <code>SHOW ROLES IN &lt;space_name&gt;</code> <code>SHOW ROLES in basketballplayer</code> Shows the roles that are assigned to a user account. SHOW SNAPSHOTS <code>SHOW SNAPSHOTS</code> <code>SHOW SNAPSHOTS</code> Shows the information of all the snapshots. SHOW SPACES <code>SHOW SPACES</code> <code>SHOW SPACES</code> Shows existing graph spaces in NebulaGraph. SHOW STATS <code>SHOW STATS</code> <code>SHOW STATS</code> Shows the statistics of the graph space collected by the latest <code>STATS</code> job. SHOW TAGS/EDGES <code>SHOW TAGS | EDGES</code> <code>SHOW TAGS</code>,<code>SHOW EDGES</code> Shows all the tags in the current graph space. SHOW USERS <code>SHOW USERS</code> <code>SHOW USERS</code> Shows the user information. SHOW SESSIONS <code>SHOW SESSIONS</code> <code>SHOW SESSIONS</code> Shows the information of all the sessions. SHOW SESSIONS <code>SHOW SESSION &lt;Session_Id&gt;</code> <code>SHOW SESSION 1623304491050858</code> Shows a specified session with its ID. SHOW QUERIES <code>SHOW [ALL] QUERIES</code> <code>SHOW QUERIES</code> Shows the information of working queries in the current session. SHOW META LEADER <code>SHOW META LEADER</code> <code>SHOW META LEADER</code> Shows the information of the leader in the current Meta cluster."},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#compound_queries","title":"Compound queries","text":"<p>Query statements in NebulaGraph can be combined to achieve more complex queries.</p> <p>When referencing the results of a subquery in a compound statement, you need to create an alias for the result and use the pipe symbol(<code>|</code>) to pass it to the next subquery. Use <code>$-</code> in the next subquery to reference the alias of that result. See Pipe Symbol for details.</p> <p>Example:</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS dstid, properties($$).name AS Name | \\\n        GO FROM $-.dstid OVER follow YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player100\" |\n| \"player102\" |\n| \"player125\" |\n| \"player100\" |\n+-------------+\n</code></pre> <p>The pipe symbol <code>|</code> is applicable only in nGQL and cannot be used in OpenCypher statements. If you need to perform compound queries using <code>MATCH</code> statements, you can use the WITH clause.</p> <p>Example:</p> <pre><code>nebula&gt; MATCH (v:player)--&gt;(v2:player) \\\n        WITH DISTINCT v2 AS v2, v2.player.age AS Age \\\n        ORDER BY Age \\\n        WHERE Age&lt;25 \\\n        RETURN v2.player.name AS Name, Age;\n+----------------------+-----+\n| Name                 | Age |\n+----------------------+-----+\n| \"Luka Doncic\"        | 20  |\n| \"Ben Simmons\"        | 22  |\n| \"Kristaps Porzingis\" | 23  |\n+----------------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/1.general-query-statements-overview/#more_information","title":"More information","text":"<p>nGQL command cheatsheet</p>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/","title":"MATCH","text":"<p>The <code>MATCH</code> statement provides pattern-based search functionality, allowing you to retrieve data that matches one or more patterns in NebulaGraph. By defining one or more patterns, you can search for data that matches the patterns in NebulaGraph. Once the matching data is retrieved, you can use the <code>RETURN</code> clause to return it as a result.</p> <p>The examples in this topic use the basketballplayer dataset as the sample dataset.</p>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#syntax","title":"Syntax","text":"<p>The syntax of <code>MATCH</code> is relatively more flexible compared with that of other query statements such as <code>GO</code> or <code>LOOKUP</code>. The path type of the <code>MATCH</code> statement is <code>trail</code>. That is, only vertices can be repeatedly visited in the graph traversal. Edges cannot be repeatedly visited. For details, see path. But generally, it can be summarized as follows.</p> <pre><code>MATCH &lt;pattern&gt; [&lt;clause_1&gt;] RETURN &lt;output&gt; [&lt;clause_2&gt;];\n</code></pre> <ul> <li><code>pattern</code>: The <code>MATCH</code> statement supports matching one or multiple patterns. Multiple patterns are separated by commas (,). For example: <code>(a)-[]-&gt;(b),(c)-[]-&gt;(d)</code>. For the detailed description of patterns, see Patterns. </li> </ul> <ul> <li><code>clause_1</code>: The <code>WHERE</code>, <code>WITH</code>, <code>UNWIND</code>, and <code>OPTIONAL MATCH</code> clauses are supported, and the <code>MATCH</code> clause can also be used.</li> </ul> <ul> <li><code>output</code>: Define the list name for the output results to be returned. You can use <code>AS</code> to set an alias for the list.</li> </ul> <ul> <li><code>clause_2</code>: The <code>ORDER BY</code> and <code>LIMIT</code> clauses are supported.</li> </ul> <p>Legacy version compatibility</p> <ul> <li>Starting from version 3.5.0, the <code>MATCH</code> statement supports full table scans. It can traverse vertices or edges in the graph without using any indexes or filter conditions. In previous versions, the <code>MATCH</code> statement required an index for certain queries or needed to use <code>LIMIT</code> to restrict the number of output results.</li> </ul> <ul> <li>Starting from NebulaGraph version 3.0.0, in order to distinguish the properties of different tags, you need to specify a tag name when querying properties. The original statement <code>RETURN &lt;variable_name&gt;.&lt;property_name&gt;</code> is changed to <code>RETURN &lt;variable_name&gt;.&lt;tag_name&gt;.&lt;property_name&gt;</code>.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#notes","title":"Notes","text":"<ul> <li>Avoid full table scans, as they may result in decreased query performance, and if there is insufficient memory during a full table scan, the query may fail, and the system will report an error. It is recommended to use queries with filter conditions or specifying tags and edge types, such as <code>v:player</code> and <code>v.player.name</code> in the statement <code>MATCH (v:player) RETURN v.player.name AS Name</code>.</li> </ul> <ul> <li>You can create an index for a tag, edge type, or a specific property of a tag or edge type to improve query performance. For example, you can create an index for the <code>player</code> tag or the name property of the <code>player</code> tag. For more information about the usage and considerations for indexes, see Must-read for using indexes.</li> </ul> <ul> <li>The <code>MATCH</code> statement cannot query dangling edges.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#using_patterns_in_match_statements","title":"Using patterns in MATCH statements","text":""},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_vertices","title":"Match vertices","text":"<p>You can use a user-defined variable in a pair of parentheses to represent a vertex in a pattern. For example: <code>(v)</code>.</p> <pre><code>nebula&gt; MATCH (v) \\\n        RETURN v \\\n        LIMIT 3;\n+-----------------------------------------------------------+\n| v                                                         |\n+-----------------------------------------------------------+\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n| (\"player106\" :player{age: 25, name: \"Kyle Anderson\"})     |\n| (\"player115\" :player{age: 40, name: \"Kobe Bryant\"})       |\n+-----------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_tags","title":"Match tags","text":"<p>Legacy version compatibility</p> <ul> <li>In NebulaGraph versions earlier than 3.0.0, the prerequisite for matching a tag is that the tag itself has an index or a certain property of the tag has an index. </li> </ul> <ul> <li>Starting from NebulaGraph 3.0.0, you can match tags without creating an index, but you need to use <code>LIMIT</code> to restrict the number of output results.</li> </ul> <ul> <li>Starting from NebulaGraph 3.5.0, the <code>MATCH</code> statement supports full table scans. There is no need to create an index for a tag or a specific property of a tag, nor use <code>LIMIT</code> to restrict the number of output results in order to execute the <code>MATCH</code> statement.</li> </ul> <p>You can specify a tag with <code>:&lt;tag_name&gt;</code> after the vertex in a pattern.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        RETURN v;\n+---------------------------------------------------------------+\n| v                                                             |\n+---------------------------------------------------------------+\n| (\"player105\" :player{age: 31, name: \"Danny Green\"})           |\n| (\"player109\" :player{age: 34, name: \"Tiago Splitter\"})        |\n| (\"player111\" :player{age: 38, name: \"David West\"})            |\n...\n</code></pre> <p>To match vertices with multiple tags, use colons (:).</p> <pre><code>nebula&gt; CREATE TAG actor (name string, age int);\nnebula&gt; INSERT VERTEX actor(name, age) VALUES \"player100\":(\"Tim Duncan\", 42);\nnebula&gt; MATCH (v:player:actor) \\\n        RETURN v \\\n+----------------------------------------------------------------------------------------+\n| v                                                                                      |\n+----------------------------------------------------------------------------------------+\n| (\"player100\" :actor{age: 42, name: \"Tim Duncan\"} :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_vertex_properties","title":"Match vertex properties","text":"<p>Note</p> <p>The prerequisite for matching a vertex property is that the tag itself has an index of the corresponding property. Otherwise, you cannot execute the <code>MATCH</code> statement to match the property.</p> <p>You can specify a vertex property with <code>{&lt;prop_name&gt;: &lt;prop_value&gt;}</code> after the tag in a pattern.</p> <pre><code># The following example uses the name property to match a vertex.\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN v;\n+----------------------------------------------------+\n| v                                                  |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n</code></pre> <p>The <code>WHERE</code> clause can do the same thing:</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name == \"Tim Duncan\" \\\n        RETURN v;\n+----------------------------------------------------+\n| v                                                  |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n</code></pre> <p>OpenCypher compatibility</p> <p>In openCypher 9, <code>=</code> is the equality operator. However, in nGQL, <code>==</code> is the equality operator and <code>=</code> is the assignment operator (as in C++ or Java).</p> <p>Use the <code>WHERE</code> clause to directly get all the vertices with the vertex property value Tim Duncan.</p> <pre><code>nebula&gt; MATCH (v) \\\n        WITH v, properties(v) as props, keys(properties(v)) as kk \\\n        WHERE [i in kk where props[i] == \"Tim Duncan\"] \\\n        RETURN v;\n+----------------------------------------------------+\n| v                                                  |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n\nnebula&gt; WITH ['Tim Duncan', 'Yao Ming'] AS names \\\n        MATCH (v1:player)--&gt;(v2:player) \\\n        WHERE v1.player.name in names \\\n        return v1, v2;\n+----------------------------------------------------+----------------------------------------------------------+\n| v1                                                 | v2                                                       |\n+----------------------------------------------------+----------------------------------------------------------+\n| (\"player133\" :player{age: 38, name: \"Yao Ming\"})   | (\"player114\" :player{age: 39, name: \"Tracy McGrady\"})    |\n| (\"player133\" :player{age: 38, name: \"Yao Ming\"})   | (\"player144\" :player{age: 47, name: \"Shaquille O'Neal\"}) |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | (\"player101\" :player{age: 36, name: \"Tony Parker\"})      |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})    |\n+----------------------------------------------------+----------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_vids","title":"Match VIDs","text":"<p>You can use the VID to match a vertex. The <code>id()</code> function can retrieve the VID of a vertex.</p> <pre><code>nebula&gt; MATCH (v) \\\n        WHERE id(v) == 'player101' \\\n        RETURN v;\n+-----------------------------------------------------+\n| v                                                   |\n+-----------------------------------------------------+\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"}) |\n+-----------------------------------------------------+\n</code></pre> <p>To match multiple VIDs, use <code>WHERE id(v) IN [vid_list]</code> or <code>WHERE id(v) IN {vid_list}</code>.</p> <pre><code>nebula&gt; MATCH (v:player { name: 'Tim Duncan' })--(v2) \\\n        WHERE id(v2) IN [\"player101\", \"player102\"] \\\n        RETURN v2;\n+-----------------------------------------------------------+\n| v2                                                        |\n+-----------------------------------------------------------+\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n+-----------------------------------------------------------+\n\nnebula&gt; MATCH (v) WHERE id(v) IN {\"player100\", \"player101\"} \\\n        RETURN v.player.name AS name;\n+---------------+\n| name          |\n+---------------+\n| \"Tony Parker\" |\n| \"Tim Duncan\"  |\n+---------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_connected_vertices","title":"Match connected vertices","text":"<p>You can use the <code>--</code> symbol to represent edges of both directions and match vertices connected by these edges.</p> <p>Legacy version compatibility</p> <p>In nGQL 1.x, the <code>--</code> symbol is used for inline comments. Starting from nGQL 2.x, the <code>--</code> symbol represents an incoming or outgoing edge.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})--(v2) \\\n        RETURN v2.player.name AS Name;\n+---------------------+\n| Name                |\n+---------------------+\n| \"Manu Ginobili\"     |\n| \"Manu Ginobili\"     |\n| \"Tiago Splitter\"    |\n...\n</code></pre> <p>You can add a <code>&gt;</code> or <code>&lt;</code> to the <code>--</code> symbol to specify the direction of an edge.</p> <p>In the following example, <code>--&gt;</code> represents an edge that starts from <code>v</code> and points to <code>v2</code>. To <code>v</code>, this is an outgoing edge, and to <code>v2</code> this is an incoming edge.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})--&gt;(v2:player) \\\n        RETURN v2.player.name AS Name;\n+-----------------+\n| Name            |\n+-----------------+\n| \"Manu Ginobili\" |\n| \"Tony Parker\"   |\n+-----------------+\n</code></pre> <p>To query the properties of the target vertices, use the <code>CASE</code> expression.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})--(v2) \\\n        RETURN \\\n        CASE WHEN v2.team.name IS NOT NULL \\\n        THEN v2.team.name  \\\n        WHEN v2.player.name IS NOT NULL \\\n        THEN v2.player.name END AS Name;\n+---------------------+\n| Name                |\n+---------------------+\n| \"Manu Ginobili\"     |\n| \"Manu Ginobili\"     |\n| \"Spurs\"             |\n| \"Dejounte Murray\"   |\n...\n</code></pre> <p>To extend the pattern, you can add more vertices and edges.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})--&gt;(v2)&lt;--(v3) \\\n        RETURN v3.player.name AS Name;\n+---------------------+\n| Name                |\n+---------------------+\n| \"Dejounte Murray\"   |\n| \"LaMarcus Aldridge\" |\n| \"Marco Belinelli\"   |\n...\n</code></pre> <p>If you do not need to refer to a vertex, you can omit the variable representing it in the parentheses.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})--&gt;()&lt;--(v3) \\\n        RETURN v3.player.name AS Name;\n+---------------------+\n| Name                |\n+---------------------+\n| \"Dejounte Murray\"   |\n| \"LaMarcus Aldridge\" |\n| \"Marco Belinelli\"   |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_paths","title":"Match paths","text":"<p>Connected vertices and edges form a path. You can use a user-defined variable to name a path as follows.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--&gt;(v2) \\\n        RETURN p;\n+--------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                    |\n+--------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:serve@0 {end_year: 2016, start_year: 1997}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt; |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;   |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt; |\n+--------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <p>OpenCypher compatibility</p> <p>In nGQL, the <code>@</code> symbol represents the rank of an edge, but openCypher has no such concept.</p>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_edges","title":"Match edges","text":"<pre><code>nebula&gt; MATCH ()&lt;-[e]-() \\\n        RETURN e \\\n        LIMIT 3;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player101\"-&gt;\"player102\" @0 {degree: 90}] |\n| [:follow \"player103\"-&gt;\"player102\" @0 {degree: 70}] |\n| [:follow \"player135\"-&gt;\"player102\" @0 {degree: 80}] |\n+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_edge_types","title":"Match edge types","text":"<p>Just like vertices, you can specify edge types with <code>:&lt;edge_type&gt;</code> in a pattern. For example: <code>-[e:follow]-</code>.</p> <p>OpenCypher compatibility</p> <ul> <li>In NebulaGraph versions earlier than 3.0.0, the prerequisite for matching a edge type is that the edge type itself has an index or a certain property of the edge type has an index. </li> </ul> <ul> <li>Starting from version 3.0.0, there is no need to create an index for matching a edge type, but you need to use <code>LIMIT</code> to limit the number of output results and you must specify the direction of the edge.</li> </ul> <ul> <li>Starting from NebulaGraph 3.5.0, you can use the <code>MATCH</code> statement to match edges without creating an index for edge type or using <code>LIMIT</code> to restrict the number of output results.</li> </ul> <pre><code>nebula&gt; MATCH ()-[e:follow]-&gt;() \\\n        RETURN e;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player102\"-&gt;\"player100\" @0 {degree: 75}] |\n| [:follow \"player102\"-&gt;\"player101\" @0 {degree: 75}] |\n| [:follow \"player129\"-&gt;\"player116\" @0 {degree: 90}] |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_edge_type_properties","title":"Match edge type properties","text":"<p>Note</p> <p>The prerequisite for matching an edge type property is that the edge type itself has an index of the corresponding property. Otherwise, you cannot execute the <code>MATCH</code> statement to match the property.</p> <p>You can specify edge type properties with <code>{&lt;prop_name&gt;: &lt;prop_value&gt;}</code> in a pattern. For example: <code>[e:follow{likeness:95}]</code>.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e:follow{degree:95}]-&gt;(v2) \\\n        RETURN e;\n+--------------------------------------------------------+\n| e                                                      |\n+--------------------------------------------------------+\n| [:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}]     |\n| [:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}]     |\n+--------------------------------------------------------+\n</code></pre> <p>Use the <code>WHERE</code> clause to directly get all the edges with the edge property value 90.</p> <pre><code>nebula&gt; MATCH ()-[e]-&gt;() \\\n        WITH e, properties(e) as props, keys(properties(e)) as kk \\\n        WHERE [i in kk where props[i] == 90] \\\n        RETURN e;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player125\"-&gt;\"player100\" @0 {degree: 90}] |\n| [:follow \"player140\"-&gt;\"player114\" @0 {degree: 90}] |\n| [:follow \"player133\"-&gt;\"player144\" @0 {degree: 90}] |\n| [:follow \"player133\"-&gt;\"player114\" @0 {degree: 90}] |\n...\n+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_multiple_edge_types","title":"Match multiple edge types","text":"<p>The <code>|</code> symbol can help matching multiple edge types. For example: <code>[e:follow|:serve]</code>. The English colon (:) before the first edge type cannot be omitted, but the English colon before the subsequent edge type can be omitted, such as <code>[e:follow|serve]</code>.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e:follow|:serve]-&gt;(v2) \\\n        RETURN e;\n+---------------------------------------------------------------------------+\n| e                                                                         |\n+---------------------------------------------------------------------------+\n| [:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}]                        |\n| [:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}]                        |\n| [:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}]     |\n+---------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_multiple_edges","title":"Match multiple edges","text":"<p>You can extend a pattern to match multiple edges in a path.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[]-&gt;(v2)&lt;-[e:serve]-(v3) \\\n        RETURN v2, v3;\n+----------------------------------+-----------------------------------------------------------+\n| v2                               | v3                                                        |\n+----------------------------------+-----------------------------------------------------------+\n| (\"team204\" :team{name: \"Spurs\"}) | (\"player104\" :player{age: 32, name: \"Marco Belinelli\"})   |\n| (\"team204\" :team{name: \"Spurs\"}) | (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"team204\" :team{name: \"Spurs\"}) | (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_fixed-length_paths","title":"Match fixed-length paths","text":"<p>You can use the <code>:&lt;edge_type&gt;*&lt;hop&gt;</code> pattern to match a fixed-length path. <code>hop</code> must be a non-negative integer.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) \\\n        RETURN DISTINCT v2 AS Friends;\n+-----------------------------------------------------------+\n| Friends                                                   |\n+-----------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n+-----------------------------------------------------------+\n</code></pre> <p>If <code>hop</code> is 0, the pattern will match the source vertex of the path.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) -[*0]-&gt; (v2) \\\n        RETURN v2;\n+----------------------------------------------------+\n| v2                                                 |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n</code></pre> <p>Note</p> <p>When you conditionally filter on multi-hop edges, such as <code>-[e:follow*2]-&gt;</code>, note that the <code>e</code> is a list of edges instead of a single edge. </p> <p>For example, the following statement is correct from the syntax point of view which may not get your expected query result, because the <code>e</code> is a list without the <code>.degree</code> property. </p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) \\\n        WHERE e.degree &gt; 1 \\\n        RETURN DISTINCT v2 AS Friends;\n</code></pre> <p>The correct statement is as follows:</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) \\\n        WHERE ALL(e_ in e WHERE e_.degree &gt; 0) \\\n        RETURN DISTINCT v2 AS Friends;\n</code></pre> <p>Further, the following statement is for filtering the properties of the first-hop edge in multi-hop edges:</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*2]-&gt;(v2) \\\n        WHERE e[0].degree &gt; 98 \\\n        RETURN DISTINCT v2 AS Friends;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_variable-length_paths","title":"Match variable-length paths","text":"<p>You can use the <code>:&lt;edge_type&gt;*[minHop..maxHop]</code> pattern to match variable-length paths.<code>minHop</code> and <code>maxHop</code> are optional and default to 1 and infinity respectively.</p> <p>Caution</p> <p>If <code>maxHop</code> is not set, it may cause the Graph service to OOM. Execute this command with caution.</p> Parameter Description <code>minHop</code> Optional. <code>minHop</code> indicates the minimum length of the path, which must be a non-negative integer. The default value is 1. <code>maxHop</code> Optional. <code>maxHop</code> indicates the maximum length of the path, which must be a non-negative integer. The default value is infinity. <p>If neither <code>minHop</code> nor <code>maxHop</code> is specified, and only <code>:&lt;edge_type&gt;*</code> is set, the default values are applied to both, i.e., <code>minHop</code> is 1 and <code>maxHop</code> is infinity.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*]-&gt;(v2) \\\n        RETURN v2 AS Friends;\n+-----------------------------------------------------------+\n| Friends                                                   |\n+-----------------------------------------------------------+\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n...\n\nnebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..3]-&gt;(v2) \\\n        RETURN v2 AS Friends;\n+-----------------------------------------------------------+\n| Friends                                                   |\n+-----------------------------------------------------------+\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        |\n...\n\nnebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..]-&gt;(v2) \\\n        RETURN v2 AS Friends;\n+-----------------------------------------------------------+\n| Friends                                                   |\n+-----------------------------------------------------------+\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        |\n...\n</code></pre> <p>You can use the <code>DISTINCT</code> keyword to aggregate duplicate results.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*1..3]-&gt;(v2:player) \\\n        RETURN DISTINCT v2 AS Friends, count(v2);\n+-----------------------------------------------------------+-----------+\n| Friends                                                   | count(v2) |\n+-----------------------------------------------------------+-----------+\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) | 1         |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        | 4         |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       | 3         |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     | 3         |\n+-----------------------------------------------------------+-----------+\n</code></pre> <p>If <code>minHop</code> is <code>0</code>, the pattern will match the source vertex of the path. Compared to the preceding statement, the following example uses <code>0</code> as the <code>minHop</code>. So in the following result set, <code>\"Tim Duncan\"</code> is counted one more time than it is in the preceding result set because it is the source vertex.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow*0..3]-&gt;(v2:player) \\\n        RETURN DISTINCT v2 AS Friends, count(v2);\n+-----------------------------------------------------------+-----------+\n| Friends                                                   | count(v2) |\n+-----------------------------------------------------------+-----------+\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) | 1         |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        | 5         |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     | 3         |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       | 3         |\n+-----------------------------------------------------------+-----------+\n</code></pre> <p>Note</p> <p>When using the variable <code>e</code> to match fixed-length or variable-length paths in a pattern, such as <code>-[e:follow*0..3]-&gt;</code>, it is not supported to reference <code>e</code> in other patterns. For example, the following statement is not supported.</p> <pre><code>nebula&gt; MATCH (v:player)-[e:like*1..3]-&gt;(n) \\\n        WHERE (n)-[e*1..4]-&gt;(:player) \\\n        RETURN v;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_variable-length_paths_with_multiple_edge_types","title":"Match variable-length paths with multiple edge types","text":"<p>You can specify multiple edge types in a fixed-length or variable-length pattern. In this case, <code>hop</code>, <code>minHop</code>, and <code>maxHop</code> take effect on all edge types.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e:follow|serve*2]-&gt;(v2) \\\n        RETURN DISTINCT v2;\n+-----------------------------------------------------------+\n| v2                                                        |\n+-----------------------------------------------------------+\n| (\"team204\" :team{name: \"Spurs\"})                          |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        |\n| (\"team215\" :team{name: \"Hornets\"})                        |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n+-----------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_multiple_patterns","title":"Match multiple patterns","text":"<p>You can separate multiple patterns with commas (,).</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS team_index ON team(name(20));\nnebula&gt; REBUILD TAG INDEX team_index;\nnebula&gt; MATCH (v1:player{name:\"Tim Duncan\"}), (v2:team{name:\"Spurs\"}) \\\n        RETURN v1,v2;\n+----------------------------------------------------+----------------------------------+\n| v1                                                 | v2                               |\n+----------------------------------------------------+----------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | (\"team204\" :team{name: \"Spurs\"}) |\n+----------------------------------------------------+----------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#match_shortest_paths","title":"Match shortest paths","text":"<p>The <code>allShortestPaths</code> function can be used to find all shortest paths between two vertices.</p> <pre><code>nebula&gt; MATCH p = allShortestPaths((a:player{name:\"Tim Duncan\"})-[e*..5]-(b:player{name:\"Tony Parker\"})) \\\n        RETURN p;\n+------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                  |\n+------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})&lt;-[:follow@0 {degree: 95}]-(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt; |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt; |\n+------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <p>The <code>shortestPath</code> function can be used to find a single shortest path between two vertices.</p> <pre><code>nebula&gt; MATCH p = shortestPath((a:player{name:\"Tim Duncan\"})-[e*..5]-(b:player{name:\"Tony Parker\"})) \\\n        RETURN p;\n+------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                  |\n+------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})&lt;-[:follow@0 {degree: 95}]-(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt; |\n+------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#retrieve_with_multiple_match","title":"Retrieve with multiple match","text":"<p>Multiple <code>MATCH</code> can be used when different patterns have different filtering criteria and return the rows that exactly match the pattern.</p> <pre><code>nebula&gt; MATCH (m)-[]-&gt;(n) WHERE id(m)==\"player100\" \\\n        MATCH (n)-[]-&gt;(l) WHERE id(n)==\"player125\" \\\n        RETURN id(m),id(n),id(l);\n+-------------+-------------+-------------+\n| id(m)       | id(n)       | id(l)       |\n+-------------+-------------+-------------+\n| \"player100\" | \"player125\" | \"team204\"   |\n| \"player100\" | \"player125\" | \"player100\" |\n+-------------+-------------+-------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/2.match/#retrieve_with_optional_match","title":"Retrieve with optional match","text":"<p>See OPTIONAL MATCH.</p> <p>Caution</p> <p>In NebulaGraph, the performance and resource usage of the <code>MATCH</code> statement have been optimized. But we still recommend to use <code>GO</code>, <code>LOOKUP</code>, <code>|</code>, and <code>FETCH</code> instead of <code>MATCH</code> when high performance is required.</p>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/","title":"GO","text":"<p>The <code>GO</code> statement is used in the NebulaGraph database to traverse the graph starting from a given starting vertex with specified filters and return results.</p>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>This topic applies to native nGQL only.</p>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#syntax","title":"Syntax","text":"<pre><code>GO [[&lt;M&gt; TO] &lt;N&gt; {STEP|STEPS}] FROM &lt;vertex_list&gt;\nOVER &lt;edge_type_list&gt; [{REVERSELY | BIDIRECT}]\n[ WHERE &lt;conditions&gt;\u00a0]\nYIELD\u00a0[DISTINCT] &lt;return_list&gt;\n[{SAMPLE &lt;sample_list&gt; | &lt;limit_by_list_clause&gt;}]\n[| GROUP BY {col_name | expr | position} YIELD &lt;col_name&gt;]\n[| ORDER BY &lt;expression&gt; [{ASC | DESC}]]\n[| LIMIT [&lt;offset&gt;,] &lt;number_rows&gt;];\n\n&lt;vertex_list&gt; ::=\n    &lt;vid&gt; [, &lt;vid&gt; ...]\n\n&lt;edge_type_list&gt; ::=\n   edge_type [, edge_type ...]\n   | *\n\n&lt;return_list&gt; ::=\n    &lt;col_name&gt; [AS &lt;col_alias&gt;] [, &lt;col_name&gt; [AS &lt;col_alias&gt;] ...]\n</code></pre> <ul> <li> <p><code>&lt;N&gt; {STEP|STEPS}</code>: specifies the hop number. If not specified, the default value for <code>N</code> is <code>one</code>. When <code>N</code> is <code>zero</code>, NebulaGraph does not traverse any edges and returns nothing.</p> <p>Note</p> <p>The path type of the <code>GO</code> statement is <code>walk</code>, which means both vertices and edges can be repeatedly visited in graph traversal. For more information, see Path.</p> </li> </ul> <ul> <li><code>M TO N {STEP|STEPS}</code>: traverses <code>from M to N</code> hops. When <code>M</code> is <code>zero</code>, the output is the same as that of <code>M</code> is <code>one</code>. That is, the output of <code>GO 0 TO 2</code> and <code>GO 1 TO 2</code> are the same.</li> </ul> <ul> <li><code>&lt;vertex_list&gt;</code>: represents a list of vertex IDs separated by commas.</li> </ul> <ul> <li><code>&lt;edge_type_list&gt;</code>: represents a list of edge types which the traversal can go through.</li> </ul> <ul> <li><code>REVERSELY | BIDIRECT</code>: defines the direction of the query. By default, the <code>GO</code> statement searches for outgoing edges of <code>&lt;vertex_list&gt;</code>. If <code>REVERSELY</code> is set, <code>GO</code> searches for incoming edges. If <code>BIDIRECT</code> is set, <code>GO</code> searches for edges of both directions. The direction of the query can be checked by returning the <code>&lt;edge_type&gt;._type</code> field using <code>YIELD</code>. A positive value indicates an outgoing edge, while a negative value indicates an incoming edge.</li> </ul> <ul> <li> <p><code>WHERE &lt;expression&gt;</code>: specifies the traversal filters. You can use the <code>WHERE</code> clause for the source vertices, the edges, and the destination vertices. You can use it together with <code>AND</code>, <code>OR</code>, <code>NOT</code>, and <code>XOR</code>. For more information, see WHERE.</p> <p>Note</p> <ul> <li>There are some restrictions for the <code>WHERE</code> clause when you traverse along with multiple edge types. For example, <code>WHERE edge1.prop1 &gt; edge2.prop2</code> is not supported.</li> <li>The GO statement is executed by traversing all the vertices and then filtering according to the filter condition.</li> </ul> </li> </ul> <ul> <li><code>YIELD [DISTINCT] &lt;return_list&gt;</code>: defines the output to be returned. It is recommended to use the Schema-related functions to fill in <code>&lt;return_list&gt;</code>. <code>src(edge)</code>, <code>dst(edge)</code>, <code>type(edge) )</code>, <code>rank(edge)</code>, etc., are currently supported, while nested functions are not. For more information, see YIELD.</li> </ul> <ul> <li><code>SAMPLE &lt;sample_list&gt;</code>: takes samples from the result set. For more information, see SAMPLE.</li> </ul> <ul> <li><code>&lt;limit_by_list_clause&gt;</code>: limits the number of outputs during the traversal process. For more information, see LIMIT.</li> </ul> <ul> <li><code>GROUP BY</code>: groups the output into subgroups based on the value of the specified property. For more information, see GROUP BY. After grouping, you need to use <code>YIELD</code> again to define the output that needs to be returned.</li> </ul> <ul> <li> <p><code>ORDER BY</code>: sorts outputs with specified orders. For more information, see ORDER BY.</p> <p>Note</p> <p>When the sorting method is not specified, the output orders can be different for the same query.</p> </li> </ul> <ul> <li><code>LIMIT  [&lt;offset&gt;,] &lt;number_rows&gt;]</code>: limits the number of rows of the output. For more information, see LIMIT.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#notes","title":"Notes","text":"<ul> <li>The <code>WHERE</code> and <code>YIELD</code> clauses in <code>GO</code> statements usually utilize property reference symbols (<code>$^</code> and <code>$$</code>) or the <code>properties($^)</code> and <code>properties($$)</code> functions to specify the properties of a vertex; use the <code>properties(edge)</code> function to specify the properties of an edge. For details, see Property Reference Symbols and Schema-related Functions.</li> </ul> <ul> <li>When referring to the result of a subquery in a compound <code>GO</code> statement, you need to set a name for the result and pass it to the next subquery using the pipe symbol <code>|</code>, and reference the name of the result in the next subquery using <code>$-</code>. See the Pipe Operator for details.</li> </ul> <ul> <li>When the queried property has no value, the returned result displays <code>NULL</code>.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#cases_and_examples","title":"Cases and examples","text":""},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_query_the_immediate_neighbors_of_a_vertex","title":"To query the immediate neighbors of a vertex","text":"<p>For example, to query the team that a person belongs to, assuming that the person is connected to the team by the <code>serve</code> edge and the person's ID is <code>player102</code>.</p> <pre><code>nebula&gt;\u00a0GO FROM \"player102\" OVER serve YIELD dst(edge);\n+-----------+\n| dst(EDGE) |\n+-----------+\n| \"team203\" |\n| \"team204\" |\n+-----------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_query_all_vertices_within_a_specified_number_of_hops_from_a_starting_vertex","title":"To query all vertices within a specified number of hops from a starting vertex","text":"<p>For example, to query all vertices within two hops of a person vertex, assuming that the person is connected to other people by the <code>follow</code> edge and the person's ID is <code>player102</code>.</p> <pre><code># Return all vertices that are 2 hops away from the player102 vertex.\nnebula&gt; GO 2 STEPS FROM \"player102\" OVER follow YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player101\" |\n| \"player125\" |\n| \"player100\" |\n| \"player102\" |\n| \"player125\" |\n+-------------+\n</code></pre> <pre><code># Return all vertices within 1 or 2 hops away from the player102 vertex.\nnebula&gt; GO 1 TO 2 STEPS FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS destination;\n+-------------+\n| destination |\n+-------------+\n| \"player101\" |\n| \"player125\" |\n...\n\n# The following MATCH query has the same semantics as the previous GO query.\nnebula&gt; MATCH (v) -[e:follow*1..2]-&gt;(v2) \\\n        WHERE id(v) == \"player100\" \\\n        RETURN id(v2) AS destination;\n+-------------+\n| destination |\n+-------------+\n| \"player100\" |\n| \"player102\" |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_add_filtering_conditions","title":"To add filtering conditions","text":"<p>Case: To query the vertices and edges that meet specific conditions.</p> <p>For example, use the <code>WHERE</code> clause to query the edges with specific properties between the starting vertex and the destination vertex.</p> <pre><code>nebula&gt;\u00a0GO FROM \"player100\", \"player102\" OVER serve \\\n        WHERE properties(edge).start_year &gt; 1995 \\\n        YIELD DISTINCT properties($$).name AS team_name, properties(edge).start_year AS start_year, properties($^).name AS player_name;\n\n+-----------------+------------+---------------------+\n| team_name       | start_year | player_name         |\n+-----------------+------------+---------------------+\n| \"Spurs\"         | 1997       | \"Tim Duncan\"        |\n| \"Trail Blazers\" | 2006       | \"LaMarcus Aldridge\" |\n| \"Spurs\"         | 2015       | \"LaMarcus Aldridge\" |\n+-----------------+------------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_query_all_edges","title":"To query all edges","text":"<p>Case: To query all edges that are connected to the starting vertex.</p> <pre><code># Return all edges that are connected to the player102 vertex.\nnebula&gt; GO FROM \"player102\" OVER * BIDIRECT YIELD edge AS e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:follow \"player101\"-&gt;\"player102\" @0 {degree: 90}]                    |\n| [:follow \"player103\"-&gt;\"player102\" @0 {degree: 70}]                    |\n| [:follow \"player135\"-&gt;\"player102\" @0 {degree: 80}]                    |\n| [:follow \"player102\"-&gt;\"player100\" @0 {degree: 75}]                    |\n| [:follow \"player102\"-&gt;\"player101\" @0 {degree: 75}]                    |\n| [:serve \"player102\"-&gt;\"team203\" @0 {end_year: 2015, start_year: 2006}] |\n| [:serve \"player102\"-&gt;\"team204\" @0 {end_year: 2019, start_year: 2015}] |\n+-----------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_query_multiple_edge_types","title":"To query multiple edge types","text":"<p>Case: To query multiple edge types that are connected to the starting vertex. You can specify multiple edge types or the <code>*</code> symbol to query multiple edge types.</p> <p>For example, to query the <code>follow</code> and <code>serve</code> edges that are connected to the starting vertex.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow, serve \\\n        YIELD properties(edge).degree, properties(edge).start_year;\n+-------------------------+-----------------------------+\n| properties(EDGE).degree | properties(EDGE).start_year |\n+-------------------------+-----------------------------+\n| 95                      | __NULL__                    |\n| 95                      | __NULL__                    |\n| __NULL__                | 1997                        |\n+-------------------------+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_query_incoming_vertices_using_the_reversely_keyword","title":"To query incoming vertices using the REVERSELY keyword","text":"<pre><code># Return the vertices that follow the player100 vertex.\nnebula&gt; GO FROM \"player100\" OVER follow REVERSELY \\\n        YIELD src(edge) AS destination;\n+-------------+\n| destination |\n+-------------+\n| \"player101\" |\n| \"player102\" |\n...\n\n# The following MATCH query has the same semantics as the previous GO query.\nnebula&gt; MATCH (v)&lt;-[e:follow]- (v2) WHERE id(v) == 'player100' \\\n        RETURN id(v2) AS destination;\n+-------------+\n| destination |\n+-------------+\n| \"player101\" |\n| \"player102\" |\n...\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_use_subqueries_as_the_starting_vertice_of_a_graph_traversal","title":"To use subqueries as the starting vertice of a graph traversal","text":"<pre><code># Return the friends of the player100 vertex and the teams that the friends belong to.\nnebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS id | \\\n        GO FROM $-.id OVER serve \\\n        WHERE properties($^).age &gt; 20 \\\n        YIELD properties($^).name AS Friend, properties($$).name AS Team;\n+---------------------+-----------------+\n| Friend              | Team            |\n+---------------------+-----------------+\n| \"Tony Parker\"       | \"Spurs\"         |\n| \"Tony Parker\"       | \"Hornets\"       |\n| \"Manu Ginobili\"     | \"Spurs\"         |\n+---------------------+-----------------+\n\n# The following MATCH query has the same semantics as the previous GO query.\nnebula&gt; MATCH (v)-[e:follow]-&gt; (v2)-[e2:serve]-&gt;(v3)  \\\n        WHERE id(v) == 'player100' \\\n        AND properties(v2).age &gt; 20 \\\n        RETURN v2.player.name AS Friend, v3.team.name AS Team;\n+---------------------+-----------------+\n| Friend              | Team            |\n+---------------------+-----------------+\n| \"Tony Parker\"       | \"Spurs\"         |\n| \"Tony Parker\"       | \"Hornets\"       |\n| \"Manu Ginobili\"     | \"Spurs\"         |\n+---------------------+-----------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_use_group_by_to_group_the_output","title":"To use <code>GROUP BY</code> to group the output","text":"<p>You need to use <code>YIELD</code> to define the output that needs to be returned after grouping.</p> <pre><code># The following example collects the outputs according to age.\nnebula&gt; GO 2 STEPS FROM \"player100\" OVER follow \\\n        YIELD src(edge) AS src, dst(edge) AS dst, properties($$).age AS age \\\n        | GROUP BY $-.dst \\\n        YIELD $-.dst AS dst, collect_set($-.src) AS src, collect($-.age) AS age;\n+-------------+----------------------------+----------+\n| dst         | src                        | age      |\n+-------------+----------------------------+----------+\n| \"player125\" | {\"player101\"}              | [41]     |\n| \"player100\" | {\"player125\", \"player101\"} | [42, 42] |\n| \"player102\" | {\"player101\"}              | [33]     |\n+-------------+----------------------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#to_use_order_by_and_limit_to_sort_and_limit_the_output","title":"To use <code>ORDER BY</code> and <code>LIMIT</code> to sort and limit the output","text":"<pre><code># The following example groups the outputs and restricts the number of rows of the outputs.\nnebula&gt; $a = GO FROM \"player100\" OVER follow YIELD src(edge) AS src, dst(edge) AS dst; \\\n        GO 2 STEPS FROM $a.dst OVER follow \\\n        YIELD $a.src AS src, $a.dst, src(edge), dst(edge) \\\n        | ORDER BY $-.src | OFFSET 1 LIMIT 2;\n+-------------+-------------+-------------+-------------+\n| src         | $a.dst      | src(EDGE)   | dst(EDGE)   |\n+-------------+-------------+-------------+-------------+\n| \"player100\" | \"player101\" | \"player100\" | \"player101\" |\n| \"player100\" | \"player125\" | \"player100\" | \"player125\" |\n+-------------+-------------+-------------+-------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/3.go/#other_examples","title":"Other examples","text":"<pre><code># The following example determines if $$.player.name IS NOT EMPTY.\nnebula&gt; GO FROM \"player100\" OVER follow WHERE properties($$).name IS NOT EMPTY YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player125\" |\n| \"player101\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/","title":"FETCH","text":"<p>The <code>FETCH</code> statement retrieves the properties of the specified vertices or edges.</p>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>This topic applies to native nGQL only.</p>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_vertex_properties","title":"Fetch vertex properties","text":""},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#syntax","title":"Syntax","text":"<pre><code>FETCH PROP ON {&lt;tag_name&gt;[, tag_name ...] | *}\n&lt;vid&gt; [, vid ...]\nYIELD [DISTINCT] &lt;return_list&gt; [AS &lt;alias&gt;];\n</code></pre> Parameter Description <code>tag_name</code> The name of the tag. <code>*</code> Represents all the tags in the current graph space. <code>vid</code> The vertex ID. <code>YIELD</code> Define the output to be returned. For details, see <code>YIELD</code>. <code>AS</code> Set an alias."},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_vertex_properties_by_one_tag","title":"Fetch vertex properties by one tag","text":"<p>Specify a tag in the <code>FETCH</code> statement to fetch the vertex properties by that tag.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player100\" YIELD properties(vertex);\n+-------------------------------+\n| properties(VERTEX)            |\n+-------------------------------+\n| {age: 42, name: \"Tim Duncan\"} |\n+-------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_specific_properties_of_a_vertex","title":"Fetch specific properties of a vertex","text":"<p>Use a <code>YIELD</code> clause to specify the properties to be returned.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player100\" \\\n        YIELD properties(vertex).name AS name;\n+--------------+\n| name         |\n+--------------+\n| \"Tim Duncan\" |\n+--------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_properties_of_multiple_vertices","title":"Fetch properties of multiple vertices","text":"<p>Specify multiple VIDs (vertex IDs) to fetch properties of multiple vertices. Separate the VIDs with commas.</p> <pre><code>nebula&gt; FETCH PROP ON player \"player101\", \"player102\", \"player103\" YIELD properties(vertex);\n+--------------------------------------+\n| properties(VERTEX)                   |\n+--------------------------------------+\n| {age: 33, name: \"LaMarcus Aldridge\"} |\n| {age: 36, name: \"Tony Parker\"}       |\n| {age: 32, name: \"Rudy Gay\"}          |\n+--------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_vertex_properties_by_multiple_tags","title":"Fetch vertex properties by multiple tags","text":"<p>Specify multiple tags in the <code>FETCH</code> statement to fetch the vertex properties by the tags. Separate the tags with commas.</p> <pre><code># The following example creates a new tag t1.\nnebula&gt; CREATE TAG IF NOT EXISTS t1(a string, b int);\n\n# The following example attaches t1 to the vertex \"player100\".\nnebula&gt; INSERT VERTEX t1(a, b) VALUES \"player100\":(\"Hello\", 100);\n\n# The following example fetches the properties of vertex \"player100\" by the tags player and t1.\nnebula&gt; FETCH PROP ON player, t1 \"player100\" YIELD vertex AS v;\n+----------------------------------------------------------------------------+\n| v                                                                          |\n+----------------------------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"} :t1{a: \"Hello\", b: 100}) |\n+----------------------------------------------------------------------------+\n</code></pre> <p>You can combine multiple tags with multiple VIDs in a <code>FETCH</code> statement.</p> <pre><code>nebula&gt; FETCH PROP ON player, t1 \"player100\", \"player103\" YIELD vertex AS v;\n+----------------------------------------------------------------------------+\n| v                                                                          |\n+----------------------------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"} :t1{a: \"Hello\", b: 100}) |\n| (\"player103\" :player{age: 32, name: \"Rudy Gay\"})                           |\n+----------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_vertex_properties_by_all_tags","title":"Fetch vertex properties by all tags","text":"<p>Set an asterisk symbol <code>*</code> to fetch properties by all tags in the current graph space.</p> <pre><code>nebula&gt; FETCH PROP ON * \"player100\", \"player106\", \"team200\" YIELD vertex AS v;\n+----------------------------------------------------------------------------+\n| v                                                                          |\n+----------------------------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"} :t1{a: \"Hello\", b: 100}) |\n| (\"player106\" :player{age: 25, name: \"Kyle Anderson\"})                      |\n| (\"team200\" :team{name: \"Warriors\"})                                        |\n+----------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_edge_properties","title":"Fetch edge properties","text":""},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#syntax_1","title":"Syntax","text":"<pre><code>FETCH PROP ON &lt;edge_type&gt; &lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;] [, &lt;src_vid&gt; -&gt; &lt;dst_vid&gt; ...]\nYIELD &lt;output&gt;;\n</code></pre> Parameter Description <code>edge_type</code> The name of the edge type. <code>src_vid</code> The VID of the source vertex. It specifies the start of an edge. <code>dst_vid</code> The VID of the destination vertex. It specifies the end of an edge. <code>rank</code> The rank of the edge. It is optional and defaults to <code>0</code>. It distinguishes an edge from other edges with the same edge type, source vertex, destination vertex, and rank. <code>YIELD</code> Define the output to be returned. For details, see <code>YIELD</code>."},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_all_properties_of_an_edge","title":"Fetch all properties of an edge","text":"<p>The following statement fetches all the properties of the <code>serve</code> edge that connects vertex <code>\"player100\"</code> and vertex <code>\"team204\"</code>.</p> <pre><code>nebula&gt; FETCH PROP ON serve \"player100\" -&gt; \"team204\" YIELD properties(edge);\n+------------------------------------+\n| properties(EDGE)                   |\n+------------------------------------+\n| {end_year: 2016, start_year: 1997} |\n+------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_specific_properties_of_an_edge","title":"Fetch specific properties of an edge","text":"<p>Use a <code>YIELD</code> clause to fetch specific properties of an edge.</p> <pre><code>nebula&gt; FETCH PROP ON serve \"player100\" -&gt; \"team204\"    \\\n        YIELD properties(edge).start_year;\n+-----------------------------+\n| properties(EDGE).start_year |\n+-----------------------------+\n| 1997                        |\n+-----------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_properties_of_multiple_edges","title":"Fetch properties of multiple edges","text":"<p>Specify multiple edge patterns (<code>&lt;src_vid&gt; -&gt; &lt;dst_vid&gt;[@&lt;rank&gt;]</code>) to fetch properties of multiple edges. Separate the edge patterns with commas.</p> <pre><code>nebula&gt; FETCH PROP ON serve \"player100\" -&gt; \"team204\", \"player133\" -&gt; \"team202\" YIELD edge AS e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}] |\n| [:serve \"player133\"-&gt;\"team202\" @0 {end_year: 2011, start_year: 2002}] |\n+-----------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#fetch_properties_based_on_edge_rank","title":"Fetch properties based on edge rank","text":"<p>If there are multiple edges with the same edge type, source vertex, and destination vertex, you can specify the rank to fetch the properties on the correct edge.</p> <pre><code># The following example inserts edges with different ranks and property values.\nnebula&gt; insert edge serve(start_year,end_year) \\\n        values \"player100\"-&gt;\"team204\"@1:(1998, 2017);\n\nnebula&gt; insert edge serve(start_year,end_year) \\\n        values \"player100\"-&gt;\"team204\"@2:(1990, 2018);\n\n# By default, the FETCH statement returns the edge whose rank is 0.\nnebula&gt; FETCH PROP ON serve \"player100\" -&gt; \"team204\" YIELD edge AS e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}] |\n+-----------------------------------------------------------------------+\n\n# To fetch on an edge whose rank is not 0, set its rank in the FETCH statement.\nnebula&gt; FETCH PROP ON serve \"player100\" -&gt; \"team204\"@1 YIELD edge AS e;\n+-----------------------------------------------------------------------+\n| e                                                                     |\n+-----------------------------------------------------------------------+\n| [:serve \"player100\"-&gt;\"team204\" @1 {end_year: 2017, start_year: 1998}] |\n+-----------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/4.fetch/#use_fetch_in_composite_queries","title":"Use FETCH in composite queries","text":"<p>A common way to use <code>FETCH</code> is to combine it with native nGQL such as <code>GO</code>.</p> <p>The following statement returns the <code>degree</code> values of the <code>follow</code> edges that start from vertex <code>\"player101\"</code>.</p> <pre><code>nebula&gt; GO FROM \"player101\" OVER follow \\\n        YIELD src(edge) AS s, dst(edge) AS d \\\n        | FETCH PROP ON follow $-.s -&gt; $-.d \\\n        YIELD properties(edge).degree;\n+-------------------------+\n| properties(EDGE).degree |\n+-------------------------+\n| 95                      |\n| 90                      |\n| 95                      |\n+-------------------------+\n</code></pre> <p>Or you can use user-defined variables to construct similar queries.</p> <pre><code>nebula&gt; $var = GO FROM \"player101\" OVER follow \\\n        YIELD src(edge) AS s, dst(edge) AS d; \\\n        FETCH PROP ON follow $var.s -&gt; $var.d \\\n        YIELD properties(edge).degree;\n+-------------------------+\n| properties(EDGE).degree |\n+-------------------------+\n| 95                      |\n| 90                      |\n| 95                      |\n+-------------------------+\n</code></pre> <p>For more information about composite queries, see Composite queries (clause structure).</p>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/","title":"LOOKUP","text":"<p>The <code>LOOKUP</code> statement traverses data based on indexes. You can use <code>LOOKUP</code> for the following purposes:</p> <ul> <li>Search for the specific data based on conditions defined by the <code>WHERE</code> clause.</li> </ul> <ul> <li>List vertices with a tag: retrieve the VID of all vertices with a tag.</li> </ul> <ul> <li>List edges with an edge type: retrieve the source vertex IDs, destination vertex IDs, and ranks of all edges with an edge type.</li> </ul> <ul> <li>Count the number of vertices or edges with a tag or an edge type.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>This topic applies to native nGQL only.</p>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#precautions","title":"Precautions","text":"<ul> <li>Correct use of indexes can speed up queries, but indexes can dramatically reduce the write performance. The performance can be greatly reduced. DO NOT use indexes in production environments unless you are fully aware of their influences on your service.</li> </ul> <ul> <li> <p>If the specified property is not indexed when using the <code>LOOKUP</code> statement, NebulaGraph randomly selects one of the available indexes.</p> <p>For example, the tag <code>player</code> has two properties, <code>name</code> and <code>age</code>. Both the tag <code>player</code> itself and the property <code>name</code> have indexes, but the property <code>age</code> has no indexes. When running <code>LOOKUP ON player WHERE player.age == 36 YIELD player.name;</code>, NebulaGraph randomly uses one of the indexes of the tag <code>player</code> and the property <code>name</code>. You can use the <code>EXPLAIN</code> statement to check the selected index.</p> <p>Legacy version compatibility</p> <p>Before the release 2.5.0, if the specified property is not indexed when using the <code>LOOKUP</code> statement, NebulaGraph reports an error and does not use other indexes.</p> </li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#prerequisites","title":"Prerequisites","text":"<p>Before using the <code>LOOKUP</code> statement, make sure that at least one index is created. If there are already related vertices, edges, or properties before an index is created, the user must rebuild the index after creating the index to make it valid.</p>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#syntax","title":"Syntax","text":"<pre><code>LOOKUP ON {&lt;vertex_tag&gt; | &lt;edge_type&gt;}\n[WHERE &lt;expression&gt; [AND &lt;expression&gt; ...]]\nYIELD [DISTINCT] &lt;return_list&gt; [AS &lt;alias&gt;];\n\n&lt;return_list&gt;\n    &lt;prop_name&gt; [AS &lt;col_alias&gt;] [, &lt;prop_name&gt; [AS &lt;prop_alias&gt;] ...];\n</code></pre> <ul> <li><code>WHERE &lt;expression&gt;</code>: filters data with specified conditions. Both <code>AND</code> and <code>OR</code> are supported between different expressions. For more information, see WHERE.</li> </ul> <ul> <li><code>YIELD</code>: Define the output to be returned. For details, see <code>YIELD</code>.</li> </ul> <ul> <li><code>DISTINCT</code>: Aggregate the output results and return the de-duplicated result set.</li> </ul> <ul> <li><code>AS</code>: Set an alias.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#limitations_of_using_where_in_lookup","title":"Limitations of using <code>WHERE</code> in <code>LOOKUP</code>","text":"<p>The <code>WHERE</code> clause in a <code>LOOKUP</code> statement does not support the following operations:</p> <ul> <li><code>$-</code> and <code>$^</code>.</li> <li>Filter <code>rank()</code>.</li> <li>In relational expressions, operators are not supported to have field names on both sides, such as <code>tagName.prop1&gt; tagName.prop2</code>.</li> <li>Nested AliasProp expressions in operation expressions and function expressions are not supported.</li> <li>The <code>XOR</code> operation is not supported.</li> <li>String operations other than <code>STARTS WITH</code> are not supported.</li> <li>Graph patterns.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#retrieve_vertices","title":"Retrieve vertices","text":"<p>The following example returns vertices whose <code>name</code> is <code>Tony Parker</code> and the tag is <code>player</code>.</p> <pre><code>nebula&gt; CREATE TAG INDEX IF NOT EXISTS index_player ON player(name(30), age);\n\nnebula&gt; REBUILD TAG INDEX index_player;\n+------------+\n| New Job Id |\n+------------+\n| 15         |\n+------------+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.name == \"Tony Parker\" \\\n        YIELD id(vertex);\n+---------------+\n| id(VERTEX)    |\n+---------------+\n| \"player101\"   |\n+---------------+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.name == \"Tony Parker\" \\\n        YIELD properties(vertex).name AS name, properties(vertex).age AS age;\n+---------------+-----+\n| name          | age |\n+---------------+-----+\n| \"Tony Parker\" | 36  |\n+---------------+-----+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.age  &gt; 45 \\\n        YIELD id(vertex);\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player144\" |\n| \"player140\" |\n+-------------+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.name STARTS WITH \"B\" \\\n        AND player.age IN [22,30] \\\n        YIELD properties(vertex).name, properties(vertex).age;\n+-------------------------+------------------------+\n| properties(VERTEX).name | properties(VERTEX).age |\n+-------------------------+------------------------+\n| \"Ben Simmons\"           | 22                     |\n| \"Blake Griffin\"         | 30                     |\n+-------------------------+------------------------+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.name == \"Kobe Bryant\"\\\n        YIELD id(vertex) AS VertexID, properties(vertex).name AS name |\\\n        GO FROM $-.VertexID OVER serve \\\n        YIELD $-.name, properties(edge).start_year, properties(edge).end_year, properties($$).name;\n+---------------+-----------------------------+---------------------------+---------------------+\n| $-.name       | properties(EDGE).start_year | properties(EDGE).end_year | properties($$).name |\n+---------------+-----------------------------+---------------------------+---------------------+\n| \"Kobe Bryant\" | 1996                        | 2016                      | \"Lakers\"            |\n+---------------+-----------------------------+---------------------------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#retrieve_edges","title":"Retrieve edges","text":"<p>The following example returns edges whose <code>degree</code> is <code>90</code> and the edge type is <code>follow</code>.</p> <pre><code>nebula&gt; CREATE EDGE INDEX IF NOT EXISTS index_follow ON follow(degree);\n\nnebula&gt; REBUILD EDGE INDEX index_follow;\n+------------+\n| New Job Id |\n+------------+\n| 62         |\n+------------+\n\nnebula&gt; LOOKUP ON follow \\\n        WHERE follow.degree == 90 YIELD edge AS e;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player109\"-&gt;\"player125\" @0 {degree: 90}] |\n| [:follow \"player118\"-&gt;\"player120\" @0 {degree: 90}] |\n| [:follow \"player118\"-&gt;\"player131\" @0 {degree: 90}] |\n...\n\nnebula&gt; LOOKUP ON follow \\\n        WHERE follow.degree == 90 \\\n        YIELD properties(edge).degree;\n+-------------+-------------+---------+-------------------------+\n| SrcVID      | DstVID      | Ranking | properties(EDGE).degree |\n+-------------+-------------+---------+-------------------------+\n| \"player150\" | \"player143\" | 0       | 90                      |\n| \"player150\" | \"player137\" | 0       | 90                      |\n| \"player148\" | \"player136\" | 0       | 90                      |\n...\n\nnebula&gt; LOOKUP ON follow \\\n        WHERE follow.degree == 60 \\\n        YIELD dst(edge) AS DstVID, properties(edge).degree AS Degree |\\\n        GO FROM $-.DstVID OVER serve \\\n        YIELD $-.DstVID, properties(edge).start_year, properties(edge).end_year, properties($$).name;\n+-------------+-----------------------------+---------------------------+---------------------+\n| $-.DstVID   | properties(EDGE).start_year | properties(EDGE).end_year | properties($$).name |\n+-------------+-----------------------------+---------------------------+---------------------+\n| \"player105\" | 2010                        | 2018                      | \"Spurs\"             |\n| \"player105\" | 2009                        | 2010                      | \"Cavaliers\"         |\n| \"player105\" | 2018                        | 2019                      | \"Raptors\"           |\n+-------------+-----------------------------+---------------------------+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#list_vertices_or_edges_with_a_tag_or_an_edge_type","title":"List vertices or edges with a tag or an edge type","text":"<p>To list vertices or edges with a tag or an edge type, at least one index must exist on the tag, the edge type, or its property.</p> <p>For example, if there is a <code>player</code> tag with a <code>name</code> property and an <code>age</code> property, to retrieve the VID of all vertices tagged with <code>player</code>, there has to be an index on the <code>player</code> tag itself, the <code>name</code> property, or the <code>age</code> property.</p> <ul> <li>The following example shows how to retrieve the VID of all vertices tagged with <code>player</code>.<pre><code>nebula&gt; CREATE TAG IF NOT EXISTS player(name string,age int);\n\nnebula&gt; CREATE TAG INDEX IF NOT EXISTS player_index on player();\n\nnebula&gt; REBUILD TAG INDEX player_index;\n+------------+\n| New Job Id |\n+------------+\n| 66         |\n+------------+\n\nnebula&gt; INSERT VERTEX player(name,age) \\\n        VALUES \"player100\":(\"Tim Duncan\", 42), \"player101\":(\"Tony Parker\", 36);\n\nThe following statement retrieves the VID of all vertices with the tag `player`. It is similar to `MATCH (n:player) RETURN id(n) /*, n */`.\n\nnebula&gt; LOOKUP ON player YIELD id(vertex);\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n...\n</code></pre> </li> </ul> <ul> <li>The following example shows how to retrieve the source Vertex IDs, destination vertex IDs, and ranks of all edges of the <code>follow</code> edge type.<pre><code>nebula&gt; CREATE EDGE IF NOT EXISTS follow(degree int);\n\nnebula&gt; CREATE EDGE INDEX IF NOT EXISTS follow_index on follow();\n\nnebula&gt; REBUILD EDGE INDEX follow_index;\n+------------+\n| New Job Id |\n+------------+\n| 88         |\n+------------+\n\nnebula&gt; INSERT EDGE follow(degree) \\\n        VALUES \"player100\"-&gt;\"player101\":(95);\n\nThe following statement retrieves all edges with the edge type `follow`. It is similar to `MATCH (s)-[e:follow]-&gt;(d) RETURN id(s), rank(e), id(d) /*, type(e) */`.\n\nnebula)&gt; LOOKUP ON follow YIELD edge AS e;\n+-----------------------------------------------------+\n| e                                                   |\n+-----------------------------------------------------+\n| [:follow \"player105\"-&gt;\"player100\" @0 {degree: 70}]  |\n| [:follow \"player105\"-&gt;\"player116\" @0 {degree: 80}]  |\n| [:follow \"player109\"-&gt;\"player100\" @0 {degree: 80}]  |\n...\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/5.lookup/#count_the_numbers_of_vertices_or_edges","title":"Count the numbers of vertices or edges","text":"<p>The following example shows how to count the number of vertices tagged with <code>player</code> and edges of the <code>follow</code> edge type.</p> <pre><code>nebula&gt; LOOKUP ON player YIELD id(vertex)|\\\n        YIELD COUNT(*) AS Player_Number;\n+---------------+\n| Player_Number |\n+---------------+\n| 51            |\n+---------------+\n\nnebula&gt; LOOKUP ON follow YIELD edge AS e| \\\n        YIELD COUNT(*) AS Follow_Number;\n+---------------+\n| Follow_Number |\n+---------------+\n| 81            |\n+---------------+\n</code></pre> <p>Note</p> <p>You can also use <code>SHOW STATS</code> to count the numbers of vertices or edges.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.find-path/","title":"FIND PATH","text":"<p>The <code>FIND PATH</code> statement finds the paths between the selected source vertices and destination vertices.</p> <p>Note</p> <p>To improve the query performance with the <code>FIND PATH</code> statement, you can add the <code>num_operator_threads</code> parameter in the <code>nebula-graphd.conf</code> configuration file. The value range of the <code>num_operator_threads</code> parameter is [2, 10] and make sure that the value is not greater than the number of CPU cores of the machine where the <code>graphd</code> service is deployed. It is recommended to set the value to the number of CPU cores of the machine where the <code>graphd</code> service is deployed. For more information about the <code>nebula-graphd.conf</code> configuration file, see nebula-graphd.conf.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.find-path/#syntax","title":"Syntax","text":"<pre><code>FIND { SHORTEST | SINGLE SHORTEST | ALL | NOLOOP } PATH [WITH PROP] FROM &lt;vertex_id_list&gt; TO &lt;vertex_id_list&gt;\nOVER &lt;edge_type_list&gt; [REVERSELY | BIDIRECT] \n[&lt;WHERE clause&gt;] [UPTO &lt;N&gt; {STEP|STEPS}] \nYIELD path as &lt;alias&gt;\n[| ORDER BY $-.path] [| LIMIT &lt;M&gt;];\n\n&lt;vertex_id_list&gt; ::=\n    [vertex_id [, vertex_id] ...]\n</code></pre> <ul> <li><code>SHORTEST</code> finds all shortest paths and returns all of them.</li> </ul> <ul> <li><code>SINGLE SHORTEST</code> finds all shortest paths and returns only one of them randomly.</li> </ul> <ul> <li><code>ALL</code> finds all the paths.</li> </ul> <ul> <li><code>NOLOOP</code> finds the paths without circles.</li> </ul> <ul> <li><code>WITH PROP</code> shows properties of vertices and edges. If not specified, properties will be hidden.</li> </ul> <ul> <li><code>&lt;vertex_id_list&gt;</code> is a list of vertex IDs separated with commas (,). It supports <code>$-</code> and <code>$var</code>.</li> </ul> <ul> <li><code>&lt;edge_type_list&gt;</code> is a list of edge types separated with commas (,). <code>*</code> is all edge types.</li> </ul> <ul> <li><code>REVERSELY | BIDIRECT</code> specifies the direction. <code>REVERSELY</code> is reverse graph traversal while <code>BIDIRECT</code> is bidirectional graph traversal.</li> </ul> <ul> <li><code>&lt;WHERE clause&gt;</code> filters properties of edges.</li> </ul> <ul> <li><code>UPTO &lt;N&gt; {STEP|STEPS}</code> is the maximum hop number of the path. The default value is <code>5</code>.</li> </ul> <ul> <li><code>ORDER BY $-.path</code> specifies the order of the returned paths. For information about the order rules, see Path.</li> </ul> <ul> <li><code>LIMIT &lt;M&gt;</code> specifies the maximum number of rows to return.</li> </ul> <p>Note</p> <p>The path type of <code>FIND PATH</code> is <code>trail</code>. Only vertices can be repeatedly visited in graph traversal. For more information, see Path.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.find-path/#limitations","title":"Limitations","text":"<ul> <li>When a list of source and/or destination vertex IDs are specified, the paths between any source vertices and the destination vertices will be returned.</li> </ul> <ul> <li>There can be cycles when searching all paths.</li> </ul> <ul> <li><code>FIND PATH</code> only supports filtering properties of edges with <code>WHERE</code> clauses. Filtering properties of vertices and functions are not supported for now.</li> </ul> <ul> <li><code>FIND PATH</code> is a single-thread procedure, so it uses much memory.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/6.find-path/#examples","title":"Examples","text":"<p>A returned path is like <code>(&lt;vertex_id&gt;)-[:&lt;edge_type_name&gt;@&lt;rank&gt;]-&gt;(&lt;vertex_id)</code>.</p> <pre><code>nebula&gt; FIND SHORTEST PATH FROM \"player102\" TO \"team204\" OVER * YIELD path AS p;\n+--------------------------------------------+\n| p                                          |\n+--------------------------------------------+\n| &lt;(\"player102\")-[:serve@0 {}]-&gt;(\"team204\")&gt; |\n+--------------------------------------------+\n</code></pre> <pre><code>nebula&gt; FIND SHORTEST PATH WITH PROP FROM \"team204\" TO \"player100\" OVER * REVERSELY YIELD path AS p;\n+--------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                    |\n+--------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"team204\" :team{name: \"Spurs\"})&lt;-[:serve@0 {end_year: 2016, start_year: 1997}]-(\"player100\" :player{age: 42, name: \"Tim Duncan\"})&gt; |\n+--------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <pre><code>nebula&gt; FIND SHORTEST PATH FROM \"player100\", \"player130\" TO \"player132\", \"player133\" OVER * BIDIRECT UPTO 18 STEPS YIELD path as p;\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                                                                              |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\")&lt;-[:follow@0 {}]-(\"player144\")&lt;-[:follow@0 {}]-(\"player133\")&gt;                                                                                                                    |\n| &lt;(\"player100\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player138\")-[:serve@0 {}]-&gt;(\"team225\")&lt;-[:serve@0 {}]-(\"player132\")&gt;                                                                |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player112\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player114\")&lt;-[:follow@0 {}]-(\"player133\")&gt;                                  |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player109\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player114\")&lt;-[:follow@0 {}]-(\"player133\")&gt;                                  |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player104\")-[:serve@20182019 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player114\")&lt;-[:follow@0 {}]-(\"player133\")&gt;                           |\n| ...                                                                                                                                                                                            |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player112\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player138\")-[:serve@0 {}]-&gt;(\"team225\")&lt;-[:serve@0 {}]-(\"player132\")&gt;        |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player109\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player138\")-[:serve@0 {}]-&gt;(\"team225\")&lt;-[:serve@0 {}]-(\"player132\")&gt;        |\n| ...                                                                                                                                                                                            |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <pre><code>nebula&gt; FIND SINGLE SHORTEST PATH FROM \"player100\", \"player130\" TO \"player132\", \"player133\" OVER * BIDIRECT UPTO 18 STEPS YIELD path as p;\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                                                                       |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\")&lt;-[:follow@0 {}]-(\"player144\")&lt;-[:follow@0 {}]-(\"player133\")&gt;                                                                                                             |\n| &lt;(\"player100\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player138\")-[:serve@0 {}]-&gt;(\"team225\")&lt;-[:serve@0 {}]-(\"player132\")&gt;                                                         |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player112\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player114\")&lt;-[:follow@0 {}]-(\"player133\")&gt;                           |\n| &lt;(\"player130\")-[:serve@0 {}]-&gt;(\"team219\")&lt;-[:serve@0 {}]-(\"player112\")-[:serve@0 {}]-&gt;(\"team204\")&lt;-[:serve@0 {}]-(\"player138\")-[:serve@0 {}]-&gt;(\"team225\")&lt;-[:serve@0 {}]-(\"player132\")&gt; |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <pre><code>nebula&gt; FIND ALL PATH FROM \"player100\" TO \"team204\" OVER * WHERE follow.degree is EMPTY or follow.degree &gt;=0 YIELD path AS p;\n+------------------------------------------------------------------------------+\n| p                                                                            |\n+------------------------------------------------------------------------------+\n| &lt;(\"player100\")-[:serve@0 {}]-&gt;(\"team204\")&gt;                                   |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player125\")-[:serve@0 {}]-&gt;(\"team204\")&gt;     |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:serve@0 {}]-&gt;(\"team204\")&gt;     |\n|...                                                                           |\n+------------------------------------------------------------------------------+\n</code></pre> <pre><code>nebula&gt; FIND NOLOOP PATH FROM \"player100\" TO \"team204\" OVER * YIELD path AS p;\n+--------------------------------------------------------------------------------------------------------+\n| p                                                                                                      |\n+--------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\")-[:serve@0 {}]-&gt;(\"team204\")&gt;                                                             |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player125\")-[:serve@0 {}]-&gt;(\"team204\")&gt;                               |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:serve@0 {}]-&gt;(\"team204\")&gt;                               |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:follow@0 {}]-&gt;(\"player125\")-[:serve@0 {}]-&gt;(\"team204\")&gt; |\n| &lt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:follow@0 {}]-&gt;(\"player102\")-[:serve@0 {}]-&gt;(\"team204\")&gt; |\n+--------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.find-path/#faq","title":"FAQ","text":""},{"location":"3.ngql-guide/7.general-query-statements/6.find-path/#does_it_support_the_where_clause_to_achieve_conditional_filtering_during_graph_traversal","title":"Does it support the WHERE clause to achieve conditional filtering during graph traversal?","text":"<p><code>FIND PATH</code> only supports filtering properties of edges with <code>WHERE</code> clauses, such as <code>WHERE follow.degree is EMPTY or follow.degree &gt;=0</code>.</p> <p>Filtering properties of vertices is not supported for now.</p>"},{"location":"3.ngql-guide/7.general-query-statements/7.get-subgraph/","title":"GET SUBGRAPH","text":"<p>The <code>GET SUBGRAPH</code> statement returns a subgraph that is generated by traversing a graph starting from a specified vertex. <code>GET SUBGRAPH</code> statements allow you to specify the number of steps and the type or direction of edges during the traversal.</p>"},{"location":"3.ngql-guide/7.general-query-statements/7.get-subgraph/#syntax","title":"Syntax","text":"<pre><code>GET SUBGRAPH [WITH PROP] [&lt;step_count&gt; {STEP|STEPS}] FROM {&lt;vid&gt;, &lt;vid&gt;...}\n[{IN | OUT | BOTH} &lt;edge_type&gt;, &lt;edge_type&gt;...]\n[WHERE &lt;expression&gt; [AND &lt;expression&gt; ...]]\nYIELD {[VERTICES AS &lt;vertex_alias&gt;] [,EDGES AS &lt;edge_alias&gt;]};\n</code></pre> <ul> <li><code>WITH PROP</code> shows the properties. If not specified, the properties will be hidden.</li> </ul> <ul> <li><code>step_count</code> specifies the number of hops from the source vertices and returns the subgraph from 0 to <code>step_count</code> hops. It must be a non-negative integer. Its default value is 1.</li> </ul> <ul> <li><code>vid</code> specifies the vertex IDs. </li> </ul> <ul> <li><code>edge_type</code> specifies the edge type. You can use <code>IN</code>, <code>OUT</code>, and <code>BOTH</code> to specify the traversal direction of the edge type. The default is <code>BOTH</code>.</li> </ul> <ul> <li><code>&lt;WHERE clause&gt;</code> specifies the filter conditions for the traversal, which can be used with the boolean operator <code>AND</code>.</li> </ul> <ul> <li><code>YIELD</code> defines the output that needs to be returned. You can return only vertices or edges. A column alias must be set.</li> </ul> <p>Note</p> <p>The path type of <code>GET SUBGRAPH</code> is <code>trail</code>. Only vertices can be repeatedly visited in graph traversal. For more information, see Path.</p>"},{"location":"3.ngql-guide/7.general-query-statements/7.get-subgraph/#limitations","title":"Limitations","text":"<p>While using the <code>WHERE</code> clause in a <code>GET SUBGRAPH</code> statement, note the following restrictions:</p> <ul> <li>Only support the <code>AND</code> operator.</li> <li>Only support filter destination vertex, the vertex format must be <code>$$.tagName.propName</code>.</li> <li>Support filter edge, the edge format must be <code>edge_type.propName</code>.</li> <li>Support math functions, aggregate functions, string functions, datetime functions, type conversion functions and general functions in list functions.</li> <li>Not support aggregate functions, schema-related functions, conditional expression, predicate functions, geography function and user-defined functions.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/7.get-subgraph/#examples","title":"Examples","text":"<p>The following graph is used as the sample.</p> <p></p> <p>Insert the test data:</p> <pre><code>nebula&gt; CREATE SPACE IF NOT EXISTS subgraph(partition_num=15, replica_factor=1, vid_type=fixed_string(30));\nnebula&gt; USE subgraph;\nnebula&gt; CREATE TAG IF NOT EXISTS player(name string, age int);\nnebula&gt; CREATE TAG IF NOT EXISTS team(name string);\nnebula&gt; CREATE EDGE IF NOT EXISTS follow(degree int);\nnebula&gt; CREATE EDGE IF NOT EXISTS serve(start_year int, end_year int);\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player100\":(\"Tim Duncan\", 42);\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player101\":(\"Tony Parker\", 36);\nnebula&gt; INSERT VERTEX player(name, age) VALUES \"player102\":(\"LaMarcus Aldridge\", 33);\nnebula&gt; INSERT VERTEX team(name) VALUES \"team203\":(\"Trail Blazers\"), \"team204\":(\"Spurs\");\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player101\" -&gt; \"player100\":(95);\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player101\" -&gt; \"player102\":(90);\nnebula&gt; INSERT EDGE follow(degree) VALUES \"player102\" -&gt; \"player100\":(75);\nnebula&gt; INSERT EDGE serve(start_year, end_year) VALUES \"player101\" -&gt; \"team204\":(1999, 2018),\"player102\" -&gt; \"team203\":(2006,  2015);\n</code></pre> <ul> <li>This example goes one step from the vertex <code>player101</code> over all edge types and gets the subgraph.<pre><code>nebula&gt; GET SUBGRAPH 1 STEPS FROM \"player101\" YIELD VERTICES AS nodes, EDGES AS relationships;\n+-------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+\n| nodes                                                                   | relationships                                                                                                               |\n+-------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+\n| [(\"player101\" :player{})]                                               | [[:serve \"player101\"-&gt;\"team204\" @0 {}], [:follow \"player101\"-&gt;\"player100\" @0 {}], [:follow \"player101\"-&gt;\"player102\" @0 {}]] |\n| [(\"team204\" :team{}), (\"player100\" :player{}), (\"player102\" :player{})] | [[:follow \"player102\"-&gt;\"player100\" @0 {}]]                                                                                  |\n+-------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+\n</code></pre> <p>The returned subgraph is as follows.</p> <p></p> </li> </ul> <ul> <li>This example goes one step from the vertex <code>player101</code> over incoming <code>follow</code> edges and gets the subgraph.<pre><code>nebula&gt; GET SUBGRAPH 1 STEPS FROM \"player101\" IN follow YIELD VERTICES AS nodes, EDGES AS relationships;\n+---------------------------+---------------+\n| nodes                     | relationships |\n+---------------------------+---------------+\n| [(\"player101\" :player{})] | []            |\n+---------------------------+---------------+\n</code></pre> <p>There is no incoming <code>follow</code> edge to <code>player101</code>, so only the vertex <code>player101</code> is returned.</p> </li> </ul> <ul> <li>This example goes one step from the vertex <code>player101</code> over outgoing <code>serve</code> edges, gets the subgraph, and shows the property of the edge.<pre><code>nebula&gt; GET SUBGRAPH WITH PROP 1 STEPS FROM \"player101\" OUT serve YIELD VERTICES AS nodes, EDGES AS relationships;\n+-------------------------------------------------------+-------------------------------------------------------------------------+\n| nodes                                                 | relationships                                                           |\n+-------------------------------------------------------+-------------------------------------------------------------------------+\n| [(\"player101\" :player{age: 36, name: \"Tony Parker\"})] | [[:serve \"player101\"-&gt;\"team204\" @0 {end_year: 2018, start_year: 1999}]] |\n| [(\"team204\" :team{name: \"Spurs\"})]                    | []                                                                      |\n+-------------------------------------------------------+-------------------------------------------------------------------------+\n</code></pre> <p>The returned subgraph is as follows.</p> <p></p> </li> </ul> <ul> <li>This example goes two steps from the vertex <code>player101</code> over <code>follow</code> edges, filters by degree &gt; 90 and age &gt; 30, and shows the properties of edges.<pre><code>nebula&gt; GET SUBGRAPH WITH PROP 2 STEPS FROM \"player101\" \\\n    WHERE follow.degree &gt; 90 AND $$.player.age &gt; 30 \\\n    YIELD VERTICES AS nodes, EDGES AS relationships;\n+-------------------------------------------------------+------------------------------------------------------+\n| nodes                                                 | relationships                                        |\n+-------------------------------------------------------+------------------------------------------------------+\n| [(\"player101\" :player{age: 36, name: \"Tony Parker\"})] | [[:follow \"player101\"-&gt;\"player100\" @0 {degree: 95}]] |\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"})]  | []                                                   |\n+-------------------------------------------------------+------------------------------------------------------+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/7.get-subgraph/#faq","title":"FAQ","text":""},{"location":"3.ngql-guide/7.general-query-statements/7.get-subgraph/#why_is_the_number_of_hops_in_the_returned_result_greater_than_step_count","title":"Why is the number of hops in the returned result greater than <code>step_count</code>?","text":"<p>To show the completeness of the subgraph, an additional hop is made on all vertices that meet the conditions. The following graph is used as the sample.</p> <p></p> <ul> <li>The returned paths of <code>GET SUBGRAPH 1 STEPS FROM \"A\";</code> are <code>A-&gt;B</code>, <code>B-&gt;A</code>, and <code>A-&gt;C</code>. To show the completeness of the subgraph, an additional hop is made on all vertices that meet the conditions, namely <code>B-&gt;C</code>.</li> </ul> <ul> <li>The returned path of <code>GET SUBGRAPH 1 STEPS FROM \"A\" IN follow;</code> is <code>B-&gt;A</code>. To show the completeness of the subgraph, an additional hop is made on all vertices that meet the conditions, namely <code>A-&gt;B</code>.</li> </ul> <p>If you only query paths or vertices that meet the conditions, we suggest you use MATCH or GO. The example is as follows.</p> <pre><code>nebula&gt; MATCH p= (v:player) -- (v2) WHERE id(v)==\"A\" RETURN p;\nnebula&gt; GO 1 STEPS FROM \"A\" OVER follow YIELD src(edge),dst(edge);\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/7.get-subgraph/#why_is_the_number_of_hops_in_the_returned_result_lower_than_step_count","title":"Why is the number of hops in the returned result lower than <code>step_count</code>?","text":"<p>The query stops when there is not enough subgraph data and will not return the null value.</p> <pre><code>nebula&gt; GET SUBGRAPH 100 STEPS FROM \"player101\" OUT follow YIELD VERTICES AS nodes, EDGES AS relationships;\n+----------------------------------------------------+--------------------------------------------------------------------------------------+\n| nodes                                              | relationships                                                                        |\n+----------------------------------------------------+--------------------------------------------------------------------------------------+\n| [(\"player101\" :player{})]                          | [[:follow \"player101\"-&gt;\"player100\" @0 {}], [:follow \"player101\"-&gt;\"player102\" @0 {}]] |\n| [(\"player100\" :player{}), (\"player102\" :player{})] | [[:follow \"player102\"-&gt;\"player100\" @0 {}]]                                           |\n+----------------------------------------------------+--------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/optional-match/","title":"OPTIONAL MATCH","text":"<p>Caution</p> <p>The feature is still in beta. It will continue to be optimized.</p> <p>The <code>OPTIONAL MATCH</code> clause is used to search for the pattern described in it. <code>OPTIONAL MATCH</code> matches patterns against your graph database, just like <code>MATCH</code> does. The difference is that if no matches are found, <code>OPTIONAL MATCH</code> will use a null for missing parts of the pattern.</p>"},{"location":"3.ngql-guide/7.general-query-statements/optional-match/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>This topic applies to the openCypher syntax in nGQL only.</p>"},{"location":"3.ngql-guide/7.general-query-statements/optional-match/#limitations","title":"Limitations","text":"<p>The <code>WHERE</code> clause cannot be used in an <code>OPTIONAL MATCH</code> clause.</p>"},{"location":"3.ngql-guide/7.general-query-statements/optional-match/#example","title":"Example","text":"<p>The example of the use of <code>OPTIONAL MATCH</code> in the <code>MATCH</code> statement is as follows:</p> <pre><code>nebula&gt; MATCH (m)-[]-&gt;(n) WHERE id(m)==\"player100\" \\\n        OPTIONAL MATCH (n)-[]-&gt;(l) \\\n        RETURN id(m),id(n),id(l);\n+-------------+-------------+-------------+\n| id(m)       | id(n)       | id(l)       |\n+-------------+-------------+-------------+\n| \"player100\" | \"team204\"   | __NULL__    |\n| \"player100\" | \"player101\" | \"team204\"   |\n| \"player100\" | \"player101\" | \"team215\"   |\n| \"player100\" | \"player101\" | \"player100\" |\n| \"player100\" | \"player101\" | \"player102\" |\n| \"player100\" | \"player101\" | \"player125\" |\n| \"player100\" | \"player125\" | \"team204\"   |\n| \"player100\" | \"player125\" | \"player100\" |\n+-------------+-------------+-------------+\n</code></pre> <p>Using multiple <code>MATCH</code> instead of <code>OPTIONAL MATCH</code> returns rows that match the pattern exactly. The example is as follows:</p> <pre><code>nebula&gt; MATCH (m)-[]-&gt;(n) WHERE id(m)==\"player100\" \\\n        MATCH (n)-[]-&gt;(l) \\\n        RETURN id(m),id(n),id(l);\n+-------------+-------------+-------------+\n| id(m)       | id(n)       | id(l)       |\n+-------------+-------------+-------------+\n| \"player100\" | \"player101\" | \"team204\"   |\n| \"player100\" | \"player101\" | \"team215\"   |\n| \"player100\" | \"player101\" | \"player100\" |\n| \"player100\" | \"player101\" | \"player102\" |\n| \"player100\" | \"player101\" | \"player125\" |\n| \"player100\" | \"player125\" | \"team204\"   |\n| \"player100\" | \"player125\" | \"player100\" |\n+-------------+-------------+-------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/1.show-charset/","title":"SHOW CHARSET","text":"<p>The <code>SHOW CHARSET</code> statement shows the available character sets.</p> <p>Currently available types are <code>utf8</code> and <code>utf8mb4</code>. The default charset type is <code>utf8</code>. NebulaGraph extends the <code>uft8</code> to support four-byte characters. Therefore <code>utf8</code> and <code>utf8mb4</code> are equivalent.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/1.show-charset/#syntax","title":"Syntax","text":"<pre><code>SHOW CHARSET;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/1.show-charset/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW CHARSET;\n+---------+-----------------+-------------------+--------+\n| Charset | Description     | Default collation | Maxlen |\n+---------+-----------------+-------------------+--------+\n| \"utf8\"  | \"UTF-8 Unicode\" | \"utf8_bin\"        | 4      |\n+---------+-----------------+-------------------+--------+\n</code></pre> Parameter Description <code>Charset</code> The name of the character set. <code>Description</code> The description of the character set. <code>Default collation</code> The default collation of the character set. <code>Maxlen</code> The maximum number of bytes required to store one character."},{"location":"3.ngql-guide/7.general-query-statements/6.show/10.show-roles/","title":"SHOW ROLES","text":"<p>The <code>SHOW ROLES</code> statement shows the roles that are assigned to a user account.</p> <p>The return message differs according to the role of the user who is running this statement:</p> <ul> <li>If the user is a <code>GOD</code> or <code>ADMIN</code> and is granted access to the specified graph space, NebulaGraph shows all roles in this graph space except for <code>GOD</code>.</li> </ul> <ul> <li>If the user is a <code>DBA</code>, <code>USER</code>, or <code>GUEST</code> and is granted access to the specified graph space, NebulaGraph shows the user's own role in this graph space.</li> </ul> <ul> <li>If the user does not have access to the specified graph space, NebulaGraph returns <code>PermissionError</code>.</li> </ul> <p>For more information about roles, see Roles and privileges.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/10.show-roles/#syntax","title":"Syntax","text":"<pre><code>SHOW ROLES IN &lt;space_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/10.show-roles/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW ROLES in basketballplayer;\n+---------+-----------+\n| Account | Role Type |\n+---------+-----------+\n| \"user1\" | \"ADMIN\"   |\n+---------+-----------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/11.show-snapshots/","title":"SHOW SNAPSHOTS","text":"<p>The <code>SHOW SNAPSHOTS</code> statement shows the information of all the snapshots.</p> <p>For how to create a snapshot and backup data, see Snapshot.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/11.show-snapshots/#role_requirement","title":"Role requirement","text":"<p>Only the <code>root</code> user who has the <code>GOD</code> role can use the <code>SHOW SNAPSHOTS</code> statement.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/11.show-snapshots/#syntax","title":"Syntax","text":"<pre><code>SHOW SNAPSHOTS;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/11.show-snapshots/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW SNAPSHOTS;\n+--------------------------------+---------+-----------------------------------------------------+\n| Name                           | Status  | Hosts                                               |\n+--------------------------------+---------+-----------------------------------------------------+\n| \"SNAPSHOT_2020_12_16_11_13_55\" | \"VALID\" | \"storaged0:9779, storaged1:9779, storaged2:9779\"    |\n| \"SNAPSHOT_2020_12_16_11_14_10\" | \"VALID\" | \"storaged0:9779, storaged1:9779, storaged2:9779\"    |\n+--------------------------------+---------+-----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/12.show-spaces/","title":"SHOW SPACES","text":"<p>The <code>SHOW SPACES</code> statement shows existing graph spaces in NebulaGraph.</p> <p>For how to create a graph space, see CREATE SPACE.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/12.show-spaces/#syntax","title":"Syntax","text":"<pre><code>SHOW SPACES;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/12.show-spaces/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW SPACES;\n+---------------------+\n| Name                |\n+---------------------+\n| \"docs\"              |\n| \"basketballplayer\"  |\n+---------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/","title":"SHOW STATS","text":"<p>The <code>SHOW STATS</code> statement shows the statistics of the graph space collected by the latest <code>SUBMIT JOB STATS</code> job.</p> <p>The statistics include the following information:</p> <ul> <li>The number of vertices in the graph space</li> <li>The number of edges in the graph space</li> <li>The number of vertices of each tag</li> <li>The number of edges of each edge type</li> </ul> <p>Warning</p> <p>The data returned by <code>SHOW STATS</code> is not real-time. The returned data is collected by the latest SUBMIT JOB STATS job and may include TTL-expired data. The expired data will be deleted and not included in the statistics the next time the Compaction operation  is performed.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/#prerequisites","title":"Prerequisites","text":"<p>You have to run the <code>SUBMIT JOB STATS</code> statement in the graph space where you want to collect statistics. For more information, see SUBMIT JOB STATS.</p> <p>Caution</p> <p>The result of the <code>SHOW STATS</code> statement is based on the last executed <code>SUBMIT JOB STATS</code> statement. If you want to update the result, run <code>SUBMIT JOB STATS</code> again. Otherwise the statistics will be wrong.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/#syntax","title":"Syntax","text":"<pre><code>SHOW STATS;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/14.show-stats/#examples","title":"Examples","text":"<pre><code># Choose a graph space.\nnebula&gt; USE basketballplayer;\n\n# Start SUBMIT JOB STATS.\nnebula&gt; SUBMIT JOB STATS;\n+------------+\n| New Job Id |\n+------------+\n| 98         |\n+------------+\n\n# Make sure the job executes successfully.\nnebula&gt; SHOW JOB 98;\n+----------------+---------------+------------+----------------------------+----------------------------+-------------+\n| Job Id(TaskId) | Command(Dest) | Status     | Start Time                 | Stop Time                  | Error Code  |\n+----------------+---------------+------------+----------------------------+----------------------------+-------------+\n| 98             | \"STATS\"       | \"FINISHED\" | 2021-11-01T09:33:21.000000 | 2021-11-01T09:33:21.000000 | \"SUCCEEDED\" |\n| 0              | \"storaged2\"   | \"FINISHED\" | 2021-11-01T09:33:21.000000 | 2021-11-01T09:33:21.000000 | \"SUCCEEDED\" |\n| 1              | \"storaged0\"   | \"FINISHED\" | 2021-11-01T09:33:21.000000 | 2021-11-01T09:33:21.000000 | \"SUCCEEDED\" |\n| 2              | \"storaged1\"   | \"FINISHED\" | 2021-11-01T09:33:21.000000 | 2021-11-01T09:33:21.000000 | \"SUCCEEDED\" |\n| \"Total:3\"      | \"Succeeded:3\" | \"Failed:0\" | \"In Progress:0\"            | \"\"                         | \"\"          |\n+----------------+---------------+------------+----------------------------+----------------------------+-------------+\n\n# Show the statistics of the graph space.\nnebula&gt; SHOW STATS;\n+---------+------------+-------+\n| Type    | Name       | Count |\n+---------+------------+-------+\n| \"Tag\"   | \"player\"   | 51    |\n| \"Tag\"   | \"team\"     | 30    |\n| \"Edge\"  | \"follow\"   | 81    |\n| \"Edge\"  | \"serve\"    | 152   |\n| \"Space\" | \"vertices\" | 81    |\n| \"Space\" | \"edges\"    | 233   |\n+---------+------------+-------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/15.show-tags-edges/","title":"SHOW TAGS/EDGES","text":"<p>The <code>SHOW TAGS</code> statement shows all the tags in the current graph space.</p> <p>The <code>SHOW EDGES</code> statement shows all the edge types in the current graph space.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/15.show-tags-edges/#syntax","title":"Syntax","text":"<pre><code>SHOW {TAGS | EDGES};\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/15.show-tags-edges/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW TAGS;\n+----------+\n| Name     |\n+----------+\n| \"player\" |\n| \"star\"   |\n| \"team\"   |\n+----------+\n\nnebula&gt; SHOW EDGES;\n+----------+\n| Name     |\n+----------+\n| \"follow\" |\n| \"serve\"  |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/16.show-users/","title":"SHOW USERS","text":"<p>The <code>SHOW USERS</code> statement shows the user information.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/16.show-users/#role_requirement","title":"Role requirement","text":"<p>Only the <code>root</code> user who has the <code>GOD</code> role can use the <code>SHOW USERS</code> statement.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/16.show-users/#syntax","title":"Syntax","text":"<pre><code>SHOW USERS;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/16.show-users/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW USERS;\n+---------+-----------------+\n| Account | IP Whitelist    |\n+---------+-----------------+\n| \"root\"  | \"\"              |\n| \"user1\" | \"\"              |\n| \"user2\" | \"192.168.10.10\" |\n+---------+-----------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/17.show-sessions/","title":"SHOW SESSIONS","text":"<p>When a user logs in to the database, a corresponding session will be created and users can query for session information.</p> <p>The <code>SHOW SESSIONS</code> statement shows the information of all the sessions. It can also show a specified session with its ID.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/17.show-sessions/#precautions","title":"Precautions","text":"<ul> <li>The client will call the API <code>release</code> to release the session and clear the session information when you run <code>exit</code> after the operation ends. If you exit the database in an unexpected way and the session timeout duration is not set via <code>session_idle_timeout_secs</code> in nebula-graphd.conf, the session will not be released automatically. For those sessions that are not automatically released, you need to delete them manually. For details, see KILL SESSIONS.</li> </ul> <ul> <li><code>SHOW SESSIONS</code> queries the session information of all the Graph services.</li> </ul> <ul> <li><code>SHOW LOCAL SESSIONS</code> queries the session information of the currently connected Graph service and does not query the session information of other Graph services.</li> </ul> <ul> <li><code>SHOW SESSION &lt;Session_Id&gt;</code> queries the session information with a specific session id.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/17.show-sessions/#syntax","title":"Syntax","text":"<pre><code>SHOW [LOCAL] SESSIONS;\nSHOW SESSION &lt;Session_Id&gt;;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/17.show-sessions/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW SESSIONS;\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n| SessionId        | UserName | SpaceName          | CreateTime                 | UpdateTime                 | GraphAddr        | Timezone | ClientIp           |\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n| 1651220858102296 | \"root\"   | \"basketballplayer\" | 2022-04-29T08:27:38.102296 | 2022-04-29T08:50:46.282921 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n| 1651199330300991 | \"root\"   | \"basketballplayer\" | 2022-04-29T02:28:50.300991 | 2022-04-29T08:16:28.339038 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n| 1651112899847744 | \"root\"   | \"basketballplayer\" | 2022-04-28T02:28:19.847744 | 2022-04-28T08:17:44.470210 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n| 1651041092662100 | \"root\"   | \"basketballplayer\" | 2022-04-27T06:31:32.662100 | 2022-04-27T07:01:25.200978 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n| 1650959429593975 | \"root\"   | \"basketballplayer\" | 2022-04-26T07:50:29.593975 | 2022-04-26T07:51:47.184810 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n| 1650958897679595 | \"root\"   | \"\"                 | 2022-04-26T07:41:37.679595 | 2022-04-26T07:41:37.683802 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n\nnebula&gt; SHOW SESSION 1635254859271703;\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n| SessionId        | UserName | SpaceName          | CreateTime                 | UpdateTime                 | GraphAddr        | Timezone | ClientIp           |\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n| 1651220858102296 | \"root\"   | \"basketballplayer\" | 2022-04-29T08:27:38.102296 | 2022-04-29T08:50:54.254384 | \"127.0.0.1:9669\" | 0        | \"127.0.0.1\" |\n+------------------+----------+--------------------+----------------------------+----------------------------+------------------+----------+--------------------+\n</code></pre> Parameter Description <code>SessionId</code> The session ID, namely the identifier of a session. <code>UserName</code> The username in a session. <code>SpaceName</code> The name of the graph space that the user uses currently. It is null (<code>\"\"</code>) when you first log in because there is no specified graph space. <code>CreateTime</code> The time when the session is created, namely the time when the user logs in. The time zone is specified by <code>timezone_name</code> in the configuration file. <code>UpdateTime</code> The system will update the time when there is an operation. The time zone is specified by <code>timezone_name</code> in the configuration file. <code>GraphAddr</code> The IP (or hostname) and port of the Graph server that hosts the session. <code>Timezone</code> A reserved parameter that has no specified meaning for now. <code>ClientIp</code> The IP or hostname of the client."},{"location":"3.ngql-guide/7.general-query-statements/6.show/18.show-queries/","title":"SHOW QUERIES","text":"<p>The <code>SHOW QUERIES</code> statement shows the information of working queries in the current session.</p> <p>Note</p> <p>To terminate queries, see Kill Query.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/18.show-queries/#precautions","title":"Precautions","text":"<ul> <li>The <code>SHOW LOCAL QUERIES</code> statement gets the status of queries in the current session from the local cache with almost no latency.</li> </ul> <ul> <li>The <code>SHOW QUERIES</code> statement gets the information of queries in all the sessions from the Meta Service. The information will be synchronized to the Meta Service according to the interval defined by <code>session_reclaim_interval_secs</code>. Therefore the information that you get from the client may belong to the last synchronization interval.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/18.show-queries/#syntax","title":"Syntax","text":"<pre><code>SHOW [LOCAL] QUERIES;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/18.show-queries/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW LOCAL QUERIES;\n+------------------+-----------------+--------+----------------------+----------------------------+----------------+-----------+-----------------------+\n| SessionID        | ExecutionPlanID | User   | Host                 | StartTime                  | DurationInUSec | Status    | Query                 |\n+------------------+-----------------+--------+----------------------+----------------------------+----------------+-----------+-----------------------+\n| 1625463842921750 | 46              | \"root\" | \"\"192.168.x.x\":9669\" | 2021-07-05T05:44:19.502903 | 0              | \"RUNNING\" | \"SHOW LOCAL QUERIES;\" |\n+------------------+-----------------+--------+----------------------+----------------------------+----------------+-----------+-----------------------+\n\nnebula&gt; SHOW QUERIES;\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+---------------------------------------------------------+\n| SessionID        | ExecutionPlanID | User    | Host                 | StartTime                  | DurationInUSec | Status    | Query                                                   |\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+---------------------------------------------------------+\n| 1625456037718757 | 54              | \"user1\" | \"\"192.168.x.x\":9669\" | 2021-07-05T05:51:08.691318 | 1504502        | \"RUNNING\" | \"MATCH p=(v:player)-[*1..4]-(v2) RETURN v2 AS Friends;\" |\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+---------------------------------------------------------+\n\n# The following statement returns the top 10 queries that have the longest duration.\nnebula&gt; SHOW QUERIES | ORDER BY $-.DurationInUSec DESC | LIMIT 10;\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+-------------------------------------------------------+\n| SessionID        | ExecutionPlanID | User    | Host                 | StartTime                  | DurationInUSec | Status    | Query                                                 |\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+-------------------------------------------------------+\n| 1625471375320831 | 98              | \"user2\" | \"\"192.168.x.x\":9669\" | 2021-07-05T07:50:24.461779 | 2608176        | \"RUNNING\" | \"MATCH (v:player)-[*1..4]-(v2) RETURN v2 AS Friends;\" |\n| 1625456037718757 | 99              | \"user1\" | \"\"192.168.x.x\":9669\" | 2021-07-05T07:50:24.910616 | 2159333        | \"RUNNING\" | \"MATCH (v:player)-[*1..4]-(v2) RETURN v2 AS Friends;\" |\n+------------------+-----------------+---------+----------------------+----------------------------+----------------+-----------+-------------------------------------------------------+\n</code></pre> <p>The descriptions are as follows.</p> Parameter Description <code>SessionID</code> The session ID. <code>ExecutionPlanID</code> The ID of the execution plan. <code>User</code> The username that executes the query. <code>Host</code> The IP address and port of the Graph server that hosts the session. <code>StartTime</code> The time when the query starts. <code>DurationInUSec</code> The duration of the query. The unit is microsecond. <code>Status</code> The current status of the query. <code>Query</code> The query statement."},{"location":"3.ngql-guide/7.general-query-statements/6.show/19.show-meta-leader/","title":"SHOW META LEADER","text":"<p>The <code>SHOW META LEADER</code> statement shows the information of the leader in the current Meta cluster.</p> <p>For more information about the Meta service, see Meta service.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/19.show-meta-leader/#syntax","title":"Syntax","text":"<pre><code>SHOW META LEADER;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/19.show-meta-leader/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW META LEADER;\n+------------------+---------------------------+\n| Meta Leader      | secs from last heart beat |\n+------------------+---------------------------+\n| \"127.0.0.1:9559\" | 3                         |\n+------------------+---------------------------+\n</code></pre> Parameter Description <code>Meta Leader</code> Shows the information of the leader in the Meta cluster, including the IP (or hostname) and port of the server where the leader is located. <code>secs from last heart beat</code> Indicates the time interval since the last heartbeat. This parameter is measured in seconds."},{"location":"3.ngql-guide/7.general-query-statements/6.show/2.show-collation/","title":"SHOW COLLATION","text":"<p>The <code>SHOW COLLATION</code> statement shows the collations supported by NebulaGraph.</p> <p>Currently available types are: <code>utf8_bin</code> and <code>utf8mb4_bin</code>.</p> <ul> <li>When the character set is <code>utf8</code>, the default collate is <code>utf8_bin</code>.</li> </ul> <ul> <li>When the character set is <code>utf8mb4</code>, the default collate is <code>utf8mb4_bin</code>.</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/2.show-collation/#syntax","title":"Syntax","text":"<pre><code>SHOW COLLATION;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/2.show-collation/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW COLLATION;\n+------------+---------+\n| Collation  | Charset |\n+------------+---------+\n| \"utf8_bin\" | \"utf8\"  |\n+------------+---------+\n</code></pre> Parameter Description <code>Collation</code> The name of the collation. <code>Charset</code> The name of the character set with which the collation is associated."},{"location":"3.ngql-guide/7.general-query-statements/6.show/4.show-create-space/","title":"SHOW CREATE SPACE","text":"<p>The <code>SHOW CREATE SPACE</code> statement shows the creating statement of the specified graph space.</p> <p>For details about the graph space information, see CREATE SPACE.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/4.show-create-space/#syntax","title":"Syntax","text":"<pre><code>SHOW CREATE SPACE &lt;space_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/4.show-create-space/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW CREATE SPACE basketballplayer;\n+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------+\n| Space              | Create Space                                                                                                                                |\n+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------+\n| \"basketballplayer\" | \"CREATE SPACE `basketballplayer` (partition_num = 10, replica_factor = 1, charset = utf8, collate = utf8_bin, vid_type = FIXED_STRING(32))\" |\n+--------------------+---------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/5.show-create-tag-edge/","title":"SHOW CREATE TAG/EDGE","text":"<p>The <code>SHOW CREATE TAG</code> statement shows the basic information of the specified tag. For details about the tag, see CREATE TAG.</p> <p>The <code>SHOW CREATE EDGE</code> statement shows the basic information of the specified edge type. For details about the edge type, see CREATE EDGE.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/5.show-create-tag-edge/#syntax","title":"Syntax","text":"<pre><code>SHOW CREATE {TAG &lt;tag_name&gt; | EDGE &lt;edge_name&gt;};\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/5.show-create-tag-edge/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW CREATE TAG player;\n+----------+-----------------------------------+\n| Tag      | Create Tag                        |\n+----------+-----------------------------------+\n| \"player\" | \"CREATE TAG `player` (            |\n|          |  `name` string NULL,              |\n|          |  `age` int64 NULL                 |\n|          | ) ttl_duration = 0, ttl_col = \"\"\" |\n+----------+-----------------------------------+\n\nnebula&gt; SHOW CREATE EDGE follow;\n+----------+-----------------------------------+\n| Edge     | Create Edge                       |\n+----------+-----------------------------------+\n| \"follow\" | \"CREATE EDGE `follow` (           |\n|          |  `degree` int64 NULL              |\n|          | ) ttl_duration = 0, ttl_col = \"\"\" |\n+----------+-----------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/6.show-hosts/","title":"SHOW HOSTS","text":"<p>The <code>SHOW HOSTS</code> statement shows the cluster information, including the port, status, leader, partition, and version information. You can also add the service type in the statement to view the information of the specific service.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/6.show-hosts/#syntax","title":"Syntax","text":"<pre><code>SHOW HOSTS [GRAPH | STORAGE | META];\n</code></pre> <p>Note</p> <p>For a NebulaGraph cluster installed with the source code, the version of the cluster will not be displayed in the output after executing the command <code>SHOW HOSTS (GRAPH | STORAGE | META)</code> with the service name.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/6.show-hosts/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW HOSTS;\n+-------------+-------+----------+--------------+----------------------------------+------------------------------+---------+\n| Host        | Port  | Status   | Leader count | Leader distribution              | Partition distribution       | Version |\n+-------------+-------+----------+--------------+----------------------------------+------------------------------+---------+\n| \"storaged0\" | 9779  | \"ONLINE\" | 8            | \"docs:5, basketballplayer:3\"     | \"docs:5, basketballplayer:3\" | \"3.8.0\" |\n| \"storaged1\" | 9779  | \"ONLINE\" | 9            | \"basketballplayer:4, docs:5\"     | \"docs:5, basketballplayer:4\" | \"3.8.0\" |\n| \"storaged2\" | 9779  | \"ONLINE\" | 8            | \"basketballplayer:3, docs:5\"     | \"docs:5, basketballplayer:3\" | \"3.8.0\" |\n+-------------+-------+----------+--------------+----------------------------------+------------------------------+---------+\n\nnebula&gt; SHOW HOSTS GRAPH;\n+-----------+------+----------+---------+--------------+---------+\n| Host      | Port | Status   | Role    | Git Info Sha | Version |\n+-----------+------+----------+---------+--------------+---------+\n| \"graphd\"  | 9669 | \"ONLINE\" | \"GRAPH\" | \"3ba41bd\"    | \"3.8.0\" |\n| \"graphd1\" | 9669 | \"ONLINE\" | \"GRAPH\" | \"3ba41bd\"    | \"3.8.0\" |\n| \"graphd2\" | 9669 | \"ONLINE\" | \"GRAPH\" | \"3ba41bd\"    | \"3.8.0\" |\n+-----------+------+----------+---------+--------------+---------+\n\nnebula&gt; SHOW HOSTS STORAGE;\n+-------------+------+----------+-----------+--------------+---------+\n| Host        | Port | Status   | Role      | Git Info Sha | Version |\n+-------------+------+----------+-----------+--------------+---------+\n| \"storaged0\" | 9779 | \"ONLINE\" | \"STORAGE\" | \"3ba41bd\"    | \"3.8.0\" |\n| \"storaged1\" | 9779 | \"ONLINE\" | \"STORAGE\" | \"3ba41bd\"    | \"3.8.0\" |\n| \"storaged2\" | 9779 | \"ONLINE\" | \"STORAGE\" | \"3ba41bd\"    | \"3.8.0\" |\n+-------------+------+----------+-----------+--------------+---------+\n\nnebula&gt; SHOW HOSTS META;\n+----------+------+----------+--------+--------------+---------+\n| Host     | Port | Status   | Role   | Git Info Sha | Version |\n+----------+------+----------+--------+--------------+---------+\n| \"metad2\" | 9559 | \"ONLINE\" | \"META\" | \"3ba41bd\"    | \"3.8.0\" |\n| \"metad0\" | 9559 | \"ONLINE\" | \"META\" | \"3ba41bd\"    | \"3.8.0\" |\n| \"metad1\" | 9559 | \"ONLINE\" | \"META\" | \"3ba41bd\"    | \"3.8.0\" |\n+----------+------+----------+--------+--------------+---------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/7.show-index-status/","title":"SHOW INDEX STATUS","text":"<p>The <code>SHOW INDEX STATUS</code> statement shows the status of jobs that rebuild native indexes, which helps check whether a native index is successfully rebuilt or not.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/7.show-index-status/#syntax","title":"Syntax","text":"<pre><code>SHOW {TAG | EDGE} INDEX STATUS;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/7.show-index-status/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW TAG INDEX STATUS;\n+------------------------------------+--------------+\n| Name                               | Index Status |\n+------------------------------------+--------------+\n| \"date1_index\"                      | \"FINISHED\"   |\n| \"basketballplayer_all_tag_indexes\" | \"FINISHED\"   |\n| \"any_shape_geo_index\"              | \"FINISHED\"   |\n+------------------------------------+--------------+\n\nnebula&gt; SHOW EDGE INDEX STATUS;\n+----------------+--------------+\n| Name           | Index Status |\n+----------------+--------------+\n| \"follow_index\" | \"FINISHED\"   |\n+----------------+--------------+\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/7.show-index-status/#related_topics","title":"Related topics","text":"<ul> <li>Job manager and the JOB statements</li> <li>REBUILD NATIVE INDEX</li> </ul>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/8.show-indexes/","title":"SHOW INDEXES","text":"<p>The <code>SHOW INDEXES</code> statement shows the names of existing native indexes.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/8.show-indexes/#syntax","title":"Syntax","text":"<pre><code>SHOW {TAG | EDGE} INDEXES;\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/8.show-indexes/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW TAG INDEXES;\n+------------------+----------+----------+\n| Index Name       | By Tag   | Columns  |\n+------------------+----------+----------+\n| \"player_index_0\" | \"player\" | []       |\n| \"player_index_1\" | \"player\" | [\"name\"] |\n+------------------+----------+----------+\n\nnebula&gt; SHOW EDGE INDEXES;\n+----------------+----------+---------+\n| Index Name     | By Edge  | Columns |\n+----------------+----------+---------+\n| \"follow_index\" | \"follow\" | []      |\n+----------------+----------+---------+\n</code></pre> <p>Legacy version compatibility</p> <p>In NebulaGraph 2.x, <code>SHOW TAG/EDGE INDEXES</code> only returns <code>Names</code>.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/9.show-parts/","title":"SHOW PARTS","text":"<p>The <code>SHOW PARTS</code> statement shows the information of a specified partition or all partitions in a graph space.</p>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/9.show-parts/#syntax","title":"Syntax","text":"<pre><code>SHOW PARTS [&lt;part_id&gt;];\n</code></pre>"},{"location":"3.ngql-guide/7.general-query-statements/6.show/9.show-parts/#examples","title":"Examples","text":"<pre><code>nebula&gt; SHOW PARTS;\n+--------------+--------------------+--------------------+-------+\n| Partition ID | Leader             | Peers              | Losts |\n+--------------+--------------------+--------------------+-------+\n| 1            | \"192.168.2.1:9779\" | \"192.168.2.1:9779\" | \"\"    |\n| 2            | \"192.168.2.2:9779\" | \"192.168.2.2:9779\" | \"\"    |\n| 3            | \"192.168.2.3:9779\" | \"192.168.2.3:9779\" | \"\"    |\n| 4            | \"192.168.2.1:9779\" | \"192.168.2.1:9779\" | \"\"    |\n| 5            | \"192.168.2.2:9779\" | \"192.168.2.2:9779\" | \"\"    |\n| 6            | \"192.168.2.3:9779\" | \"192.168.2.3:9779\" | \"\"    |\n| 7            | \"192.168.2.1:9779\" | \"192.168.2.1:9779\" | \"\"    |\n| 8            | \"192.168.2.2:9779\" | \"192.168.2.2:9779\" | \"\"    |\n| 9            | \"192.168.2.3:9779\" | \"192.168.2.3:9779\" | \"\"    |\n| 10           | \"192.168.2.1:9779\" | \"192.168.2.1:9779\" | \"\"    |\n+--------------+--------------------+--------------------+-------+\n\nnebula&gt; SHOW PARTS 1;\n+--------------+--------------------+--------------------+-------+\n| Partition ID | Leader             | Peers              | Losts |\n+--------------+--------------------+--------------------+-------+\n| 1            | \"192.168.2.1:9779\" | \"192.168.2.1:9779\" | \"\"    |\n+--------------+--------------------+--------------------+-------+\n</code></pre> <p>The descriptions are as follows.</p> Parameter Description <code>Partition ID</code> The ID of the partition. <code>Leader</code> The IP (or hostname) and the port of the leader. <code>Peers</code> The IPs (or hostnames) and the ports of all the replicas. <code>Losts</code> The IPs (or hostnames) and the ports of replicas at fault."},{"location":"3.ngql-guide/8.clauses-and-options/group-by/","title":"GROUP BY","text":"<p>The <code>GROUP BY</code> clause can be used to aggregate data.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/group-by/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>This topic applies to native nGQL only.</p> <p>You can also use the count() function to aggregate data.</p> <pre><code>nebula&gt;  MATCH (v:player)&lt;-[:follow]-(:player) RETURN v.player.name AS Name, count(*) as cnt ORDER BY cnt DESC;\n+----------------------+-----+\n| Name                 | cnt |\n+----------------------+-----+\n| \"Tim Duncan\"         | 10  |\n| \"LeBron James\"       | 6   |\n| \"Tony Parker\"        | 5   |\n| \"Chris Paul\"         | 4   |\n| \"Manu Ginobili\"      | 4   |\n+----------------------+-----+\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/group-by/#syntax","title":"Syntax","text":"<p>The <code>GROUP BY</code> clause groups the rows with the same value. Then operations such as counting, sorting, and calculation can be applied.</p> <p>The <code>GROUP BY</code> clause works after the pipe symbol (|) and before a <code>YIELD</code> clause.</p> <pre><code>| GROUP BY &lt;var&gt; YIELD &lt;var&gt;, &lt;aggregation_function(var)&gt;\n</code></pre> <p>The <code>aggregation_function()</code> function supports <code>avg()</code>, <code>sum()</code>, <code>max()</code>, <code>min()</code>, <code>count()</code>, <code>collect()</code>, and <code>std()</code>.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/group-by/#examples","title":"Examples","text":"<p>The following statement finds all the vertices connected directly to vertex <code>\"player100\"</code>, groups the result set by player names, and counts how many times the name shows up in the result set.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow BIDIRECT \\\n        YIELD properties($$).name as Name \\\n        | GROUP BY $-.Name \\\n        YIELD $-.Name as Player, count(*) AS Name_Count;\n+---------------------+------------+\n| Player              | Name_Count |\n+---------------------+------------+\n| \"Shaquille O'Neal\"  | 1          |\n| \"Tiago Splitter\"    | 1          |\n| \"Manu Ginobili\"     | 2          |\n| \"Boris Diaw\"        | 1          |\n| \"LaMarcus Aldridge\" | 1          |\n| \"Tony Parker\"       | 2          |\n| \"Marco Belinelli\"   | 1          |\n| \"Dejounte Murray\"   | 1          |\n| \"Danny Green\"       | 1          |\n| \"Aron Baynes\"       | 1          |\n+---------------------+------------+\n</code></pre> <p>The following statement finds all the vertices connected directly to vertex <code>\"player100\"</code>, groups the result set by source vertices, and returns the sum of degree values.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD src(edge) AS player, properties(edge).degree AS degree \\\n        | GROUP BY $-.player \\\n        YIELD sum($-.degree);\n+----------------+\n| sum($-.degree) |\n+----------------+\n| 190            |\n+----------------+\n</code></pre> <p>For more information about the <code>sum()</code> function, see Built-in math functions.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/group-by/#implicit_group_by","title":"Implicit GROUP BY","text":"<p>The usage of <code>GROUP BY</code> in the above nGQL statements that explicitly write <code>GROUP BY</code> and act as grouping fields is called explicit <code>GROUP BY</code>, while in openCypher, the <code>GROUP BY</code> is implicit, i.e., <code>GROUP BY</code> groups fields without explicitly writing <code>GROUP BY</code>. The explicit <code>GROUP BY</code> in nGQL is the same as the implicit <code>GROUP BY</code> in openCypher, and nGQL also supports the implicit <code>GROUP BY</code>. For the implicit usage of <code>GROUP BY</code>, see Stack Overflow.</p> <p>For example, to look up the players over 34 years old with the same length of service, you can use the following statement:</p> <pre><code>nebula&gt; LOOKUP ON player WHERE player.age &gt; 34 YIELD id(vertex) AS v | \\\n        GO FROM $-.v OVER serve YIELD serve.start_year AS start_year, serve.end_year AS end_year | \\\n        YIELD $-.start_year, $-.end_year, count(*) AS count | \\\n        ORDER BY $-.count DESC | LIMIT 5;\n+---------------+-------------+-------+\n| $-.start_year | $-.end_year | count |\n+---------------+-------------+-------+\n| 2018          | 2019        | 3     |\n| 2007          | 2012        | 2     |\n| 1998          | 2004        | 2     |\n| 2017          | 2018        | 2     |\n| 2010          | 2011        | 2     |\n+---------------+-------------+-------+ \n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/","title":"INNER JOIN","text":"<p><code>INNER JOIN</code> is a type of join query that matches records based on common column values between two tables. It is commonly used to create a result set that includes two tables based on values in their associated columns. In NebulaGraph, the <code>INNER JOIN</code> clause can be explicitly used to conduct join queries between two tables, leading to more complex query results.</p> <p>Note</p> <p>In nGQL statements, the multi-hop query of <code>GO</code> implicitly utilizes the <code>INNER JOIN</code> clause. For example, in the statement <code>GO 1 TO 2 STEPS FROM \"player101\" OVER follow YIELD $$.player.name AS name, $$.player.age AS age</code>, the <code>GO</code> clause implicitly utilizes the <code>INNER JOIN</code> clause, matching the result columns of the first-hop query starting from <code>player101</code> along the <code>follow</code> edge with the starting columns of the second-hop query. Then, based on the matching results, it returns <code>name</code> and <code>age</code>. </p>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#opencypher_compatibility","title":"openCypher compatibility","text":"<p>The <code>INNER JOIN</code> clause is only applicable to the native nGQL syntax.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#syntax","title":"Syntax","text":"<pre><code>YIELD &lt;column_name_list&gt;\nFROM &lt;first_table&gt; INNER JOIN &lt;second_table&gt; ON &lt;join_condition&gt;\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#notes","title":"Notes","text":"<p>To conduct an <code>INNER JOIN</code> query, you need to follow these rules:</p> <ul> <li>Use the <code>YIELD</code> clause to specify the returned columns, and place it before the <code>INNER JOIN</code> clause.</li> <li>Use the <code>FROM</code> clause to specify the two tables to be joined.</li> <li>The <code>INNER JOIN</code> clause must contain the <code>ON</code> clause, which specifies the join condition. The join condition only supports equi-join (i.e., <code>==</code>).</li> <li><code>&lt;first_table&gt;</code> and <code>&lt;second_table&gt;</code> are the two tables to be joined, and the two table names cannot be the same.</li> <li>Use user-defined variables to specify the table names. For more information, see User-defined variables.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#examples","title":"Examples","text":"<p>The following examples show how to use the <code>INNER JOIN</code> clause to join the results of two queries in nGQL statements.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#example_1","title":"Example 1","text":"<p>Firstly, the <code>dst</code> column obtained from the initial <code>LOOK UP</code> operation (whose value for Tony Parker has an ID of <code>player101</code>) is connected with the <code>src</code> column obtained from the second <code>GO</code> query (which has IDs <code>player101</code> and <code>player125</code>). By matching the two columns where <code>player101</code> appears on both sides, we obtain the resulting data set. The final request then uses a <code>YIELD</code> statement <code>YIELD $b.vid AS vid, $a.v AS v, $b.e2 AS e2</code> to display the information.</p> <pre><code>nebula&gt; $a = LOOKUP ON player WHERE player.name == 'Tony Parker' YIELD id(vertex) as dst, vertex AS v; \\\n        $b = GO FROM 'player101', 'player125' OVER follow YIELD id($^) as src, id($$) as vid, edge AS e2; \\\n        YIELD $b.vid AS vid, $a.v AS v, $b.e2 AS e2 FROM $a INNER JOIN $b ON $a.dst == $b.src;\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n| vid         | v                                                   | e2                                                 |\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n| \"player100\" | (\"player101\" :player{age: 36, name: \"Tony Parker\"}) | [:follow \"player101\"-&gt;\"player100\" @0 {degree: 95}] |\n| \"player102\" | (\"player101\" :player{age: 36, name: \"Tony Parker\"}) | [:follow \"player101\"-&gt;\"player102\" @0 {degree: 90}] |\n| \"player125\" | (\"player101\" :player{age: 36, name: \"Tony Parker\"}) | [:follow \"player101\"-&gt;\"player125\" @0 {degree: 95}] |\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#example_2","title":"Example 2","text":"<p>The following nGQL example utilizes the <code>INNER JOIN</code> clause to combine the <code>src</code> column from the first <code>LOOKUP</code> query (with <code>player101</code> as ID for <code>Tony Parker</code>) and the <code>src</code> column from the second <code>FETCH</code> query (with <code>player101</code> being the starting point to <code>player100</code>). By matching <code>player101</code> in both source columns, we obtain the resulting data set. The final request then utilizes a <code>YIELD</code> clause <code>YIELD $a.src AS src, $a.v AS v, $b.e AS e</code> to display the information.</p> <pre><code>nebula&gt; $a = LOOKUP ON player WHERE player.name == 'Tony Parker' YIELD id(vertex) as src, vertex AS v; \\\n        $b = FETCH PROP ON follow 'player101'-&gt;'player100' YIELD src(edge) as src, edge as e; \\\n        YIELD $a.src AS src, $a.v AS v, $b.e AS e FROM $a INNER JOIN $b ON $a.src == $b.src;\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n| src         | v                                                   | e                                                  |\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n| \"player101\" | (\"player101\" :player{age: 36, name: \"Tony Parker\"}) | [:follow \"player101\"-&gt;\"player100\" @0 {degree: 95}] |\n+-------------+-----------------------------------------------------+----------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/joins/#example_3","title":"Example 3","text":"<p>The following example shows the process of using the <code>INNER JOIN</code> clause to join the results of the <code>LOOKUP</code>, <code>GO</code>, and <code>FIND PATH</code> clauses.</p> <ol> <li>Query the <code>player</code> table using the <code>LOOKUP ON</code> statement to find the vertex for player <code>Tony Parker</code>, storing the ID and properties in the <code>$a.src</code> and <code>$a.v</code> columns, respectively.</li> <li>Then use the <code>GO</code> statement to find player nodes that are reachable in 2-5 steps through the <code>follow</code> edges from the node <code>$a.src</code>. It also requires that the players corresponding to these nodes have an age greater than 30 years old. We store the IDs of these nodes in the <code>$b.dst</code> column.</li> <li>Use the <code>FIND ALL PATH</code> statement to find all the paths that traverse the <code>follow</code> edges from <code>$a.src</code> to <code>$b.dst</code>. We also return the paths themselves as <code>$c.p</code> and the destination of each path as <code>$c.dst</code>.</li> <li>Using the <code>FIND SHORTEST PATH</code> statement, find the shortest path from <code>$c.dst</code> back to <code>$a.src</code>, storing the path in <code>$d.p</code> and the starting point in <code>$d.src</code>.</li> <li>Finally, we utilize the <code>INNER JOIN</code> clause to join the results of steps 3 and 4 by matching the <code>$c.dst</code> column with the <code>$d.src</code> column. Then use the <code>YIELD</code> statement <code>YIELD $c.forward AS forwardPath, $c.dst AS end, $d.p AS backwardPath</code> to return the matched records of the join.</li> </ol> <pre><code>nebula&gt; $a = LOOKUP ON player WHERE player.name == 'Tony Parker' YIELD id(vertex) as src, vertex AS v; \\\n        $b = GO 2 TO 5 STEPS FROM $a.src OVER follow WHERE $$.player.age &gt; 30 YIELD id($$) AS dst; \\\n        $c = (FIND ALL PATH FROM $a.src TO $b.dst OVER follow YIELD path AS p | YIELD $-.p AS forward, id(endNode($-.p)) AS dst); \\\n        $d = (FIND SHORTEST PATH FROM $c.dst TO $a.src OVER follow YIELD path AS p | YIELD $-.p AS p, id(startNode($-.p)) AS src); \\\n        YIELD $c.forward AS forwardPath, $c.dst AS end, $d.p AS backwordPath FROM $c INNER JOIN $d ON $c.dst == $d.src;\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+-----------------------------------------------------------------------------+\n| forwardPath                                                                                                                                                           | end         | backwordPath                                                                |\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+-----------------------------------------------------------------------------+\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player102\")&gt;                                                                                                                         | \"player102\" | &lt;(\"player102\")-[:follow@0 {}]-&gt;(\"player101\")&gt;                               |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:follow@0 {}]-&gt;(\"player102\")&gt;                                                             | \"player102\" | &lt;(\"player102\")-[:follow@0 {}]-&gt;(\"player101\")&gt;                               |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player125\")&gt;                                                                                                                         | \"player125\" | &lt;(\"player125\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")&gt; |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player125\")&gt;                                                                                           | \"player125\" | &lt;(\"player125\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")&gt; |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")-[:follow@0 {}]-&gt;(\"player125\")&gt;                                                             | \"player125\" | &lt;(\"player125\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")&gt; |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player102\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player125\")&gt;                                                             | \"player125\" | &lt;(\"player125\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")&gt; |\n| &lt;(\"player101\")-[:follow@0 {}]-&gt;(\"player102\")-[:follow@0 {}]-&gt;(\"player101\")-[:follow@0 {}]-&gt;(\"player125\")&gt;                                                             | \"player125\" | &lt;(\"player125\")-[:follow@0 {}]-&gt;(\"player100\")-[:follow@0 {}]-&gt;(\"player101\")&gt; |\n...\n+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+-----------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/","title":"LIMIT AND SKIP","text":"<p>The <code>LIMIT</code> clause constrains the number of rows in the output. The usage of <code>LIMIT</code> in native nGQL statements and openCypher compatible statements is different.</p> <ul> <li>Native nGQL: Generally, a pipe <code>|</code> needs to be used before the <code>LIMIT</code> clause. The offset parameter can be set or omitted directly after the <code>LIMIT</code> statement.</li> </ul> <ul> <li>OpenCypher compatible statements: No pipes are permitted before the <code>LIMIT</code> clause. And you can use <code>SKIP</code> to indicate an offset.</li> </ul> <p>Note<p>When using <code>LIMIT</code> in either syntax above, it is important to use an <code>ORDER BY</code> clause that constrains the output into a unique order. Otherwise, you will get an unpredictable subset of the output.</p> </p>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#limit_in_native_ngql_statements","title":"LIMIT in native nGQL statements","text":"<p>In native nGQL, <code>LIMIT</code> has general syntax and exclusive syntax in <code>GO</code> statements.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#general_limit_syntax_in_native_ngql_statements","title":"General LIMIT syntax in native nGQL statements","text":"<p>In native nGQL,  the general <code>LIMIT</code> syntax works the same as in <code>SQL</code>. The <code>LIMIT</code> clause accepts one or two parameters. The values of both parameters must be non-negative integers and be used after a pipe. The syntax and description are as follows:</p> <pre><code>... | LIMIT [&lt;offset&gt;,] &lt;number_rows&gt;;\n</code></pre> Parameter Description <code>offset</code> The offset value. It defines the row from which to start returning. The offset starts from <code>0</code>. The default value is <code>0</code>, which returns from the first row. <code>number_rows</code> It constrains the total number of returned rows. <p>For example:</p> <pre><code># The following example returns the top 3 rows of data from the result.\nnebula&gt; LOOKUP ON player YIELD id(vertex)|\\\n        LIMIT 3;\n+-------------+\n| id(VERTEX)  |\n+-------------+\n| \"player100\" |\n| \"player101\" |\n| \"player102\" |\n+-------------+\n\n# The following example returns the 3 rows of data starting from the second row of the sorted output.\nnebula&gt; GO FROM \"player100\" OVER follow REVERSELY \\\n        YIELD properties($$).name AS Friend, properties($$).age AS Age \\\n        | ORDER BY $-.Age, $-.Friend \\\n        | LIMIT 1, 3;\n+-------------------+-----+\n| Friend            | Age |\n+-------------------+-----+\n| \"Danny Green\"     | 31  |\n| \"Aron Baynes\"     | 32  |\n| \"Marco Belinelli\" | 32  |\n+-------------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#limit_in_go_statements","title":"LIMIT in GO statements","text":"<p>In addition to the general syntax in the native nGQL, the <code>LIMIT</code> in the <code>GO</code> statement also supports limiting the number of output results based on edges.</p> <p>Syntax:</p> <pre><code>&lt;go_statement&gt; LIMIT &lt;limit_list&gt;;\n</code></pre> <p><code>limit_list</code> is a list. Elements in the list must be natural numbers, and the number of elements must be the same as the maximum number of <code>STEPS</code> in the <code>GO</code> statement. The following takes <code>GO 1 TO 3 STEPS FROM \"A\" OVER * LIMIT &lt;limit_list&gt;</code> as an example to introduce this usage of <code>LIMIT</code> in detail.</p> <ul> <li>The list <code>limit_list</code> must contain 3 natural numbers, such as <code>GO 1 TO 3 STEPS FROM \"A\" OVER * LIMIT [1,2,4]</code>.</li> <li><code>1</code> in <code>LIMIT [1,2,4]</code> means that the system automatically selects 1 edge to continue traversal in the first step. <code>2</code> means to select 2 edges to continue traversal in the second step. <code>4</code> indicates that 4 edges are selected to continue traversal in the third step.</li> <li>Because <code>GO 1 TO 3 STEPS</code> means to return all the traversal results from the first to third steps, all the red edges and their source and destination vertices in the figure below will be matched by this <code>GO</code> statement. And the yellow edges represent there is no path selected when the GO statement traverses. If it is not <code>GO 1 TO 3 STEPS</code> but <code>GO 3 STEPS</code>, it will only match the red edges of the third step and the vertices at both ends.</li> </ul> <p></p> <p>In the basketballplayer dataset, the example is as follows:</p> <pre><code>nebula&gt; GO 3 STEPS FROM \"player100\" \\\n        OVER * \\\n        YIELD properties($$).name AS NAME, properties($$).age AS Age \\\n        LIMIT [3,3,3];\n+-----------------+----------+\n| NAME            | Age      |\n+-----------------+----------+\n| \"Tony Parker\"   | 36       |\n| \"Manu Ginobili\" | 41       |\n| \"Spurs\"         | __NULL__ |\n+-----------------+----------+\n\nnebula&gt; GO 3 STEPS FROM \"player102\" OVER * BIDIRECT\\\n        YIELD dst(edge) \\\n        LIMIT [rand32(5),rand32(5),rand32(5)];\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player100\" |\n| \"player100\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#limit_in_opencypher_compatible_statements","title":"LIMIT in openCypher compatible statements","text":"<p>In openCypher compatible statements such as <code>MATCH</code>, there is no need to use a pipe when <code>LIMIT</code> is used. The syntax and description are as follows:</p> <pre><code>... [SKIP &lt;offset&gt;] [LIMIT &lt;number_rows&gt;];\n</code></pre> Parameter Description <code>offset</code> The offset value. It defines the row from which to start returning. The offset starts from <code>0</code>. The default value is <code>0</code>, which returns from the first row. <code>number_rows</code> It constrains the total number of returned rows. <p>Both <code>offset</code> and <code>number_rows</code> accept expressions, but the result of the expression must be a non-negative integer.</p> <p>Note</p> <p>Fraction expressions composed of two integers are automatically floored to integers. For example, <code>8/6</code> is floored to 1.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#examples_of_limit","title":"Examples of LIMIT","text":"<p><code>LIMIT</code> can be used alone to return a specified number of results.</p> <pre><code>nebula&gt; MATCH (v:player) RETURN v.player.name AS Name, v.player.age AS Age \\\n        ORDER BY Age LIMIT 5;\n+-------------------------+-----+\n| Name                    | Age |\n+-------------------------+-----+\n| \"Luka Doncic\"           | 20  |\n| \"Ben Simmons\"           | 22  |\n| \"Kristaps Porzingis\"    | 23  |\n| \"Giannis Antetokounmpo\" | 24  |\n| \"Kyle Anderson\"         | 25  |\n+-------------------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#examples_of_skip","title":"Examples of SKIP","text":"<p><code>SKIP</code> can be used alone to set the offset and return the data after the specified position.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age \\\n        ORDER BY Age DESC SKIP 1;\n+-----------------+-----+\n| Name            | Age |\n+-----------------+-----+\n| \"Manu Ginobili\" | 41  |\n| \"Tony Parker\"   | 36  |\n+-----------------+-----+\n\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age \\\n        ORDER BY Age DESC SKIP 1+1;\n+---------------+-----+\n| Name          | Age |\n+---------------+-----+\n| \"Tony Parker\" | 36  |\n+---------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/limit/#example_of_skip_and_limit","title":"Example of SKIP and LIMIT","text":"<p><code>SKIP</code> and <code>LIMIT</code> can be used together to return the specified amount of data starting from the specified position.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age \\\n        ORDER BY Age DESC SKIP 1 LIMIT 1;\n+-----------------+-----+\n| Name            | Age |\n+-----------------+-----+\n| \"Manu Ginobili\" | 41  |\n+-----------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/","title":"ORDER BY","text":"<p>The <code>ORDER BY</code> clause specifies the order of the rows in the output.</p> <ul> <li>Native nGQL: You must use a pipe (<code>|</code>) and an <code>ORDER BY</code> clause after <code>YIELD</code> clause.</li> </ul> <ul> <li>OpenCypher style: No pipes are permitted. The <code>ORDER BY</code> clause follows a <code>RETURN</code> clause.</li> </ul> <p>There are two order options:</p> <ul> <li><code>ASC</code>: Ascending. <code>ASC</code> is the default order.</li> <li><code>DESC</code>: Descending.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/#native_ngql_syntax","title":"Native nGQL Syntax","text":"<pre><code>&lt;YIELD clause&gt;\n| ORDER BY &lt;expression&gt; [ASC | DESC] [, &lt;expression&gt; [ASC | DESC] ...];\n</code></pre> <p>Compatibility</p> <p>In the native nGQL syntax, <code>$-.</code> must be used after <code>ORDER BY</code>. But it is not required in releases prior to 2.5.0.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/#examples","title":"Examples","text":"<pre><code>nebula&gt; FETCH PROP ON player \"player100\", \"player101\", \"player102\", \"player103\" \\\n        YIELD player.age AS age, player.name AS name \\\n        | ORDER BY $-.age ASC, $-.name DESC;\n+-----+---------------------+\n| age | name                |\n+-----+---------------------+\n| 32  | \"Rudy Gay\"          |\n| 33  | \"LaMarcus Aldridge\" |\n| 36  | \"Tony Parker\"       |\n| 42  | \"Tim Duncan\"        |\n+-----+---------------------+\n\nnebula&gt; $var = GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS dst; \\\n        ORDER BY $var.dst DESC;\n+-------------+\n| dst         |\n+-------------+\n| \"player125\" |\n| \"player101\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/#opencypher_syntax","title":"OpenCypher Syntax","text":"<pre><code>&lt;RETURN clause&gt;\nORDER BY &lt;expression&gt; [ASC | DESC] [, &lt;expression&gt; [ASC | DESC] ...];\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/#examples_1","title":"Examples","text":"<pre><code>nebula&gt; MATCH (v:player) RETURN v.player.name AS Name, v.player.age AS Age  \\\n        ORDER BY Name DESC;\n+-----------------+-----+\n| Name            | Age |\n+-----------------+-----+\n| \"Yao Ming\"      | 38  |\n| \"Vince Carter\"  | 42  |\n| \"Tracy McGrady\" | 39  |\n| \"Tony Parker\"   | 36  |\n| \"Tim Duncan\"    | 42  |\n+-----------------+-----+\n...\n\n# In the following example, nGQL sorts the rows by age first. If multiple people are of the same age, nGQL will then sort them by name.\nnebula&gt; MATCH (v:player) RETURN v.player.age AS Age, v.player.name AS Name  \\\n        ORDER BY Age DESC, Name ASC;\n+-----+-------------------+\n| Age | Name              |\n+-----+-------------------+\n| 47  | \"Shaquille O'Neal\" |\n| 46  | \"Grant Hill\"      |\n| 45  | \"Jason Kidd\"      |\n| 45  | \"Steve Nash\"      |\n+-----+-------------------+\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/order-by/#order_of_null_values","title":"Order of NULL values","text":"<p>nGQL lists NULL values at the end of the output for ascending sorting, and at the start for descending sorting.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age  \\\n        ORDER BY Age;\n+-----------------+----------+\n| Name            | Age      |\n+-----------------+----------+\n| \"Tony Parker\"   | 36       |\n| \"Manu Ginobili\" | 41       |\n| __NULL__        | __NULL__ |\n+-----------------+----------+\n\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) --&gt; (v2) \\\n        RETURN v2.player.name AS Name, v2.player.age AS Age  \\\n        ORDER BY Age DESC;\n+-----------------+----------+\n| Name            | Age      |\n+-----------------+----------+\n| __NULL__        | __NULL__ |\n| \"Manu Ginobili\" | 41       |\n| \"Tony Parker\"   | 36       |\n+-----------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/","title":"RETURN","text":"<p>The <code>RETURN</code> clause defines the output of an nGQL query. To return multiple fields, separate them with commas.</p> <p><code>RETURN</code> can lead a clause or a statement:</p> <ul> <li>A <code>RETURN</code> clause can work in openCypher statements in nGQL, such as <code>MATCH</code> or <code>UNWIND</code>.</li> </ul> <ul> <li>A <code>RETURN</code> statement can work independently to output the result of an expression.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>This topic applies to the openCypher syntax in nGQL only. For native nGQL, use <code>YIELD</code>.</p> <p><code>RETURN</code> does not support the following openCypher features yet.</p> <ul> <li> <p>Return variables with uncommon characters, for example:</p> <pre><code>MATCH (`non-english_characters`:player) \\\nRETURN `non-english_characters`;\n</code></pre> </li> </ul> <ul> <li> <p>Set a pattern in the <code>RETURN</code> clause and return all elements that this pattern matches, for example:</p> <pre><code>MATCH (v:player) \\\nRETURN (v)-[e]-&gt;(v2);\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#map_order_description","title":"Map order description","text":"<p>When <code>RETURN</code> returns the map data structure, the order of key-value pairs is undefined.</p> <pre><code>nebula&gt; RETURN {age: 32, name: \"Marco Belinelli\"};\n+------------------------------------+\n| {age:32,name:\"Marco Belinelli\"}    |\n+------------------------------------+\n| {age: 32, name: \"Marco Belinelli\"} |\n+------------------------------------+\n\nnebula&gt; RETURN {zage: 32, name: \"Marco Belinelli\"};\n+-------------------------------------+\n| {zage:32,name:\"Marco Belinelli\"}    |\n+-------------------------------------+\n| {name: \"Marco Belinelli\", zage: 32} |\n+-------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_vertices_or_edges","title":"Return vertices or edges","text":"<p>Use the <code>RETURN {&lt;vertex_name&gt; | &lt;edge_name&gt;}</code> to return vertices and edges all information.</p> <pre><code>// Return vertices\nnebula&gt; MATCH (v:player) \\\n        RETURN v;\n+---------------------------------------------------------------+\n| v                                                             |\n+---------------------------------------------------------------+\n| (\"player104\" :player{age: 32, name: \"Marco Belinelli\"})       |\n| (\"player107\" :player{age: 32, name: \"Aron Baynes\"})           |\n| (\"player116\" :player{age: 34, name: \"LeBron James\"})          |\n| (\"player120\" :player{age: 29, name: \"James Harden\"})          |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})         |\n+---------------------------------------------------------------+\n...\n\n// Return edges\nnebula&gt; MATCH (v:player)-[e]-&gt;() \\\n        RETURN e;\n+------------------------------------------------------------------------------+\n| e                                                                            |\n+------------------------------------------------------------------------------+\n| [:follow \"player104\"-&gt;\"player100\" @0 {degree: 55}]                           |\n| [:follow \"player104\"-&gt;\"player101\" @0 {degree: 50}]                           |\n| [:follow \"player104\"-&gt;\"player105\" @0 {degree: 60}]                           |\n| [:serve \"player104\"-&gt;\"team200\" @0 {end_year: 2009, start_year: 2007}]        |\n| [:serve \"player104\"-&gt;\"team208\" @0 {end_year: 2016, start_year: 2015}]        |\n+------------------------------------------------------------------------------+\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_vids","title":"Return VIDs","text":"<p>Use the <code>id()</code> function to retrieve VIDs.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN id(v);\n+-------------+\n| id(v)       |\n+-------------+\n| \"player100\" |\n+-------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_tag","title":"Return Tag","text":"<p>Use the <code>labels()</code> function to return the list of tags on a vertex.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN labels(v);\n+------------+\n| labels(v)  |\n+------------+\n| [\"player\"] |\n+------------+\n</code></pre> <p>To retrieve the nth element in the <code>labels(v)</code> list, use <code>labels(v)[n-1]</code>. The following example shows how to use <code>labels(v)[0]</code> to return the first tag in the list.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN labels(v)[0];\n+--------------+\n| labels(v)[0] |\n+--------------+\n| \"player\"     |\n+--------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_properties","title":"Return properties","text":"<p>When returning properties of a vertex, it is necessary to specify the tag to which the properties belong because a vertex can have multiple tags and the same property name can appear on different tags.</p> <p>It is possible to specify the tag of a vertex to return all properties of that tag, or to specify both the tag and a property name to return only that property of the tag.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        RETURN v.player, v.player.name, v.player.age \\\n        LIMIT 3;\n+--------------------------------------+---------------------+--------------+\n| v.player                             | v.player.name       | v.player.age |\n+--------------------------------------+---------------------+--------------+\n| {age: 33, name: \"LaMarcus Aldridge\"} | \"LaMarcus Aldridge\" | 33           |\n| {age: 25, name: \"Kyle Anderson\"}     | \"Kyle Anderson\"     | 25           |\n| {age: 40, name: \"Kobe Bryant\"}       | \"Kobe Bryant\"       | 40           |\n+--------------------------------------+---------------------+--------------+\n</code></pre> <p>When returning edge properties, it is not necessary to specify the edge type to which the properties belong, because an edge can only have one edge type.</p> <pre><code>// Return the property of a vertex\nnebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) \\\n        RETURN properties(v2);\n+----------------------------------+\n| properties(v2)                   |\n+----------------------------------+\n| {name: \"Spurs\"}                  |\n| {age: 36, name: \"Tony Parker\"}   |\n| {age: 41, name: \"Manu Ginobili\"} |\n+----------------------------------+\n</code></pre> <pre><code>// Return the property of an edge\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN e.start_year, e.degree \\\n+--------------+----------+\n| e.start_year | e.degree |\n+--------------+----------+\n| __NULL__     | 95       |\n| __NULL__     | 95       |\n| 1997         | __NULL__ |\n+--------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_edge_type","title":"Return edge type","text":"<p>Use the <code>type()</code> function to return the matched edge types.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[e]-&gt;() \\\n        RETURN DISTINCT type(e);\n+----------+\n| type(e)  |\n+----------+\n| \"serve\"  |\n| \"follow\" |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_paths","title":"Return paths","text":"<p>Use <code>RETURN &lt;path_name&gt;</code> to return all the information of the matched paths.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[*3]-&gt;() \\\n        RETURN p;\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| p                                                                                                                                                                                                                                                                                                              |\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 90}]-&gt;(\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"})-[:serve@0 {end_year: 2019, start_year: 2015}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;         |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 90}]-&gt;(\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"})-[:serve@0 {end_year: 2015, start_year: 2006}]-&gt;(\"team203\" :team{name: \"Trail Blazers\"})&gt; |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 90}]-&gt;(\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"})-[:follow@0 {degree: 75}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;           |\n+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_vertices_in_a_path","title":"Return vertices in a path","text":"<p>Use the <code>nodes()</code> function to return all vertices in a path.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) \\\n        RETURN nodes(p);\n+-------------------------------------------------------------------------------------------------------------+\n| nodes(p)                                                                                                    |\n+-------------------------------------------------------------------------------------------------------------+\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"team204\" :team{name: \"Spurs\"})]                      |\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"player101\" :player{age: 36, name: \"Tony Parker\"})]   |\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})] |\n+-------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_edges_in_a_path","title":"Return edges in a path","text":"<p>Use the <code>relationships()</code> function to return all edges in a path.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[]-&gt;(v2) \\\n        RETURN relationships(p);\n+-------------------------------------------------------------------------+\n| relationships(p)                                                        |\n+-------------------------------------------------------------------------+\n| [[:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}]] |\n| [[:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}]]                    |\n| [[:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}]]                    |\n+-------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_path_length","title":"Return path length","text":"<p>Use the <code>length()</code> function to return the length of a path.</p> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})-[*..2]-&gt;(v2) \\\n        RETURN p AS Paths, length(p) AS Length;\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+\n| Paths                                                                                                                                                                                                                  | Length |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:serve@0 {end_year: 2016, start_year: 1997}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;                                                                                   | 1      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;                                                                                     | 1      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt;                                                                                   | 1      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:serve@0 {end_year: 2018, start_year: 1999}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;     | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:serve@0 {end_year: 2019, start_year: 2018}]-&gt;(\"team215\" :team{name: \"Hornets\"})&gt;   | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 95}]-&gt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})&gt;        | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 90}]-&gt;(\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"})&gt; | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt;     | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})-[:serve@0 {end_year: 2018, start_year: 2002}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;   | 2      |\n| &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})-[:follow@0 {degree: 90}]-&gt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})&gt;      | 2      |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_all_elements","title":"Return all elements","text":"<p>To return all the elements that this pattern matches, use an asterisk (*).</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"}) \\\n        RETURN *;\n+----------------------------------------------------+\n| v                                                  |\n+----------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) |\n+----------------------------------------------------+\n\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) \\\n        RETURN *;\n+----------------------------------------------------+-----------------------------------------------------------------------+-------------------------------------------------------+\n| v                                                  | e                                                                     | v2                                                    |\n+----------------------------------------------------+-----------------------------------------------------------------------+-------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | [:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}]                    | (\"player101\" :player{age: 36, name: \"Tony Parker\"})   |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | [:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}]                    | (\"player125\" :player{age: 41, name: \"Manu Ginobili\"}) |\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"}) | [:serve \"player100\"-&gt;\"team204\" @0 {end_year: 2016, start_year: 1997}] | (\"team204\" :team{name: \"Spurs\"})                      |\n+----------------------------------------------------+-----------------------------------------------------------------------+-------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#rename_a_field","title":"Rename a field","text":"<p>Use the <code>AS &lt;alias&gt;</code> syntax to rename a field in the output.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[:serve]-&gt;(v2) \\\n        RETURN v2.team.name AS Team;\n+---------+\n| Team    |\n+---------+\n| \"Spurs\" |\n+---------+\n\nnebula&gt; RETURN \"Amber\" AS Name;\n+---------+\n| Name    |\n+---------+\n| \"Amber\" |\n+---------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_a_non-existing_property","title":"Return a non-existing property","text":"<p>If a property matched does not exist, <code>NULL</code> is returned.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(v2) \\\n        RETURN v2.player.name, type(e), v2.player.age;\n+-----------------+----------+---------------+\n| v2.player.name  | type(e)  | v2.player.age |\n+-----------------+----------+---------------+\n| \"Manu Ginobili\" | \"follow\" | 41            |\n| __NULL__        | \"serve\"  | __NULL__      |\n| \"Tony Parker\"   | \"follow\" | 36            |\n+-----------------+----------+---------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_expression_results","title":"Return expression results","text":"<p>To return the results of expressions such as literals, functions, or predicates, set them in a <code>RETURN</code> clause.</p> <pre><code>nebula&gt; MATCH (v:player{name:\"Tony Parker\"})--&gt;(v2:player) \\\n        RETURN DISTINCT v2.player.name, \"Hello\"+\" graphs!\", v2.player.age &gt; 35;\n+---------------------+----------------------+--------------------+\n| v2.player.name      | (\"Hello\"+\" graphs!\") | (v2.player.age&gt;35) |\n+---------------------+----------------------+--------------------+\n| \"LaMarcus Aldridge\" | \"Hello graphs!\"      | false              |\n| \"Tim Duncan\"        | \"Hello graphs!\"      | true               |\n| \"Manu Ginobili\"     | \"Hello graphs!\"      | true               |\n+---------------------+----------------------+--------------------+\n\nnebula&gt; RETURN 1+1;\n+-------+\n| (1+1) |\n+-------+\n| 2     |\n+-------+\n\nnebula&gt; RETURN 1- -1;\n+----------+\n| (1--(1)) |\n+----------+\n| 2        |\n+----------+\n\nnebula&gt; RETURN 3 &gt; 1;\n+-------+\n| (3&gt;1) |\n+-------+\n| true  |\n+-------+\n\nnebula&gt; RETURN 1+1, rand32(1, 5);\n+-------+-------------+\n| (1+1) | rand32(1,5) |\n+-------+-------------+\n| 2     | 1           |\n+-------+-------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/return/#return_unique_fields","title":"Return unique fields","text":"<p>Use <code>DISTINCT</code> to remove duplicate fields in the result set.</p> <pre><code># Before using DISTINCT.\nnebula&gt; MATCH (v:player{name:\"Tony Parker\"})--(v2:player) \\\n        RETURN v2.player.name, v2.player.age;\n+---------------------+---------------+\n| v2.player.name      | v2.player.age |\n+---------------------+---------------+\n| \"Manu Ginobili\"     | 41            |\n| \"Boris Diaw\"        | 36            |\n| \"Marco Belinelli\"   | 32            |\n| \"Dejounte Murray\"   | 29            |\n| \"Tim Duncan\"        | 42            |\n| \"Tim Duncan\"        | 42            |\n| \"LaMarcus Aldridge\" | 33            |\n| \"LaMarcus Aldridge\" | 33            |\n+---------------------+---------------+\n\n# After using DISTINCT.\nnebula&gt; MATCH (v:player{name:\"Tony Parker\"})--(v2:player) \\\n        RETURN DISTINCT v2.player.name, v2.player.age;\n+---------------------+---------------+\n| v2.player.name      | v2.player.age |\n+---------------------+---------------+\n| \"Manu Ginobili\"     | 41            |\n| \"Boris Diaw\"        | 36            |\n| \"Marco Belinelli\"   | 32            |\n| \"Dejounte Murray\"   | 29            |\n| \"Tim Duncan\"        | 42            |\n| \"LaMarcus Aldridge\" | 33            |\n+---------------------+---------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/sample/","title":"SAMPLE","text":"<p>The <code>SAMPLE</code> clause takes samples evenly in the result set and returns the specified amount of data.</p> <p><code>SAMPLE</code> can be used in <code>GO</code> statements only. The syntax is as follows:</p> <pre><code>&lt;go_statement&gt; SAMPLE &lt;sample_list&gt;;\n</code></pre> <p><code>sample_list</code> is a list. Elements in the list must be natural numbers, and the number of elements must be the same as the maximum number of <code>STEPS</code> in the <code>GO</code> statement. The following takes <code>GO 1 TO 3 STEPS FROM \"A\" OVER * SAMPLE &lt;sample_list&gt;</code> as an example to introduce this usage of <code>SAMPLE</code> in detail.</p> <ul> <li>The list <code>sample_list</code> must contain 3 natural numbers, such as <code>GO 1 TO 3 STEPS FROM \"A\" OVER * SAMPLE [1,2,4]</code>.</li> <li><code>1</code> in <code>SAMPLE [1,2,4]</code> means that the system automatically selects 1 edge to continue traversal in the first step. <code>2</code> means to select 2 edges to continue traversal in the second step. <code>4</code> indicates that 4 edges are selected to continue traversal in the third step. If there is no matched edge in a certain step or the number of matched edges is less than the specified number, the actual number will be returned.</li> <li>Because <code>GO 1 TO 3 STEPS</code> means to return all the traversal results from the first to third steps, all the red edges and their source and destination vertices in the figure below will be matched by this <code>GO</code> statement. And the yellow edges represent there is no path selected when the GO statement traverses. If it is not <code>GO 1 TO 3 STEPS</code> but <code>GO 3 STEPS</code>, it will only match the red edges of the third step and the vertices at both ends.</li> </ul> <p></p> <p>In the basketballplayer dataset, the example is as follows:</p> <pre><code>nebula&gt; GO 3 STEPS FROM \"player100\" \\\n        OVER * \\\n        YIELD properties($$).name AS NAME, properties($$).age AS Age \\\n        SAMPLE [1,2,3];\n+-----------------+----------+\n| NAME            | Age      |\n+-----------------+----------+\n| \"Tony Parker\"   | 36       |\n| \"Manu Ginobili\" | 41       |\n| \"Spurs\"         | __NULL__ |\n+-----------------+----------+\n\nnebula&gt; GO 1 TO 3 STEPS FROM \"player100\" \\\n        OVER * \\\n        YIELD properties($$).name AS NAME, properties($$).age AS Age \\\n        SAMPLE [2,2,2];\n+-----------------+----------+\n| NAME            | Age      |\n+-----------------+----------+\n| \"Manu Ginobili\" | 41       |\n| \"Spurs\"         | __NULL__ |\n| \"Tim Duncan\"    | 42       |\n| \"Spurs\"         | __NULL__ |\n| \"Manu Ginobili\" | 41       |\n| \"Spurs\"         | __NULL__ |\n+-----------------+----------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/","title":"TTL","text":"<p>TTL (Time To Live) is a mechanism in NebulaGraph that defines the lifespan of data. Once the data reaches its predefined lifespan, it is automatically deleted from the database. This feature is particularly suitable for data that only needs temporary storage, such as temporary sessions or cached data.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#opencypher_compatibility","title":"OpenCypher Compatibility","text":"<p>This topic applies to native nGQL only.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#precautions","title":"Precautions","text":"<ul> <li>You CANNOT modify a property schema with TTL options on it.</li> </ul> <ul> <li> <p>TTL options and indexes have coexistence issues.</p> <ul> <li>TTL options and indexes CANNOT coexist on a tag or an edge type. If there is an index on a property, you cannot set TTL options on other properties.</li> </ul> <ul> <li>If there are TTL options on a tag, an edge type, or a property, you can still add an index on them.</li> </ul> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#ttl_options","title":"TTL options","text":"<p>The native nGQL TTL feature has the following options.</p> Option Description <code>ttl_col</code> Specifies an existing property to set a lifespan on. The data type of the property must be <code>int</code> or <code>timestamp</code>. <code>ttl_duration</code> Specifies the timeout adds-on value in seconds. The value must be a non-negative int64 number. A property expires if the sum of its value and the <code>ttl_duration</code> value is smaller than the current timestamp. If the <code>ttl_duration</code> value is <code>0</code>, the property never expires.You can set <code>ttl_use_ms</code> to <code>true</code> in the configuration file <code>nebula-storaged.conf</code> (default path: <code>/usr/local/nightly/etc/</code>) to set the default unit to milliseconds. <p>Warning</p> <ul> <li>Before setting <code>ttl_use_ms</code> to <code>true</code>, make sure that no TTL has been set for any property, as shortening the expiration time may cause data to be erroneously deleted.</li> </ul> <ul> <li>After setting <code>ttl_use_ms</code> to <code>true</code>, which sets the default TTL unit to milliseconds, the data type of the property specified by <code>ttl_col</code> must be <code>int</code>, and the property value needs to be manually converted to milliseconds. For example, when setting <code>ttl_col</code> to <code>a</code>, you need to convert the value of <code>a</code> to milliseconds, such as when the value of <code>a</code> is <code>now()</code>, you need to set the value of <code>a</code> to <code>now() * 1000</code>.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#use_ttl_options","title":"Use TTL options","text":"<p>You must use the TTL options together to set a lifespan on a property.</p> <p>Before using the TTL feature, you must first create a timestamp or integer property and specify it in the TTL options. NebulaGraph will not automatically create or manage this timestamp property for you.</p> <p>When inserting the value of the timestamp or integer property, it is recommended to use the <code>now()</code> function or the current timestamp to represent the present time.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#set_a_timeout_if_a_tag_or_an_edge_type_exists","title":"Set a timeout if a tag or an edge type exists","text":"<p>If a tag or an edge type is already created, to set a timeout on a property bound to the tag or edge type, use <code>ALTER</code> to update the tag or edge type.</p> <pre><code># Create a tag.\nnebula&gt; CREATE TAG IF NOT EXISTS t1 (a timestamp);\n\n# Use ALTER to update the tag and set the TTL options.\nnebula&gt; ALTER TAG t1 TTL_COL = \"a\", TTL_DURATION = 5;\n\n# Insert a vertex with tag t1. The vertex expires 5 seconds after the insertion.\nnebula&gt; INSERT VERTEX t1(a) VALUES \"101\":(now());\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#set_a_timeout_when_creating_a_tag_or_an_edge_type","title":"Set a timeout when creating a tag or an edge type","text":"<p>Use TTL options in the <code>CREATE</code> statement to set a timeout when creating a tag or an edge type. For more information, see CREATE TAG and CREATE EDGE.</p> <pre><code># Create a tag and set the TTL options.\nnebula&gt; CREATE TAG IF NOT EXISTS t2(a int, b int, c string) TTL_DURATION= 100, TTL_COL = \"a\";\n\n# Insert a vertex with tag t2. The timeout timestamp is 1648197238 (1648197138 + 100).\nnebula&gt; INSERT VERTEX t2(a, b, c) VALUES \"102\":(1648197138, 30, \"Hello\");\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#data_expiration_and_deletion","title":"Data expiration and deletion","text":"<p>Caution</p> <ul> <li>When the TTL options are set for a property of a tag or an edge type and the property's value is <code>NULL</code>, the property never expires. </li> <li>If a property with a default value of <code>now()</code> is added to a tag or an edge type and the TTL options are set for the property, the history data related to the tag or the edge type will never expire because the value of that property for the history data is the current timestamp.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#vertex_property_expiration","title":"Vertex property expiration","text":"<p>Vertex property expiration has the following impact.</p> <ul> <li>If a vertex has only one tag, once a property of the vertex expires, the vertex expires.</li> </ul> <ul> <li>If a vertex has multiple tags, once a property of the vertex expires, properties bound to the same tag with the expired property also expire, but the vertex does not expire and other properties of it remain untouched.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#edge_property_expiration","title":"Edge property expiration","text":"<p>Since an edge can have only one edge type, once an edge property expires, the edge expires.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#data_deletion","title":"Data deletion","text":"<p>The expired data are still stored on the disk, but queries will filter them out.</p> <p>NebulaGraph automatically deletes the expired data and reclaims the disk space during the next compaction.</p> <p>Note</p> <p>If TTL is disabled, the corresponding data deleted after the last compaction can be queried again.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/ttl-options/#remove_a_timeout","title":"Remove a timeout","text":"<p>To disable TTL and remove the timeout on a property, you can use the following approaches.</p> <ul> <li>Drop the property with the timeout.<pre><code>nebula&gt; ALTER TAG t1 DROP (a);\n</code></pre> </li> </ul> <ul> <li>Set <code>ttl_col</code> to an empty string.<pre><code>nebula&gt; ALTER TAG t1 TTL_COL = \"\";\n</code></pre> </li> </ul> <ul> <li>Set <code>ttl_duration</code> to <code>0</code>. This operation keeps the TTL options and prevents the property from expiring and the property schema from being modified.<pre><code>nebula&gt; ALTER TAG t1 TTL_DURATION = 0;\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/unwind/","title":"UNWIND","text":"<p><code>UNWIND</code> transform a list into a sequence of rows.</p> <p><code>UNWIND</code> can be used as an individual statement or as a clause within a statement.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#unwind_statement","title":"UNWIND statement","text":""},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#syntax","title":"Syntax","text":"<pre><code>UNWIND &lt;list&gt; AS &lt;alias&gt; &lt;RETURN clause&gt;;\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#examples","title":"Examples","text":"<ul> <li> <p>To transform a list.</p> <pre><code>nebula&gt; UNWIND [1,2,3] AS n RETURN n;\n+---+\n| n |\n+---+\n| 1 |\n| 2 |\n| 3 |\n+---+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#unwind_clause","title":"UNWIND clause","text":""},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#syntax_1","title":"Syntax","text":"<ul> <li> <p>The <code>UNWIND</code> clause in native nGQL statements.</p> <p>Note</p> <p>To use a <code>UNWIND</code> clause in a native nGQL statement, use it after the <code>|</code> operator and use the <code>$-</code> prefix for variables. If you use a statement or clause after the <code>UNWIND</code> clause, use the <code>|</code> operator and use the <code>$-</code> prefix for variables.</p> <pre><code>&lt;statement&gt; | UNWIND $-.&lt;var&gt; AS &lt;alias&gt; &lt;|&gt; &lt;clause&gt;;\n</code></pre> </li> </ul> <ul> <li> <p>The <code>UNWIND</code> clause in openCypher statements.</p> <pre><code>&lt;statement&gt; UNWIND &lt;list&gt; AS &lt;alias&gt; &lt;RETURN clause&gt;\uff1b\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/unwind/#examples_1","title":"Examples","text":"<ul> <li> <p>To transform a list of duplicates into a unique set of rows using <code>WITH DISTINCT</code> in a <code>UNWIND</code> clause.</p> <p>Note</p> <p><code>WITH DISTINCT</code> is not available in native nGQL statements.  </p> <pre><code>// Transform the list `[1,1,2,2,3,3]` into a unique set of rows, sort the rows, and then transform the rows into a list of unique values.\n\nnebula&gt; WITH [1,1,2,2,3,3] AS n \\\n        UNWIND n AS r \\\n        WITH DISTINCT r AS r \\\n        ORDER BY r \\\n        RETURN collect(r);\n+------------+\n| collect(r) |\n+------------+\n| [1, 2, 3]  |\n+------------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>MATCH</code> statement.</p> <pre><code>// Get a list of the vertices in the matched path, transform the list into a unique set of rows, and then transform the rows into a list. \n\nnebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--(v2) \\\n        WITH nodes(p) AS n \\\n        UNWIND n AS r \\\n        WITH DISTINCT r AS r \\\n        RETURN collect(r);\n+----------------------------------------------------------------------------------------------------------------------+\n| collect(r)                                                                                                           |\n+----------------------------------------------------------------------------------------------------------------------+\n| [(\"player100\" :player{age: 42, name: \"Tim Duncan\"}), (\"player101\" :player{age: 36, name: \"Tony Parker\"}),            |\n|(\"team204\" :team{name: \"Spurs\"}), (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}),                          |\n|(\"player125\" :player{age: 41, name: \"Manu Ginobili\"}), (\"player104\" :player{age: 32, name: \"Marco Belinelli\"}),       |\n|(\"player144\" :player{age: 47, name: \"Shaquile O'Neal\"}), (\"player105\" :player{age: 31, name: \"Danny Green\"}),         |\n|(\"player113\" :player{age: 29, name: \"Dejounte Murray\"}), (\"player107\" :player{age: 32, name: \"Aron Baynes\"}),         |\n|(\"player109\" :player{age: 34, name: \"Tiago Splitter\"}), (\"player108\" :player{age: 36, name: \"Boris Diaw\"})]           |  \n+----------------------------------------------------------------------------------------------------------------------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>GO</code> statement.</p> <pre><code>// Query the vertices in a list for the corresponding edges with a specified statement.\n\nnebula&gt; YIELD ['player101', 'player100'] AS a | UNWIND $-.a AS  b | GO FROM $-.b OVER follow YIELD edge AS e;\n+----------------------------------------------------+\n| e                                                  |\n+----------------------------------------------------+\n| [:follow \"player101\"-&gt;\"player100\" @0 {degree: 95}] |\n| [:follow \"player101\"-&gt;\"player102\" @0 {degree: 90}] |\n| [:follow \"player101\"-&gt;\"player125\" @0 {degree: 95}] |\n| [:follow \"player100\"-&gt;\"player101\" @0 {degree: 95}] |\n| [:follow \"player100\"-&gt;\"player125\" @0 {degree: 95}] |\n+----------------------------------------------------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>LOOKUP</code> statement.</p> <pre><code>// Find all the properties of players whose age is greater than 46, get a list of unique properties, and then transform the list into rows. \n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.age &gt; 46 \\\n        YIELD DISTINCT keys(vertex) as p | UNWIND $-.p as a | YIELD $-.a AS a;\n+--------+\n| a      |\n+--------+\n| \"age\"  |\n| \"name\" |\n+--------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>FETCH</code> statement. </p> <pre><code>// Query player101 for all tags related to player101, get a list of the tags and then transform the list into rows.\n\nnebula&gt; CREATE TAG hero(like string, height int);\n        INSERT VERTEX hero(like, height) VALUES \"player101\":(\"deep\", 182);\n        FETCH PROP ON * \"player101\" \\\n        YIELD tags(vertex) as t | UNWIND $-.t as a | YIELD $-.a AS a;\n+----------+\n| a        |\n+----------+\n| \"hero\"   |\n| \"player\" |\n+----------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>GET SUBGRAPH</code> statement. </p> <pre><code>// Get the subgraph including outgoing and incoming serve edges within 0~2 hops from/to player100, and transform the result into rows.\n\nnebula&gt; GET SUBGRAPH 2 STEPS FROM \"player100\" BOTH serve \\\n        YIELD edges as e | UNWIND $-.e as a | YIELD $-.a AS a;\n+----------------------------------------------+\n| a                                            |\n+----------------------------------------------+\n| [:serve \"player100\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player101\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player102\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player103\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player105\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player106\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player107\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player108\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player109\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player110\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player111\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player112\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player113\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player114\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player125\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player138\"-&gt;\"team204\" @0 {}]        |\n| [:serve \"player104\"-&gt;\"team204\" @20132015 {}] |\n| [:serve \"player104\"-&gt;\"team204\" @20182019 {}] |\n+----------------------------------------------+\n</code></pre> </li> </ul> <ul> <li> <p>To use an <code>UNWIND</code> clause in a <code>FIND PATH</code> statement.</p> <pre><code>// Find all the vertices in the shortest path from player101 to team204 along the serve edge, and transform the result into rows. \n\nnebula&gt; FIND SHORTEST PATH FROM \"player101\" TO \"team204\" OVER serve \\\n        YIELD path as p | YIELD nodes($-.p) AS nodes | UNWIND $-.nodes AS a | YIELD $-.a AS a;\n+---------------+\n| a             |\n+---------------+\n| (\"player101\") |\n| (\"team204\")   |\n+---------------+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/where/","title":"WHERE","text":"<p>The <code>WHERE</code> clause filters the output by conditions.</p> <p>The <code>WHERE</code> clause usually works in the following queries:</p> <ul> <li>Native nGQL: such as <code>GO</code> and <code>LOOKUP</code>.</li> </ul> <ul> <li>OpenCypher syntax: such as <code>MATCH</code> and <code>WITH</code>.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>Filtering on edge rank is a native nGQL feature. To retrieve the rank value in openCypher statements, use the rank() function, such as <code>MATCH (:player)-[e:follow]-&gt;() RETURN rank(e);</code>.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#basic_usage","title":"Basic usage","text":"<p>Note</p> <p>In the following examples, <code>$$</code> and <code>$^</code> are reference operators. For more information, see Operators.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#define_conditions_with_boolean_operators","title":"Define conditions with boolean operators","text":"<p>Use the boolean operators <code>NOT</code>, <code>AND</code>, <code>OR</code>, and <code>XOR</code> to define conditions in <code>WHERE</code> clauses. For the precedence of the operators, see Precedence.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name == \"Tim Duncan\" \\\n        XOR (v.player.age &lt; 30 AND v.player.name == \"Yao Ming\") \\\n        OR NOT (v.player.name == \"Yao Ming\" OR v.player.name == \"Tim Duncan\") \\\n        RETURN v.player.name, v.player.age;\n+-------------------------+--------------+\n| v.player.name           | v.player.age |\n+-------------------------+--------------+\n| \"Danny Green\"           | 31           |\n| \"Tiago Splitter\"        | 34           |\n| \"David West\"            | 38           |\n...\n</code></pre> <pre><code>nebula&gt; GO FROM \"player100\" \\\n        OVER follow \\\n        WHERE properties(edge).degree &gt; 90 \\\n        OR properties($$).age != 33 \\\n        AND properties($$).name != \"Tony Parker\" \\\n        YIELD properties($$);\n+----------------------------------+\n| properties($$)                   |\n+----------------------------------+\n| {age: 41, name: \"Manu Ginobili\"} |\n+----------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_properties","title":"Filter on properties","text":"<p>Use vertex or edge properties to define conditions in <code>WHERE</code> clauses.</p> <ul> <li>Filter on a vertex property:<pre><code>nebula&gt; MATCH (v:player)-[e]-&gt;(v2) \\\n        WHERE v2.player.age &lt; 25 \\\n        RETURN v2.player.name, v2.player.age;\n+----------------------+---------------+\n| v2.player.name       | v2.player.age |\n+----------------------+---------------+\n| \"Ben Simmons\"        | 22            |\n| \"Luka Doncic\"        | 20            |\n| \"Kristaps Porzingis\" | 23            |\n+----------------------+---------------+\n</code></pre> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        WHERE $^.player.age &gt;= 42 \\\n        YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n+-------------+\n| \"player101\" |\n| \"player125\" |\n+-------------+\n</code></pre> </li> </ul> <ul> <li>Filter on an edge property:<pre><code>nebula&gt; MATCH (v:player)-[e]-&gt;() \\\n        WHERE e.start_year &lt; 2000 \\\n        RETURN DISTINCT v.player.name, v.player.age;\n+--------------------+--------------+\n| v.player.name      | v.player.age |\n+--------------------+--------------+\n| \"Tony Parker\"      | 36           |\n| \"Tim Duncan\"       | 42           |\n| \"Grant Hill\"       | 46           |\n...\n</code></pre> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        WHERE follow.degree &gt; 90 \\\n        YIELD dst(edge);\n+-------------+\n| dst(EDGE)   |\n+-------------+\n| \"player101\" |\n| \"player125\" |\n+-------------+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_dynamically-calculated_properties","title":"Filter on dynamically-calculated properties","text":"<pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v[toLower(\"AGE\")] &lt; 21 \\\n        RETURN v.player.name, v.player.age;\n+---------------+-------+\n| v.name        | v.age |\n+---------------+-------+\n| \"Luka Doncic\" | 20    |\n+---------------+-------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_existing_properties","title":"Filter on existing properties","text":"<pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE exists(v.player.age) \\\n        RETURN v.player.name, v.player.age;\n+-------------------------+--------------+\n| v.player.name           | v.player.age |\n+-------------------------+--------------+\n| \"Danny Green\"           | 31           |\n| \"Tiago Splitter\"        | 34           |\n| \"David West\"            | 38           |\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_edge_rank","title":"Filter on edge rank","text":"<p>In nGQL, if a group of edges has the same source vertex, destination vertex, and properties, the only thing that distinguishes them is the rank. Use rank conditions in <code>WHERE</code> clauses to filter such edges.</p> <pre><code># The following example creates test data.\nnebula&gt; CREATE SPACE IF NOT EXISTS test (vid_type=FIXED_STRING(30));\nnebula&gt; USE test;\nnebula&gt; CREATE EDGE IF NOT EXISTS e1(p1 int);\nnebula&gt; CREATE TAG IF NOT EXISTS person(p1 int);\nnebula&gt; INSERT VERTEX person(p1) VALUES \"1\":(1);\nnebula&gt; INSERT VERTEX person(p1) VALUES \"2\":(2);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@0:(10);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@1:(11);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@2:(12);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@3:(13);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@4:(14);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@5:(15);\nnebula&gt; INSERT EDGE e1(p1) VALUES \"1\"-&gt;\"2\"@6:(16);\n\n# The following example use rank to filter edges and retrieves edges with a rank greater than 2.\nnebula&gt; GO FROM \"1\" \\\n        OVER e1 \\\n        WHERE rank(edge) &gt; 2 \\\n        YIELD src(edge), dst(edge), rank(edge) AS Rank, properties(edge).p1 | \\\n        ORDER BY $-.Rank DESC;\n+-----------+-----------+------+---------------------+\n| src(EDGE) | dst(EDGE) | Rank | properties(EDGE).p1 |\n+-----------+-----------+------+---------------------+\n| \"1\"       | \"2\"       | 6    | 16                  |\n| \"1\"       | \"2\"       | 5    | 15                  |\n| \"1\"       | \"2\"       | 4    | 14                  |\n| \"1\"       | \"2\"       | 3    | 13                  |\n+-----------+-----------+------+---------------------+\n\n# Filter edges by rank. Find follow edges with rank equal to 0.\nnebula&gt; MATCH (v)-[e:follow]-&gt;() \\\n         WHERE rank(e)==0 \\\n         RETURN *;\n+------------------------------------------------------------+-----------------------------------------------------+\n| v                                                          | e                                                   |\n+------------------------------------------------------------+-----------------------------------------------------+\n| (\"player142\" :player{age: 29, name: \"Klay Thompson\"})      | [:follow \"player142\"-&gt;\"player117\" @0 {degree: 90}]  |\n| (\"player139\" :player{age: 34, name: \"Marc Gasol\"})         | [:follow \"player139\"-&gt;\"player138\" @0 {degree: 99}]  |\n| (\"player108\" :player{age: 36, name: \"Boris Diaw\"})         | [:follow \"player108\"-&gt;\"player100\" @0 {degree: 80}]  |\n| (\"player108\" :player{age: 36, name: \"Boris Diaw\"})         | [:follow \"player108\"-&gt;\"player101\" @0 {degree: 80}]  |\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_pattern","title":"Filter on pattern","text":"<pre><code>nebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(t) \\\n        WHERE (v)-[e]-&gt;(t:team) \\\n        RETURN (v)--&gt;();\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| (v)--&gt;() = (v)--&gt;()                                                                                                                                                                                                                                                                                                                                                                                              |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [&lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:serve@0 {end_year: 2016, start_year: 1997}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt;] |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\nnebula&gt; MATCH (v:player{name:\"Tim Duncan\"})-[e]-&gt;(t) \\\n        WHERE NOT (v)-[e]-&gt;(t:team) \\\n        RETURN (v)--&gt;();\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| (v)--&gt;() = (v)--&gt;()                                                                                                                                                                                                                                                                                                                                                                                              |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [&lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:serve@0 {end_year: 2016, start_year: 1997}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt;] |\n| [&lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:serve@0 {end_year: 2016, start_year: 1997}]-&gt;(\"team204\" :team{name: \"Spurs\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player101\" :player{age: 36, name: \"Tony Parker\"})&gt;, &lt;(\"player100\" :player{age: 42, name: \"Tim Duncan\"})-[:follow@0 {degree: 95}]-&gt;(\"player125\" :player{age: 41, name: \"Manu Ginobili\"})&gt;] |\n+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_strings","title":"Filter on strings","text":"<p>Use <code>STARTS WITH</code>, <code>ENDS WITH</code>, or <code>CONTAINS</code> in <code>WHERE</code> clauses to match a specific part of a string. String matching is case-sensitive.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#starts_with","title":"<code>STARTS WITH</code>","text":"<p><code>STARTS WITH</code> will match the beginning of a string.</p> <p>The following example uses <code>STARTS WITH \"T\"</code> to retrieve the information of players whose name starts with <code>T</code>.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name STARTS WITH \"T\" \\\n        RETURN v.player.name, v.player.age;\n+------------------+--------------+\n| v.player.name    | v.player.age |\n+------------------+--------------+\n| \"Tony Parker\"    | 36           |\n| \"Tiago Splitter\" | 34           |\n| \"Tim Duncan\"     | 42           |\n| \"Tracy McGrady\"  | 39           |\n+------------------+--------------+\n</code></pre> <p>If you use <code>STARTS WITH \"t\"</code> in the preceding statement, an empty set is returned because no name in the dataset starts with the lowercase <code>t</code>.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name STARTS WITH \"t\" \\\n        RETURN v.player.name, v.player.age;\n+---------------+--------------+\n| v.player.name | v.player.age |\n+---------------+--------------+\n+---------------+--------------+\nEmpty set (time spent 5080/6474 us)\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#ends_with","title":"<code>ENDS WITH</code>","text":"<p><code>ENDS WITH</code> will match the ending of a string.</p> <p>The following example uses <code>ENDS WITH \"r\"</code> to retrieve the information of players whose name ends with <code>r</code>.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name ENDS WITH \"r\" \\\n        RETURN v.player.name, v.player.age;\n+------------------+--------------+\n| v.player.name    | v.player.age |\n+------------------+--------------+\n| \"Tony Parker\"    | 36           |\n| \"Tiago Splitter\" | 34           |\n| \"Vince Carter\"   | 42           |\n+------------------+--------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#contains","title":"<code>CONTAINS</code>","text":"<p><code>CONTAINS</code> will match a certain part of a string.</p> <p>The following example uses <code>CONTAINS \"Pa\"</code> to match the information of players whose name contains <code>Pa</code>.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.name CONTAINS \"Pa\" \\\n        RETURN v.player.name, v.player.age;\n+---------------+--------------+\n| v.player.name | v.player.age |\n+---------------+--------------+\n| \"Paul George\" | 28           |\n| \"Tony Parker\" | 36           |\n| \"Paul Gasol\"  | 38           |\n| \"Chris Paul\"  | 33           |\n+---------------+--------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#negative_string_matching","title":"Negative string matching","text":"<p>You can use the boolean operator <code>NOT</code> to negate a string matching condition.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE NOT v.player.name ENDS WITH \"R\" \\\n        RETURN v.player.name, v.player.age;\n+-------------------------+--------------+\n| v.player.name           | v.player.age |\n+-------------------------+--------------+\n| \"Danny Green\"           | 31           |\n| \"Tiago Splitter\"        | 34           |\n| \"David West\"            | 38           |\n| \"Russell Westbrook\"     | 30           |\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#filter_on_lists","title":"Filter on lists","text":""},{"location":"3.ngql-guide/8.clauses-and-options/where/#match_values_in_a_list","title":"Match values in a list","text":"<p>Use the <code>IN</code> operator to check if a value is in a specific list.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.age IN range(20,25) \\\n        RETURN v.player.name, v.player.age;\n+-------------------------+--------------+\n| v.player.name           | v.player.age |\n+-------------------------+--------------+\n| \"Ben Simmons\"           | 22           |\n| \"Giannis Antetokounmpo\" | 24           |\n| \"Kyle Anderson\"         | 25           |\n| \"Joel Embiid\"           | 25           |\n| \"Kristaps Porzingis\"    | 23           |\n| \"Luka Doncic\"           | 20           |\n+-------------------------+--------------+\n\nnebula&gt; LOOKUP ON player \\\n        WHERE player.age IN [25,28]  \\\n        YIELD properties(vertex).name, properties(vertex).age;\n+-------------------------+------------------------+\n| properties(VERTEX).name | properties(VERTEX).age |\n+-------------------------+------------------------+\n| \"Kyle Anderson\"         | 25                     |\n| \"Damian Lillard\"        | 28                     |\n| \"Joel Embiid\"           | 25                     |\n| \"Paul George\"           | 28                     |\n| \"Ricky Rubio\"           | 28                     |\n+-------------------------+------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/where/#match_values_not_in_a_list","title":"Match values not in a list","text":"<p>Use <code>NOT</code> before <code>IN</code> to rule out the values in a list.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WHERE v.player.age NOT IN range(20,25) \\\n        RETURN v.player.name AS Name, v.player.age AS Age \\\n        ORDER BY Age;\n+---------------------+-----+\n| Name                | Age |\n+---------------------+-----+\n| \"Kyrie Irving\"      | 26  |\n| \"Cory Joseph\"       | 27  |\n| \"Damian Lillard\"    | 28  |\n| \"Paul George\"       | 28  |\n| \"Ricky Rubio\"       | 28  |\n+---------------------+-----+\n...\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/with/","title":"WITH","text":"<p>The <code>WITH</code> clause can retrieve the output from a query part, process it, and pass it to the next query part as the input.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>This topic applies to openCypher syntax only.</p> <p>Note</p> <p><code>WITH</code> has a similar function with the Pipe symbol in native nGQL, but they work in different ways. DO NOT use pipe symbols in the openCypher syntax or use <code>WITH</code> in native nGQL statements.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#combine_statements_and_form_a_composite_query","title":"Combine statements and form a composite query","text":"<p>Use a <code>WITH</code> clause to combine statements and transfer the output of a statement as the input of another statement.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#example_1","title":"Example 1","text":"<p>The following statement:</p> <ol> <li>Matches a path.</li> <li>Outputs all the vertices on the path to a list with the <code>nodes()</code> function.</li> <li>Unwinds the list into rows.</li> <li>Removes duplicated vertices and returns a set of distinct vertices.</li> </ol> <pre><code>nebula&gt; MATCH p=(v:player{name:\"Tim Duncan\"})--() \\\n        WITH nodes(p) AS n \\\n        UNWIND n AS n1 \\\n        RETURN DISTINCT n1;\n+-----------------------------------------------------------+\n| n1                                                        |\n+-----------------------------------------------------------+\n| (\"player100\" :player{age: 42, name: \"Tim Duncan\"})        |\n| (\"player101\" :player{age: 36, name: \"Tony Parker\"})       |\n| (\"team204\" :team{name: \"Spurs\"})                          |\n| (\"player102\" :player{age: 33, name: \"LaMarcus Aldridge\"}) |\n| (\"player125\" :player{age: 41, name: \"Manu Ginobili\"})     |\n| (\"player104\" :player{age: 32, name: \"Marco Belinelli\"})   |\n| (\"player144\" :player{age: 47, name: \"Shaquille O'Neal\"})  |\n| (\"player105\" :player{age: 31, name: \"Danny Green\"})       |\n| (\"player113\" :player{age: 29, name: \"Dejounte Murray\"})   |\n| (\"player107\" :player{age: 32, name: \"Aron Baynes\"})       |\n| (\"player109\" :player{age: 34, name: \"Tiago Splitter\"})    |\n| (\"player108\" :player{age: 36, name: \"Boris Diaw\"})        |\n+-----------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#example_2","title":"Example 2","text":"<p>The following statement:</p> <ol> <li>Matches the vertex with the VID <code>player100</code>.</li> <li>Outputs all the tags of the vertex into a list with the <code>labels()</code> function.</li> <li>Unwinds the list into rows.</li> <li>Returns the output.</li> </ol> <pre><code>nebula&gt; MATCH (v) \\\n        WHERE id(v)==\"player100\" \\\n        WITH labels(v) AS tags_unf \\\n        UNWIND tags_unf AS tags_f \\\n        RETURN tags_f;\n+----------+\n| tags_f   |\n+----------+\n| \"player\" |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#filter_composite_queries","title":"Filter composite queries","text":"<p><code>WITH</code> can work as a filter in the middle of a composite query.</p> <pre><code>nebula&gt; MATCH (v:player)--&gt;(v2:player) \\\n        WITH DISTINCT v2 AS v2, v2.player.age AS Age \\\n        ORDER BY Age \\\n        WHERE Age&lt;25 \\\n        RETURN v2.player.name AS Name, Age;\n+----------------------+-----+\n| Name                 | Age |\n+----------------------+-----+\n| \"Luka Doncic\"        | 20  |\n| \"Ben Simmons\"        | 22  |\n| \"Kristaps Porzingis\" | 23  |\n+----------------------+-----+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#process_the_output_before_using_collect","title":"Process the output before using collect()","text":"<p>Use a <code>WITH</code> clause to sort and limit the output before using <code>collect()</code> to transform the output into a list.</p> <pre><code>nebula&gt; MATCH (v:player) \\\n        WITH v.player.name AS Name \\\n        ORDER BY Name DESC \\\n        LIMIT 3 \\\n        RETURN collect(Name);\n+-----------------------------------------------+\n| collect(Name)                                 |\n+-----------------------------------------------+\n| [\"Yao Ming\", \"Vince Carter\", \"Tracy McGrady\"] |\n+-----------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/with/#use_with_return","title":"Use with RETURN","text":"<p>Set an alias using a <code>WITH</code> clause, and then output the result through a <code>RETURN</code> clause.</p> <pre><code>nebula&gt; WITH [1, 2, 3] AS `list` RETURN 3 IN `list` AS r;\n+------+\n| r    |\n+------+\n| true |\n+------+\n\nnebula&gt; WITH 4 AS one, 3 AS two RETURN one &gt; two AS result;\n+--------+\n| result |\n+--------+\n| true   |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/yield/","title":"YIELD","text":"<p><code>YIELD</code> defines the output of an nGQL query.</p> <p><code>YIELD</code> can lead a clause or a statement:</p> <ul> <li>A <code>YIELD</code> clause works in nGQL statements such as <code>GO</code>, <code>FETCH</code>, or <code>LOOKUP</code> and must be defined to return the result.</li> </ul> <ul> <li>A <code>YIELD</code> statement works in a composite query or independently.</li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/yield/#opencypher_compatibility","title":"OpenCypher compatibility","text":"<p>This topic applies to native nGQL only. For the openCypher syntax, use <code>RETURN</code>.</p> <p><code>YIELD</code> has different functions in openCypher and nGQL.</p> <ul> <li> <p>In openCypher, <code>YIELD</code> is used in the <code>CALL[\u2026YIELD]</code> clause to specify the output of the procedure call.</p> <p>Note</p> <p>NGQL does not support <code>CALL[\u2026YIELD]</code> yet.</p> </li> </ul> <ul> <li>In nGQL, <code>YIELD</code> works like <code>RETURN</code> in openCypher.</li> </ul> <p>Note</p> <p>In the following examples, <code>$$</code> and <code>$-</code> are property references. For more information, see Reference to properties.</p>"},{"location":"3.ngql-guide/8.clauses-and-options/yield/#yield_clauses","title":"YIELD clauses","text":""},{"location":"3.ngql-guide/8.clauses-and-options/yield/#syntax","title":"Syntax","text":"<pre><code>YIELD [DISTINCT] &lt;col&gt; [AS &lt;alias&gt;] [, &lt;col&gt; [AS &lt;alias&gt;] ...];\n</code></pre> Parameter Description <code>DISTINCT</code> Aggregates the output and makes the statement return a distinct result set. <code>col</code> A field to be returned. If no alias is set, <code>col</code> will be a column name in the output. <code>alias</code> An alias for <code>col</code>. It is set after the keyword <code>AS</code> and will be a column name in the output."},{"location":"3.ngql-guide/8.clauses-and-options/yield/#use_a_yield_clause_in_a_statement","title":"Use a YIELD clause in a statement","text":"<ul> <li>Use <code>YIELD</code> with <code>GO</code>:<pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD properties($$).name AS Friend, properties($$).age AS Age;\n+-----------------+-----+\n| Friend          | Age |\n+-----------------+-----+\n| \"Tony Parker\"   | 36  |\n| \"Manu Ginobili\" | 41  |\n+-----------------+-----+\n</code></pre> </li> </ul> <ul> <li>Use <code>YIELD</code> with <code>FETCH</code>:<pre><code>nebula&gt; FETCH PROP ON player \"player100\" \\\n        YIELD properties(vertex).name;\n+-------------------------+\n| properties(VERTEX).name |\n+-------------------------+\n| \"Tim Duncan\"            |\n+-------------------------+\n</code></pre> </li> </ul> <ul> <li>Use <code>YIELD</code> with <code>LOOKUP</code>:<pre><code>nebula&gt; LOOKUP ON player WHERE player.name == \"Tony Parker\" \\\n        YIELD properties(vertex).name, properties(vertex).age;\n+-------------------------+------------------------+\n| properties(VERTEX).name | properties(VERTEX).age |\n+-------------------------+------------------------+\n| \"Tony Parker\"           | 36                     |\n+-------------------------+------------------------+\n</code></pre> </li> </ul>"},{"location":"3.ngql-guide/8.clauses-and-options/yield/#yield_statements","title":"YIELD statements","text":""},{"location":"3.ngql-guide/8.clauses-and-options/yield/#syntax_1","title":"Syntax","text":"<pre><code>YIELD [DISTINCT] &lt;col&gt; [AS &lt;alias&gt;] [, &lt;col&gt; [AS &lt;alias&gt;] ...]\n[WHERE &lt;conditions&gt;];\n</code></pre> Parameter Description <code>DISTINCT</code> Aggregates the output and makes the statement return a distinct result set. <code>col</code> A field to be returned. If no alias is set, <code>col</code> will be a column name in the output. <code>alias</code> An alias for <code>col</code>. It is set after the keyword <code>AS</code> and will be a column name in the output. <code>conditions</code> Conditions set in a <code>WHERE</code> clause to filter the output. For more information, see <code>WHERE</code>."},{"location":"3.ngql-guide/8.clauses-and-options/yield/#use_a_yield_statement_in_a_composite_query","title":"Use a YIELD statement in a composite query","text":"<p>In a composite query, a <code>YIELD</code> statement accepts, filters, and modifies the result set of the preceding statement, and then outputs it.</p> <p>The following query finds the players that \"player100\" follows and calculates their average age.</p> <pre><code>nebula&gt; GO FROM \"player100\" OVER follow \\\n        YIELD dst(edge) AS ID \\\n        | FETCH PROP ON player $-.ID \\\n        YIELD properties(vertex).age AS Age \\\n        | YIELD AVG($-.Age) as Avg_age, count(*)as Num_friends;\n+---------+-------------+\n| Avg_age | Num_friends |\n+---------+-------------+\n| 38.5    | 2           |\n+---------+-------------+\n</code></pre> <p>The following query finds the players that \"player101\" follows with the follow degrees greater than 90.</p> <pre><code>nebula&gt; $var1 = GO FROM \"player101\" OVER follow \\\n        YIELD properties(edge).degree AS Degree, dst(edge) as ID; \\\n        YIELD $var1.ID AS ID WHERE $var1.Degree &gt; 90;\n+-------------+\n| ID          |\n+-------------+\n| \"player100\" |\n| \"player125\" |\n+-------------+\n</code></pre> <p>The following query finds the vertices in the player that are older than 30 and younger than 32, and returns the de-duplicate results.</p> <pre><code>nebula&gt; LOOKUP ON player  \\\n        WHERE player.age &lt; 32 and player.age &gt;30  \\\n        YIELD DISTINCT properties(vertex).age as v;\n+--------+\n| v      |\n+--------+\n| 31     |\n+--------+\n</code></pre>"},{"location":"3.ngql-guide/8.clauses-and-options/yield/#use_a_standalone_yield_statement","title":"Use a standalone YIELD statement","text":"<p>A <code>YIELD</code> statement can calculate a valid expression and output the result.</p> <pre><code>nebula&gt; YIELD rand32(1, 6);\n+-------------+\n| rand32(1,6) |\n+-------------+\n| 3           |\n+-------------+\n\nnebula&gt; YIELD \"Hel\" + \"\\tlo\" AS string1, \", World!\" AS string2;\n+-------------+------------+\n| string1     | string2    |\n+-------------+------------+\n| \"Hel    lo\" | \", World!\" |\n+-------------+------------+\n\nnebula&gt; YIELD hash(\"Tim\") % 100;\n+-----------------+\n| (hash(Tim)%100) |\n+-----------------+\n| 42              |\n+-----------------+\n\nnebula&gt; YIELD \\\n      CASE 2+3 \\\n      WHEN 4 THEN 0 \\\n      WHEN 5 THEN 1 \\\n      ELSE -1 \\\n      END \\\n      AS result;\n+--------+\n| result |\n+--------+\n| 1      |\n+--------+\n\nnebula&gt; YIELD 1- -1;\n+----------+\n| (1--(1)) |\n+----------+\n| 2        |\n+----------+\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/","title":"CREATE SPACE","text":"<p>Graph spaces are used to store data in a physically isolated way in NebulaGraph, which is similar to the database concept in MySQL. The <code>CREATE SPACE</code> statement can create a new graph space or clone the schema of an existing graph space.</p>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/#prerequisites","title":"Prerequisites","text":"<p>Only the God role can use the <code>CREATE SPACE</code> statement. For more information, see AUTHENTICATION.</p>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/#syntax","title":"Syntax","text":""},{"location":"3.ngql-guide/9.space-statements/1.create-space/#create_graph_spaces","title":"Create graph spaces","text":"<pre><code>CREATE SPACE [IF NOT EXISTS] &lt;graph_space_name&gt; (\n    [partition_num = &lt;partition_number&gt;,]\n    [replica_factor = &lt;replica_number&gt;,]\n    vid_type = {FIXED_STRING(&lt;N&gt;) | INT[64]}\n    )\n    [COMMENT = '&lt;comment&gt;']\n</code></pre> Parameter Description <code>IF NOT EXISTS</code> Detects if the related graph space exists. If it does not exist, a new one will be created. The graph space existence detection here only compares the graph space name (excluding properties). <code>&lt;graph_space_name&gt;</code> 1. Uniquely identifies a graph space in a NebulaGraph instance. 2. Space names cannot be modified after they are set. 3. By default, the name only supports 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc. However, it cannot include special characters other than the underscore (_), and cannot start with a number. 4. To use special characters, reserved keywords, or start with a number, quote the entire name with backticks (`) and do not include periods (<code>.</code>) within the pair of backticks (`). For more information, see Keywords and reserved words. Note:1. If you name a space in Chinese and encounter a <code>SyntaxError</code>, you need to quote the Chinese characters with backticks (`). 2. To include a backtick (`) in a space name, use a backslash to escape the backtick, such as \\`; to include a backslash, the backslash itself also needs to be escaped, such as \\ . <code>partition_num</code> Specifies the number of partitions in each replica. The suggested value is 20 times (2 times for HDD) the number of the hard disks in the cluster. For example, if you have three hard disks in the cluster, we recommend that you set 60 partitions. The default value is 100. <code>replica_factor</code> Specifies the number of replicas in the cluster. The suggested number is 3 in a production environment and 1 in a test environment. The replica number must be an odd number for the need of quorum-based voting. The default value is 1. <code>vid_type</code> A required parameter. Specifies the VID type in a graph space. Available values are <code>FIXED_STRING(N)</code> and <code>INT64</code>. <code>INT</code> equals to <code>INT64</code>. <code>`FIXED_STRING(&lt;N&gt;)</code> specifies the VID as a string, while <code>INT64</code> specifies it as an integer. <code>N</code> represents the maximum length of the VIDs. If you set a VID that is longer than <code>N</code> bytes, NebulaGraph throws an error. Note, for UTF-8 chars, the length may vary in different cases, i.e. a UTF-8 Chinese char is 3 byte, this means 11 Chinese chars(length-33) will exeed a FIXED_STRING(32) vid defination. <code>COMMENT</code> The remarks of the graph space. The maximum length is 256 bytes. By default, there is no comments on a space. <p>Caution</p> <ul> <li>If the replica number is set to one, you will not be able to load balance or scale out the NebulaGraph Storage Service with the SUBMIT JOB BALANCE statement.</li> </ul> <ul> <li> <p>Restrictions on VID type change and VID length:</p> <ul> <li>For NebulaGraph v1.x, the type of VIDs can only be <code>INT64</code>, and the String type is not allowed. For NebulaGraph v2.x, both <code>INT64</code> and <code>FIXED_STRING(&lt;N&gt;)</code> VID types are allowed. You must specify the VID type when creating a graph space, and use the same VID type in <code>INSERT</code> statements, otherwise, an error message <code>Wrong vertex id type: 1001</code> occurs.</li> </ul> <ul> <li>The length of the VID should not be longer than <code>N</code> characters. If it exceeds <code>N</code>, NebulaGraph throws <code>The VID must be a 64-bit integer or a string fitting space vertex id length limit.</code>.</li> </ul> </li> </ul> <ul> <li> <p>If the <code>Host not enough!</code> error appears, the immediate cause is that the number of online storage hosts is less than the value of <code>replica_factor</code> specified when creating a graph space. In this case, you can use the <code>SHOW HOSTS</code> command to see if the following situations occur:</p> <ul> <li>For the case where there is only one storage host in a cluster, the value of <code>replica_factor</code> can only be specified to <code>1</code>. Or create a graph space after storage hosts are scaled out. </li> </ul> <ul> <li>A new storage host is found, but <code>ADD HOSTS</code> is not executed to activate it. In this case, run <code>SHOW HOSTS</code> to locate the new storage host information and then run <code>ADD HOSTS</code> to activate it. A graph space can be created after there are enough storage hosts.</li> </ul> <ul> <li>For offline storage hosts after running <code>SHOW HOSTS</code>, troubleshooting is needed.</li> </ul> </li> </ul> <p>Legacy version compatibility</p> <p>For NebulaGraph v2.x before v2.5.0, <code>vid_type</code> is optional and defaults to <code>FIXED_STRING(8)</code>.</p> <p>Note</p> <p><code>graph_space_name</code>, <code>partition_num</code>, <code>replica_factor</code>, <code>vid_type</code>, and <code>comment</code> cannot be modified once set. To modify them, drop the current working graph space with <code>DROP SPACE</code> and create a new one with <code>CREATE SPACE</code>.</p>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/#clone_graph_spaces","title":"Clone graph spaces","text":"<pre><code>CREATE SPACE [IF NOT EXISTS] &lt;new_graph_space_name&gt; AS &lt;old_graph_space_name&gt;;\n</code></pre> Parameter Description <code>IF NOT EXISTS</code> Detects if the new graph space exists. If it does not exist, the new one will be created. The graph space existence detection here only compares the graph space name (excluding properties). <code>&lt;new_graph_space_name&gt;</code> The name of the graph space that is newly created.  By default, the space name only supports 1-4 byte UTF-8 encoded characters, including English letters (case sensitive), numbers, Chinese characters, etc. But special characters can only use underscore, and cannot start with a number. To use special characters, reserved keywords, or start with a number, quote the entire name with backticks (`) and cannot use periods (<code>.</code>). For more information, see Keywords and reserved words. When a new graph space is created, the schema of the old graph space <code>&lt;old_graph_space_name&gt;</code> will be cloned, including its parameters (the number of partitions and replicas, etc.), Tag, Edge type and native indexes. Note:1. If you name a space in Chinese and encounter a <code>SyntaxError</code>, you need to quote the Chinese characters with backticks (`). 2. To include a backtick (`) in a space name, use a backslash to escape the backtick, such as \\`; to include a backslash, the backslash itself also needs to be escaped, such as \\ . <code>&lt;old_graph_space_name&gt;</code> The name of the graph space that already exists."},{"location":"3.ngql-guide/9.space-statements/1.create-space/#examples","title":"Examples","text":"<pre><code># The following example creates a graph space with a specified VID type and the maximum length. Other fields still use the default values.\nnebula&gt; CREATE SPACE IF NOT EXISTS my_space_1 (vid_type=FIXED_STRING(30));\n\n# The following example creates a graph space with a specified partition number, replica number, and VID type.\nnebula&gt; CREATE SPACE IF NOT EXISTS my_space_2 (partition_num=15, replica_factor=1, vid_type=FIXED_STRING(30));\n\n#  The following example creates a graph space with a specified partition number, replica number, and VID type, and adds a comment on it.\nnebula&gt; CREATE SPACE IF NOT EXISTS my_space_3 (partition_num=15, replica_factor=1, vid_type=FIXED_STRING(30)) comment=\"Test the graph space\";\n\n# Clone a graph space.\nnebula&gt; CREATE SPACE IF NOT EXISTS my_space_4 as my_space_3;\nnebula&gt; SHOW CREATE SPACE my_space_4;\n+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Space        | Create Space                                                                                                                                                 |\n+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| \"my_space_4\" | \"CREATE SPACE `my_space_4` (partition_num = 15, replica_factor = 1, charset = utf8, collate = utf8_bin, vid_type = FIXED_STRING(30)) comment = '\u6d4b\u8bd5\u56fe\u7a7a\u95f4'\" |\n+--------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/#implementation_of_the_operation","title":"Implementation of the operation","text":"<p>Caution</p> <p>Trying to use a newly created graph space may fail because the creation is implemented asynchronously. To make sure the follow-up operations work as expected, Wait for two heartbeat cycles, i.e., 20 seconds. To change the heartbeat interval, modify the <code>heartbeat_interval_secs</code> parameter in the configuration files for all services. If the heartbeat interval is too short (i.e., less than 5 seconds), disconnection between peers may happen because of the misjudgment of machines in the distributed system.</p>"},{"location":"3.ngql-guide/9.space-statements/1.create-space/#check_partition_distribution","title":"Check partition distribution","text":"<p>On some large clusters, the partition distribution is possibly unbalanced because of the different startup times. You can run the following command to do a check of the machine distribution.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+-------------+------+----------+--------------+--------------------------------+--------------------------------+---------+\n| Host        | Port | Status   | Leader count | Leader distribution            | Partition distribution         | Version |\n+-------------+------+----------+--------------+--------------------------------+--------------------------------+---------+\n| \"storaged0\" | 9779 | \"ONLINE\" | 8            | \"basketballplayer:3, test:5\"   | \"basketballplayer:10, test:10\" | \"3.8.0\" |\n| \"storaged1\" | 9779 | \"ONLINE\" | 9            | \"basketballplayer:4, test:5\"   | \"basketballplayer:10, test:10\" | \"3.8.0\" |\n| \"storaged2\" | 9779 | \"ONLINE\" | 3            | \"basketballplayer:3\"           | \"basketballplayer:10, test:10\" | \"3.8.0\" |\n+-------------+------+----------+--------------+--------------------------------+--------------------------------+---------+\n</code></pre> <p>To balance the request loads, use the following command.</p> <pre><code>nebula&gt; BALANCE LEADER;\nnebula&gt; SHOW HOSTS;\n+-------------+------+----------+--------------+--------------------------------+--------------------------------+---------+\n| Host        | Port | HTTP port | Status   | Leader count | Leader distribution            | Partition distribution         | Version |\n+-------------+------+-----------+----------+--------------+--------------------------------+--------------------------------+---------+\n| \"storaged0\" | 9779 | \"ONLINE\" | 7            | \"basketballplayer:3, test:4\"   | \"basketballplayer:10, test:10\" | \"3.8.0\" |\n| \"storaged1\" | 9779 | \"ONLINE\" | 7            | \"basketballplayer:4, test:3\"   | \"basketballplayer:10, test:10\" | \"3.8.0\" |\n| \"storaged2\" | 9779 | \"ONLINE\" | 6            | \"basketballplayer:3, test:3\"   | \"basketballplayer:10, test:10\" | \"3.8.0\" |\n+-------------+------+----------+--------------+--------------------------------+--------------------------------+---------+\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/2.use-space/","title":"USE","text":"<p><code>USE</code> specifies a graph space as the current working graph space for subsequent queries.</p>"},{"location":"3.ngql-guide/9.space-statements/2.use-space/#prerequisites","title":"Prerequisites","text":"<p>Running the <code>USE</code> statement requires some privileges for the graph space. Otherwise, NebulaGraph throws an error.</p>"},{"location":"3.ngql-guide/9.space-statements/2.use-space/#syntax","title":"Syntax","text":"<pre><code>USE &lt;graph_space_name&gt;;\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/2.use-space/#examples","title":"Examples","text":"<pre><code># The following example creates two sample spaces.\nnebula&gt; CREATE SPACE IF NOT EXISTS space1 (vid_type=FIXED_STRING(30));\nnebula&gt; CREATE SPACE IF NOT EXISTS space2 (vid_type=FIXED_STRING(30));\n\n# The following example specifies space1 as the current working graph space.\nnebula&gt; USE space1;\n\n# The following example specifies space2 as the current working graph space. Hereafter, you cannot read any data from space1, because these vertices and edges being traversed have no relevance with space1.\nnebula&gt; USE space2;\n</code></pre> <p>Caution</p> <p>You cannot use two graph spaces in one statement.</p> <p>Different from Fabric Cypher, graph spaces in NebulaGraph are fully isolated from each other. Making a graph space as the working graph space prevents you from accessing other spaces. The only way to traverse in a new graph space is to switch by the <code>USE</code> statement. In Fabric Cypher, you can use two graph spaces in one statement (using the <code>USE + CALL</code> syntax). But in NebulaGraph, you can only use one graph space in one statement.</p>"},{"location":"3.ngql-guide/9.space-statements/3.show-spaces/","title":"SHOW SPACES","text":"<p><code>SHOW SPACES</code> lists all the graph spaces in the NebulaGraph examples.</p>"},{"location":"3.ngql-guide/9.space-statements/3.show-spaces/#syntax","title":"Syntax","text":"<pre><code>SHOW SPACES;\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/3.show-spaces/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW SPACES;\n+--------------------+\n| Name               |\n+--------------------+\n| \"cba\"              |\n| \"basketballplayer\" |\n+--------------------+\n</code></pre> <p>To create graph spaces, see CREATE SPACE.</p>"},{"location":"3.ngql-guide/9.space-statements/4.describe-space/","title":"DESCRIBE SPACE","text":"<p><code>DESCRIBE SPACE</code> returns the information about the specified graph space.</p>"},{"location":"3.ngql-guide/9.space-statements/4.describe-space/#syntax","title":"Syntax","text":"<p>You can use <code>DESC</code> instead of <code>DESCRIBE</code> for short.</p> <pre><code>DESC[RIBE] SPACE &lt;graph_space_name&gt;;\n</code></pre> <p>The <code>DESCRIBE SPACE</code> statement is different from the <code>SHOW SPACES</code> statement. For details about <code>SHOW SPACES</code>, see SHOW SPACES.</p>"},{"location":"3.ngql-guide/9.space-statements/4.describe-space/#example","title":"Example","text":"<pre><code>nebula&gt; DESCRIBE SPACE basketballplayer;\n+----+--------------------+------------------+----------------+---------+------------+--------------------+---------+\n| ID | Name               | Partition Number | Replica Factor | Charset | Collate    | Vid Type           | Comment |\n+----+--------------------+------------------+----------------+---------+------------+--------------------+---------+\n| 1  | \"basketballplayer\" | 10               | 1              | \"utf8\"  | \"utf8_bin\" | \"FIXED_STRING(32)\" |         |\n+----+--------------------+------------------+----------------+---------+------------+--------------------+---------+\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/5.drop-space/","title":"DROP SPACE","text":"<p><code>DROP SPACE</code> deletes the specified graph space and everything in it.</p> <p>Note</p> <p><code>DROP SPACE</code> can only delete the specified logic graph space while retain all the data on the hard disk by modifying the value of <code>auto_remove_invalid_space</code> to <code>false</code> in the Storage service configuration file. For more information, see Storage configuration.</p> <p>Warning</p> <p>After you execute <code>DROP SPACE</code>, even if the snapshot contains data of the graph space, the data of the graph space cannot be recovered.</p>"},{"location":"3.ngql-guide/9.space-statements/5.drop-space/#prerequisites","title":"Prerequisites","text":"<p>Only the God role can use the <code>DROP SPACE</code> statement. For more information, see AUTHENTICATION.</p>"},{"location":"3.ngql-guide/9.space-statements/5.drop-space/#syntax","title":"Syntax","text":"<pre><code>DROP SPACE [IF EXISTS] &lt;graph_space_name&gt;;\n</code></pre> <p>You can use the <code>IF EXISTS</code> keywords when dropping spaces. These keywords automatically detect if the related graph space exists. If it exists, it will be deleted. Otherwise, no graph space will be deleted.</p> <p>Legacy version compatibility</p> <p>In NebulaGraph versions earlier than 3.1.0, the <code>DROP SPACE</code> statement does not remove all the files and directories from the disk by default.</p> <p>Danger<p>BE CAUTIOUS about running the <code>DROP SPACE</code> statement.</p> </p>"},{"location":"3.ngql-guide/9.space-statements/5.drop-space/#faq","title":"FAQ","text":"<p>Q: Why is my disk space not freed after executing the 'DROP SPACE' statement and deleting a graph space?</p> <p>A: For NebulaGraph version earlier than 3.1.0, <code>DROP SPACE</code> can only delete the specified logic graph space and does not delete the files and directories on the disk. To delete the files and directories on the disk, manually delete the corresponding file path. The file path is located in <code>&lt;nebula_graph_install_path&gt;/data/storage/nebula/&lt;space_id&gt;</code>. The <code>&lt;space_id&gt;</code> can be viewed via <code>DESCRIBE SPACE {space_name}</code>.</p>"},{"location":"3.ngql-guide/9.space-statements/6.clear-space/","title":"CLEAR SPACE","text":"<p><code>CLEAR SPACE</code> deletes the vertices and edges in a graph space, but does not delete the graph space itself and the schema information.</p> <p>Note</p> <p>It is recommended to execute SUBMIT JOB COMPACT immediately after executing the <code>CLEAR SPACE</code> operation improve the query performance. Note that the COMPACT operation may affect query performance, and it is recommended to perform this operation during low business hours (e.g., early morning).</p>"},{"location":"3.ngql-guide/9.space-statements/6.clear-space/#permission_requirements","title":"Permission requirements","text":"<p>Only the God role has the permission to run <code>CLEAR SPACE</code>.</p>"},{"location":"3.ngql-guide/9.space-statements/6.clear-space/#caution","title":"Caution","text":"<ul> <li>Once cleared, the data CANNOT be recovered. Use <code>CLEAR SPACE</code> with caution.</li> <li><code>CLEAR SPACE</code> is not an atomic operation. If an error occurs, re-run <code>CLEAR SPACE</code> to avoid data remaining.</li> <li>The larger the amount of data in the graph space, the longer it takes to clear it. If the execution fails due to client connection timeout, increase the value of the <code>storage_client_timeout_ms</code> parameter in the Graph Service configuration.</li> <li>During the execution of <code>CLEAR SPACE</code>, writing data into the graph space is not automatically prohibited. Such write operations can result in incomplete data clearing, and the residual data can be damaged.</li> </ul> <p>Note</p> <p>The NebulaGraph Community Edition does not support blocking data writing while allowing <code>CLEAR SPACE</code>.</p>"},{"location":"3.ngql-guide/9.space-statements/6.clear-space/#syntax","title":"Syntax","text":"<pre><code>CLEAR SPACE [IF EXISTS] &lt;space_name&gt;;\n</code></pre> Parameter/Option Description <code>IF EXISTS</code> Check whether the graph space to be cleared exists. If it exists, continue to clear it. If it does not exist, the execution finishes, and a message indicating that the execution succeeded is displayed. If <code>IF EXISTS</code> is not set and the graph space does not exist, the <code>CLEAR SPACE</code> statement fails to execute, and an error occurs. <code>space_name</code> The name of the space to be cleared. <p>Example:</p> <pre><code>CLEAR SPACE basketballplayer;\n</code></pre>"},{"location":"3.ngql-guide/9.space-statements/6.clear-space/#data_reserved","title":"Data reserved","text":"<p><code>CLEAR SPACE</code> does not delete the following data in a graph space:</p> <ul> <li>Tag information.</li> <li>Edge type information.</li> <li>The metadata of native indexes and full-text indexes.</li> </ul> <p>The following example shows what <code>CLEAR SPACE</code> deletes and reserves.</p> <pre><code># Enter the graph space basketballplayer.\nnebula [(none)]&gt; use basketballplayer;\nExecution succeeded\n\n# List tags and Edge types.\nnebula[basketballplayer]&gt; SHOW TAGS;\n+----------+\n| Name     |\n+----------+\n| \"player\" |\n| \"team\"   |\n+----------+\nGot 2 rows\n\nnebula[basketballplayer]&gt; SHOW EDGES;\n+----------+\n| Name     |\n+----------+\n| \"follow\" |\n| \"serve\"  |\n+----------+\nGot 2 rows\n\n# Submit a job to make statistics of the graph space.\nnebula[basketballplayer]&gt; SUBMIT JOB STATS;\n+------------+\n| New Job Id |\n+------------+\n| 4          |\n+------------+\nGot 1 rows\n\n# Check the statistics.\nnebula[basketballplayer]&gt; SHOW STATS;\n+---------+------------+-------+\n| Type    | Name       | Count |\n+---------+------------+-------+\n| \"Tag\"   | \"player\"   | 51    |\n| \"Tag\"   | \"team\"     | 30    |\n| \"Edge\"  | \"follow\"   | 81    |\n| \"Edge\"  | \"serve\"    | 152   |\n| \"Space\" | \"vertices\" | 81    |\n| \"Space\" | \"edges\"    | 233   |\n+---------+------------+-------+\nGot 6 rows\n\n# List tag indexes.\nnebula[basketballplayer]&gt; SHOW TAG INDEXES;\n+------------------+----------+----------+\n| Index Name       | By Tag   | Columns  |\n+------------------+----------+----------+\n| \"player_index_0\" | \"player\" | []       |\n| \"player_index_1\" | \"player\" | [\"name\"] |\n+------------------+----------+----------+\nGot 2 rows\n\n# ----------------------- Dividing line for CLEAR SPACE -----------------------\n# Run CLEAR SPACE to clear the graph space basketballplayer.\nnebula[basketballplayer]&gt; CLEAR SPACE basketballplayer;\nExecution succeeded\n\n# Update the statistics.\nnebula[basketballplayer]&gt; SUBMIT JOB STATS;\n+------------+\n| New Job Id |\n+------------+\n| 5          |\n+------------+\nGot 1 rows\n\n# Check the statistics. The tags and edge types still exist, but all the vertices and edges are gone.\nnebula[basketballplayer]&gt; SHOW STATS;\n+---------+------------+-------+\n| Type    | Name       | Count |\n+---------+------------+-------+\n| \"Tag\"   | \"player\"   | 0     |\n| \"Tag\"   | \"team\"     | 0     |\n| \"Edge\"  | \"follow\"   | 0     |\n| \"Edge\"  | \"serve\"    | 0     |\n| \"Space\" | \"vertices\" | 0     |\n| \"Space\" | \"edges\"    | 0     |\n+---------+------------+-------+\nGot 6 rows\n\n# Try to list the tag indexes. They still exist.\nnebula[basketballplayer]&gt; SHOW TAG INDEXES;\n+------------------+----------+----------+\n| Index Name       | By Tag   | Columns  |\n+------------------+----------+----------+\n| \"player_index_0\" | \"player\" | []       |\n| \"player_index_1\" | \"player\" | [\"name\"] |\n+------------------+----------+----------+\nGot 2 rows (time spent 523/978 us)\n</code></pre>"},{"location":"4.deployment-and-installation/1.resource-preparations/","title":"Prepare resources for compiling, installing, and running NebulaGraph","text":"<p>This topic describes the requirements and suggestions for compiling and installing NebulaGraph, as well as how to estimate the resource you need to reserve for running a NebulaGraph cluster.</p>"},{"location":"4.deployment-and-installation/1.resource-preparations/#about_storage_devices","title":"About storage devices","text":"<p>NebulaGraph is designed and implemented for NVMe SSD. All default parameters are optimized for the SSD devices and require extremely high IOPS and low latency.</p> <ul> <li>Due to the poor IOPS capability and long random seek latency, HDD is not recommended. Users may encounter many problems when using HDD.</li> </ul> <ul> <li>Do not use remote storage devices, such as NAS or SAN. Do not connect an external virtual hard disk based on HDFS or Ceph.</li> </ul> <ul> <li>RAID is not recommended because NebulaGraph provides a multi-replica mechanism. Configuring RAID would result in a waste of resources.</li> </ul> <ul> <li>Use local SSD devices, or AWS Provisioned IOPS SSD equivalence.</li> </ul>"},{"location":"4.deployment-and-installation/1.resource-preparations/#about_cpu_architecture","title":"About CPU architecture","text":"<p>Starting with 3.0.2, you can run containerized NebulaGraph databases on Docker Desktop for ARM macOS or on ARM Linux servers. </p> <p>Caution</p> <p>We do not recommend you deploy NebulaGraph on Docker Desktop for Windows due to its subpar performance. For details, see #12401. </p>"},{"location":"4.deployment-and-installation/1.resource-preparations/#requirements_for_compiling_the_source_code","title":"Requirements for compiling the source code","text":""},{"location":"4.deployment-and-installation/1.resource-preparations/#hardware_requirements_for_compiling_nebulagraph","title":"Hardware requirements for compiling NebulaGraph","text":"Item Requirement CPU architecture x86_64 Memory 4 GB Disk 10 GB, SSD"},{"location":"4.deployment-and-installation/1.resource-preparations/#supported_operating_systems_for_compiling_nebulagraph","title":"Supported operating systems for compiling NebulaGraph","text":"<p>For now, we can only compile NebulaGraph in the Linux system. We recommend that you use any Linux system with kernel version <code>4.15</code> or above.</p> <p>Note</p> <p>To install NebulaGraph on Linux systems with kernel version lower than required, use RPM/DEB packages or TAR files.</p>"},{"location":"4.deployment-and-installation/1.resource-preparations/#software_requirements_for_compiling_nebulagraph","title":"Software requirements for compiling NebulaGraph","text":"<p>You must have the correct version of the software listed below to compile NebulaGraph. If they are not as required or you are not sure, follow the steps in Prepare software for compiling NebulaGraph to get them ready.</p> Software Version Note glibc 2.17 or above You can run <code>ldd --version</code> to check the glibc version. make Any stable version - m4 Any stable version - git Any stable version - wget Any stable version - unzip Any stable version - xz Any stable version - readline-devel Any stable version - ncurses-devel Any stable version - zlib-devel Any stable version - g++ 8.5.0 or above You can run <code>gcc -v</code> to check the gcc version. cmake 3.14.0 or above You can run <code>cmake --version</code> to check the cmake version. curl Any stable version - redhat-lsb-core Any stable version - libstdc++-static Any stable version Only needed in CentOS 8+, RedHat 8+, and Fedora systems. libasan Any stable version Only needed in CentOS 8+, RedHat 8+, and Fedora systems. bzip2 Any stable version - <p>Other third-party software will be automatically downloaded and installed to the <code>build</code> directory at the configure (cmake) stage.</p>"},{"location":"4.deployment-and-installation/1.resource-preparations/#prepare_software_for_compiling_nebulagraph","title":"Prepare software for compiling NebulaGraph","text":"<p>If part of the dependencies are missing or the versions does not meet the requirements, manually install them with the following steps. You can skip unnecessary dependencies or steps according to your needs.</p> <ol> <li> <p>Install dependencies.</p> <ul> <li>For CentOS, RedHat, and Fedora users, run the following commands.<pre><code>$ yum update\n$ yum install -y make \\\n                 m4 \\\n                 git \\\n                 wget \\\n                 unzip \\\n                 xz \\\n                 readline-devel \\\n                 ncurses-devel \\\n                 zlib-devel \\\n                 gcc \\\n                 gcc-c++ \\\n                 cmake \\\n                 curl \\\n                 redhat-lsb-core \\\n                 bzip2\n  // For CentOS 8+, RedHat 8+, and Fedora, install libstdc++-static and libasan as well\n$ yum install -y libstdc++-static libasan\n</code></pre> </li> </ul> <ul> <li>For Debian and Ubuntu users, run the following commands.<pre><code>$ apt-get update\n$ apt-get install -y make \\\n                     m4 \\\n                     git \\\n                     wget \\\n                     unzip \\\n                     xz-utils \\\n                     curl \\\n                     lsb-core \\\n                     build-essential \\\n                     libreadline-dev \\\n                     ncurses-dev \\\n                     cmake \\\n                     bzip2\n</code></pre> </li> </ul> </li> <li> <p>Check if the GCC and cmake on your host are in the right version. See Software requirements for compiling NebulaGraph for the required versions.</p> <pre><code>$ g++ --version\n$ cmake --version\n</code></pre> <p>If your GCC and CMake are in the right versions, then you are all set and you can ignore the subsequent steps. If they are not, select and perform the needed steps as follows.</p> </li> <li> <p>If the CMake version is incorrect, visit the CMake official website to install the required version.</p> </li> <li> <p>If the G++ version is incorrect, visit the G++ official website or follow the instructions below to to install the required version.</p> <ul> <li> <p>For CentOS users, run:</p> <pre><code>yum install centos-release-scl\nyum install devtoolset-11\nscl enable devtoolset-11 'bash'\n</code></pre> </li> </ul> <ul> <li> <p>For Ubuntu users, run:</p> <pre><code>add-apt-repository ppa:ubuntu-toolchain-r/test\napt install gcc-11 g++-11\n</code></pre> </li> </ul> </li> </ol>"},{"location":"4.deployment-and-installation/1.resource-preparations/#requirements_and_suggestions_for_installing_nebulagraph_in_test_environments","title":"Requirements and suggestions for installing NebulaGraph in test environments","text":""},{"location":"4.deployment-and-installation/1.resource-preparations/#hardware_requirements_for_test_environments","title":"Hardware requirements for test environments","text":"Item Requirement CPU architecture x86_64 Number of CPU core 4 Memory 8 GB Disk 100 GB, SSD"},{"location":"4.deployment-and-installation/1.resource-preparations/#supported_operating_systems_for_test_environments","title":"Supported operating systems for test environments","text":"<p>For now, we can only install NebulaGraph in the Linux system. To install NebulaGraph in a test environment, we recommend that you use any Linux system with kernel version <code>3.9</code> or above.</p>"},{"location":"4.deployment-and-installation/1.resource-preparations/#suggested_service_architecture_for_test_environments","title":"Suggested service architecture for test environments","text":"Process Suggested number metad (the metadata service process) 1 storaged (the storage service process) 1 or more graphd (the query engine service process) 1 or more <p>For example, for a single-machine test environment, you can deploy 1 metad, 1 storaged, and 1 graphd processes in the machine.</p> <p>For a more common test environment, such as a cluster of 3 machines (named as A, B, and C), you can deploy NebulaGraph as follows:</p> Machine name Number of metad Number of storaged Number of graphd A 1 1 1 B None 1 1 C None 1 1"},{"location":"4.deployment-and-installation/1.resource-preparations/#requirements_and_suggestions_for_installing_nebulagraph_in_production_environments","title":"Requirements and suggestions for installing NebulaGraph in production environments","text":""},{"location":"4.deployment-and-installation/1.resource-preparations/#hardware_requirements_for_production_environments","title":"Hardware requirements for production environments","text":"Item Requirement CPU architecture x86_64 Number of CPU core 48 Memory 256 GB Disk 2 * 1.6 TB, NVMe SSD"},{"location":"4.deployment-and-installation/1.resource-preparations/#supported_operating_systems_for_production_environments","title":"Supported operating systems for production environments","text":"<p>For now, we can only install NebulaGraph in the Linux system. To install NebulaGraph in a production environment, we recommend that you use any Linux system with kernel version 3.9 or above.</p> <p>Users can adjust some of the kernel parameters to better accommodate the need for running NebulaGraph. For more information, see kernel configuration.</p>"},{"location":"4.deployment-and-installation/1.resource-preparations/#suggested_service_architecture_for_production_environments","title":"Suggested service architecture for production environments","text":"<p>Danger</p> <p>DO NOT deploy a single cluster across IDCs (The Enterprise Edtion supports data synchronization between clusters across IDCs).</p> Process Suggested number metad (the metadata service process) 3 storaged (the storage service process) 3 or more graphd (the query engine service process) 3 or more <p>Each metad process automatically creates and maintains a replica of the metadata. Usually, you need to deploy three metad processes and only three.</p> <p>The number of storaged processes does not affect the number of graph space replicas.</p> <p>Users can deploy multiple processes on a single machine. For example, on a cluster of 5 machines (named as A, B, C, D, and E), you can deploy NebulaGraph as follows:</p> Machine name Number of metad Number of storaged Number of graphd A 1 1 1 B 1 1 1 C 1 1 1 D None 1 1 E None 1 1"},{"location":"4.deployment-and-installation/1.resource-preparations/#capacity_requirements_for_running_a_nebulagraph_cluster","title":"Capacity requirements for running a NebulaGraph cluster","text":"<p>Users can estimate the memory, disk space, and partition number needed for a NebulaGraph cluster of 3 replicas as follows.</p> Resource Unit How to estimate Description Disk space for a cluster Bytes <code>the_sum_of_edge_number_and_vertex_number</code> * <code>average_bytes_of_properties</code> * 7.5 * 120% For more information, see Edge partitioning and storage amplification. Memory for a cluster Bytes [<code>the_sum_of_edge_number_and_vertex_number</code> * 16 + <code>the_number_of_RocksDB_instances</code> * (<code>write_buffer_size</code> * <code>max_write_buffer_number</code>) + <code>rocksdb_block_cache</code>] * 120% <code>write_buffer_size</code> and <code>max_write_buffer_number</code> are RocksDB parameters. For more information, see MemTable. For details about <code>rocksdb_block_cache</code>, see Memory usage in RocksDB. Number of partitions for a graph space - <code>the_number_of_disks_in_the_cluster</code> * <code>disk_partition_num_multiplier</code> <code>disk_partition_num_multiplier</code> is an integer between 2 and 20 (both including). Its value depends on the disk performance. Use 20 for SSD and 2 for HDD. <ul> <li>Question 1: Why do I need to multiply by 7.5 in the disk space estimation formula?<p>Answer: On one hand, the data in one single replica takes up about 2.5 times more space than that of the original data file (csv) according to test values.    On the other hand, indexes take up additional space. Each indexed vertex or edge takes up 16 bytes of memory. The hard disk space occupied by the index can be empirically estimated as the total number of indexed vertices or edges * 50 bytes.</p> </li> </ul> <ul> <li>Question 2: Why do we multiply the disk space and memory by 120%?<p>Answer: The extra 20% is for buffer.</p> </li> </ul> <ul> <li> <p>Question 3: How to get the number of RocksDB instances?</p> <p>Answer: Each graph space corresponds to one RocksDB instance and each directory in the <code>--data_path</code> item in the <code>etc/nebula-storaged.conf</code> file corresponds to one RocksDB instance.    That is, the number of RocksDB instances = the number of directories * the number of graph spaces.</p> <p>Note</p> <p>Users can decrease the memory size occupied by the bloom filter by adding <code>--enable_partitioned_index_filter=true</code> in <code>etc/nebula-storaged.conf</code>. But it may decrease the read performance in some random-seek cases.</p> </li> </ul> <p>Caution</p> <p>Each RocksDB instance takes up about 70M of disk space even when no data has been written yet. One partition corresponds to one RocksDB instance, and when the partition setting is very large, for example, 100, the graph space takes up a lot of disk space after it is created.</p>"},{"location":"4.deployment-and-installation/4.uninstall-nebula-graph/","title":"Uninstall NebulaGraph","text":"<p>This topic describes how to uninstall NebulaGraph.</p> <p>Caution</p> <p>Before re-installing NebulaGraph on a machine, follow this topic to completely uninstall the old NebulaGraph, in case the remaining data interferes with the new services, including inconsistencies between Meta services.</p>"},{"location":"4.deployment-and-installation/4.uninstall-nebula-graph/#prerequisite","title":"Prerequisite","text":"<p>The NebulaGraph services should be stopped before the uninstallation. For more information, see Manage NebulaGraph services.</p>"},{"location":"4.deployment-and-installation/4.uninstall-nebula-graph/#step_1_delete_data_files_of_the_storage_and_meta_services","title":"Step 1: Delete data files of the Storage and Meta Services","text":"<p>If you have modified the <code>data_path</code> in the configuration files for the Meta Service and Storage Service, the directories where NebulaGraph stores data may not be in the installation path of NebulaGraph. Check the configuration files to confirm the data paths, and then manually delete the directories to clear all data.</p> <p>Note</p> <p>For a NebulaGraph cluster, delete the data files of all Storage and Meta servers.</p> <ol> <li> <p>Check the Storage Service disk settings. For example:</p> <pre><code>########## Disk ##########\n# Root data path. Split by comma. e.g. --data_path=/disk1/path1/,/disk2/path2/\n# One path per Rocksdb instance.\n--data_path=/nebula/data/storage\n</code></pre> </li> <li> <p>Check the Metad Service configurations and find the corresponding metadata directories.</p> </li> <li> <p>Delete the data and the directories found in step 2.</p> </li> </ol>"},{"location":"4.deployment-and-installation/4.uninstall-nebula-graph/#step_2_delete_the_installation_directories","title":"Step 2: Delete the installation directories","text":"<p>Note</p> <p>Delete all installation directories, including the <code>cluster.id</code> file in them.</p> <p>The default installation path is <code>/usr/local/nebula</code>, which is specified by <code>--prefix</code> while installing NebulaGraph.</p>"},{"location":"4.deployment-and-installation/4.uninstall-nebula-graph/#uninstall_nebulagraph_deployed_with_source_code","title":"Uninstall NebulaGraph deployed with source code","text":"<p>Find the installation directories of NebulaGraph, and delete them all.</p>"},{"location":"4.deployment-and-installation/4.uninstall-nebula-graph/#uninstall_nebulagraph_deployed_with_rpm_packages","title":"Uninstall NebulaGraph deployed with RPM packages","text":"<ol> <li> <p>Run the following command to get the NebulaGraph version.</p> <pre><code>$ rpm -qa | grep \"nebula\"\n</code></pre> <p>The return message is as follows.</p> <pre><code>nebula-graph-3.8.0-1.x86_64\n</code></pre> </li> <li> <p>Run the following command to uninstall NebulaGraph.</p> <pre><code>sudo rpm -e &lt;nebula_version&gt;\n</code></pre> <p>For example:</p> <pre><code>sudo rpm -e nebula-graph-3.8.0-1.x86_64\n</code></pre> </li> <li> <p>Delete the installation directories.</p> </li> </ol>"},{"location":"4.deployment-and-installation/4.uninstall-nebula-graph/#uninstall_nebulagraph_deployed_with_deb_packages","title":"Uninstall NebulaGraph deployed with DEB packages","text":"<ol> <li> <p>Run the following command to get the NebulaGraph version.</p> <pre><code>$ dpkg -l | grep \"nebula\"\n</code></pre> <p>The return message is as follows.</p> <pre><code>ii  nebula-graph  3.8.0  amd64     NebulaGraph Package built using CMake\n</code></pre> </li> <li> <p>Run the following command to uninstall NebulaGraph.</p> <pre><code>sudo dpkg -r &lt;nebula_version&gt;\n</code></pre> <p>For example:</p> <pre><code>sudo dpkg -r nebula-graph\n</code></pre> </li> <li> <p>Delete the installation directories.</p> </li> </ol>"},{"location":"4.deployment-and-installation/4.uninstall-nebula-graph/#uninstall_nebulagraph_deployed_with_docker_compose","title":"Uninstall NebulaGraph deployed with Docker Compose","text":"<ol> <li> <p>In the <code>nebula-docker-compose</code> directory, run the following command to stop the NebulaGraph services.</p> <pre><code>docker-compose down -v\n</code></pre> </li> <li> <p>Delete the <code>nebula-docker-compose</code> directory.</p> </li> </ol>"},{"location":"4.deployment-and-installation/connect-to-nebula-graph/","title":"Connect to NebulaGraph","text":"<p>This topic provides basic instruction on how to use the native CLI client NebulaGraph Console to connect to NebulaGraph.</p> <p>Caution</p> <p>When connecting to NebulaGraph for the first time, you must register the Storage Service before querying data.</p> <p>NebulaGraph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. For more information, see the client list.</p>"},{"location":"4.deployment-and-installation/connect-to-nebula-graph/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have started NebulaGraph services.</li> </ul> <ul> <li>The machine on which you plan to run NebulaGraph Console has network access to the Graph Service of NebulaGraph.</li> </ul> <ul> <li> <p>The NebulaGraph Console version is compatible with the NebulaGraph version.</p> <p>Note</p> <p>NebulaGraph Console and NebulaGraph of the same version number are the most compatible. There may be compatibility issues when connecting to NebulaGraph with a different version of NebulaGraph Console. The error message <code>incompatible version between client and server</code> is displayed when there is such an issue.</p> </li> </ul>"},{"location":"4.deployment-and-installation/connect-to-nebula-graph/#steps","title":"Steps","text":"<ol> <li> <p>On the NebulaGraph Console releases page, select a NebulaGraph Console version and click Assets.</p> <p>Note</p> <p>It is recommended to select the latest version.</p> </li> <li> <p>In the Assets area, find the correct binary file for the machine where you want to run NebulaGraph Console and download the file to the machine.</p> </li> <li> <p>(Optional) Rename the binary file to <code>nebula-console</code> for convenience.</p> <p>Note</p> <p>For Windows, rename the file to <code>nebula-console.exe</code>.</p> </li> <li> <p>On the machine to run NebulaGraph Console, grant the execute permission of the nebula-console binary file to the user.</p> <p>Note</p> <p>For Windows, skip this step.</p> <pre><code>$ chmod 111 nebula-console\n</code></pre> </li> <li> <p>In the command line interface, change the working directory to the one where the nebula-console binary file is stored.</p> </li> <li> <p>Run the following command to connect to NebulaGraph.</p> <ul> <li>For Linux or macOS:</li> </ul> <pre><code>$ ./nebula-console -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <ul> <li>For Windows:</li> </ul> <pre><code>&gt; nebula-console.exe -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <p>Parameter descriptions are as follows:</p> Parameter Description <code>-h/-help</code> Shows the help menu. <code>-addr/-address</code> Sets the IP (or hostname) of the Graph service. The default address is 127.0.0.1.  <code>-P/-port</code> Sets the port number of the graphd service. The default port number is 9669. <code>-u/-user</code> Sets the username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is <code>root</code>. <code>-p/-password</code> Sets the password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password. <code>-t/-timeout</code> Sets an integer-type timeout threshold of the connection. The unit is millisecond. The default value is 120. <code>-e/-eval</code> Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned. <code>-f/-file</code> Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. The result will be returned and the connection stops then. <code>-enable_ssl</code> Enables SSL encryption when connecting to NebulaGraph. <code>-ssl_root_ca_path</code> Sets the storage path of the certification authority file. <code>-ssl_cert_path</code> Sets the storage path of the certificate file. <code>-ssl_private_key_path</code> Sets the storage path of the private key file. <p>For information on more parameters, see the project repository.</p> </li> </ol>"},{"location":"4.deployment-and-installation/manage-service/","title":"Manage NebulaGraph Service","text":"<p>NebulaGraph supports managing services with scripts. </p>"},{"location":"4.deployment-and-installation/manage-service/#manage_services_with_script","title":"Manage services with script","text":"<p>You can use the <code>nebula.service</code> script to start, stop, restart, terminate, and check the NebulaGraph services.</p> <p>Note</p> <p><code>nebula.service</code> is stored in the <code>/usr/local/nebula/scripts</code> directory by default. If you have customized the path, use the actual path in your environment.</p>"},{"location":"4.deployment-and-installation/manage-service/#syntax","title":"Syntax","text":"<pre><code>$ sudo /usr/local/nebula/scripts/nebula.service\n[-v] [-c &lt;config_file_path&gt;]\n&lt;start | stop | restart | kill | status&gt;\n&lt;metad | graphd | storaged | all&gt;\n</code></pre> Parameter Description <code>-v</code> Display detailed debugging information. <code>-c</code> Specify the configuration file path. The default path is <code>/usr/local/nebula/etc/</code>. <code>start</code> Start the target services. <code>stop</code> Stop the target services. <code>restart</code> Restart the target services. <code>kill</code> Terminate the target services. <code>status</code> Check the status of the target services. <code>metad</code> Set the Meta Service as the target service. <code>graphd</code> Set the Graph Service as the target service. <code>storaged</code> Set the Storage Service as the target service. <code>all</code> Set all the NebulaGraph services as the target services."},{"location":"4.deployment-and-installation/manage-service/#start_nebulagraph","title":"Start NebulaGraph","text":"<p>Run the following command to start NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service start all\n[INFO] Starting nebula-metad...\n[INFO] Done\n[INFO] Starting nebula-graphd...\n[INFO] Done\n[INFO] Starting nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"4.deployment-and-installation/manage-service/#stop_nebulagraph","title":"Stop NebulaGraph","text":"<p>Danger</p> <p>Do not run <code>kill -9</code> to forcibly terminate the processes. Otherwise, there is a low probability of data loss.</p> <p>Run the following command to stop NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service stop all\n[INFO] Stopping nebula-metad...\n[INFO] Done\n[INFO] Stopping nebula-graphd...\n[INFO] Done\n[INFO] Stopping nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"4.deployment-and-installation/manage-service/#check_the_service_status","title":"Check the service status","text":"<p>Run the following command to check the service status of NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service status all\n</code></pre> <ul> <li> <p>NebulaGraph is running normally if the following information is returned.</p> <pre><code>INFO] nebula-metad(33fd35e): Running as 29020, Listening on 9559\n[INFO] nebula-graphd(33fd35e): Running as 29095, Listening on 9669\n[WARN] nebula-storaged after v3.0.0 will not start service until it is added to cluster.\n[WARN] See Manage Storage hosts:ADD HOSTS in https://docs.nebula-graph.io/\n[INFO] nebula-storaged(33fd35e): Running as 29147, Listening on 9779\n</code></pre> <p>Note</p> <p>After starting NebulaGraph, the port of the <code>nebula-storaged</code> process is shown in red. Because the <code>nebula-storaged</code> process waits for the <code>nebula-metad</code> to add the current Storage service during the startup process. The Storage works after it receives the ready signal. Starting from NebulaGraph 3.0.0, the Meta service cannot directly read or write data in the Storage service that you add in the configuration file. The configuration file only registers the Storage service to the Meta service. You must run the <code>ADD HOSTS</code> command to enable the Meta to read and write data in the Storage service. For more information, see Manage Storage hosts.</p> </li> </ul> <ul> <li>If the returned result is similar to the following one, there is a problem. You may also go to the NebulaGraph community for help.<pre><code>[INFO] nebula-metad: Running as 25600, Listening on 9559\n[INFO] nebula-graphd: Exited\n[INFO] nebula-storaged: Running as 25646, Listening on 9779\n</code></pre> </li> </ul> <p>The NebulaGraph services consist of the Meta Service, Graph Service, and Storage Service. The configuration files for all three services are stored in the <code>/usr/local/nebula/etc/</code> directory by default. You can check the configuration files according to the returned result to troubleshoot problems.</p>"},{"location":"4.deployment-and-installation/manage-service/#next_to_do","title":"Next to do","text":"<p>Connect to NebulaGraph</p>"},{"location":"4.deployment-and-installation/manage-storage-host/","title":"Manage Storage hosts","text":"<p>Starting from NebulaGraph 3.0.0, setting Storage hosts in the configuration files only registers the hosts on the Meta side, but does not add them into the cluster. You must run the <code>ADD HOSTS</code> statement to add the Storage hosts.</p> <p>Note</p> <p>NebulaGraph Cloud clusters add Storage hosts automatically. Cloud users do not need to manually run <code>ADD HOSTS</code>.</p>"},{"location":"4.deployment-and-installation/manage-storage-host/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have connected to the NebulaGraph database.</li> </ul>"},{"location":"4.deployment-and-installation/manage-storage-host/#add_storage_hosts","title":"Add Storage hosts","text":"<p>Add the Storage hosts to a NebulaGraph cluster.</p> <pre><code>nebula&gt; ADD HOSTS &lt;ip&gt;:&lt;port&gt; [,&lt;ip&gt;:&lt;port&gt; ...];\nnebula&gt; ADD HOSTS \"&lt;hostname&gt;\":&lt;port&gt; [,\"&lt;hostname&gt;\":&lt;port&gt; ...];\n</code></pre> <p>Note</p> <ul> <li>To make sure the follow-up operations work as expected, wait for two heartbeat cycles, i.e., 20 seconds, and then run <code>SHOW HOSTS</code> to check whether the host is online.</li> </ul> <ul> <li>Make sure that the IP address and port number are the same as those in the configuration file. For example, the default IP address and port number in standalone deployment are <code>127.0.0.1:9779</code>.</li> </ul> <ul> <li>When using a domain name, enclose it in quotation marks, for example, <code>ADD HOSTS \"foo-bar\":9779</code>.</li> </ul> <ul> <li>Ensure that the storage host to be added is not used by any other cluster, otherwise, the storage adding operation will fail.</li> </ul>"},{"location":"4.deployment-and-installation/manage-storage-host/#drop_storage_hosts","title":"Drop Storage hosts","text":"<p>Delete the Storage hosts from cluster.</p> <p>Note</p> <p>You can not delete an in-use Storage host directly. Delete the associated graph space before deleting the Storage host.</p> <pre><code>nebula&gt; DROP HOSTS &lt;ip&gt;:&lt;port&gt; [,&lt;ip&gt;:&lt;port&gt; ...];\nnebula&gt; DROP HOSTS \"&lt;hostname&gt;\":&lt;port&gt; [,\"&lt;hostname&gt;\":&lt;port&gt; ...];\n</code></pre>"},{"location":"4.deployment-and-installation/manage-storage-host/#view_storage_hosts","title":"View Storage hosts","text":"<p>View the Storage hosts in the cluster.</p> <pre><code>nebula&gt; SHOW HOSTS STORAGE;\n+-------------+------+----------+-----------+--------------+---------+\n| Host        | Port | Status   | Role      | Git Info Sha | Version |\n+-------------+------+----------+-----------+--------------+---------+\n| \"storaged0\" | 9779 | \"ONLINE\" | \"STORAGE\" | \"3ba41bd\"    | \"3.8.0\" |\n| \"storaged1\" | 9779 | \"ONLINE\" | \"STORAGE\" | \"3ba41bd\"    | \"3.8.0\" |\n| \"storaged2\" | 9779 | \"ONLINE\" | \"STORAGE\" | \"3ba41bd\"    | \"3.8.0\" |\n+-------------+------+----------+-----------+--------------+---------+\n</code></pre>"},{"location":"4.deployment-and-installation/standalone-deployment/","title":"Standalone NebulaGraph","text":"<p>Standalone NebulaGraph merges the Meta, Storage, and Graph services into a single process deployed on a single machine. This topic introduces scenarios, deployment steps, etc. of standalone NebulaGraph.</p> <p>Danger</p> <p>Do not use standalone NebulaGraph in production environments. </p>"},{"location":"4.deployment-and-installation/standalone-deployment/#background","title":"Background","text":"<p>The traditional NebulaGraph consists of three services, each service having executable binary files and the corresponding process. Processes communicate with each other by RPC. In standalone NebulaGraph, the three processes corresponding to the three services are combined into one process. For more information about NebulaGraph, see Architecture overview.</p>"},{"location":"4.deployment-and-installation/standalone-deployment/#scenarios","title":"Scenarios","text":"<p>Small data sizes and low availability requirements. For example, test environments that are limited by the number of machines, scenarios that are only used to verify functionality.</p>"},{"location":"4.deployment-and-installation/standalone-deployment/#limitations","title":"Limitations","text":"<ul> <li>Single service instance per machine.</li> <li>High availability and reliability not supported.</li> </ul>"},{"location":"4.deployment-and-installation/standalone-deployment/#resource_requirements","title":"Resource requirements","text":"<p>For information about the resource requirements for standalone NebulaGraph, see Software requirements for compiling NebulaGraph.</p>"},{"location":"4.deployment-and-installation/standalone-deployment/#steps","title":"Steps","text":"<p>Currently, you can only install standalone NebulaGraph with the source code. The steps are similar to those of the multi-process NebulaGraph. You only need to modify the step Generate Makefile with CMake by adding <code>-DENABLE_STANDALONE_VERSION=on</code> to the command. For example:</p> <pre><code>cmake -DCMAKE_INSTALL_PREFIX=/usr/local/nebula -DENABLE_TESTING=OFF -DENABLE_STANDALONE_VERSION=on -DCMAKE_BUILD_TYPE=Release .. \n</code></pre> <p>For more information about installation details, see Install NebulaGraph by compiling the source code.</p> <p>After installing standalone NebulaGraph, see the topic connect to Service to connect to NebulaGraph databases.</p>"},{"location":"4.deployment-and-installation/standalone-deployment/#configuration_file","title":"Configuration file","text":"<p>The path to the configuration file for standalone NebulaGraph is <code>/usr/local/nebula/etc</code> by default.</p> <p>You can run <code>sudo cat nebula-standalone.conf.default</code> to see the file content. The parameters and the corresponding descriptions in the file are generally the same as the configurations for multi-process NebulaGraph except for the following parameters.</p> Parameter Predefined value Description <code>meta_port</code> <code>9559</code> The port number of the Meta service. <code>storage_port</code> <code>9779</code> The port number of the Storage Service. <code>meta_data_path</code> <code>data/meta</code> The path to Meta data. <p>You can run commands to check configurable parameters and the corresponding descriptions. For details, see Configurations.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/","title":"Install NebulaGraph by compiling the source code","text":"<p>Installing NebulaGraph from the source code allows you to customize the compiling and installation settings and test the latest features.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Users have to prepare correct resources described in Prepare resources for compiling, installing, and running NebulaGraph.</p> <p>Note</p> <p>Compilation of NebulaGraph offline is not currently supported.</p> </li> </ul> <ul> <li>The host to be installed with NebulaGraph has access to the Internet.</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#installation_steps","title":"Installation steps","text":"<ol> <li> <p>Use Git to clone the source code of NebulaGraph to the host.</p> <ul> <li> <p>[Recommended] To install NebulaGraph 3.8.0, run the following command.</p> <pre><code>$ git clone --branch release-3.6 https://github.com/vesoft-inc/nebula.git\n</code></pre> </li> </ul> <ul> <li> <p>To install the latest developing release, run the following command to clone the source code from the master branch.</p> <pre><code>$ git clone https://github.com/vesoft-inc/nebula.git\n</code></pre> </li> </ul> </li> <li> <p>Go to the <code>nebula/third-party</code> directory, and run the <code>install-third-party.sh</code> script to install the third-party libraries.</p> <pre><code>$ cd nebula/third-party\n$ ./install-third-party.sh\n</code></pre> </li> <li> <p>Go back to the <code>nebula</code> directory, create a directory named <code>build</code>, and enter the directory.</p> <pre><code>$ cd ..\n$ mkdir build &amp;&amp; cd build\n</code></pre> </li> <li> <p>Generate Makefile with CMake.</p> <p>Note</p> <p>The installation path is <code>/usr/local/nebula</code> by default. To customize it, add the <code>-DCMAKE_INSTALL_PREFIX=&lt;installation_path&gt;</code> CMake variable in the following command.</p> <p>For more information about CMake variables, see CMake variables.</p> <pre><code>$ cmake -DCMAKE_INSTALL_PREFIX=/usr/local/nebula -DENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=Release ..\n</code></pre> </li> <li> <p>Compile NebulaGraph.</p> <p>Note</p> <p>Check Prepare resources for compiling, installing, and running NebulaGraph.</p> <p>To speed up the compiling, use the <code>-j</code> option to set a concurrent number <code>N</code>. It should be \\(\\min(\\text{CPU core number},\\frac{\\text{the memory size(GB)}}{2})\\).</p> <pre><code>$ make -j{N} # E.g., make -j2\n</code></pre> </li> <li> <p>Install NebulaGraph.</p> <pre><code>$ sudo make install\n</code></pre> </li> </ol> <p>Note</p> <p>The configuration files in the <code>etc/</code> directory (<code>/usr/local/nebula/etc</code> by default) are references. Users can create their own configuration files accordingly. If you want to use the scripts in the <code>script</code> directory to start, stop, restart, and kill the service, and check the service status, the configuration files have to be named as <code>nebula-graph.conf</code>, <code>nebula-metad.conf</code>, and <code>nebula-storaged.conf</code>.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#update_the_master_branch","title":"Update the master branch","text":"<p>The source code of the master branch changes frequently. If the corresponding NebulaGraph release is installed, update it in the following steps.</p> <ol> <li> <p>In the <code>nebula</code> directory, run <code>git pull upstream master</code> to update the source code.</p> </li> <li> <p>In the <code>nebula/build</code> directory, run <code>make -j{N}</code> and <code>make install</code> again.</p> </li> </ol>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#next_to_do","title":"Next to do","text":"<p>Manage NebulaGraph services</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_variables","title":"CMake variables","text":""},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#usage_of_cmake_variables","title":"Usage of CMake variables","text":"<pre><code>$ cmake -D&lt;variable&gt;=&lt;value&gt; ...\n</code></pre> <p>The following CMake variables can be used at the configure (cmake) stage to adjust the compiling settings.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_install_prefix","title":"CMAKE_INSTALL_PREFIX","text":"<p><code>CMAKE_INSTALL_PREFIX</code> specifies the path where the service modules, scripts, configuration files are installed. The default path is <code>/usr/local/nebula</code>.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_werror","title":"ENABLE_WERROR","text":"<p><code>ENABLE_WERROR</code> is <code>ON</code> by default and it makes all warnings into errors. You can set it to <code>OFF</code> if needed.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_testing","title":"ENABLE_TESTING","text":"<p><code>ENABLE_TESTING</code> is <code>ON</code> by default and unit tests are built with the NebulaGraph services. If you just need the service modules, set it to <code>OFF</code>.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_asan","title":"ENABLE_ASAN","text":"<p><code>ENABLE_ASAN</code> is <code>OFF</code> by default and the building of ASan (AddressSanitizer), a memory error detector, is disabled. To enable it, set <code>ENABLE_ASAN</code> to <code>ON</code>. This variable is intended for NebulaGraph developers.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_build_type","title":"CMAKE_BUILD_TYPE","text":"<p>NebulaGraph supports the following building types of <code>MAKE_BUILD_TYPE</code>:</p> <ul> <li> <p><code>Debug</code></p> <p>The default value of <code>CMAKE_BUILD_TYPE</code>. It indicates building NebulaGraph with the debug info but not the optimization options.</p> </li> </ul> <ul> <li> <p><code>Release</code></p> <p>It indicates building NebulaGraph with the optimization options but not the debug info.</p> </li> </ul> <ul> <li> <p><code>RelWithDebInfo</code></p> <p>It indicates building NebulaGraph with the optimization options and the debug info.</p> </li> </ul> <ul> <li> <p><code>MinSizeRel</code></p> <p>It indicates building NebulaGraph with the optimization options for controlling the code size but not the debug info.</p> </li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_include_what_you_use","title":"ENABLE_INCLUDE_WHAT_YOU_USE","text":"<p><code>ENABLE_INCLUDE_WHAT_YOU_USE</code> is <code>OFF</code> by default. When set to <code>ON</code> and include-what-you-use is installed on the system, the system reports redundant headers contained in the project source code during makefile generation.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#nebula_use_linker","title":"NEBULA_USE_LINKER","text":"<p>Specifies the program linker on the system. The available values are:</p> <ul> <li><code>bfd</code>, the default value, indicates that ld.bfd is applied as the linker.</li> <li><code>lld</code>, indicates that ld.lld, if installed on the system, is applied as the linker.</li> <li><code>gold</code>, indicates that ld.gold, if installed on the system, is applied as the linker.</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#cmake_c_compilercmake_cxx_compiler","title":"CMAKE_C_COMPILER/CMAKE_CXX_COMPILER","text":"<p>Usually, CMake locates and uses a C/C++ compiler installed in the host automatically. But if your compiler is not installed at the standard path, or if you want to use a different one, run the command as follows to specify the installation path of the target compiler:</p> <pre><code>$ cmake -DCMAKE_C_COMPILER=&lt;path_to_gcc/bin/gcc&gt; -DCMAKE_CXX_COMPILER=&lt;path_to_gcc/bin/g++&gt; ..\n$ cmake -DCMAKE_C_COMPILER=&lt;path_to_clang/bin/clang&gt; -DCMAKE_CXX_COMPILER=&lt;path_to_clang/bin/clang++&gt; ..\n</code></pre>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#enable_ccache","title":"ENABLE_CCACHE","text":"<p><code>ENABLE_CCACHE</code> is <code>ON</code> by default and Ccache (compiler cache) is used to speed up the compiling of NebulaGraph.</p> <p>To disable <code>ccache</code>, setting <code>ENABLE_CCACHE</code> to <code>OFF</code> is not enough. On some platforms, the <code>ccache</code> installation hooks up or precedes the compiler. In such a case, you have to set an environment variable <code>export CCACHE_DISABLE=true</code> or add a line <code>disable=true</code> in <code>~/.ccache/ccache.conf</code> as well. For more information, see the ccache official documentation.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#nebula_thirdparty_root","title":"NEBULA_THIRDPARTY_ROOT","text":"<p><code>NEBULA_THIRDPARTY_ROOT</code> specifies the path where the third party software is installed. By default it is <code>/opt/vesoft/third-party</code>.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/1.install-nebula-graph-by-compiling-the-source-code/#examine_problems","title":"Examine problems","text":"<p>If the compiling fails, we suggest you:</p> <ol> <li> <p>Check whether the operating system release meets the requirements and whether the memory and hard disk space are sufficient.</p> </li> <li> <p>Check whether the third-party is installed correctly.</p> </li> <li> <p>Use <code>make -j1</code> to reduce the compiling concurrency.</p> </li> </ol>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/2.install-nebula-graph-by-rpm-or-deb/","title":"Install NebulaGraph with RPM or DEB package","text":"<p>RPM and DEB are common package formats on Linux systems. This topic shows how to quickly install NebulaGraph with the RPM or DEB package.</p> <p>Note</p> <p>The console is not complied or packaged with NebulaGraph server binaries. You can install nebula-console by yourself.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/2.install-nebula-graph-by-rpm-or-deb/#prerequisites","title":"Prerequisites","text":"<ul> <li>The tool <code>wget</code> is installed.</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/2.install-nebula-graph-by-rpm-or-deb/#step_1_download_the_package_from_cloud_service","title":"Step 1: Download the package from cloud service","text":"<p>Note</p> <p>NebulaGraph is currently only supported for installation on Linux systems, and only CentOS 7.x, CentOS 8.x, Ubuntu 16.04, Ubuntu 18.04, and Ubuntu 20.04 operating systems are supported. </p> <ul> <li>Download the released version.<p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the release package <code>3.8.0</code> for <code>Centos 7.5</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>Download the release package <code>3.8.0</code> for <code>Ubuntu 1804</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul> <ul> <li> <p>Download the nightly version.</p> <p>Danger</p> <ul> <li>Nightly versions are usually used to test new features. Do not use it in a production environment.</li> <li>Nightly versions may not be built successfully every night. And the names may change from day to day.</li> </ul> <p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the <code>Centos 7.5</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>For example, download the <code>Ubuntu 1804</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/2.install-nebula-graph-by-rpm-or-deb/#step_2_install_nebulagraph","title":"Step 2: Install NebulaGraph","text":"<ul> <li> <p>Use the following syntax to install with an RPM package.</p> <pre><code>$ sudo rpm -ivh --prefix=&lt;installation_path&gt; &lt;package_name&gt;\n</code></pre> <p>The option <code>--prefix</code> indicates the installation path. The default path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install an RPM package in the default path for the 3.8.0 version, run the following command.</p> <pre><code>sudo rpm -ivh nebula-graph-3.8.0.el7.x86_64.rpm\n</code></pre> </li> </ul> <ul> <li> <p>Use the following syntax to install with a DEB package.</p> <pre><code>$ sudo dpkg -i &lt;package_name&gt;\n</code></pre> <p>Note</p> <p>Customizing the installation path is not supported when installing NebulaGraph with a DEB package. The default installation path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install a DEB package for the 3.8.0 version, run the following command.</p> <pre><code>sudo dpkg -i nebula-graph-3.8.0.ubuntu1804.amd64.deb\n</code></pre> <p>Note</p> <p>The default installation path is <code>/usr/local/nebula/</code>.</p> </li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/2.install-nebula-graph-by-rpm-or-deb/#next_to_do","title":"Next to do","text":"<ul> <li>Start NebulaGraph </li> </ul> <ul> <li>Connect to NebulaGraph</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/","title":"Deploy NebulaGraph with Docker Compose","text":"<p>Using Docker Compose can quickly deploy NebulaGraph services based on the prepared configuration file. It is only recommended to use this method when testing functions of NebulaGraph.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>You have installed the following applications on your host.</p> Application Recommended version Official installation reference Docker Latest Install Docker Engine Docker Compose Latest Install Docker Compose Git Latest Download Git </li> </ul> <ul> <li>If you are deploying NebulaGraph as a non-root user, grant the user with Docker-related privileges. For detailed instructions, see Manage Docker as a non-root user.</li> </ul> <ul> <li>You have started the Docker service on your host.</li> </ul> <ul> <li>If you have already deployed another version of NebulaGraph with Docker Compose on your host, to avoid compatibility issues, you need to delete the <code>nebula-docker-compose/data</code> directory.</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#deploy_nebulagraph","title":"Deploy NebulaGraph","text":"<ol> <li> <p>Clone the <code>3.8.0</code> branch of the <code>nebula-docker-compose</code> repository to your host with Git.</p> <p>Danger</p> <p>The <code>master</code> branch contains the untested code for the latest NebulaGraph development release. DO NOT use this release in a production environment.</p> <pre><code>$ git clone -b release-3.8 https://github.com/vesoft-inc/nebula-docker-compose.git\n</code></pre> <p>Note</p> <p>The <code>x.y</code> version of Docker Compose aligns to the <code>x.y</code> version of NebulaGraph. For the NebulaGraph <code>z</code> version, Docker Compose does not publish the corresponding <code>z</code> version, but pulls the <code>z</code> version of the NebulaGraph image.</p> </li> <li> <p>Go to the <code>nebula-docker-compose</code> directory.</p> <pre><code>$ cd nebula-docker-compose/\n</code></pre> </li> <li> <p>Run the following command to start all the NebulaGraph services.</p> <p>Note</p> <ul> <li>Update the NebulaGraph images and NebulaGraph Console images first if they are out of date.</li> <li>The return result after executing the command varies depending on the installation directory.</li> </ul> <pre><code>[nebula-docker-compose]$ docker-compose up -d\nCreating nebula-docker-compose_metad0_1 ... done\nCreating nebula-docker-compose_metad2_1 ... done\nCreating nebula-docker-compose_metad1_1 ... done\nCreating nebula-docker-compose_graphd2_1   ... done\nCreating nebula-docker-compose_graphd_1    ... done\nCreating nebula-docker-compose_graphd1_1   ... done\nCreating nebula-docker-compose_storaged0_1 ... done\nCreating nebula-docker-compose_storaged2_1 ... done\nCreating nebula-docker-compose_storaged1_1 ... done\n</code></pre> <p>Compatibility</p> <p>Starting from NebulaGraph version 3.1.0, nebula-docker-compose automatically starts a NebulaGraph Console docker container and adds the storage host to the cluster (i.e. <code>ADD HOSTS</code> command).</p> <p>Note</p> <p>For more information of the preceding services, see NebulaGraph architecture.</p> </li> </ol>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#connect_to_nebulagraph","title":"Connect to NebulaGraph","text":"<p>There are two ways to connect to NebulaGraph:</p> <ul> <li>Connected with Nebula Console outside the container. Because the external mapping port for the Graph service is also fixed as <code>9669</code> in the container's configuration file, you can connect directly through the default port. For details, see Connect to NebulaGraph.</li> </ul> <ul> <li>Log into the container installed NebulaGraph Console, then connect to the Graph service. This section describes this approach.</li> </ul> <ol> <li> <p>Run the following command to view the name of NebulaGraph Console docker container.</p> <pre><code>$ docker-compose ps\n            Name                             Command                  State                                        Ports                                 \n-----------------------------------------------------------------------------------------------------------------------------------------------------------\nnebula-docker-compose_console_1     sh -c for i in `seq 1 60`; ...   Up                                                                                    \nnebula-docker-compose_graphd1_1     /usr/local/nebula/bin/nebu ...   Up (healthy)   0.0.0.0:32847-&gt;15669/tcp,:::32847-&gt;15669/tcp, 19669/tcp,               \n                                                                                    0.0.0.0:32846-&gt;19670/tcp,:::32846-&gt;19670/tcp,                          \n                                                                                    0.0.0.0:32849-&gt;5669/tcp,:::32849-&gt;5669/tcp, 9669/tcp         \n......\n</code></pre> <p>Note</p> <p><code>nebula-docker-compose_console_1</code> and <code>nebula-docker-compose_graphd1_1</code> are the container names of NebulaGraph Console and Graph Service respectively.</p> </li> <li> <p>Run the following command to enter the NebulaGraph Console docker container.</p> <pre><code>docker exec -it nebula-docker-compose_console_1 /bin/sh\n/ #\n</code></pre> </li> <li> <p>Connect to NebulaGraph with NebulaGraph Console.</p> <pre><code>/ # ./usr/local/bin/nebula-console -u &lt;user_name&gt; -p &lt;password&gt; --address=graphd --port=9669\n</code></pre> <p>Note</p> <p>By default, the authentication is off, you can only log in with an existing username (the default is <code>root</code>) and any password. To turn it on, see Enable authentication.</p> </li> <li> <p>Run the following commands to view the cluster state.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+-------------+------+----------+--------------+----------------------+------------------------+---------+\n| Host        | Port | Status   | Leader count | Leader distribution  | Partition distribution | Version |\n+-------------+------+----------+--------------+----------------------+------------------------+---------+\n| \"storaged0\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n| \"storaged1\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n| \"storaged2\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n+-------------+------+----------+--------------+----------------------+------------------------+---------+\n</code></pre> </li> </ol> <p>Run <code>exit</code> twice to switch back to your terminal (shell).</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#check_the_nebulagraph_service_status_and_ports","title":"Check the NebulaGraph service status and ports","text":"<p>Run <code>docker-compose ps</code> to list all the services of NebulaGraph and their status and ports.</p> <p>Note</p> <p>NebulaGraph provides services to the clients through port <code>9669</code> by default. To use other ports, modify the <code>docker-compose.yaml</code> file in the <code>nebula-docker-compose</code> directory and restart the NebulaGraph services.</p> <pre><code>$ docker-compose ps\nnebula-docker-compose_console_1     sh -c sleep 3 &amp;&amp;                 Up\n                                  nebula-co ...\nnebula-docker-compose_graphd1_1     /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49174-&gt;19669/tcp,:::49174-&gt;19669/tcp, 0.0.0.0:49171-&gt;19670/tcp,:::49171-&gt;19670/tcp, 0.0.0.0:49177-&gt;9669/tcp,:::49177-&gt;9669/tcp\nnebula-docker-compose_graphd2_1     /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49175-&gt;19669/tcp,:::49175-&gt;19669/tcp, 0.0.0.0:49172-&gt;19670/tcp,:::49172-&gt;19670/tcp, 0.0.0.0:49178-&gt;9669/tcp,:::49178-&gt;9669/tcp\nnebula-docker-compose_graphd_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49180-&gt;19669/tcp,:::49180-&gt;19669/tcp, 0.0.0.0:49179-&gt;19670/tcp,:::49179-&gt;19670/tcp, 0.0.0.0:9669-&gt;9669/tcp,:::9669-&gt;9669/tcp\nnebula-docker-compose_metad0_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49157-&gt;19559/tcp,:::49157-&gt;19559/tcp, 0.0.0.0:49154-&gt;19560/tcp,:::49154-&gt;19560/tcp, 0.0.0.0:49160-&gt;9559/tcp,:::49160-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_metad1_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49156-&gt;19559/tcp,:::49156-&gt;19559/tcp, 0.0.0.0:49153-&gt;19560/tcp,:::49153-&gt;19560/tcp, 0.0.0.0:49159-&gt;9559/tcp,:::49159-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_metad2_1      /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49158-&gt;19559/tcp,:::49158-&gt;19559/tcp, 0.0.0.0:49155-&gt;19560/tcp,:::49155-&gt;19560/tcp, 0.0.0.0:49161-&gt;9559/tcp,:::49161-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_storaged0_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49166-&gt;19779/tcp,:::49166-&gt;19779/tcp, 0.0.0.0:49163-&gt;19780/tcp,:::49163-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49169-&gt;9779/tcp,:::49169-&gt;9779/tcp, 9780/tcp\nnebula-docker-compose_storaged1_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49165-&gt;19779/tcp,:::49165-&gt;19779/tcp, 0.0.0.0:49162-&gt;19780/tcp,:::49162-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49168-&gt;9779/tcp,:::49168-&gt;9779/tcp, 9780/tcp\nnebula-docker-compose_storaged2_1   /usr/local/nebula/bin/nebu ...   Up      0.0.0.0:49167-&gt;19779/tcp,:::49167-&gt;19779/tcp, 0.0.0.0:49164-&gt;19780/tcp,:::49164-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:49170-&gt;9779/tcp,:::49170-&gt;9779/tcp, 9780/tcp\n</code></pre> <p>If the service is abnormal, you can first confirm the abnormal container name (such as <code>nebula-docker-compose_graphd2_1</code>) and then log in to the container and troubleshoot.</p> <pre><code>$ docker exec -it nebula-docker-compose_graphd2_1 bash\n</code></pre>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#check_the_service_data_and_logs","title":"Check the service data and logs","text":"<p>All the data and logs of NebulaGraph are stored persistently in the <code>nebula-docker-compose/data</code> and <code>nebula-docker-compose/logs</code> directories.</p> <p>The structure of the directories is as follows:</p> <pre><code>nebula-docker-compose/\n  |-- docker-compose.yaml\n  \u251c\u2500\u2500 data\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta0\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta1\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 meta2\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 storage0\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 storage1\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 storage2\n  \u2514\u2500\u2500 logs\n      \u251c\u2500\u2500 graph\n      \u251c\u2500\u2500 graph1\n      \u251c\u2500\u2500 graph2\n      \u251c\u2500\u2500 meta0\n      \u251c\u2500\u2500 meta1\n      \u251c\u2500\u2500 meta2\n      \u251c\u2500\u2500 storage0\n      \u251c\u2500\u2500 storage1\n      \u2514\u2500\u2500 storage2\n</code></pre>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#modify_configurations","title":"Modify configurations","text":"<p>The configuration file of Docker Compose is <code>nebula-docker-compose/docker-compose.yaml</code>. To make the new configuration take effect, modify the configuration in this file and restart the service.</p> <p>The configurations in the <code>docker-compose.yaml</code> file overwrite the configurations in the configuration file (<code>/usr/local/nebula/etc</code>) of the containered NebulaGraph service. Therefore, you can modify the configurations in the <code>docker-compose.yaml</code> file to customize the configurations of the NebulaGraph service.</p> <p>For more instructions, see Configurations.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#restart_nebulagraph_services","title":"Restart NebulaGraph services","text":"<p>To restart all the NebulaGraph services, run the following command:</p> <pre><code>$ docker-compose restart\nRestarting nebula-docker-compose_console_1   ... done\nRestarting nebula-docker-compose_graphd_1    ... done\nRestarting nebula-docker-compose_graphd1_1   ... done\nRestarting nebula-docker-compose_graphd2_1   ... done\nRestarting nebula-docker-compose_storaged1_1 ... done\nRestarting nebula-docker-compose-storaged0_1 ... done\nRestarting nebula-docker-compose_storaged2_1 ... done\nRestarting nebula-docker-compose_metad1_1    ... done\nRestarting nebula-docker-compose_metad2_1    ... done\nRestarting nebula-docker-compose_metad0_1    ... done\n</code></pre> <p>To restart multiple services, such as graphd and storaged0, run the following command:</p> <pre><code>$ docker-compose restart graphd storaged0\nRestarting nebula-docker-compose_graphd_1    ... done\nRestarting nebula-docker-compose_storaged0_1 ... done\n</code></pre>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#stop_and_remove_nebulagraph_services","title":"Stop and remove NebulaGraph services","text":"<p>You can stop and remove all the NebulaGraph services by running the following command:</p> <p>Danger</p> <p>This command stops and removes all the containers of the NebulaGraph services and the related network. If you define volumes in the <code>docker-compose.yaml</code>, the related data are retained.</p> <p>The command <code>docker-compose down -v</code> removes all the local data. Try this command if you are using the nightly release and having some compatibility issues.</p> <pre><code>$ docker-compose down\n</code></pre> <p>The following information indicates you have successfully stopped the NebulaGraph services:</p> <pre><code>Stopping nebula-docker-compose_console_1   ... done\nStopping nebula-docker-compose_graphd1_1   ... done\nStopping nebula-docker-compose_graphd_1    ... done\nStopping nebula-docker-compose_graphd2_1   ... done\nStopping nebula-docker-compose_storaged1_1 ... done\nStopping nebula-docker-compose_storaged0_1 ... done\nStopping nebula-docker-compose_storaged2_1 ... done\nStopping nebula-docker-compose_metad2_1    ... done\nStopping nebula-docker-compose_metad0_1    ... done\nStopping nebula-docker-compose_metad1_1    ... done\nRemoving nebula-docker-compose_console_1   ... done\nRemoving nebula-docker-compose_graphd1_1   ... done\nRemoving nebula-docker-compose_graphd_1    ... done\nRemoving nebula-docker-compose_graphd2_1   ... done\nRemoving nebula-docker-compose_storaged1_1 ... done\nRemoving nebula-docker-compose_storaged0_1 ... done\nRemoving nebula-docker-compose_storaged2_1 ... done\nRemoving nebula-docker-compose_metad2_1    ... done\nRemoving nebula-docker-compose_metad0_1    ... done\nRemoving nebula-docker-compose_metad1_1    ... done\nRemoving network nebula-docker-compose_nebula-net\n</code></pre>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#faq","title":"FAQ","text":""},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#how_to_fix_the_docker_mapping_to_external_ports","title":"How to fix the docker mapping to external ports?","text":"<p>To set the <code>ports</code> of corresponding services as fixed mapping, modify the <code>docker-compose.yaml</code> in the <code>nebula-docker-compose</code> directory. For example:</p> <pre><code>graphd:\n    image: vesoft/nebula-graphd:release-3.6\n    ...\n    ports:\n      - 9669:9669\n      - 19669\n      - 19670\n</code></pre> <p><code>9669:9669</code> indicates the internal port 9669 is uniformly mapped to external ports, while <code>19669</code> indicates the internal port 19669 is randomly mapped to external ports.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#how_to_upgrade_or_update_the_docker_images_of_nebulagraph_services","title":"How to upgrade or update the docker images of NebulaGraph services?","text":"<ol> <li> <p>In the <code>nebula-docker-compose/docker-compose.yaml</code> file, change all the <code>image</code> values to the required image version.</p> </li> <li> <p>In the <code>nebula-docker-compose</code> directory, run <code>docker-compose pull</code> to update the images of the Graph Service, Storage Service, Meta Service, and NebulaGraph Console.</p> </li> <li> <p>Run <code>docker-compose up -d</code> to start the NebulaGraph services again.</p> </li> <li> <p>After connecting to NebulaGraph with NebulaGraph Console, run <code>SHOW HOSTS GRAPH</code>, <code>SHOW HOSTS STORAGE</code>, or <code>SHOW HOSTS META</code> to check the version of the responding service respectively.</p> </li> </ol>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#error_toomanyrequests_when_docker-compose_pull","title":"<code>ERROR: toomanyrequests</code> when <code>docker-compose pull</code>","text":"<p>You may meet the following error.</p> <p><code>ERROR: toomanyrequests: You have reached your pull rate limit. You may increase the limit by authenticating and upgrading: https://www.docker.com/increase-rate-limit</code>.</p> <p>You have met the rate limit of Docker Hub. Learn more on Understanding Docker Hub Rate Limiting.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#how_to_update_the_nebulagraph_console_client","title":"How to update the NebulaGraph Console client?","text":"<p>The command <code>docker-compose pull</code> updates both the NebulaGraph services and the NebulaGraph Console.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#how_to_activate_storaged_containers_when_they_remain_in_offline_status","title":"How to activate storaged containers when they remain in <code>offline</code> status?","text":"<p>The activation script for storaged containers in Docker Compose may fail to run in rare cases. You can connect to NebulaGraph with NebulaGraph Console or NebulaGraph Studio and then manually run the <code>ADD HOSTS</code> command to activate them by adding the storaged containers to the cluster. An example of the command is as follows:</p> <pre><code>nebula&gt; ADD HOSTS \"storaged0\":9779,\"storaged1\":9779,\"storaged2\":9779\n</code></pre>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/3.deploy-nebula-graph-with-docker-compose/#related_documents","title":"Related documents","text":"<ul> <li>Install and deploy NebulaGraph with the source code</li> <li>Install NebulaGraph by RPM or DEB</li> <li>Connect to NebulaGraph</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/4.install-nebula-graph-from-tar/","title":"Install NebulaGraph graph with the tar.gz file","text":"<p>You can install NebulaGraph by downloading the tar.gz file.</p> <p>Note</p> <ul> <li>NebulaGraph provides installing with the tar.gz file starting from version 2.6.0.</li> </ul> <ul> <li>NebulaGraph is currently only supported for installation on Linux systems, and only CentOS 7.x, CentOS 8.x, Ubuntu 16.04, Ubuntu 18.04, and Ubuntu 20.04 operating systems are supported. </li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/4.install-nebula-graph-from-tar/#installation_steps","title":"Installation steps","text":"<ol> <li> <p>Download the NebulaGraph tar.gz file using the following address.</p> <p>Before downloading, you need to replace <code>&lt;release_version&gt;</code> with the version you want to download.</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.com.cn/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el7.x86_64.tar.gz\n//Checksum\nhttps://oss-cdn.nebula-graph.com.cn/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el7.x86_64.tar.gz.sha256sum.txt\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.com.cn/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el8.x86_64.tar.gz\n//Checksum\nhttps://oss-cdn.nebula-graph.com.cn/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el8.x86_64.tar.gz.sha256sum.txt\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.com.cn/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1604.amd64.tar.gz\n//Checksum\nhttps://oss-cdn.nebula-graph.com.cn/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1604.amd64.tar.gz.sha256sum.txt\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.com.cn/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1804.amd64.tar.gz\n//Checksum\nhttps://oss-cdn.nebula-graph.com.cn/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1804.amd64.tar.gz.sha256sum.txt\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.com.cn/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu2004.amd64.tar.gz\n//Checksum\nhttps://oss-cdn.nebula-graph.com.cn/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu2004.amd64.tar.gz.sha256sum.txt\n</code></pre> <p>For example, to download the NebulaGraph release-3.6 tar.gz file for <code>CentOS 7.5</code>, run the following command:</p> <pre><code>wget https://oss-cdn.nebula-graph.com.cn/package/3.8.0/nebula-graph-3.8.0.el7.x86_64.tar.gz\n</code></pre> </li> <li> <p>Decompress the tar.gz file to the NebulaGraph installation directory.</p> <pre><code>tar -xvzf &lt;tar.gz_file_name&gt; -C &lt;install_path&gt;\n</code></pre> <ul> <li><code>tar.gz_file_name</code> specifies the name of the tar.gz file.</li> <li><code>install_path</code> specifies the installation path.</li> </ul> <p>For example:</p> <pre><code>tar -xvzf nebula-graph-3.8.0.el7.x86_64.tar.gz -C /home/joe/nebula/install\n</code></pre> </li> <li> <p>Modify the name of the configuration file.</p> <p>Enter the decompressed directory, rename the files <code>nebula-graphd.conf.default</code>, <code>nebula-metad.conf.default</code>, and <code>nebula-storaged.conf.default</code> in the subdirectory <code>etc</code>, and delete <code>.default</code> to apply the default configuration of NebulaGraph.</p> </li> </ol> <p>Note</p> <p>To modify the configuration, see Configurations.</p> <p>So far, you have installed NebulaGraph successfully.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/4.install-nebula-graph-from-tar/#next_to_do","title":"Next to do","text":"<p>Manage NebulaGraph services</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/6.deploy-nebula-graph-with-peripherals/","title":"Install NebulaGraph with ecosystem tools","text":"<p>You can install the NebulaGraph Community Edition with the following ecosystem tools:</p> <ul> <li>NebulaGraph Operator</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/6.deploy-nebula-graph-with-peripherals/#installation_details","title":"Installation details","text":"<ul> <li>To install NebulaGraph with NebulaGraph Operator, see Install NebulaGraph clusters.</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/7.compile-using-docker/","title":"Compile NebulaGraph using Docker","text":"<p>NebulaGraph's source code is written in C++. Compiling NebulaGraph requires certain dependencies which might conflict with host system dependencies, potentially causing compilation failures. Docker offers a solution to this. NebulaGraph provides a Docker image containing the complete compilation environment, ensuring an efficient build process and avoiding host OS conflicts. This guide outlines the steps to compile NebulaGraph using Docker.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/7.compile-using-docker/#prerequisites","title":"Prerequisites","text":"<p>Before you begin:</p> <ol> <li> <p>Docker: Ensure Docker is installed on your system.</p> </li> <li> <p>Clone NebulaGraph's Source Code: Clone the repository locally using:</p> <pre><code>git clone --branch release-3.6 https://github.com/vesoft-inc/nebula.git\n</code></pre> <p>This clones the NebulaGraph source code to a subdirectory named <code>nebula</code>.</p> </li> </ol>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/7.compile-using-docker/#compilation_steps","title":"Compilation steps","text":"<ol> <li> <p>Pull the NebulaGraph compilation image.</p> <pre><code>docker pull vesoft/nebula-dev:ubuntu2004\n</code></pre> <p>Here, we use the official NebulaGraph compilation image, <code>ubuntu2004</code>. For different versions, see nebula-dev-docker.</p> </li> <li> <p>Start the compilation container.</p> <pre><code>docker run -ti \\\n  --security-opt seccomp=unconfined \\\n  -v \"$PWD\":/home \\\n  -w /home \\\n  --name nebula_dev \\\n  vesoft/nebula-dev:ubuntu2004 \\\n  bash\n</code></pre> <ul> <li><code>--security-opt seccomp=unconfined</code>: Disables the seccomp security mechanism to avoid compilation errors.</li> </ul> <ul> <li><code>-v \"$PWD\":/home</code>: Mounts the local path of the NebulaGraph code to the container's <code>/home</code> directory.</li> </ul> <ul> <li><code>-w /home</code>: Sets the container's working directory to <code>/home</code>. Any command run inside the container will use this directory as the current directory.</li> </ul> <ul> <li><code>--name nebula_dev</code>: Assigns a name to the container, making it easier to manage and operate.</li> </ul> <ul> <li><code>vesoft/nebula-dev:ubuntu2004</code>: Uses the <code>ubuntu2004</code> version of the <code>vesoft/nebula-dev</code> compilation image.</li> </ul> <ul> <li><code>bash</code>: Executes the <code>bash</code> command inside the container, entering the container's interactive terminal.</li> </ul> <p>After executing this command, you'll enter an interactive terminal inside the container. To re-enter the container, use <code>docker exec -ti nebula_dev bash</code>.</p> </li> <li> <p>Compile NebulaGraph inside the container.</p> <ol> <li> <p>Enter the NebulaGraph source code directory.</p> <pre><code>cd nebula\n</code></pre> </li> <li> <p>Create a build directory and enter it.</p> <pre><code>mkdir build &amp;&amp; cd build\n</code></pre> </li> <li> <p>Use CMake to generate the Makefile.</p> <p><pre><code>cmake -DCMAKE_CXX_COMPILER=$TOOLSET_CLANG_DIR/bin/g++ -DCMAKE_C_COMPILER=$TOOLSET_CLANG_DIR/bin/gcc -DENABLE_WERROR=OFF -DCMAKE_BUILD_TYPE=Debug -DENABLE_TESTING=OFF ..\n</code></pre> For more on CMake, see CMake Parameters.</p> </li> <li> <p>Compile NebulaGraph.</p> <pre><code># The -j parameter specifies the number of threads to use.\n# If you have a multi-core CPU, you can use more threads to speed up compilation.\nmake -j2\n</code></pre> <p>Compilation might take some time based on your system performance. </p> </li> </ol> </li> <li> <p>Install the Executables and Libraries.</p> <p>Post successful compilation, NebulaGraph's binaries and libraries are located in <code>/home/nebula/build</code>. Install them to <code>/usr/local/nebula</code>:</p> <pre><code>make install\n</code></pre> </li> </ol> <p>Once completed, NebulaGraph is compiled and installed in the host directory <code>/usr/local/nebula</code>.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/7.compile-using-docker/#next_steps","title":"Next Steps","text":"<ul> <li>Start NebulaGraph Service</li> <li>Connect to NebulaGraph</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/8.deploy-nebula-graph-with-lite/","title":"Deploy NebulaGraph with NebulaGraph Lite","text":"<p>Using NebulaGraph Lite can quickly deploy NebulaGraph and start experiencing NebulaGraph in just five minutes. It is ideal for ad-hoc development and learning NebulaGraph.</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/8.deploy-nebula-graph-with-lite/#benefits","title":"Benefits","text":"<ul> <li>Quick installation of NebulaGraph Lite through the Python package management tool.</li> <li>NebulaGraph Lite supports the deployment of NebulaGraph with non-root permission.</li> <li>NebulaGraph Lite supports the deployment of NebulaGraph in containers or any Jupyter Notebook platform on Linux-based systems.</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/8.deploy-nebula-graph-with-lite/#steps","title":"Steps","text":"<ol> <li> <p>Run the following statement to install NebulaGraph Lite.</p> <pre><code>pip3 install nebulagraph-lite\n</code></pre> </li> <li> <p>Start NebulaGraph Lite. NebulaGraph Lite automatically deploys and starts a single-node NebulaGraph service, and imports a test dataset.</p> <ul> <li> <p>Start from Jupyter Notebook</p> <pre><code>from nebulagraph_lite import nebulagraph_let as ng_let\nn = ng_let()\nn.start()\n</code></pre> </li> </ul> <ul> <li> <p>Start from the command line</p> <pre><code>nebulagraph start\n</code></pre> </li> </ul> </li> </ol> <p>The following result is returned indicating that the startup and import of the test dataset was successful.</p> <pre><code>Info: loading basketballplayer dataset...\n\n  _   _      _           _        ____                 _\n | \\ | | ___| |__  _   _| | __ _ / ___|_ __ __ _ _ __ | |__\n |  \\| |/ _ | '_ \\| | | | |/ _` | |  _| '__/ _` | '_ \\| '_ \\\n | |\\  |  __| |_) | |_| | | (_| | |_| | | | (_| | |_) | | | |\n |_| \\_|\\___|_.__/ \\__,_|_|\\__,_|\\____|_|  \\__,_| .__/|_| |_|\n                                                |_|\n                                                lite version\n\n[ OK ] nebulagraph_lite started successfully!\n</code></pre>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/8.deploy-nebula-graph-with-lite/#whats_next","title":"What's next","text":"<ul> <li>Connect to NebulaGraph with NebulaGraph Jupyter Extension.</li> <li>Connect to NebulaGraph with NebulaGraph Console.</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/deploy-nebula-graph-cluster/","title":"Deploy a NebulaGraph cluster with RPM/DEB package on multiple servers","text":"<p>You can deploy a NebulaGraph cluster with RPM or DEB package manually. This topic provides an example of deploying a NebulaGraph cluster across multiple servers (machines).</p> <p>Note</p> <p>You can also deploy a NebulaGraph cluster with official tools. For more information, see Install NebulaGraph with ecosystem tools</p>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/deploy-nebula-graph-cluster/#deployment","title":"Deployment","text":"Machine name IP address Number of graphd Number of storaged Number of metad A 192.168.10.111 1 1 1 B 192.168.10.112 1 1 1 C 192.168.10.113 1 1 1 D 192.168.10.114 1 1 None E 192.168.10.115 1 1 None"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/deploy-nebula-graph-cluster/#prerequisites","title":"Prerequisites","text":"<ul> <li>Prepare 5 machines for deploying the cluster.</li> <li>Use the NTP service to synchronize time in the cluster.</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/deploy-nebula-graph-cluster/#manual_deployment_process","title":"Manual deployment process","text":""},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/deploy-nebula-graph-cluster/#install_nebulagraph","title":"Install NebulaGraph","text":"<p>Install NebulaGraph on each machine in the cluster. Available approaches of installation are as follows.</p> <ul> <li>Install NebulaGraph with RPM or DEB package</li> </ul> <ul> <li>Install NebulaGraph by compiling the source code</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/deploy-nebula-graph-cluster/#modify_the_configurations","title":"Modify the configurations","text":"<p>To deploy NebulaGraph according to your requirements, you have to modify the configuration files.</p> <p>All the configuration files for NebulaGraph, including <code>nebula-graphd.conf</code>, <code>nebula-metad.conf</code>, and <code>nebula-storaged.conf</code>, are stored in the <code>etc</code> directory in the installation path. You only need to modify the configuration for the corresponding service on the machines. The configurations that need to be modified for each machine are as follows.</p> Machine name The configuration to be modified A <code>nebula-graphd.conf</code>, <code>nebula-storaged.conf</code>, <code>nebula-metad.conf</code> B <code>nebula-graphd.conf</code>, <code>nebula-storaged.conf</code>, <code>nebula-metad.conf</code> C <code>nebula-graphd.conf</code>, <code>nebula-storaged.conf</code>, <code>nebula-metad.conf</code> D <code>nebula-graphd.conf</code>, <code>nebula-storaged.conf</code> E <code>nebula-graphd.conf</code>, <code>nebula-storaged.conf</code> <p>Users can refer to the content of the following configurations, which only show part of the cluster settings. The hidden content uses the default setting so that users can better understand the relationship between the servers in the NebulaGraph cluster.</p> <p>Note</p> <p>The main configuration to be modified is <code>meta_server_addrs</code>. All configurations need to fill in the IP addresses and ports of all Meta services. At the same time, <code>local_ip</code> needs to be modified as the network IP address of the machine itself. For detailed descriptions of the configuration parameters, see:</p> <ul> <li>Meta Service configurations</li> </ul> <ul> <li>Graph Service configurations</li> </ul> <ul> <li>Storage Service configurations</li> </ul> <ul> <li> <p>Deploy machine A</p> <ul> <li> <p><code>nebula-graphd.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta Server Addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-graphd process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.111\n# Network device to listen on\n--listen_netdev=any\n# Port to listen on\n--port=9669\n</code></pre> </li> </ul> <ul> <li> <p><code>nebula-storaged.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta server addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-storaged process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.111\n# Storage daemon listening port\n--port=9779\n</code></pre> </li> </ul> <ul> <li> <p><code>nebula-metad.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta Server addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-metad process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.111\n# Meta daemon listening port\n--port=9559\n</code></pre> </li> </ul> </li> </ul> <ul> <li> <p>Deploy machine B</p> <ul> <li> <p><code>nebula-graphd.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta Server Addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-graphd process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.112\n# Network device to listen on\n--listen_netdev=any\n# Port to listen on\n--port=9669\n</code></pre> </li> </ul> <ul> <li> <p><code>nebula-storaged.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta server addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-storaged process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.112\n# Storage daemon listening port\n--port=9779\n</code></pre> </li> </ul> <ul> <li> <p><code>nebula-metad.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta Server addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-metad process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.112\n# Meta daemon listening port\n--port=9559\n</code></pre> </li> </ul> </li> </ul> <ul> <li> <p>Deploy machine C</p> <ul> <li> <p><code>nebula-graphd.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta Server Addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-graphd process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.113\n# Network device to listen on\n--listen_netdev=any\n# Port to listen on\n--port=9669\n</code></pre> </li> </ul> <ul> <li> <p><code>nebula-storaged.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta server addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-storaged process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.113\n# Storage daemon listening port\n--port=9779\n</code></pre> </li> </ul> <ul> <li> <p><code>nebula-metad.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta Server addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-metad process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.113\n# Meta daemon listening port\n--port=9559\n</code></pre> </li> </ul> </li> </ul> <ul> <li> <p>Deploy machine D</p> <ul> <li> <p><code>nebula-graphd.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta Server Addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-graphd process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.114\n# Network device to listen on\n--listen_netdev=any\n# Port to listen on\n--port=9669\n</code></pre> </li> </ul> <ul> <li> <p><code>nebula-storaged.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta server addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-storaged process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.114\n# Storage daemon listening port\n--port=9779\n</code></pre> </li> </ul> </li> </ul> <ul> <li> <p>Deploy machine E</p> <ul> <li> <p><code>nebula-graphd.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta Server Addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-graphd process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.115\n# Network device to listen on\n--listen_netdev=any\n# Port to listen on\n--port=9669\n</code></pre> </li> </ul> <ul> <li> <p><code>nebula-storaged.conf</code></p> <pre><code>########## networking ##########\n# Comma separated Meta server addresses\n--meta_server_addrs=192.168.10.111:9559,192.168.10.112:9559,192.168.10.113:9559\n# Local IP used to identify the nebula-storaged process.\n# Change it to an address other than loopback if the service is distributed or\n# will be accessed remotely.\n--local_ip=192.168.10.115\n# Storage daemon listening port\n--port=9779\n</code></pre> </li> </ul> </li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/deploy-nebula-graph-cluster/#start_the_cluster","title":"Start the cluster","text":"<p>Start the corresponding service on each machine. Descriptions are as follows.</p> Machine name The process to be started A graphd, storaged, metad B graphd, storaged, metad C graphd, storaged, metad D graphd, storaged E graphd, storaged <p>The command to start the NebulaGraph services is as follows.</p> <pre><code>sudo /usr/local/nebula/scripts/nebula.service start &lt;metad|graphd|storaged|all&gt;\n</code></pre> <p>Note</p> <ul> <li>Make sure all the processes of services on each machine are started. Otherwise, you will fail to start NebulaGraph.</li> </ul> <ul> <li>When the graphd process, the storaged process, and the metad process are all started, you can use <code>all</code> instead.</li> </ul> <ul> <li><code>/usr/local/nebula</code> is the default installation path for NebulaGraph. Use the actual path if you have customized the path. For more information about how to start and stop the services, see Manage NebulaGraph services.</li> </ul>"},{"location":"4.deployment-and-installation/2.compile-and-install-nebula-graph/deploy-nebula-graph-cluster/#check_the_cluster_status","title":"Check the cluster status","text":"<p>Install the native CLI client NebulaGraph Console, then connect to any machine that has started the graphd process, run <code>ADD HOSTS</code> command to add storage hosts, and run <code>SHOW HOSTS</code> to check the cluster status. For example:</p> <pre><code>$ ./nebula-console --addr 192.168.10.111 --port 9669 -u root -p nebula\n\n2021/05/25 01:41:19 [INFO] connection pool is initialized successfully\nWelcome to NebulaGraph!\n\n&gt; ADD HOSTS 192.168.10.111:9779, 192.168.10.112:9779, 192.168.10.113:9779, 192.168.10.114:9779, 192.168.10.115:9779;\n&gt; SHOW HOSTS;\n+------------------+------+----------+--------------+----------------------+------------------------+---------+\n| Host             | Port | Status   | Leader count | Leader distribution  | Partition distribution | Version |\n+------------------+------+----------+--------------+----------------------+------------------------+---------+\n| \"192.168.10.111\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n| \"192.168.10.112\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n| \"192.168.10.113\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n| \"192.168.10.114\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n| \"192.168.10.115\" | 9779 | \"ONLINE\" | 0            | \"No valid partition\" | \"No valid partition\"   | \"3.8.0\" |\n+------------------+------+-----------+----------+--------------+----------------------+------------------------+---------+\n</code></pre>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/","title":"Upgrade NebulaGraph to 3.8.0","text":"<p>This topic describes how to upgrade NebulaGraph from version 2.x and 3.x to 3.8.0, taking upgrading from version 2.6.1 to 3.8.0 as an example.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#applicable_source_versions","title":"Applicable source versions","text":"<p>This topic applies to upgrading NebulaGraph from 2.5.0 and later 2.x, and 3.x versions to 3.8.0. It does not apply to historical versions earlier than 2.5.0, including the 1.x versions.</p> <p>To upgrade NebulaGraph from historical versions to 3.8.0:</p> <ol> <li>Upgrade it to the latest 2.5 version according to the docs of that version.</li> <li>Follow this topic to upgrade it to 3.8.0.</li> </ol> <p>Caution</p> <p>To upgrade NebulaGraph from versions earlier than 2.0.0 (including the 1.x versions) to 3.8.0, you need to find the <code>date_time_zonespec.csv</code> in the <code>share/resources</code> directory of 3.8.0 files, and then copy it to the same directory in the NebulaGraph installation path.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#limitations","title":"Limitations","text":"<ul> <li>Rolling Upgrade is not supported. You must stop all the NebulaGraph services before the upgrade.</li> </ul> <ul> <li>There is no upgrade script. You have to manually upgrade each server in the cluster.</li> </ul> <ul> <li>This topic does not apply to scenarios where NebulaGraph is deployed with Docker, including Docker Swarm, Docker Compose, and K8s.</li> </ul> <ul> <li>You must upgrade the old NebulaGraph services on the same machines they are deployed. DO NOT change the IP addresses, configuration files of the machines, and DO NOT change the cluster topology.</li> </ul> <ul> <li>Known issues that could cause data loss are listed on GitHub known issues. The issues are all related to altering schema or default values.</li> </ul> <ul> <li>DO NOT use soft links to switch the data directories.</li> </ul> <ul> <li>You must have the sudo privileges to complete the steps in this topic.</li> </ul>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#upgrade_influences","title":"Upgrade influences","text":"<ul> <li> <p>Client compatibility</p> <p>After the upgrade, you will not be able to connect to NebulaGraph from old clients. You will need to upgrade all clients to a version compatible with NebulaGraph 3.8.0.</p> </li> </ul> <ul> <li> <p>Configuration changes</p> <p>A few configuration parameters have been changed. For more information, see the release notes and configuration docs.</p> </li> </ul> <ul> <li> <p>nGQL compatibility</p> <p>The nGQL syntax is partially incompatible:</p> <ul> <li>Disable the <code>YIELD</code> clause to return custom variables.</li> </ul> <ul> <li>The <code>YIELD</code> clause is required in the <code>FETCH</code>, <code>GO</code>, <code>LOOKUP</code>, <code>FIND PATH</code> and <code>GET SUBGRAPH</code> statements.</li> </ul> <ul> <li>It is required to specify a tag to query properties of a vertex in a <code>MATCH</code> statement. For example, from <code>return v.name</code> to <code>return v.player.name</code>.</li> </ul> </li> </ul> <ul> <li> <p>Full-text indexes</p> <p>Before upgrading a NebulaGraph cluster with full-text indexes deployed, you must manually delete the full-text indexes in Elasticsearch, and then run the <code>SIGN IN</code> command to log into ES and recreate the indexes after the upgrade is complete. To manually delete the full-text indexes in Elasticsearch, you can use the curl command <code>curl -XDELETE -u &lt;es_username&gt;:&lt;es_password&gt; '&lt;es_access_ip&gt;:&lt;port&gt;/&lt;fullindex_name&gt;'</code>, for example, <code>curl -XDELETE -u elastic:elastic 'http://192.168.8.xxx:9200/nebula_index_2534'</code>. If no username and password are set for Elasticsearch, you can omit the <code>-u &lt;es_username&gt;:&lt;es_password&gt;</code> part.</p> </li> </ul> <p>Caution</p> <p>There may be other undiscovered influences. Before the upgrade, we recommend that you read the release notes and user manual carefully, and keep an eye on the posts on the forum and issues on Github.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#preparations_before_the_upgrade","title":"Preparations before the upgrade","text":"<ul> <li> <p>Download the package of NebulaGraph 3.8.0 according to your operating system and system architecture. You need the binary files during the upgrade. Find the package on the download page.</p> <p>Note</p> <p>You can also get the new binaries from the source code or the RPM/DEB package.</p> </li> </ul> <ul> <li> <p>Locate the data files based on the value of the <code>data_path</code> parameters in the Storage and Meta configurations, and backup the data files. The default paths are <code>nebula/data/storage</code> and <code>nebula/data/meta</code>.</p> <p>Danger</p> <p>The old data will not be automatically backed up during the upgrade. You must manually back up the data to avoid data loss.</p> </li> </ul> <ul> <li>Backup the configuration files.</li> </ul> <ul> <li> <p>Collect the statistics of all graph spaces before the upgrade. After the upgrade, you can collect again and compare the results to make sure that no data is lost. To collect the statistics:</p> <ol> <li>Run <code>SUBMIT JOB STATS</code>.</li> <li>Run <code>SHOW JOBS</code> and record the result.</li> </ol> </li> </ul>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#upgrade_steps","title":"Upgrade steps","text":"<ol> <li> <p>Stop all NebulaGraph services.</p> <pre><code>&lt;nebula_install_path&gt;/scripts/nebula.service stop all\n</code></pre> <p><code>nebula_install_path</code> indicates the installation path of NebulaGraph.</p> <p>The storaged progress needs around 1 minute to flush data. You can run <code>nebula.service status all</code> to check if all services are stopped. For more information about starting and stopping services, see Manage services.</p> <p>Note</p> <p>If the services are not fully stopped in 20 minutes, stop upgrading and ask for help on the forum or Github.</p> <p>Caution</p> <p>Starting from version 3.0.0, it is possible to insert vertices without tags. If you need to keep vertices without tags, add <code>--graph_use_vertex_key=true</code> in the configuration file (<code>nebula-graphd.conf</code>) of all Graph services within the cluster; and add <code>--use_vertex_key=true</code> in the configuration file (<code>nebula-storaged.conf</code>) of all Storage services.\"</p> </li> <li> <p>In the target path where you unpacked the package, use the binaries in the <code>bin</code> directory to replace the old binaries in the <code>bin</code> directory in the NebulaGraph installation path.</p> <p>Note</p> <p>Update the binary of the corresponding service on each NebulaGraph server.</p> </li> <li> <p>Modify the following parameters in all Graph configuration files to accommodate the value range of the new version. If the parameter values are within the specified range, skip this step.</p> <ul> <li>Set a value in [1,604800] for <code>session_idle_timeout_secs</code>. The recommended value is 28800.</li> <li>Set a value in [1,604800] for <code>client_idle_timeout_secs</code>. The recommended value is 28800.</li> </ul> <p>The default values of these parameters in the 2.x versions are not within the range of the new version. If you do not change the default values, the upgrade will fail. For detailed parameter description, see Graph Service Configuration.</p> </li> <li> <p>Start all Meta services.</p> <pre><code>&lt;nebula_install_path&gt;/scripts/nebula-metad.service start\n</code></pre> <p>Once started, the Meta services take several seconds to elect a leader.</p> <p>To verify that Meta services are all started, you can start any Graph server, connect to it through NebulaGraph Console, and run <code>SHOW HOSTS meta</code> and <code>SHOW META LEADER</code>. If the status of Meta services are correctly returned, the services are successfully started.</p> <p>Note</p> <p>If the operation fails, stop the upgrade and ask for help on the forum or GitHub.</p> </li> <li> <p>Start all the Graph and Storage services.</p> <p>Note</p> <p>If the operation fails, stop the upgrade and ask for help on the forum or GitHub.</p> </li> <li> <p>Connect to the new version of NebulaGraph to verify that services are available and data are complete. For how to connect, see Connect to NebulaGraph.</p> <p>Currently, there is no official way to check whether the upgrade is successful. You can run the following reference statements to test the upgrade:</p> <pre><code>nebula&gt; SHOW HOSTS;\nnebula&gt; SHOW HOSTS storage;\nnebula&gt; SHOW SPACES;\nnebula&gt; USE &lt;space_name&gt;\nnebula&gt; SHOW PARTS;\nnebula&gt; SUBMIT JOB STATS;\nnebula&gt; SHOW STATS;\nnebula&gt; MATCH (v) RETURN v LIMIT 5;\n</code></pre> <p>You can also test against new features in version 3.8.0.</p> </li> </ol>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#upgrade_failure_and_rollback","title":"Upgrade failure and rollback","text":"<p>If the upgrade fails, stop all NebulaGraph services of the new version, recover the old configuration files and binaries, and start the services of the old version.</p> <p>All NebulaGraph clients in use must be switched to the old version.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#faq","title":"FAQ","text":""},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#can_i_write_through_the_client_during_the_upgrade","title":"Can I write through the client during the upgrade?","text":"<p>A: No. You must stop all NebulaGraph services during the upgrade.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#the_space_0_not_found_warning_message_during_the_upgrade_process","title":"The <code>Space 0 not found</code> warning message during the upgrade process","text":"<p>When the <code>Space 0 not found</code> warning message appears during the upgrade process, you can ignore it. The space <code>0</code> is used to store meta information about the Storage service and does not contain user data, so it will not affect the upgrade.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#how_to_upgrade_if_a_machine_has_only_the_graph_service_but_not_the_storage_service","title":"How to upgrade if a machine has only the Graph Service, but not the Storage Service?","text":"<p>A: You only need to update the configuration files and binaries of the Graph Service.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#how_to_resolve_the_error_permission_denied","title":"How to resolve the error <code>Permission denied</code>?","text":"<p>A: Try again with the sudo privileges.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#is_there_any_change_in_gflags","title":"Is there any change in gflags?","text":"<p>A: Yes. For more information, see the release notes and configuration docs.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#is_there_a_tool_or_solution_for_verifying_data_consistency_after_the_upgrade","title":"Is there a tool or solution for verifying data consistency after the upgrade?","text":"<p>A: No. But if you only want to check the number of vertices and edges, run <code>SUBMIT JOB STATS</code> and <code>SHOW STATS</code> after the upgrade, and compare the result with the result that you recorded before the upgrade.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#how_to_solve_the_issue_that_storage_is_offline_and_leader_count_is_0","title":"How to solve the issue that Storage is <code>OFFLINE</code> and <code>Leader count</code> is <code>0</code>?","text":"<p>A: Run the following statement to add the Storage hosts into the cluster manually.</p> <pre><code>ADD HOSTS &lt;ip&gt;:&lt;port&gt;[, &lt;ip&gt;:&lt;port&gt; ...];\n</code></pre> <p>For example:</p> <pre><code>ADD HOSTS 192.168.10.100:9779, 192.168.10.101:9779, 192.168.10.102:9779;\n</code></pre> <p>If the issue persists, ask for help on the forum or GitHub.</p>"},{"location":"4.deployment-and-installation/3.upgrade-nebula-graph/upgrade-nebula-comm/#why_the_job_type_changed_after_the_upgrade_but_job_id_remains_the_same","title":"Why the job type changed after the upgrade, but job ID remains the same?","text":"<p>A: <code>SHOW JOBS</code> depends on an internal ID to identify job types, but in NebulaGraph 2.5.0 the internal ID changed in this pull request, so this issue happens after upgrading from a version earlier than 2.5.0.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/1.text-based-index-restrictions/","title":"Full-text index restrictions","text":"<p>This topic introduces the restrictions for full-text indexes. Please read the restrictions very carefully before using the full-text indexes.</p> <p>Caution</p> <p>The full-text index feature has been redone in version 3.6.0 and is not compatible with previous versions. If you want to continue to use wildcards, regulars, fuzzy matches, etc., there are 3 ways to do so as follows:</p> <ul> <li>Delete the original full-text index, rebuild the full-text index in the new way, and use the new query syntax.</li> <li>Delete the original full-text index and use the native index and string operators directly.</li> <li>Continue to use the previous version of NebulaGraph and its full-text index.</li> </ul> <p>For now, full-text search has the following limitations:</p> <ul> <li>Currently, full-text search supports <code>LOOKUP</code> statements only.</li> </ul> <ul> <li>The full-text index name can contain only numbers, lowercase letters, and underscores.</li> </ul> <ul> <li>The names of full-text indexes within different graph spaces cannot be duplicated.</li> </ul> <ul> <li>The query returns 10 records by default. You can use the <code>LIMIT</code> clause to return more records, up to 10,000. You can modify the ElasticSearch parameters to adjust the maximum number of records returned.</li> </ul> <ul> <li>If there is a full-text index on the tag/edge type, the tag/edge type cannot be deleted or modified.</li> </ul> <ul> <li>The type of properties must be <code>STRING</code> or <code>FIXED_STRING</code>.</li> </ul> <ul> <li>Full-text index can not be applied to search multiple tags/edge types.</li> </ul> <ul> <li>Full-text index can not search properties with value <code>NULL</code>.</li> </ul> <ul> <li>Altering Elasticsearch indexes is not supported at this time.</li> </ul> <ul> <li>Modifying the analyzer is not supported. You have to delete the index data and then specify the analyzer when you rebuild the index.</li> </ul> <ul> <li>Make sure that you start the Elasticsearch cluster and Nebula\u00a0Graph at the same time. If not, the data writing on the Elasticsearch cluster can be incomplete.</li> </ul> <ul> <li>It may take a while for Elasticsearch to create indexes. If Nebula\u00a0Graph warns no index is found, you can check the status of the indexing task.</li> </ul> <ul> <li>NebulaGraph clusters deployed with K8s do not have native support for the full-text search feature. However, you can manually deploy the feature yourself.</li> </ul>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/","title":"Deploy full-text index","text":"<p>Nebula\u00a0Graph full-text indexes are powered by Elasticsearch. This means that you can use Elasticsearch full-text query language to retrieve what you want. Full-text indexes are managed through built-in procedures. They can be created only for variable <code>STRING</code> and <code>FIXED_STRING</code> properties when the listener cluster and the Elasticsearch cluster are deployed.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#precaution","title":"Precaution","text":"<p>Before you start using the full-text index, please make sure that you know the restrictions.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#deploy_elasticsearch_cluster","title":"Deploy Elasticsearch cluster","text":"<p>To deploy an Elasticsearch cluster, see Kubernetes Elasticsearch deployment or Elasticsearch installation.</p> <p>Note</p> <ul> <li>To support external network access to Elasticsearch, set <code>network.host</code> to <code>0.0.0.0</code> in <code>config/elasticsearch.yml</code>.</li> <li>Only Elasticsearch version 7.x is supported.</li> </ul> <p>You can configure the Elasticsearch to meet your business needs. To customize the Elasticsearch, see Elasticsearch Document.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#sign_in_to_the_text_search_clients","title":"Sign in to the text search clients","text":"<p>When the Elasticsearch cluster is deployed, use the <code>SIGN IN</code> statement to sign in to the Elasticsearch clients. Multiple <code>elastic_ip:port</code> pairs are separated with commas. You must use the IPs and the port number in the configuration file for the Elasticsearch.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#syntax","title":"Syntax","text":"<pre><code>SIGN IN TEXT SERVICE (&lt;elastic_ip:port&gt;, {HTTP | HTTPS} [,\"&lt;username&gt;\", \"&lt;password&gt;\"]) [, (&lt;elastic_ip:port&gt;, ...)];\n</code></pre>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#example","title":"Example","text":"<pre><code>nebula&gt; SIGN IN TEXT SERVICE (192.168.8.100:9200, HTTP);\n</code></pre> <p>Note</p> <p>Elasticsearch does not have a username or password by default. If you configured a username and password, you need to specify them in the <code>SIGN IN</code> statement.</p> <p>Caution</p> <p>The Elasticsearch client can only be logged in once, and if there are changes, you need to <code>SIGN OUT</code> and then <code>SIGN IN</code> again, and the client takes effect globally, and multiple graph spaces share the same Elasticsearch client.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#show_text_search_clients","title":"Show text search clients","text":"<p>The <code>SHOW TEXT SEARCH CLIENTS</code> statement can list the text search clients.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#syntax_1","title":"Syntax","text":"<pre><code>SHOW TEXT SEARCH CLIENTS;\n</code></pre>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#example_1","title":"Example","text":"<pre><code>nebula&gt; SHOW TEXT SEARCH CLIENTS;\n+-----------------+-----------------+------+\n| Type            | Host            | Port |\n+-----------------+-----------------+------+\n| \"ELASTICSEARCH\" | \"192.168.8.100\" | 9200 |\n+-----------------+-----------------+------+\n</code></pre>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#sign_out_to_the_text_search_clients","title":"Sign out to the text search clients","text":"<p>The <code>SIGN OUT TEXT SERVICE</code> statement can sign out all the text search clients.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#syntax_2","title":"Syntax","text":"<pre><code>SIGN OUT TEXT SERVICE;\n</code></pre>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/2.deploy-es/#example_2","title":"Example","text":"<pre><code>nebula&gt; SIGN OUT TEXT SERVICE;\n</code></pre>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/","title":"Deploy Raft Listener for NebulaGraph Storage service","text":"<p>Full-text index data is written to the Elasticsearch cluster asynchronously. The Raft Listener (Listener for short) is a separate process that fetches data from the Storage Service and writes them into the Elasticsearch cluster.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have read and fully understood the restrictions for using full-text indexes.</li> </ul> <ul> <li>You have deployed a NebulaGraph cluster.</li> </ul> <ul> <li>You have deployed a Elasticsearch cluster.</li> </ul> <ul> <li>You have prepared one or multiple servers to run one or multiple raft listeners.</li> </ul>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#precautions","title":"Precautions","text":"<ul> <li>The Storage Service that you want to run as the Listener must have the same or later release with all the other Nebula\u00a0Graph services in the cluster.</li> </ul> <ul> <li>For now, you can only add all Listeners to a graph space once and for all. Trying to add a new Listener to a graph space that already has a Listener will fail. To add all Listeners, set them in one statement.</li> </ul>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#deployment_process","title":"Deployment process","text":""},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#step_1_install_the_listener_service","title":"Step 1: Install the Listener service","text":"<p>The Listener service uses the same binary as the storaged service. However, the configuration files are different and the processes use different ports. You can install NebulaGraph on all servers that need to deploy a Listener, but only the storaged service can be used. For details, see Install NebulaGraph by RPM or DEB Package.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#step_2_prepare_the_configuration_file_for_the_listener","title":"Step 2: Prepare the configuration file for the Listener","text":"<p>In the <code>etc</code> directory, remove the suffix from <code>nebula-storaged-listener.conf.default</code> or <code>nebula-storaged-listener.conf.production</code> to <code>nebula-storaged-listener.conf</code>, and then modify the configuration content.</p> <p>Most configurations are the same as the configurations of Storage Service. This topic only introduces the differences.</p> Name Default value Description <code>daemonize</code> <code>true</code> When set to <code>true</code>, the process is a daemon process. <code>pid_file</code> <code>pids/nebula-metad-listener.pid</code> The file that records the process ID. <code>meta_server_addrs</code> - IP (or hostname) and ports of all Meta services. Multiple Meta services are separated by commas. <code>local_ip</code> - The local IP (or hostname) of the Listener service. Use real IP addresses instead of domain names or loopback IP addresses such as <code>127.0.0.1</code>. <code>port</code> - The listening port of the RPC daemon of the Listener service. <code>heartbeat_interval_secs</code> <code>10</code> The heartbeat interval of the Meta service. The unit is second (s). <code>listener_path</code> <code>data/listener</code> The WAL directory of the Listener. Only one directory is allowed. <code>data_path</code> <code>data</code> For compatibility reasons, this parameter can be ignored. Fill in the default value <code>data</code>. <code>part_man_type</code> <code>memory</code> The type of the part manager. Optional values \u200b\u200bare <code>memory</code> and <code>meta</code>. <code>rocksdb_batch_size</code> <code>4096</code> The default reserved bytes for batch operations. <code>rocksdb_block_cache</code> <code>4</code> The default block cache size of BlockBasedTable. The unit is Megabyte (MB). <code>engine_type</code> <code>rocksdb</code> The type of the Storage engine, such as <code>rocksdb</code>, <code>memory</code>, etc. <code>part_type</code> <code>simple</code> The type of the part, such as <code>simple</code>, <code>consensus</code>, etc."},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#step_3_start_listeners","title":"Step 3: Start Listeners","text":"<p>To initiate the Listener, navigate to the installation path of the desired cluster and execute the following command:</p> <pre><code>./bin/nebula-storaged --flagfile etc/nebula-storaged-listener.conf\n</code></pre>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#step_4_add_listeners_to_nebulagraph","title":"Step 4: Add Listeners to NebulaGraph","text":"<p>Connect to NebulaGraph and run <code>USE &lt;space&gt;</code> to enter the graph space that you want to create full-text indexes for. Then run the following statement to add a Listener into NebulaGraph.</p> <pre><code>ADD LISTENER ELASTICSEARCH &lt;listener_ip:port&gt; [,&lt;listener_ip:port&gt;, ...]\n</code></pre> <p>Warning</p> <p>You must use real IPs for a Listener.</p> <p>Add all Listeners in one statement completely.</p> <pre><code>nebula&gt; ADD LISTENER ELASTICSEARCH 192.168.8.100:9789,192.168.8.101:9789;\n</code></pre>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#show_listeners","title":"Show Listeners","text":"<p>Run the <code>SHOW LISTENER</code> statement to list all Listeners.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#example","title":"Example","text":"<pre><code>nebula&gt; SHOW LISTENER;\n+--------+-----------------+------------------------+-------------+\n| PartId | Type            | Host                   | Host Status |\n+--------+-----------------+------------------------+-------------+\n| 1      | \"ELASTICSEARCH\" | \"\"192.168.8.100\":9789\" | \"ONLINE\"    |\n| 2      | \"ELASTICSEARCH\" | \"\"192.168.8.100\":9789\" | \"ONLINE\"    |\n| 3      | \"ELASTICSEARCH\" | \"\"192.168.8.100\":9789\" | \"ONLINE\"    |\n+--------+-----------------+------------------------+-------------+\n</code></pre>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#remove_listeners","title":"Remove Listeners","text":"<p>Run the <code>REMOVE LISTENER ELASTICSEARCH</code> statement to remove all Listeners in a graph space.</p>"},{"location":"4.deployment-and-installation/6.deploy-text-based-index/3.deploy-listener/#example_1","title":"Example","text":"<pre><code>nebula&gt; REMOVE LISTENER ELASTICSEARCH;\n</code></pre>"},{"location":"5.configurations-and-logs/1.configurations/1.configurations/","title":"Configurations","text":"<p>NebulaGraph builds the configurations based on the gflags repository. Most configurations are flags. When the NebulaGraph service starts, it will get the configuration information from Configuration files by default. Configurations that are not in the file apply the default values.</p> <p>Note</p> <ul> <li>Because there are many configurations and they may change as NebulaGraph develops, this topic will not introduce all configurations. To get detailed descriptions of configurations, follow the instructions below.</li> <li>It is not recommended to modify the configurations that are not introduced in this topic, unless you are familiar with the source code and fully understand the function of configurations.</li> </ul> <p>Legacy version compatibility</p> <p>In the topic of 1.x, we provide a method of using the <code>CONFIGS</code> command to modify the configurations in the cache. However, using this method in a production environment can easily cause inconsistencies of configurations between clusters and the local. Therefore, this method will no longer be introduced starting with version 2.x.</p>"},{"location":"5.configurations-and-logs/1.configurations/1.configurations/#get_the_configuration_list_and_descriptions","title":"Get the configuration list and descriptions","text":"<p>Use the following command to get all the configuration information of the service corresponding to the binary file:</p> <pre><code>&lt;binary&gt; --help\n</code></pre> <p>For example:</p> <pre><code># Get the help information from Meta\n$ /usr/local/nebula/bin/nebula-metad  --help\n\n# Get the help information from Graph\n$ /usr/local/nebula/bin/nebula-graphd --help\n\n# Get the help information from Storage\n$ /usr/local/nebula/bin/nebula-storaged --help\n</code></pre> <p>The above examples use the default storage path <code>/usr/local/nebula/bin/</code>. If you modify the installation path of NebulaGraph, use the actual path to query the configurations.</p>"},{"location":"5.configurations-and-logs/1.configurations/1.configurations/#get_configurations","title":"Get configurations","text":"<p>Use the <code>curl</code> command to get the value of the running configurations.</p> <p>For example:</p> <pre><code># Get the running configurations from Meta\ncurl 127.0.0.1:19559/flags\n\n# Get the running configurations from Graph\ncurl 127.0.0.1:19669/flags\n\n# Get the running configurations from Storage\ncurl 127.0.0.1:19779/flags\n</code></pre> <p>Utilizing the <code>-s</code> or `-silent option allows for the concealment of the progress bar and error messages. For example:</p> <pre><code>curl -s 127.0.0.1:19559/flags\n</code></pre> <p>Note</p> <p>In an actual environment, use the real IP (or hostname) instead of <code>127.0.0.1</code> in the above example.</p>"},{"location":"5.configurations-and-logs/1.configurations/1.configurations/#configuration_files","title":"Configuration files","text":""},{"location":"5.configurations-and-logs/1.configurations/1.configurations/#configuration_files_for_clusters_installed_from_source_with_an_rpmdeb_package_or_a_tar_package","title":"Configuration files for clusters installed from source, with an RPM/DEB package, or a TAR package","text":"<p>NebulaGraph provides two initial configuration files for each service, <code>&lt;service_name&gt;.conf.default</code> and <code>&lt;service_name&gt;.conf.production</code>. You can use them in different scenarios conveniently. For clusters installed from source and with a RPM/DEB package, the default path is <code>/usr/local/nebula/etc/</code>. For clusters installed with a TAR package, the path is <code>&lt;install_path&gt;/&lt;tar_package_directory&gt;/etc</code>.</p> <p>The configuration values in the initial configuration file are for reference only and can be adjusted according to actual needs. To use the initial configuration file, choose one of the above two files and delete the suffix <code>.default</code> or <code>.production</code> to make it valid.</p> <p>Note</p> <p>To ensure the availability of services, it is recommended that configurations for the same service be consistent, except for <code>local_ip</code>. For example, three Storage servers are deployed in one NebulaGraph cluster. The configurations of the three Storage servers are recommended to be consistent, except for <code>local_ip</code>.</p> <p>The initial configuration files corresponding to each service are as follows.</p> NebulaGraph service Initial configuration file Description Meta <code>nebula-metad.conf.default</code> and <code>nebula-metad.conf.production</code> Meta service configuration Graph <code>nebula-graphd.conf.default</code> and <code>nebula-graphd.conf.production</code> Graph service configuration Storage <code>nebula-storaged.conf.default</code> and <code>nebula-storaged.conf.production</code> Storage service configuration <p>Each initial configuration file of all services contains <code>local_config</code>. The default value is <code>true</code>, which means that the NebulaGraph service will get configurations from its configuration files and start it.</p> <p>Caution</p> <p>It is not recommended to modify the value of <code>local_config</code> to <code>false</code>. If modified, the NebulaGraph service will first read the cached configurations, which may cause configuration inconsistencies between clusters and cause unknown risks.</p>"},{"location":"5.configurations-and-logs/1.configurations/1.configurations/#configuration_files_for_clusters_installed_with_docker_compose","title":"Configuration files for clusters installed with Docker Compose","text":"<p>For clusters installed with Docker Compose, the configuration file's default installation path of the cluster is <code>&lt;install_path&gt;/nebula-docker-compose/docker-compose.yaml</code>. The parameters in the <code>command</code> field of the file are the launch parameters for each service.  </p>"},{"location":"5.configurations-and-logs/1.configurations/1.configurations/#configuration_files_for_clusters_installed_with_nebulagraph_operator","title":"Configuration files for clusters installed with NebulaGraph Operator","text":"<p>For clusters installed with Kubectl through NebulaGraph Operator, the configuration file's path is the path of the cluster YAML file. You can modify the configuration of each service through the <code>spec.{graphd|storaged|metad}.config</code> parameter.  </p> <p>Note</p> <p>The services cannot be configured for clusters installed with Helm.</p>"},{"location":"5.configurations-and-logs/1.configurations/1.configurations/#modify_configurations","title":"Modify configurations","text":"<p>You can modify the configurations of NebulaGraph in the configuration file or use commands to dynamically modify configurations.</p> <p>Caution</p> <p>Using both methods to modify the configuration can cause the configuration information to be managed inconsistently, which may result in confusion. It is recommended to only use the configuration file to manage the configuration, or to make the same modifications to the configuration file after dynamically updating the configuration through commands to ensure consistency.</p>"},{"location":"5.configurations-and-logs/1.configurations/1.configurations/#modifying_configurations_in_the_configuration_file","title":"Modifying configurations in the configuration file","text":"<p>By default, each NebulaGraph service gets configured from its configuration files. You can modify configurations and make them valid according to the following steps:</p> <ul> <li> <p>For clusters installed from source, with a RPM/DEB, or a TAR package</p> <ol> <li> <p>Use a text editor to modify the configuration files of the target service and save the modification.</p> </li> <li> <p>Choose an appropriate time to restart all NebulaGraph services to make the modifications valid.</p> </li> </ol> </li> </ul> <ul> <li> <p>For clusters installed with Docker Compose</p> <ol> <li>In the <code>&lt;install_path&gt;/nebula-docker-compose/docker-compose.yaml</code> file, modify the configurations of the target service.</li> <li>In the <code>nebula-docker-compose</code> directory, run the command <code>docker-compose up -d</code> to restart the service involving configuration modifications.</li> </ol> </li> </ul> <ul> <li> <p>For clusters installed with Kubectl</p> <p>For details, see Customize configuration parameters for a NebulaGraph cluster.</p> </li> </ul>"},{"location":"5.configurations-and-logs/1.configurations/1.configurations/#dynamically_modifying_configurations_using_command","title":"Dynamically modifying configurations using command","text":"<p>You can dynamically modify the configuration of NebulaGraph by using the curl command. For example, to modify the <code>wal_ttl</code> parameter of the Storage service to <code>600</code>, use the following command:</p> <pre><code>curl -X PUT -H \"Content-Type: application/json\" -d'{\"wal_ttl\":\"600\"}' -s \"http://192.168.15.6:19779/flags\"\n</code></pre> <p>In this command, <code>{\"wal_ttl\":\"600\"}</code> specifies the configuration parameter and its value to be modified, and <code>192.168.15.6:19779</code> specifies the IP address and HTTP port number of the Storage service.</p> <p>Caution</p> <ul> <li>The functionality of dynamically modifying configurations is only applicable to prototype verification and testing environments. It is not recommended to use this feature in production environments. This is because when the <code>local_config</code> value is set to <code>true</code>, the dynamically modified configuration is not persisted, and the configuration will be restored to the initial configuration after the service is restarted.</li> </ul> <ul> <li>Only part of the configuration parameters can be dynamically modified. For the specific list of parameters that can be modified, see the description of Whether supports runtime dynamic modifications in the respective service configuration.</li> </ul>"},{"location":"5.configurations-and-logs/1.configurations/2.meta-config/","title":"Meta Service configuration","text":"<p>NebulaGraph provides two initial configuration files for the Meta service, <code>nebula-metad.conf.default</code> and <code>nebula-metad.conf.production</code>. Users can use them in different scenarios conveniently. The default file path is <code>/usr/local/nebula/etc/</code>.</p> <p>Caution</p> <ul> <li>It is not recommended to modify the value of <code>local_config</code> to <code>false</code>. If modified, the NebulaGraph service will first read the cached configurations, which may cause configuration inconsistencies between clusters and cause unknown risks.</li> <li>It is not recommended to modify the configurations that are not introduced in this topic, unless you are familiar with the source code and fully understand the function of configurations.</li> </ul>"},{"location":"5.configurations-and-logs/1.configurations/2.meta-config/#how_to_use_the_configuration_files","title":"How to use the configuration files","text":"<p>To use the initial configuration file, choose one of the above two files and delete the suffix <code>.default</code> or <code>.production</code> from the initial configuration file for the Meta Service to apply the configurations defined in it.</p>"},{"location":"5.configurations-and-logs/1.configurations/2.meta-config/#about_parameter_values","title":"About parameter values","text":"<p>If a parameter is not set in the configuration file, NebulaGraph uses the default value. Not all parameters are predefined. And the predefined parameters in the two initial configuration files are different. This topic uses the parameters in <code>nebula-metad.conf.default</code>.</p> <p>Caution</p> <p>Some parameter values in the configuration file can be dynamically modified during runtime. We label these parameters as Yes that supports runtime dynamic modification in this article. When the <code>local_config</code> value is set to <code>true</code>, the dynamically modified configuration is not persisted, and the configuration will be restored to the initial configuration after the service is restarted. For more information, see Modify configurations.</p> <p>For all parameters and their current values, see Configurations.</p>"},{"location":"5.configurations-and-logs/1.configurations/2.meta-config/#basics_configurations","title":"Basics configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>daemonize</code> <code>true</code> When set to <code>true</code>, the process is a daemon process. No <code>pid_file</code> <code>pids/nebula-metad.pid</code> The file that records the process ID. No <code>timezone_name</code> - Specifies the NebulaGraph time zone. This parameter is not predefined in the initial configuration files. You can manually set it if you need it. The system default value is <code>UTC+00:00:00</code>. For the format of the parameter value, see Specifying the Time Zone with TZ. For example, <code>--timezone_name=UTC+08:00</code> represents the GMT+8 time zone. No <p>Note</p> <ul> <li>While inserting property values of time types, NebulaGraph transforms time types (except TIMESTAMP) to the corresponding UTC according to the time zone specified by <code>timezone_name</code>. The time-type values returned by nGQL queries are all UTC time.</li> <li><code>timezone_name</code> is only used to transform the data stored in NebulaGraph. Other time-related data of the NebulaGraph processes still uses the default time zone of the host, such as the log printing time.</li> </ul>"},{"location":"5.configurations-and-logs/1.configurations/2.meta-config/#logging_configurations","title":"Logging configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>log_dir</code> <code>logs</code> The directory that stores the Meta Service log. It is recommended to put logs on a different hard disk from the data. No <code>minloglevel</code> <code>0</code> Specifies the minimum level of the log. That is, log messages at or above this level. Optional values are <code>0</code> (INFO), <code>1</code> (WARNING), <code>2</code> (ERROR), <code>3</code> (FATAL). It is recommended to set it to <code>0</code> during debugging and <code>1</code> in a production environment. If it is set to <code>4</code>, NebulaGraph will not print any logs. Yes <code>v</code> <code>0</code> Specifies the detailed level of VLOG. That is, log all VLOG messages less or equal to the level. Optional values are <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>. The VLOG macro provided by glog allows users to define their own numeric logging levels and control verbose messages that are logged with the parameter <code>v</code>. For details, see Verbose Logging. Yes <code>logbufsecs</code> <code>0</code> Specifies the maximum time to buffer the logs. If there is a timeout, it will output the buffered log to the log file. <code>0</code> means real-time output. This configuration is measured in seconds. No <code>redirect_stdout</code> <code>true</code> When set to <code>true</code>, the process redirects the<code>stdout</code> and <code>stderr</code> to separate output files. No <code>stdout_log_file</code> <code>metad-stdout.log</code> Specifies the filename for the <code>stdout</code> log. No <code>stderr_log_file</code> <code>metad-stderr.log</code> Specifies the filename for the <code>stderr</code> log. No <code>stderrthreshold</code> <code>3</code> Specifies the <code>minloglevel</code> to be copied to the <code>stderr</code> log. No <code>timestamp_in_logfile_name</code> <code>true</code> Specifies if the log file name contains a timestamp. <code>true</code> indicates yes, <code>false</code> indicates no. No"},{"location":"5.configurations-and-logs/1.configurations/2.meta-config/#networking_configurations","title":"Networking configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>meta_server_addrs</code> <code>127.0.0.1:9559</code> Specifies the IPs (or hostnames) and ports of all Meta Services.  Multiple addresses are separated with commas. No <code>local_ip</code> <code>127.0.0.1</code> Specifies the local IP (or hostname) for the Meta Service. The local IP address is used to identify the nebula-metad process. If it is a distributed cluster or requires remote access, modify it to the corresponding address. No <code>port</code> <code>9559</code> Specifies RPC daemon listening port of the Meta service. The neighboring <code>+1</code> (<code>9560</code>) port is used for Raft communication between Meta services. No <code>ws_ip</code> <code>0.0.0.0</code> Specifies the IP address for the HTTP service. No <code>ws_http_port</code> <code>19559</code> Specifies the port for the HTTP service. No <code>ws_storage_http_port</code> <code>19779</code> Specifies the Storage service listening port used by the HTTP protocol. It must be consistent with the <code>ws_http_port</code> in the Storage service configuration file. This parameter only applies to standalone NebulaGraph. No <p>Caution</p> <p>It is recommended to use a real IP when using IP address. Otherwise, <code>127.0.0.1/0.0.0.0</code> cannot be parsed correctly in some cases.</p>"},{"location":"5.configurations-and-logs/1.configurations/2.meta-config/#storage_configurations","title":"Storage configurations","text":"Name Predefined Value Description Whether supports runtime dynamic modifications <code>data_path</code> <code>data/meta</code> The storage path for Meta data. No"},{"location":"5.configurations-and-logs/1.configurations/2.meta-config/#misc_configurations","title":"Misc configurations","text":"Name Predefined Value Description Whether supports runtime dynamic modifications <code>default_parts_num</code> <code>10</code> Specifies the default partition number when creating a new graph space. No <code>default_replica_factor</code> <code>1</code> Specifies the default replica number when creating a new graph space. No <code>heartbeat_interval_secs</code> <code>10</code> Specifies the default heartbeat interval. Make sure the <code>heartbeat_interval_secs</code> values for all services are the same, otherwise NebulaGraph CANNOT work normally. This configuration is measured in seconds. Yes <code>agent_heartbeat_interval_secs</code> <code>60</code> Specifies the default heartbeat interval for the Agent service. This configuration influences the time it takes for the system to determine that the Agent service is offline. This configuration is measured in seconds. No"},{"location":"5.configurations-and-logs/1.configurations/2.meta-config/#rocksdb_options_configurations","title":"RocksDB options configurations","text":"Name Predefined Value Description Whether supports runtime dynamic modifications <code>rocksdb_wal_sync</code> <code>true</code> Enables or disables RocksDB WAL synchronization. Available values are <code>true</code> (enable) and <code>false</code> (disable). No"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/","title":"Graph Service configuration","text":"<p>NebulaGraph provides two initial configuration files for the Graph Service, <code>nebula-graphd.conf.default</code> and <code>nebula-graphd.conf.production</code>. Users can use them in different scenarios conveniently. The default file path is <code>/usr/local/nebula/etc/</code>.</p> <p>Caution</p> <ul> <li>It is not recommended to modify the value of <code>local_config</code> to <code>false</code>. If modified, the NebulaGraph service will first read the cached configurations, which may cause configuration inconsistencies between clusters and cause unknown risks.</li> <li>It is not recommended to modify the configurations that are not introduced in this topic, unless you are familiar with the source code and fully understand the function of configurations.</li> </ul>"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#how_to_use_the_configuration_files","title":"How to use the configuration files","text":"<p>To use the initial configuration file, choose one of the above two files and delete the suffix <code>.default</code> or <code>.production</code> from the initial configuration file for the Meta Service to apply the configurations defined in it.</p>"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#about_parameter_values","title":"About parameter values","text":"<p>If a parameter is not set in the configuration file, NebulaGraph uses the default value. Not all parameters are predefined. And the predefined parameters in the two initial configuration files are different. This topic uses the parameters in <code>nebula-metad.conf.default</code>.</p> <p>Caution</p> <p>Some parameter values in the configuration file can be dynamically modified during runtime. We label these parameters as Yes that supports runtime dynamic modification in this article. When the <code>local_config</code> value is set to <code>true</code>, the dynamically modified configuration is not persisted, and the configuration will be restored to the initial configuration after the service is restarted. For more information, see Modify configurations.</p> <p>For all parameters and their current values, see Configurations.</p>"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#basics_configurations","title":"Basics configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>daemonize</code> <code>true</code> When set to <code>true</code>, the process is a daemon process. No <code>pid_file</code> <code>pids/nebula-graphd.pid</code> The file that records the process ID. No <code>enable_optimizer</code> <code>true</code> When set to <code>true</code>, the optimizer is enabled. No <code>timezone_name</code> - Specifies the NebulaGraph time zone. This parameter is not predefined in the initial configuration files. The system default value is <code>UTC+00:00:00</code>. For the format of the parameter value, see Specifying the Time Zone with TZ. For example, <code>--timezone_name=UTC+08:00</code> represents the GMT+8 time zone. No <code>default_charset</code> <code>utf8</code> Specifies the default charset when creating a new graph space. No <code>default_collate</code> <code>utf8_bin</code> Specifies the default collate when creating a new graph space. No <code>local_config</code> <code>true</code> When set to <code>true</code>, the process gets configurations from the configuration files. No <p>Note</p> <ul> <li>While inserting property values of time types, NebulaGraph transforms time types (except TIMESTAMP) to the corresponding UTC according to the time zone specified by <code>timezone_name</code>. The time-type values returned by nGQL queries are all UTC time.</li> <li><code>timezone_name</code> is only used to transform the data stored in NebulaGraph. Other time-related data of the NebulaGraph processes still uses the default time zone of the host, such as the log printing time.</li> </ul>"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#logging_configurations","title":"Logging configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>log_dir</code> <code>logs</code> The directory that stores the Graph service log. It is recommended to put logs on a different hard disk from the data. No <code>minloglevel</code> <code>0</code> Specifies the minimum level of the log. That is, log messages at or above this level. Optional values are <code>0</code> (INFO), <code>1</code> (WARNING), <code>2</code> (ERROR), <code>3</code> (FATAL). It is recommended to set it to <code>0</code> during debugging and <code>1</code> in a production environment. If it is set to <code>4</code>, NebulaGraph will not print any logs. Yes <code>v</code> <code>0</code> Specifies the detailed level of VLOG. That is, log all VLOG messages less or equal to the level. Optional values are <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>. The VLOG macro provided by glog allows users to define their own numeric logging levels and control verbose messages that are logged with the parameter <code>v</code>. For details, see Verbose Logging. Yes <code>logbufsecs</code> <code>0</code> Specifies the maximum time to buffer the logs. If there is a timeout, it will output the buffered log to the log file. <code>0</code> means real-time output. This configuration is measured in seconds. No <code>redirect_stdout</code> <code>true</code> When set to <code>true</code>, the process redirects the<code>stdout</code> and <code>stderr</code> to separate output files. No <code>stdout_log_file</code> <code>graphd-stdout.log</code> Specifies the filename for the <code>stdout</code> log. No <code>stderr_log_file</code> <code>graphd-stderr.log</code> Specifies the filename for the <code>stderr</code> log. No <code>stderrthreshold</code> <code>3</code> Specifies the <code>minloglevel</code> to be copied to the <code>stderr</code> log. No <code>timestamp_in_logfile_name</code> <code>true</code> Specifies if the log file name contains a timestamp. <code>true</code> indicates yes, <code>false</code> indicates no. No"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#query_configurations","title":"Query configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>accept_partial_success</code> <code>false</code> When set to <code>false</code>, the process treats partial success as an error. This configuration only applies to read-only requests. Write requests always treat partial success as an error. A partial success query will prompt <code>Got partial result</code>. Yes <code>session_reclaim_interval_secs</code> <code>60</code> Specifies the interval that the Session information is sent to the Meta service. This configuration is measured in seconds. Yes <code>max_allowed_query_size</code> <code>4194304</code> Specifies the maximum length of queries. Unit: bytes. The default value is <code>4194304</code>, namely 4MB. Yes"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#networking_configurations","title":"Networking configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>meta_server_addrs</code> <code>127.0.0.1:9559</code> Specifies the IPs (or hostnames) and ports of all Meta Services.  Multiple addresses are separated with commas. No <code>local_ip</code> <code>127.0.0.1</code> Specifies the local IP (or hostname) for the Graph Service. The local IP address is used to identify the nebula-graphd process. If it is a distributed cluster or requires remote access, modify it to the corresponding address. No <code>listen_netdev</code> <code>any</code> Specifies the listening network device. No <code>port</code> <code>9669</code> Specifies RPC daemon listening port of the Graph service. No <code>reuse_port</code> <code>false</code> When set to <code>false</code>, the <code>SO_REUSEPORT</code> is closed. No <code>listen_backlog</code> <code>1024</code> Specifies the maximum length of the connection queue for socket monitoring. This configuration must be modified together with the <code>net.core.somaxconn</code>. No <code>client_idle_timeout_secs</code> <code>28800</code> Specifies the time to expire an idle connection. The value ranges from 1 to 604800. The default is 8 hours. This configuration is measured in seconds. No <code>session_idle_timeout_secs</code> <code>28800</code> Specifies the time to expire an idle session. The value ranges from 1 to 604800. The default is 8 hours. This configuration is measured in seconds. No <code>num_accept_threads</code> <code>1</code> Specifies the number of threads that accept incoming connections. No <code>num_netio_threads</code> <code>0</code> Specifies the number of networking IO threads. <code>0</code> is the number of CPU cores. No <code>num_max_connections</code> <code>0</code> Max active connections for all networking threads. 0 means no limit.Max connections for each networking thread = num_max_connections / num_netio_threads No <code>num_worker_threads</code> <code>0</code> Specifies the number of threads that execute queries. <code>0</code> is the number of CPU cores. No <code>ws_ip</code> <code>0.0.0.0</code> Specifies the IP address for the HTTP service. No <code>ws_http_port</code> <code>19669</code> Specifies the port for the HTTP service. No <code>heartbeat_interval_secs</code> <code>10</code> Specifies the default heartbeat interval. Make sure the <code>heartbeat_interval_secs</code> values for all services are the same, otherwise NebulaGraph CANNOT work normally. This configuration is measured in seconds. Yes <code>storage_client_timeout_ms</code> - Specifies the RPC connection timeout threshold between the Graph Service and the Storage Service. This parameter is not predefined in the initial configuration files. You can manually set it if you need it. The system default value is <code>60000</code> ms. No <code>slow_query_threshold_us</code> <code>200000</code> When the execution time of a query exceeds the value, the query is called a slow query. Unit: Microsecond.Note: Even if the execution time of DML statements exceeds this value, they will not be recorded as slow queries. No <code>ws_meta_http_port</code> <code>19559</code> Specifies the Meta service listening port used by the HTTP protocol. It must be consistent with the <code>ws_http_port</code> in the Meta service configuration file. No <p>Caution</p> <p>It is recommended to use a real IP when using IP address. Otherwise, <code>127.0.0.1/0.0.0.0</code> cannot be parsed correctly in some cases.</p>"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#authorization_configurations","title":"Authorization configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>enable_authorize</code> <code>false</code> When set to <code>false</code>, the system authentication is not enabled. For more information, see Authentication. No <code>auth_type</code> <code>password</code> Specifies the login method. Available values are <code>password</code>, <code>ldap</code>, and <code>cloud</code>. No"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#memory_configurations","title":"Memory configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>system_memory_high_watermark_ratio</code> <code>0.8</code> Specifies the trigger threshold of the high-level memory alarm mechanism. If the system memory usage is higher than this value, an alarm mechanism will be triggered, and NebulaGraph will stop querying. This parameter is not predefined in the initial configuration files. Yes"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#metrics_configurations","title":"Metrics configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>enable_space_level_metrics</code> <code>false</code> Enable or disable space-level metrics. Such metric names contain the name of the graph space that it monitors, for example, <code>query_latency_us{space=basketballplayer}.avg.3600</code>. You can view the supported metrics with the <code>curl</code> command. For more information, see Query NebulaGraph metrics. No"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#session_configurations","title":"Session configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>max_sessions_per_ip_per_user</code> <code>300</code> The maximum number of active sessions that can be created from a single IP adddress for a single user. No"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#experimental_configurations","title":"Experimental configurations","text":"<p>Note</p> <p>The switch of the experimental feature is only available in the Community Edition.</p> Name Predefined value Description Whether supports runtime dynamic modifications <code>enable_experimental_feature</code> <code>false</code> Specifies the experimental feature. Optional values are <code>true</code> and <code>false</code>. No <code>enable_data_balance</code> <code>true</code> Whether to enable the BALANCE DATA feature. Only works when <code>enable_experimental_feature</code> is <code>true</code>. No"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#memory_tracker_configurations","title":"Memory tracker configurations","text":"<p>Note</p> <p>Memory Tracker is a memory management tool designed to monitor and limit memory usage. For large-scale queries, Memory Tracker can prevent Out Of Memory (OOM) issues. If you're using Memory Tracker in a containerized environment, you need to add the relevant configurations to the configuration file of the Graph service.</p> <ol> <li>Create the directory <code>/sys/fs/cgroup/graphd/</code>, and then add and configure the <code>memory.max</code> file under the directory.</li> <li> <p>Add the following configurations to <code>etc/nebula-graphd.conf</code>.</p> <pre><code>--containerized=true\n--cgroup_v2_controllers=/sys/fs/cgroup/graphd/cgroup.controllers\n--cgroup_v2_memory_stat_path=/sys/fs/cgroup/graphd/memory.stat\n--cgroup_v2_memory_max_path=/sys/fs/cgroup/graphd/memory.max\n--cgroup_v2_memory_current_path=/sys/fs/cgroup/graphd/memory.current\n</code></pre> </li> </ol> <p>For more details, see Memory Tracker: Memory Management Practice in NebulaGraph Database.</p> Name Predefined value Description Whether supports runtime dynamic modifications <code>memory_tracker_limit_ratio</code> <code>0.8</code> The value of this parameter can be set to <code>(0, 1]</code>, <code>2</code>, and <code>3</code>.Caution: When setting this parameter, ensure that the value of <code>system_memory_high_watermark_ratio</code> is not set to <code>1</code>, otherwise the value of this parameter will not take effect.<code>(0, 1]</code>: The percentage of available memory. Formula: <code>Percentage of available memory = Available memory / (Total memory - Reserved memory)</code>.When an ongoing query results in memory usage exceeding the configured limit, the query fails and subsequently the memory is released.  Note: For the hybrid deployment of a cluster with cloud-based and on-premises nodes, the value of <code>memory_tracker_limit_ratio</code> should be set to a lower value. For example, when the graphd is expected to occupy only 50% of memory, the value can be set to less than <code>0.5</code>.<code>2</code>: Dynamic Self Adaptive mode. MemoryTracker dynamically adjusts the available memory based on the system's current available memory. Note: This feature is experimental. As memory usage cannot be monitored in real time in dynamic adaptive mode, an OOM error may still occur to handle large memory allocations. <code>3</code>: Disable MemoryTracker. MemoryTracker only logs memory usage and does not interfere with executions even if the limit is exceeded. Yes <code>memory_tracker_untracked_reserved_memory_mb</code> <code>50</code> The reserved memory that is not tracked by the memory tracker. Unit: MB. Yes <code>memory_tracker_detail_log</code> <code>false</code> Whether to enable the memory tracker log. When the value is <code>true</code>, the memory tracker log is generated. Yes <code>memory_tracker_detail_log_interval_ms</code> <code>60000</code> The time interval for generating the memory tracker log. Unit: Millisecond. <code>memory_tracker_detail_log</code> is <code>true</code> when this parameter takes effect. Yes <code>memory_purge_enabled</code> <code>true</code> Whether to enable the memory purge feature. When the value is <code>true</code>, the memory purge feature is enabled. Yes <code>memory_purge_interval_seconds</code> <code>10</code> The time interval for the memory purge feature to purge memory. Unit: Second. This parameter only takes effect if <code>memory_purge_enabled</code> is set to true. Yes"},{"location":"5.configurations-and-logs/1.configurations/3.graph-config/#performance_optimization_configurations","title":"performance optimization configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>max_job_size</code> <code>1</code> The maximum number of concurrent jobs, i.e., the maximum number of threads used in the phase of query execution where concurrent execution is possible. It is recommended to be half of the physical CPU cores. Yes <code>min_batch_size</code> <code>8192</code> The minimum batch size for processing the dataset. Takes effect only when <code>max_job_size</code> is greater than 1. Yes <code>optimize_appendvertices</code> <code>false</code> When enabled, the <code>MATCH</code> statement is executed without filtering dangling edges. Yes <code>path_batch_size</code> <code>10000</code> The number of paths constructed per thread. Yes"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/","title":"Storage Service configurations","text":"<p>NebulaGraph provides two initial configuration files for the Storage Service, <code>nebula-storaged.conf.default</code> and <code>nebula-storaged.conf.production</code>. Users can use them in different scenarios conveniently. The default file path is <code>/usr/local/nebula/etc/</code>.</p> <p>Caution</p> <ul> <li>It is not recommended to modify the value of <code>local_config</code> to <code>false</code>. If modified, the NebulaGraph service will first read the cached configurations, which may cause configuration inconsistencies between clusters and cause unknown risks.</li> <li>It is not recommended to modify the configurations that are not introduced in this topic, unless you are familiar with the source code and fully understand the function of configurations.</li> </ul>"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#how_to_use_the_configuration_files","title":"How to use the configuration files","text":"<p>To use the initial configuration file, choose one of the above two files and delete the suffix <code>.default</code> or <code>.production</code> from the initial configuration file for the Meta Service to apply the configurations defined in it.</p>"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#about_parameter_values","title":"About parameter values","text":"<p>If a parameter is not set in the configuration file, NebulaGraph uses the default value. Not all parameters are predefined. And the predefined parameters in the two initial configuration files are different. This topic uses the parameters in <code>nebula-metad.conf.default</code>. For parameters that are not included in <code>nebula-metad.conf.default</code>, see <code>nebula-storaged.conf.production</code>.</p> <p>Caution</p> <p>Some parameter values in the configuration file can be dynamically modified during runtime. We label these parameters as Yes that supports runtime dynamic modification in this article. When the <code>local_config</code> value is set to <code>true</code>, the dynamically modified configuration is not persisted, and the configuration will be restored to the initial configuration after the service is restarted. For more information, see Modify configurations.</p> <p>Note</p> <p>The configurations of the Raft Listener and the Storage service are different. For details, see Deploy Raft listener.</p> <p>For all parameters and their current values, see Configurations.</p>"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#basics_configurations","title":"Basics configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>daemonize</code> <code>true</code> When set to <code>true</code>, the process is a daemon process. No <code>pid_file</code> <code>pids/nebula-storaged.pid</code> The file that records the process ID. No <code>timezone_name</code> <code>UTC+00:00:00</code> Specifies the NebulaGraph time zone. This parameter is not predefined in the initial configuration files, if you need to use this parameter, add it manually. For the format of the parameter value, see Specifying the Time Zone with TZ. For example, <code>--timezone_name=UTC+08:00</code> represents the GMT+8 time zone. No <code>local_config</code> <code>true</code> When set to <code>true</code>, the process gets configurations from the configuration files. No <p>Note</p> <ul> <li>While inserting property values of time types, NebulaGraph transforms time types (except TIMESTAMP) to the corresponding UTC according to the time zone specified by <code>timezone_name</code>. The time-type values returned by nGQL queries are all UTC.</li> <li><code>timezone_name</code> is only used to transform the data stored in NebulaGraph. Other time-related data of the NebulaGraph processes still uses the default time zone of the host, such as the log printing time.</li> </ul>"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#logging_configurations","title":"Logging configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>log_dir</code> <code>logs</code> The directory that stores the Storage service log. It is recommended to put logs on a different hard disk from the data. No <code>minloglevel</code> <code>0</code> Specifies the minimum level of the log. That is, log messages at or above this level. Optional values are <code>0</code> (INFO), <code>1</code> (WARNING), <code>2</code> (ERROR), <code>3</code> (FATAL). It is recommended to set it to <code>0</code> during debugging and <code>1</code> in a production environment. If it is set to <code>4</code>, NebulaGraph will not print any logs. Yes <code>v</code> <code>0</code> Specifies the detailed level of VLOG. That is, log all VLOG messages less or equal to the level. Optional values are <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>. The VLOG macro provided by glog allows users to define their own numeric logging levels and control verbose messages that are logged with the parameter <code>v</code>. For details, see Verbose Logging. Yes <code>logbufsecs</code> <code>0</code> Specifies the maximum time to buffer the logs. If there is a timeout, it will output the buffered log to the log file. <code>0</code> means real-time output. This configuration is measured in seconds. No <code>redirect_stdout</code> <code>true</code> When set to <code>true</code>, the process redirects the<code>stdout</code> and <code>stderr</code> to separate output files. No <code>stdout_log_file</code> <code>graphd-stdout.log</code> Specifies the filename for the <code>stdout</code> log. No <code>stderr_log_file</code> <code>graphd-stderr.log</code> Specifies the filename for the <code>stderr</code> log. No <code>stderrthreshold</code> <code>3</code> Specifies the <code>minloglevel</code> to be copied to the <code>stderr</code> log. No <code>timestamp_in_logfile_name</code> <code>true</code> Specifies if the log file name contains a timestamp. <code>true</code> indicates yes, <code>false</code> indicates no. No"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#networking_configurations","title":"Networking configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>meta_server_addrs</code> <code>127.0.0.1:9559</code> Specifies the IPs (or hostnames) and ports of all Meta Services.  Multiple addresses are separated with commas. No <code>local_ip</code> <code>127.0.0.1</code> Specifies the local IP (or hostname) for the Storage Service. The local IP address is used to identify the nebula-storaged process. If it is a distributed cluster or requires remote access, modify it to the corresponding address. No <code>port</code> <code>9779</code> Specifies RPC daemon listening port of the Storage service. The neighboring ports <code>-1</code> (<code>9778</code>) and <code>+1</code> (<code>9780</code>) are also used. <code>9778</code>: The port used by the Admin service, which receives Meta commands for Storage. <code>9780</code>: The port used for Raft communication between Storage services. No <code>ws_ip</code> <code>0.0.0.0</code> Specifies the IP address for the HTTP service. No <code>ws_http_port</code> <code>19779</code> Specifies the port for the HTTP service. No <code>heartbeat_interval_secs</code> <code>10</code> Specifies the default heartbeat interval. Make sure the <code>heartbeat_interval_secs</code> values for all services are the same, otherwise NebulaGraph CANNOT work normally. This configuration is measured in seconds. Yes <p>Caution</p> <p>It is recommended to use a real IP when using IP address. Otherwise, <code>127.0.0.1/0.0.0.0</code> cannot be parsed correctly in some cases.</p>"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#raft_configurations","title":"Raft configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>raft_heartbeat_interval_secs</code> <code>30</code> Specifies the time to expire the Raft election. The configuration is measured in seconds. Yes <code>raft_rpc_timeout_ms</code> <code>500</code> Specifies the time to expire the Raft RPC. The configuration is measured in milliseconds. Yes <code>wal_ttl</code> <code>14400</code> Specifies the lifetime of the RAFT WAL. The configuration is measured in seconds. Yes"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#disk_configurations","title":"Disk configurations","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>data_path</code> <code>data/storage</code> Specifies the data storage path. Multiple paths are separated with commas. For NebulaGraph of the community edition, one RocksDB instance corresponds to one path. No <code>minimum_reserved_bytes</code> <code>268435456</code> Specifies the minimum remaining space of each data storage path. When the value is lower than this standard, the cluster data writing may fail. This configuration is measured in bytes. No <code>rocksdb_batch_size</code> <code>4096</code> Specifies the block cache for a batch operation. The configuration is measured in bytes. No <code>rocksdb_block_cache</code> <code>4</code> Specifies the block cache for BlockBasedTable. The configuration is measured in megabytes. No <code>disable_page_cache</code> <code>false</code> Enables or disables the operating system's page cache for NebulaGraph. By default, the parameter value is <code>false</code> and page cache is enabled. If the value is set to <code>true</code>, page cache is disabled and sufficient block cache space must be configured for NebulaGraph. No <code>engine_type</code> <code>rocksdb</code> Specifies the engine type. No <code>rocksdb_compression</code> <code>lz4</code> Specifies the compression algorithm for RocksDB. Optional values are <code>no</code>, <code>snappy</code>, <code>lz4</code>, <code>lz4hc</code>, <code>zlib</code>, <code>bzip2</code>, and <code>zstd</code>.This parameter modifies the compression algorithm for each level. If you want to set different compression algorithms for each level, use the parameter <code>rocksdb_compression_per_level</code>. No <code>rocksdb_compression_per_level</code> \\ Specifies the compression algorithm for each level. The priority is higher than <code>rocksdb_compression</code>. For example, <code>no:no:lz4:lz4:snappy:zstd:snappy</code>.You can also not set certain levels of compression algorithms, for example, <code>no:no:lz4:lz4::zstd</code>, level L4 and L6 use the compression algorithm of <code>rocksdb_compression</code>. No <code>enable_rocksdb_statistics</code> <code>false</code> When set to <code>false</code>, RocksDB statistics is disabled. No <code>rocksdb_stats_level</code> <code>kExceptHistogramOrTimers</code> Specifies the stats level for RocksDB. Optional values are <code>kExceptHistogramOrTimers</code>, <code>kExceptTimers</code>, <code>kExceptDetailedTimers</code>, <code>kExceptTimeForMutex</code>, and <code>kAll</code>. No <code>enable_rocksdb_prefix_filtering</code> <code>true</code> When set to <code>true</code>, the prefix bloom filter for RocksDB is enabled. Enabling prefix bloom filter makes the graph traversal faster but occupies more memory. No <code>enable_rocksdb_whole_key_filtering</code> <code>false</code> When set to <code>true</code>, the whole key bloom filter for RocksDB is enabled. <code>rocksdb_filtering_prefix_length</code> <code>12</code> Specifies the prefix length for each key. Optional values are <code>12</code> and <code>16</code>. The configuration is measured in bytes. No <code>enable_partitioned_index_filter</code> <code>false</code> When set to <code>true</code>, it reduces the amount of memory used by the bloom filter. But in some random-seek situations, it may reduce the read performance. This parameter is not predefined in the initial configuration files, if you need to use this parameter, add it manually. No"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#rocksdb_options","title":"RocksDB options","text":"Name Predefined value Description Whether supports runtime dynamic modifications <code>rocksdb_db_options</code> <code>{}</code> Specifies the RocksDB database options. No <code>rocksdb_column_family_options</code> <code>{\"write_buffer_size\":\"67108864\",</code><code>\"max_write_buffer_number\":\"4\",</code><code>\"max_bytes_for_level_base\":\"268435456\"}</code> Specifies the RocksDB column family options. No <code>rocksdb_block_based_table_options</code> <code>{\"block_size\":\"8192\"}</code> Specifies the RocksDB block based table options. No <p>The format of the RocksDB option is <code>{\"&lt;option_name&gt;\":\"&lt;option_value&gt;\"}</code>. Multiple options are separated with commas.</p> <p>Supported options of <code>rocksdb_db_options</code> and <code>rocksdb_column_family_options</code> are listed as follows.</p> <ul> <li><code>rocksdb_db_options</code><pre><code>max_total_wal_size\ndelete_obsolete_files_period_micros\nmax_background_jobs\nstats_dump_period_sec\ncompaction_readahead_size\nwritable_file_max_buffer_size\nbytes_per_sync\nwal_bytes_per_sync\ndelayed_write_rate\navoid_flush_during_shutdown\nmax_open_files\nstats_persist_period_sec\nstats_history_buffer_size\nstrict_bytes_per_sync\nenable_rocksdb_prefix_filtering\nenable_rocksdb_whole_key_filtering\nrocksdb_filtering_prefix_length\nnum_compaction_threads\nrate_limit\n</code></pre> </li> </ul> <ul> <li><code>rocksdb_column_family_options</code><pre><code>write_buffer_size\nmax_write_buffer_number\nlevel0_file_num_compaction_trigger\nlevel0_slowdown_writes_trigger\nlevel0_stop_writes_trigger\ntarget_file_size_base\ntarget_file_size_multiplier\nmax_bytes_for_level_base\nmax_bytes_for_level_multiplier\ndisable_auto_compactions \n</code></pre> </li> </ul> <p>For more information, see RocksDB official documentation.</p>"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#misc_configurations","title":"Misc configurations","text":"<p>Caution</p> <p>The configuration <code>snapshot</code> in the following table is different from the snapshot in NebulaGraph. The <code>snapshot</code> here refers to the stock data on the leader when synchronizing Raft.</p> Name Predefined value Description Whether supports runtime dynamic modifications <code>query_concurrently</code> <code>true</code> Whether to turn on multi-threaded queries. Enabling it can improve the latency performance of individual queries, but it will reduce the overall throughput under high pressure. Yes <code>auto_remove_invalid_space</code> <code>true</code> After executing <code>DROP SPACE</code>, the specified graph space will be deleted. This parameter sets whether to delete all the data in the specified graph space at the same time. When the value is <code>true</code>, all the data in the specified graph space will be deleted at the same time. Yes <code>num_io_threads</code> <code>16</code> The number of network I/O threads used to send RPC requests and receive responses. No <code>num_max_connections</code> <code>0</code> Max active connections for all networking threads. 0 means no limit.Max connections for each networking thread = num_max_connections / num_netio_threads No <code>num_worker_threads</code> <code>32</code> The number of worker threads for one RPC-based Storage service. No <code>max_concurrent_subtasks</code> <code>10</code> The maximum number of concurrent subtasks to be executed by the task manager. No <code>snapshot_part_rate_limit</code> <code>10485760</code> The rate limit when the Raft leader synchronizes the stock data with other members of the Raft group. Unit: bytes/s. Yes <code>snapshot_batch_size</code> <code>1048576</code> The amount of data sent in each batch when the Raft leader synchronizes the stock data with other members of the Raft group. Unit: bytes. Yes <code>rebuild_index_part_rate_limit</code> <code>4194304</code> The rate limit when the Raft leader synchronizes the index data rate with other members of the Raft group during the index rebuilding process. Unit: bytes/s. Yes <code>rebuild_index_batch_size</code> <code>1048576</code> The amount of data sent in each batch when the Raft leader synchronizes the index data with other members of the Raft group during the index rebuilding process. Unit: bytes. Yes"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#memory_tracker_configurations","title":"Memory Tracker configurations","text":"<p>Note</p> <p>Memory Tracker is a memory management tool designed to monitor and limit memory usage. For large-scale queries, Memory Tracker can prevent Out Of Memory (OOM) issues. If you're using Memory Tracker in a containerized environment, you need to add the relevant configurations to the configuration file of the Storage service.</p> <ol> <li>Create the directory <code>/sys/fs/cgroup/storaged/</code>, and then add and configure the <code>memory.max</code> file under the directory.</li> <li> <p>Add the following configurations to <code>etc/nebula-storaged.conf</code>.</p> <pre><code>--containerized=true\n--cgroup_v2_controllers=/sys/fs/cgroup/graphd/cgroup.controllers\n--cgroup_v2_memory_stat_path=/sys/fs/cgroup/graphd/memory.stat\n--cgroup_v2_memory_max_path=/sys/fs/cgroup/graphd/memory.max\n--cgroup_v2_memory_current_path=/sys/fs/cgroup/graphd/memory.current\n</code></pre> </li> </ol> <p>For more details, see Memory Tracker: Memory Management Practice in NebulaGraph Database.</p> Name Predefined value Description Whether supports runtime dynamic modifications <code>memory_tracker_limit_ratio</code> <code>0.8</code> The value of this parameter can be set to <code>(0, 1]</code>, <code>2</code>, and <code>3</code>.<code>(0, 1]</code>: The percentage of available memory. Formula: <code>Percentage of available memory = Available memory / (Total memory - Reserved memory)</code>.When an ongoing query results in memory usage exceeding the configured limit, the query fails and subsequently the memory is released.  Note: For the hybrid deployment of a cluster with cloud-based and on-premises nodes, the value of <code>memory_tracker_limit_ratio</code> should be set to a lower value. For example, when the graphd is expected to occupy only 50% of memory, the value can be set to less than <code>0.5</code>.<code>2</code>: Dynamic Self Adaptive mode. MemoryTracker dynamically adjusts the available memory based on the system's current available memory. Note: This feature is experimental. As memory usage cannot be monitored in real time in dynamic adaptive mode, an OOM error may still occur to handle large memory allocations. <code>3</code>: Disable MemoryTracker. MemoryTracker only logs memory usage and does not interfere with executions even if the limit is exceeded. Yes <code>memory_tracker_untracked_reserved_memory_mb</code> <code>50</code> The reserved memory that is not tracked by the Memory Tracker. Unit: MB. Yes <code>memory_tracker_detail_log</code> <code>false</code> Whether to enable the Memory Tracker log. When the value is <code>true</code>, the Memory Tracker log is generated. Yes <code>memory_tracker_detail_log_interval_ms</code> <code>60000</code> The time interval for generating the Memory Tracker log. Unit: Millisecond. <code>memory_tracker_detail_log</code> is <code>true</code> when this parameter takes effect. Yes <code>memory_purge_enabled</code> <code>true</code> Whether to enable the memory purge feature. When the value is <code>true</code>, the memory purge feature is enabled. Yes <code>memory_purge_interval_seconds</code> <code>10</code> The time interval for the memory purge feature to purge memory. Unit: Second. This parameter only takes effect if <code>memory_purge_enabled</code> is set to true. Yes"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#for_super-large_vertices","title":"For super-Large vertices","text":"<p>When the query starting from each vertex gets an edge, truncate it directly to avoid too many neighboring edges on the super-large vertex, because a single query occupies too much hard disk and memory. Or you can truncate a certain number of edges specified in the <code>Max_edge_returned_per_vertex</code> parameter. Excess edges will not be returned. This parameter applies to all spaces.</p> Property name Default value Description Whether supports runtime dynamic modifications max_edge_returned_per_vertex <code>2147483647</code> Specifies the maximum number of edges returned for each dense vertex. Excess edges are truncated and not returned. This parameter is not predefined in the initial configuration files, if you need to use this parameter, add it manually. No"},{"location":"5.configurations-and-logs/1.configurations/4.storage-config/#storage_configurations_for_large_dataset","title":"Storage configurations for large dataset","text":"<p>Warning</p> <p>One graph space takes up at least about 300 MB of memory.</p> <p>When you have a large dataset (in the RocksDB directory) and your memory is tight, we suggest that you set the <code>enable_partitioned_index_filter</code> parameter to <code>true</code>. The performance is affected because RocksDB indexes are cached.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/","title":"Kernel configurations","text":"<p>This topic introduces the Kernel configurations in Nebula\u00a0Graph.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#resource_control","title":"Resource control","text":"<p>You may run the <code>ulimit</code> command to control the resource threshold. However, the changes made only take effect for the current session or sub-process. To make permanent changes, edit file <code>/etc/security/limits.conf</code>. The configuration is as follows:</p> <pre><code># &lt;domain&gt;     &lt;type&gt;      &lt;item&gt;          &lt;value&gt;\n*              soft         core           unlimited    \n*              hard         core           unlimited   \n*              soft         nofile          130000   \n*              hard         nofile          130000\n</code></pre> <p>Note</p> <p>The configuration modification takes effect for new sessions.</p> <p>The parameter descriptions are as follows.</p> Parameter Description <code>domain</code> Control Domain. This parameter can be a user name, a user group name (starting with <code>@</code>), or <code>*</code> to indicate all users. <code>type</code> Control type. This parameter can be <code>soft</code> or <code>hard</code>. <code>soft</code> indicates a soft threshold (the default threshold) for the resource and <code>hard</code> indicates a maximum value that can be set by the user. The <code>ulimit</code> command can be used to increase <code>soft</code>, but not to exceed <code>hard</code>. <code>item</code> Resource types. For example, <code>core</code> limits the size of the core dump file, and <code>nofile</code> limits the maximum number of file descriptors a process can open. <code>value</code> Resource limit value. This parameter can be a number, or <code>unlimited</code> to indicate that there is no limit. <p>You can run <code>man limits.conf</code> for more helpful information.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#memory","title":"Memory","text":""},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#vmswappiness","title":"vm.swappiness","text":"<p><code>vm.swappiness</code> specifies the percentage of the available memory before starting swap. The greater the value, the more likely the swap occurs. We recommend that you set it to 0. When set to 0, the page cache is removed first. Note that when <code>vm.swappiness</code> is 0, it does not mean that there is no swap.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#vmmin_free_kbytes","title":"vm.min_free_kbytes","text":"<p><code>vm.min_free_kbytes</code> specifies the minimum number of kilobytes available kept by Linux VM. If you have a large system memory, we recommend that you increase this value. For example, if your physical memory 128GB, set it to 5GB. If the value is not big enough, the system cannot apply for enough continuous physical memory.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#vmmax_map_count","title":"vm.max_map_count","text":"<p><code>vm.max_map_count</code> limits the maximum number of vma (virtual memory area) for a process. The default value is <code>65530</code>. It is enough for most applications. If your memory application fails because the memory consumption is large, increase the <code>vm.max_map_count</code> value.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#vmdirty_","title":"vm.dirty_*","text":"<p>These values control the dirty data cache for the system. For write-intensive scenarios, you can make adjustments based on your needs (throughput priority or delay priority). We recommend that you use the system default value.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#transparent_huge_pages","title":"Transparent Huge Pages","text":"<p>Transparent Huge Pages (THP) is a memory management feature of the Linux kernel, which enhances the system's ability to use large pages. In most database systems, Transparent Huge Pages can degrade performance, so it is recommended to disable it.</p> <p>Perform the following steps:</p> <ol> <li> <p>Edit the GRUB configuration file <code>/etc/default/grub</code>.</p> <pre><code>sudo vi /etc/default/grub\n</code></pre> </li> <li> <p>Add <code>transparent_hugepage=never</code> to the <code>GRUB_CMDLINE_LINUX</code> option, and then save and exit.</p> <pre><code>GRUB_CMDLINE_LINUX=\"... transparent_hugepage=never\"\n</code></pre> </li> <li> <p>Update the GRUB configuration.</p> <ul> <li> <p>For CentOS:</p> <pre><code>sudo grub2-mkconfig -o /boot/grub2/grub.cfg\n</code></pre> </li> </ul> <ul> <li> <p>For Ubuntu:</p> <pre><code>sudo update-grub\n</code></pre> </li> </ul> </li> <li> <p>Reboot the computer.</p> <pre><code>sudo reboot\n</code></pre> <p>If you don't want to reboot, you can run the following commands to temporarily disable THP until the next reboot.</p> <pre><code>echo 'never' &gt; /sys/kernel/mm/transparent_hugepage/enabled\necho 'never' &gt; /sys/kernel/mm/transparent_hugepage/defrag\n</code></pre> </li> </ol>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#networking","title":"Networking","text":""},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#netipv4tcp_slow_start_after_idle","title":"net.ipv4.tcp_slow_start_after_idle","text":"<p>The default value of <code>net.ipv4.tcp_slow_start_after_idle</code> is <code>1</code>. If set, the congestion window is timed out after an idle period. We recommend that you set it to <code>0</code>, especially for long fat scenarios (high latency and large bandwidth).</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#netcoresomaxconn","title":"net.core.somaxconn","text":"<p><code>net.core.somaxconn</code> specifies the maximum number of connection queues listened by the socket. The default value is <code>128</code>. For scenarios with a large number of burst connections, we recommend that you set it to greater than <code>1024</code>.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#netipv4tcp_max_syn_backlog","title":"net.ipv4.tcp_max_syn_backlog","text":"<p><code>net.ipv4.tcp_max_syn_backlog</code> specifies the maximum number of TCP connections in the SYN_RECV (semi-connected) state. The setting rule for this parameter is the same as that of <code>net.core.somaxconn</code>.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#netcorenetdev_max_backlog","title":"net.core.netdev_max_backlog","text":"<p><code>net.core.netdev_max_backlog</code> specifies the maximum number of packets. The default value is <code>1000</code>. We recommend that you increase it to greater than <code>10,000</code>, especially for 10G network adapters.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#netipv4tcp_keepalive_","title":"net.ipv4.tcp_keepalive_*","text":"<p>These values keep parameters alive for TCP connections. For applications that use a 4-layer transparent load balancer, if the idle connection is disconnected unexpectedly, decrease the values of <code>tcp_keepalive_time</code> and <code>tcp_keepalive_intvl</code>.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#netipv4tcp_rmemwmem","title":"net.ipv4.tcp_rmem/wmem","text":"<p><code>net.ipv4.tcp_wmem/rmem</code> specifies the minimum, default, and maximum size of the buffer pool sent/received by the TCP socket. For long fat links, we recommend that you increase the default value to <code>bandwidth (GB) * RTT (ms)</code>.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#scheduler","title":"scheduler","text":"<p>For SSD devices, we recommend that you set <code>scheduler</code> to <code>noop</code> or <code>none</code>. The path is <code>/sys/block/DEV_NAME/queue/scheduler</code>.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#other_parameters","title":"Other parameters","text":""},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#kernelcore_pattern","title":"kernel.core_pattern","text":"<p>we recommend that you set it to <code>core</code> and set <code>kernel.core_uses_pid</code> to <code>1</code>.</p>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#modify_parameters","title":"Modify parameters","text":""},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#sysctl","title":"sysctl","text":"<ul> <li> <p><code>sysctl &lt;conf_name&gt;</code></p> <p>Checks the current parameter value.</p> </li> </ul> <ul> <li> <p><code>sysctl -w &lt;conf_name&gt;=&lt;value&gt;</code></p> <p>Modifies the parameter value. The modification takes effect immediately. The original value is restored after restarting.</p> </li> </ul> <ul> <li> <p><code>sysctl -p [&lt;file_path&gt;]</code> </p> <p>Loads Linux parameter values \u200b\u200bfrom the specified configuration file. The default path is <code>/etc/sysctl.conf</code>.</p> </li> </ul>"},{"location":"5.configurations-and-logs/1.configurations/6.kernel-config/#prlimit","title":"prlimit","text":"<p>The <code>prlimit</code> command gets and sets process resource limits. You can modify the hard threshold by using it and the <code>sudo</code> command. For example, <code>prlimit --nofile = 130000 --pid = $$</code> adjusts the maximum number of open files permitted by the current process to <code>14000</code>. And the modification takes effect immediately. Note that this command is only available in RedHat 7u or higher versions.</p>"},{"location":"5.configurations-and-logs/2.log-management/logs/","title":"Runtime logs","text":"<p>Runtime logs are provided for DBAs and developers to locate faults when the system fails.</p> <p>NebulaGraph uses glog to print runtime logs, uses gflags to control the severity level of the log, and provides an HTTP interface to dynamically change the log level at runtime to facilitate tracking.</p>"},{"location":"5.configurations-and-logs/2.log-management/logs/#log_directory","title":"Log directory","text":"<p>The default runtime log directory is <code>/usr/local/nebula/logs/</code>.</p> <p>If the log directory is deleted while NebulaGraph is running, the log would not continue to be printed. However, this operation will not affect the services. To recover the logs, restart the services.</p>"},{"location":"5.configurations-and-logs/2.log-management/logs/#parameter_descriptions","title":"Parameter descriptions","text":"<ul> <li><code>minloglevel</code>: Specifies the minimum level of the log. That is, no logs below this level will be printed. Optional values are <code>0</code> (INFO), <code>1</code> (WARNING), <code>2</code> (ERROR), <code>3</code> (FATAL). It is recommended to set it to <code>0</code> during debugging and <code>1</code> in a production environment. If it is set to <code>4</code>, NebulaGraph will not print any logs.</li> </ul> <ul> <li><code>v</code>: Specifies the detailed level of the log. The larger the value, the more detailed the log is. Optional values are <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>.</li> </ul> <p>The default severity level for the metad, graphd, and storaged logs can be found in their respective configuration files. The default path is <code>/usr/local/nebula/etc/</code>.</p>"},{"location":"5.configurations-and-logs/2.log-management/logs/#check_the_severity_level","title":"Check the severity level","text":"<p>Check all the flag values (log values included) of the current gflags with the following command.</p> <pre><code>$ curl &lt;ws_ip&gt;:&lt;ws_port&gt;/flags\n</code></pre> Parameter Description <code>ws_ip</code> The IP address for the HTTP service, which can be found in the configuration files above. The default value is <code>127.0.0.1</code>. <code>ws_port</code> The port for the HTTP service, which can be found in the configuration files above. The default values are <code>19559</code>(Meta), <code>19669</code>(Graph), and <code>19779</code>(Storage) respectively. <p>Examples are as follows:</p> <ul> <li>Check the current <code>minloglevel</code> in the Meta service:<pre><code>$ curl 127.0.0.1:19559/flags | grep 'minloglevel'\n</code></pre> </li> </ul> <ul> <li>Check the current <code>v</code> in the Storage service:<pre><code>$ curl 127.0.0.1:19779/flags | grep -w 'v'\n</code></pre> </li> </ul>"},{"location":"5.configurations-and-logs/2.log-management/logs/#change_the_severity_level","title":"Change the severity level","text":"<p>Change the severity level of the log with the following command.</p> <pre><code>$ curl -X PUT -H \"Content-Type: application/json\" -d '{\"&lt;key&gt;\":&lt;value&gt;[,\"&lt;key&gt;\":&lt;value&gt;]}' \"&lt;ws_ip&gt;:&lt;ws_port&gt;/flags\"\n</code></pre> Parameter Description <code>key</code> The type of the log to be changed. For optional values, see Parameter descriptions. <code>value</code> The level of the log. For optional values, see Parameter descriptions. <code>ws_ip</code> The IP address for the HTTP service, which can be found in the configuration files above. The default value is <code>127.0.0.1</code>. <code>ws_port</code> The port for the HTTP service, which can be found in the configuration files above. The default values are <code>19559</code>(Meta), <code>19669</code>(Graph), and <code>19779</code>(Storage) respectively. <p>Examples are as follows:</p> <pre><code>$ curl -X PUT -H \"Content-Type: application/json\" -d '{\"minloglevel\":0,\"v\":3}' \"127.0.0.1:19779/flags\" # storaged\n$ curl -X PUT -H \"Content-Type: application/json\" -d '{\"minloglevel\":0,\"v\":3}' \"127.0.0.1:19669/flags\" # graphd\n$ curl -X PUT -H \"Content-Type: application/json\" -d '{\"minloglevel\":0,\"v\":3}' \"127.0.0.1:19559/flags\" # metad\n</code></pre> <p>If the log level is changed while NebulaGraph is running, it will be restored to the level set in the configuration file after restarting the service. To permanently modify it, see Configuration files.</p>"},{"location":"5.configurations-and-logs/2.log-management/logs/#rocksdb_runtime_logs","title":"RocksDB runtime logs","text":"<p>RocksDB runtime logs are usually used to debug RocksDB parameters and stored in <code>/usr/local/nebula/data/storage/nebula/$id/data/LOG</code>. <code>$id</code> is the ID of the example.</p>"},{"location":"5.configurations-and-logs/2.log-management/logs/#log_recycling","title":"Log recycling","text":"<p>Glog does not inherently support log recycling. To implement this feature, you can either use cron jobs in Linux to regularly remove old log files or use the log management tool, logrotate, to rotate logs for regular archiving and deletion.</p>"},{"location":"5.configurations-and-logs/2.log-management/logs/#log_recycling_using_cron_jobs","title":"Log recycling using cron jobs","text":"<p>This section provides an example of how to use cron jobs to regularly delete old log files from the Graph service's runtime logs.</p> <ol> <li> <p>In the Graph service configuration file, apply the following settings and restart the service:</p> <pre><code>timestamp_in_logfile_name = true\nmax_log_size = 500\n</code></pre> <ul> <li>By setting <code>timestamp_in_logfile_name</code> to <code>true</code>, the log file name includes a timestamp, allowing regular deletion of old log files.</li> <li>The <code>max_log_size</code> parameter sets the maximum size of a single log file in MB, such as <code>500</code>. Once this size is exceeded, a new log file is automatically created. The default value is <code>1800</code>.</li> </ul> </li> <li> <p>Use the following command to open the cron job editor.</p> <pre><code>crontab -e\n</code></pre> </li> <li> <p>Add a cron job command to the editor to regularly delete old log files.</p> <pre><code>* * * * * find &lt;log_path&gt; -name \"&lt;YourProjectName&gt;\" -mtime +7 -delete\n</code></pre> <p>Caution</p> <p>The <code>find</code> command in the above command should be executed by the root user or a user with sudo privileges.</p> <ul> <li><code>* * * * *</code>: This cron job time field signifies that the task is executed every minute. For other settings, see Cron Expression.</li> <li><code>&lt;log_path&gt;</code>: The path of the service runtime log file, such as <code>/usr/local/nebula/logs</code>.</li> <li><code>&lt;YourProjectName&gt;</code>: The log file name, such as <code>nebula-graphd.*</code>.</li> <li><code>-mtime +7</code>: This deletes log files that are older than 7 days. Alternatively, use <code>-mmin +n</code> to delete log files older than <code>n</code> minutes. For details, see the find command.</li> <li><code>-delete</code>: This deletes log files that meet the conditions.</li> </ul> <p>For example, to automatically delete the Graph service runtime log files older than 7 days at 3 o'clock every morning, use:</p> <pre><code>0 3 * * * find /usr/local/nebula/logs -name nebula-graphd.* -mtime +7 -delete\n</code></pre> </li> <li> <p>Save the cron job and exit the editor.</p> </li> </ol>"},{"location":"5.configurations-and-logs/2.log-management/logs/#log_recycling_using_logrotate","title":"Log recycling using logrotate","text":"<p>Logrotate is a tool that can rotate specified log files for archiving and recycling.</p> <p>Note</p> <p>You must be the root user or a user with sudo privileges to install or run logrotate.</p> <p>This section provides an example of how to use logrotate to manage the Graph service's <code>INFO</code> level log file (<code>/usr/local/nebula/logs/nebula-graphd.INFO.impl</code>). </p> <ol> <li> <p>In the Graph service configuration file, set <code>timestamp_in_logfile_name</code> to <code>false</code> so that the logrotate tool can recognize the log file name. Then, restart the service.</p> <pre><code>timestamp_in_logfile_name = false\n</code></pre> </li> <li> <p>Install logrotate.</p> <ul> <li> <p>For Debian/Ubuntu:</p> <pre><code>sudo apt-get install logrotate\n</code></pre> </li> </ul> <ul> <li> <p>For CentOS/RHEL:</p> <pre><code>sudo yum install logrotate\n</code></pre> </li> </ul> </li> <li> <p>Create a logrotate configuration file, add log rotation rules, and save the configuration file.</p> <p>In the <code>/etc/logrotate.d</code> directory, create a new logrotate configuration file <code>nebula-graphd.INFO</code>.</p> <pre><code>sudo vim /etc/logrotate.d/nebula-graphd.INFO\n</code></pre> <p>Then, add the following content:</p> <pre><code># The absolute path of the log file needs to be configured\n# And the file name cannot be a symbolic link file, such as `nebula-graph.INFO`\n/usr/local/nebula/logs/nebula-graphd.INFO.impl {\n    daily\n    rotate 2\n    copytruncate\n    nocompress\n    missingok\n    notifempty\n    create 644 root root\n    dateext\n    dateformat .%Y-%m-%d-%s\n    maxsize 1k\n}\n</code></pre> Parameter Description <code>daily</code> Rotate the log daily. Other available time units include <code>hourly</code>, <code>daily</code>, <code>weekly</code>, <code>monthly</code>, and <code>yearly</code>. <code>rotate 2</code> Keep the most recent 2 log files before deleting the older one. <code>copytruncate</code> Copy the current log file and then truncate it, ensuring no disruption to the logging process. <code>nocompress</code> Do not compress the old log files. <code>missingok</code> Do not report errors if the log file is missing. <code>notifempty</code> Do not rotate the log file if it's empty. <code>create 644 root root</code> Create a new log file with the specified permissions and ownership. <code>dateext</code> Add a date extension to the log file name. The default is the current date in the format <code>-%Y%m%d</code>. You can extend this using the <code>dateformat</code> option. <code>dateformat .%Y-%m-%d-%s</code> This must follow immediately after <code>dateext</code> and defines the file name after log rotation. Before V3.9.0, only <code>%Y</code>, <code>%m</code>, <code>%d</code>, and <code>%s</code> parameters were supported. Starting from V3.9.0, the <code>%H</code> parameter is also supported. <code>maxsize 1k</code> Rotate the log when it exceeds 1 kilobyte (<code>1024</code> bytes) in size or when the specified time unit (e.g., <code>daily</code>) passes. You can use size units like <code>k</code> and <code>M</code>, with the default unit being bytes. <p>Modify the parameters in the configuration file according to actual needs. For more information about parameter configuration, see logrotate.</p> </li> <li> <p>Test the logrotate configuration.</p> <p>To verify whether the logrotate configuration is correct, use the following command for testing.</p> <pre><code>sudo logrotate --debug /etc/logrotate.d/nebula-graphd.INFO\n</code></pre> </li> <li> <p>Execute logrotate.</p> <p>Although <code>logrotate</code> is typically executed automatically by cron jobs, you can manually execute the following command to perform log rotation immediately.</p> <pre><code>sudo logrotate -fv /etc/logrotate.d/nebula-graphd.INFO\n</code></pre> <p><code>-fv</code>: <code>f</code> stands for forced execution, <code>v</code> stands for verbose output.</p> </li> <li> <p>Verify the log rotation results.</p> <p>After log rotation, new log files are found in the <code>/usr/local/nebula/logs</code> directory, such as <code>nebula-graphd.INFO.impl.2024-01-04-1704338204</code>. The original log content is cleared, but the file is retained for new log entries. When the number of log files exceeds the value set by <code>rotate</code>, the oldest log file is deleted. </p> <p>For example, <code>rotate</code>2` means keeping the 2 most recently generated log files. When the number of log files exceeds 2, the oldest log file is deleted.</p> <pre><code>[test@test logs]$ ll\n-rw-r--r-- 1 root root        0 Jan  4 11:18 nebula-graphd.INFO.impl \n-rw-r--r-- 1 root root     6894 Jan  4 11:16 nebula-graphd.INFO.impl.2024-01-04-1704338204 # This file is deleted when a new log file is generated\n-rw-r--r-- 1 root root      222 Jan  4 11:18 nebula-graphd.INFO.impl.2024-01-04-1704338287\n[test@test logs]$ ll\n-rw-r--r-- 1 root root        0 Jan  4 11:18 nebula-graphd.INFO.impl\n-rw-r--r-- 1 root root      222 Jan  4 11:18 nebula-graphd.INFO.impl.2024-01-04-1704338287\n-rw-r--r-- 1 root root      222 Jan  4 11:18 nebula-graphd.INFO.impl.2024-01-04-1704338339 # The new log file is generated\n</code></pre> </li> </ol> <p>If you need to rotate multiple log files, create multiple configuration files in the <code>/etc/logrotate.d</code> directory, with each configuration file corresponding to a log file. For example, to rotate the <code>INFO</code> level log file and the <code>WARNING</code> level log file of the Meta service, create two configuration files <code>nebula-metad.INFO</code> and <code>nebula-metad.WARNING</code>, and add log rotation rules in them respectively.</p>"},{"location":"6.monitor-and-metrics/1.query-performance-metrics/","title":"Query NebulaGraph metrics","text":"<p>NebulaGraph supports querying the monitoring metrics through HTTP ports.</p>"},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#metrics_structure","title":"Metrics structure","text":"<p>Each metric of NebulaGraph consists of three fields: name, type, and time range. The fields are separated by periods, for example, <code>num_queries.sum.600</code>. Different NebulaGraph services (Graph, Storage, or Meta) support different metrics. The detailed description is as follows.</p> Field Example Description Metric name <code>num_queries</code> Indicates the function of the metric. Metric type <code>sum</code> Indicates how the metrics are collected. Supported types are SUM, AVG, RATE, and the P-th sample quantiles such as P75, P95, P99, and P999. Time range <code>600</code> The time range in seconds for the metric collection. Supported values are 5, 60, 600, and 3600, representing the last 5 seconds, 1 minute, 10 minutes, and 1 hour."},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#query_metrics_over_http","title":"Query metrics over HTTP","text":""},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#syntax","title":"Syntax","text":"<pre><code>curl -G \"http://&lt;host&gt;:&lt;port&gt;/stats?stats=&lt;metric_name_list&gt; [&amp;format=json]\"\n</code></pre> Parameter Description <code>host</code> The IP (or hostname) of the server. You can find it in the configuration file in the installation directory. <code>port</code> The HTTP port of the server. You can find it in the configuration file in the installation directory. The default ports are 19559 (Meta), 19669 (Graph), and 19779 (Storage). <code>metric_name_list</code> The metrics names. Multiple metrics are separated by commas (,). <code>&amp;format=json</code> Optional. Returns the result in the JSON format. <p>Note</p> <p>If NebulaGraph is deployed with Docker Compose, run <code>docker-compose ps</code> to check the ports that are mapped from the service ports inside of the container and then query through them.</p>"},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#query_a_single_metric","title":"Query a single metric","text":"<p>Query the query number in the last 10 minutes in the Graph Service.</p> <pre><code>$ curl -G \"http://192.168.8.40:19669/stats?stats=num_queries.sum.600\"\nnum_queries.sum.600=400\n</code></pre>"},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#query_multiple_metrics","title":"Query multiple metrics","text":"<p>Query the following metrics together:</p> <ul> <li>The average heartbeat latency in the last 1 minute.</li> </ul> <ul> <li> <p>The average latency of the slowest 1% heartbeats, i.e., the P99 heartbeats, in the last 10 minutes.</p> <pre><code>$ curl -G \"http://192.168.8.40:19559/stats?stats=heartbeat_latency_us.avg.60,heartbeat_latency_us.p99.600\"\nheartbeat_latency_us.avg.60=281\nheartbeat_latency_us.p99.600=985\n</code></pre> </li> </ul>"},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#return_a_json_result","title":"Return a JSON result.","text":"<p>Query the number of new vertices in the Storage Service in the last 10 minutes and return the result in the JSON format.</p> <pre><code>$ curl -G \"http://192.168.8.40:19779/stats?stats=num_add_vertices.sum.600&amp;format=json\"\n[{\"value\":1,\"name\":\"num_add_vertices.sum.600\"}]\n</code></pre>"},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#query_all_metrics_in_a_service","title":"Query all metrics in a service.","text":"<p>If no metric is specified in the query, NebulaGraph returns all metrics in the service.</p> <pre><code>$ curl -G \"http://192.168.8.40:19559/stats\"\nheartbeat_latency_us.avg.5=304\nheartbeat_latency_us.avg.60=308\nheartbeat_latency_us.avg.600=299\nheartbeat_latency_us.avg.3600=285\nheartbeat_latency_us.p75.5=652\nheartbeat_latency_us.p75.60=669\nheartbeat_latency_us.p75.600=651\nheartbeat_latency_us.p75.3600=642\nheartbeat_latency_us.p95.5=930\nheartbeat_latency_us.p95.60=963\nheartbeat_latency_us.p95.600=933\nheartbeat_latency_us.p95.3600=929\nheartbeat_latency_us.p99.5=986\nheartbeat_latency_us.p99.60=1409\nheartbeat_latency_us.p99.600=989\nheartbeat_latency_us.p99.3600=986\nnum_heartbeats.rate.5=0\nnum_heartbeats.rate.60=0\nnum_heartbeats.rate.600=0\nnum_heartbeats.rate.3600=0\nnum_heartbeats.sum.5=2\nnum_heartbeats.sum.60=40\nnum_heartbeats.sum.600=394\nnum_heartbeats.sum.3600=2364\n...\n</code></pre>"},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#space-level_metrics","title":"Space-level metrics","text":"<p>The Graph service supports a set of space-level metrics that record the information of different graph spaces separately.</p> <p>Space-level metrics can be queried only by querying all metrics. For example, run <code>curl -G \"http://192.168.8.40:19559/stats\"</code> to show all metrics. The returned result contains the graph space name in the form of '{space=space_name}', such as <code>num_active_queries{space=basketballplayer}.sum.5=0</code>.</p> <p>Caution</p> <p>To enable space-level metrics, set the value of <code>enable_space_level_metrics</code> to <code>true</code> in the Graph service configuration file before starting NebulaGraph. For details about how to modify the configuration, see Configuration Management.</p>"},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#metric_description","title":"Metric description","text":""},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#graph","title":"Graph","text":"Parameter Description <code>num_active_queries</code> The number of changes in the number of active queries. Formula: The number of started queries minus the number of finished queries within a specified time. <code>num_active_sessions</code> The number of changes in the number of active sessions. Formula: The number of logged in sessions minus the number of logged out sessions within a specified time.For example, when querying <code>num_active_sessions.sum.5</code>, if there were 10 sessions logged in and 30 sessions logged out in the last 5 seconds, the value of this metric is <code>-20</code> (10-30). <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions_out_of_max_allowed</code> The number of sessions that failed to authenticate logins because the value of the parameter <code>FLAG_OUT_OF_MAX_ALLOWED_CONNECTIONS</code> was exceeded. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_killed_queries</code> The number of killed queries. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries</code> The number of queries. <code>num_query_errors_leader_changes</code> The number of the raft leader changes due to query errors. <code>num_query_errors</code> The number of query errors. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>num_sentences</code> The number of statements received by the Graphd service. <code>num_slow_queries</code> The number of slow queries. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>slow_query_latency_us</code> The latency of slow queries. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>resp_part_completeness</code> The completeness of the partial success. You need to set <code>accept_partial_success</code> to <code>true</code> in the graph configuration first."},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#meta","title":"Meta","text":"Parameter Description <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>heartbeat_latency_us</code> The latency of heartbeats. <code>num_heartbeats</code> The number of heartbeats. <code>num_raft_votes</code> The number of votes in Raft. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>num_agent_heartbeats</code> The number of heartbeats for the AgentHBProcessor. <code>agent_heartbeat_latency_us</code> The latency of the AgentHBProcessor. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_send_snapshot</code> The number of times that Raft sends snapshots to other nodes. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>num_start_elect</code> The number of times that Raft starts an election."},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#storage","title":"Storage","text":"Parameter Description <code>add_edges_latency_us</code> The latency of adding edges. <code>add_vertices_latency_us</code> The latency of adding vertices. <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>delete_edges_latency_us</code> The latency of deleting edges. <code>delete_vertices_latency_us</code> The latency of deleting vertices. <code>get_neighbors_latency_us</code> The latency of querying neighbor vertices. <code>get_dst_by_src_latency_us</code> The latency of querying the destination vertex by the source vertex. <code>num_get_prop</code> The number of executions for the GetPropProcessor. <code>num_get_neighbors_errors</code> The number of execution errors for the GetNeighborsProcessor. <code>num_get_dst_by_src_errors</code> The number of execution errors for the GetDstBySrcProcessor. <code>get_prop_latency_us</code> The latency of executions for the GetPropProcessor. <code>num_edges_deleted</code> The number of deleted edges. <code>num_edges_inserted</code> The number of inserted edges. <code>num_raft_votes</code> The number of votes in Raft. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Storage service sent to the Meta service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Storaged service sent to the Metad service. <code>num_tags_deleted</code> The number of deleted tags. <code>num_vertices_deleted</code> The number of deleted vertices. <code>num_vertices_inserted</code> The number of inserted vertices. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>lookup_latency_us</code> The latency of executions for the LookupProcessor. <code>num_lookup_errors</code> The number of execution errors for the LookupProcessor. <code>num_scan_vertex</code> The number of executions for the ScanVertexProcessor. <code>num_scan_vertex_errors</code> The number of execution errors for the ScanVertexProcessor. <code>update_edge_latency_us</code> The latency of executions for the UpdateEdgeProcessor. <code>num_update_vertex</code> The number of executions for the UpdateVertexProcessor. <code>num_update_vertex_errors</code> The number of execution errors for the UpdateVertexProcessor. <code>kv_get_latency_us</code> The latency of executions for the Getprocessor. <code>kv_put_latency_us</code> The latency of executions for the PutProcessor. <code>kv_remove_latency_us</code> The latency of executions for the RemoveProcessor. <code>num_kv_get_errors</code> The number of execution errors for the GetProcessor. <code>num_kv_get</code> The number of executions for the GetProcessor. <code>num_kv_put_errors</code> The number of execution errors for the PutProcessor. <code>num_kv_put</code> The number of executions for the PutProcessor. <code>num_kv_remove_errors</code> The number of execution errors for the RemoveProcessor. <code>num_kv_remove</code> The number of executions for the RemoveProcessor. <code>forward_tranx_latency_us</code> The latency of transmission. <code>scan_edge_latency_us</code> The latency of executions for the ScanEdgeProcessor. <code>num_scan_edge_errors</code> The number of execution errors for the ScanEdgeProcessor. <code>num_scan_edge</code> The number of executions for the ScanEdgeProcessor. <code>scan_vertex_latency_us</code> The latency of executions for the ScanVertexProcessor. <code>num_add_edges</code> The number of times that edges are added. <code>num_add_edges_errors</code> The number of errors when adding edges. <code>num_add_vertices</code> The number of times that vertices are added. <code>num_start_elect</code> The number of times that Raft starts an election. <code>num_add_vertices_errors</code> The number of errors when adding vertices. <code>num_delete_vertices_errors</code> The number of errors when deleting vertices. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_delete_tags</code> The number of times that tags are deleted. <code>num_delete_tags_errors</code> The number of errors when deleting tags. <code>num_delete_edges</code> The number of edge deletions. <code>num_delete_edges_errors</code> The number of errors when deleting edges <code>num_send_snapshot</code> The number of times that snapshots are sent. <code>update_vertex_latency_us</code> The latency of executions for the UpdateVertexProcessor. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_update_edge</code> The number of executions for the UpdateEdgeProcessor. <code>delete_tags_latency_us</code> The latency of deleting tags. <code>num_update_edge_errors</code> The number of execution errors for the UpdateEdgeProcessor. <code>num_get_neighbors</code> The number of executions for the GetNeighborsProcessor. <code>num_get_dst_by_src</code> The number of executions for the GetDstBySrcProcessor. <code>num_get_prop_errors</code> The number of execution errors for the GetPropProcessor. <code>num_delete_vertices</code> The number of times that vertices are deleted. <code>num_lookup</code> The number of executions for the LookupProcessor. <code>num_sync_data</code> The number of times the Storage service synchronizes data from the Drainer. <code>num_sync_data_errors</code> The number of errors that occur when the Storage service synchronizes data from the Drainer. <code>sync_data_latency_us</code> The latency of the Storage service synchronizing data from the Drainer."},{"location":"6.monitor-and-metrics/1.query-performance-metrics/#graph_space","title":"Graph space","text":"<p>Note</p> <p>Space-level metrics are created dynamically, so that only when the behavior is triggered in the graph space, the corresponding metric is created and can be queried by the user.</p> Parameter Description <code>num_active_queries</code> The number of queries currently being executed. <code>num_queries</code> The number of queries. <code>num_sentences</code> The number of statements received by the Graphd service. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>num_slow_queries</code> The number of slow queries. <code>num_query_errors</code> The number of query errors. <code>num_query_errors_leader_changes</code> The number of raft leader changes due to query errors. <code>num_killed_queries</code> The number of killed queries. <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>slow_query_latency_us</code> The latency of slow queries."},{"location":"6.monitor-and-metrics/2.rocksdb-statistics/","title":"RocksDB statistics","text":"<p>NebulaGraph uses RocksDB as the underlying storage. This topic describes how to collect and show the RocksDB statistics of NebulaGraph.</p>"},{"location":"6.monitor-and-metrics/2.rocksdb-statistics/#enable_rocksdb","title":"Enable RocksDB","text":"<p>By default, the function of RocksDB statistics is disabled. To enable RocksDB statistics, you need to:</p> <ol> <li> <p>Modify the <code>--enable_rocksdb_statistics</code> parameter as <code>true</code> in the <code>nebula-storaged.conf</code> file. The default path of the configuration file is <code>/use/local/nebula/etc</code>.</p> </li> <li> <p>Restart the service to make the modification valid.</p> </li> </ol>"},{"location":"6.monitor-and-metrics/2.rocksdb-statistics/#get_rocksdb_statistics","title":"Get RocksDB statistics","text":"<p>Users can use the built-in HTTP service in the storage service to get the following types of statistics. Results in the JSON format are supported.</p> <ul> <li>All RocksDB statistics.</li> <li>Specified RocksDB statistics.</li> </ul>"},{"location":"6.monitor-and-metrics/2.rocksdb-statistics/#examples","title":"Examples","text":"<p>Use the following command to get all RocksDB statistics: <pre><code>curl -L \"http://${storage_ip}:${port}/rocksdb_stats\"\n</code></pre></p> <p>For example: <pre><code>curl -L \"http://172.28.2.1:19779/rocksdb_stats\"\n\nrocksdb.blobdb.blob.file.bytes.read=0\nrocksdb.blobdb.blob.file.bytes.written=0\nrocksdb.blobdb.blob.file.bytes.synced=0\n...\n</code></pre></p> <p>Use the following command to get specified RocksDB statistics: <pre><code>curl -L \"http://${storage_ip}:${port}/rocksdb_stats?stats=${stats_name}\"\n</code></pre></p> <p>For example, use the following command to get the information of <code>rocksdb.bytes.read</code> and <code>rocksdb.block.cache.add</code>. <pre><code>curl -L \"http://172.28.2.1:19779/rocksdb_stats?stats=rocksdb.bytes.read,rocksdb.block.cache.add\"\n\nrocksdb.block.cache.add=14\nrocksdb.bytes.read=1632\n</code></pre></p> <p>Use the following command to get specified RocksDB statistics in the JSON format: <pre><code>curl -L \"http://${storage_ip}:${port}/rocksdb_stats?stats=${stats_name}&amp;format=json\"\n</code></pre></p> <p>For example, use the following command to get the information of <code>rocksdb.bytes.read</code> and <code>rocksdb.block.cache.add</code> and return the results in the JSON format. <pre><code>curl -L \"http://172.28.2.1:19779/rocksdb_stats?stats=rocksdb.bytes.read,rocksdb.block.cache.add&amp;format=json\"\n\n[\n  {\n    \"rocksdb.block.cache.add\": 1\n  },\n  {\n    \"rocksdb.bytes.read\": 160\n  }\n]\n</code></pre></p>"},{"location":"7.data-security/4.ssl/","title":"SSL encryption","text":"<p>NebulaGraph supports SSL encrypted transfers between the Client, Graph Service, Meta Service, and Storage Service, and this topic describes how to set up SSL encryption.</p>"},{"location":"7.data-security/4.ssl/#precaution","title":"Precaution","text":"<p>Enabling SSL encryption will slightly affect the performance, such as causing operation latency.</p>"},{"location":"7.data-security/4.ssl/#certificate_modes","title":"Certificate modes","text":"<p>To use SSL encryption, SSL certificates are required. NebulaGraph supports two certificate modes.</p> <ul> <li> <p>Self-signed certificate mode</p> <p>A certificate that is generated by the server itself and signed by itself. In the self-signed certificate mode, the server needs to generate its own SSL certificate and key, and then use its own private key to sign the certificate. It is suitable for building secure communications for systems and applications within a LAN.</p> </li> </ul> <ul> <li> <p>CA-signed certificate mode</p> <p>A certificate granted by a trusted third-party Certificate Authority (CA). In the CA signed certificate mode, the server needs to apply for an SSL certificate from a trusted CA and ensure the authenticity and trustworthiness of the certificate through the auditing and signing of the certificate authority center. It is suitable for public network environment, especially for websites, e-commerce and other occasions that need to protect user information security.</p> </li> </ul>"},{"location":"7.data-security/4.ssl/#authentication_policies","title":"Authentication policies","text":"<p>Policies for the NebulaGraph community edition.</p> Scene TLS External device access to Graph Modify the Graph configuration file to add the following parameters:<code>--enable_graph_ssl = true</code> <code>--ca_path=xxxxxx</code><code>--cert_path=xxxxxx</code><code>--key_path=xxxxxx</code> Graph access Meta In the Graph/Meta configuration file, add the following parameters:<code>--enable_meta_ssl = true</code><code>--ca_path=xxxxxx</code><code>--cert_path=xxxxxx</code><code>--key_path=xxxxxx</code> Graph access StorageMeta access Storage In the Graph/Meta/Storage configuration file, add the following parameters:<code>--enable_storage_ssl = true</code><code>--ca_path=xxxxxx</code><code>--cert_path=xxxxxx</code><code>--key_path=xxxxxx</code> Graph access Meta/StorageMeta access Storage In the Graph/Meta/Storage configuration file, add the following parameters:<code>--enable_meta_ssl = true</code><code>--enable_storage_ssl = true</code><code>--ca_path=xxxxxx</code><code>--cert_path=xxxxxx</code><code>--key_path=xxxxxx</code> External device access to GraphGraph access Meta/StorageMeta access Storage In the Graph/Meta/Storage configuration file, add the following parameters:<code>--enable_ssl = true</code><code>--ca_path=xxxxxx</code><code>--cert_path=xxxxxx</code><code>--key_path=xxxxxx</code> <p>The parameters are described below.</p> Parameter Default value Description <code>cert_path</code> - The path to the SSL public key certificate. This certificate is usually a <code>.pem</code> or <code>.crt</code> file, which is used to prove the identity of the server side, and contains information such as the public key, certificate owner, digital signature, and so on. <code>key_path</code> - The path to the SSL key. The SSL key is usually a <code>.key</code> file. <code>password_path</code> - (Optional) The path to the password file for the SSL key. Some SSL keys are encrypted and require a corresponding password to decrypt. We need to store the password in a separate file and use this parameter to specify the path to the password file. <code>ca_path</code> - The path to the SSL root certificate. The root certificate is a special SSL certificate that is considered the highest level in the SSL trust chain and is used to validate and authorize other SSL certificates. <code>enable_ssl</code> <code>false</code> Whether to enable SSL encryption in all services. only. <code>enable_graph_ssl</code> <code>false</code> Whether to enable SSL encryption in the Graph service only. <code>enable_meta_ssl</code> <code>false</code> Whether to enable SSL encryption in the Meta service only. <code>enable_storage_ssl</code> <code>false</code> Whether to enable SSL encryption in the Storage service only."},{"location":"7.data-security/4.ssl/#example_of_tls","title":"Example of TLS","text":"<ol> <li> <p>For example, using self-signed certificates and TLS for data transfers between the client NebulaGraph Python, the Graph service, the Meta service, and the Storage service. You need to set up all three Graph/Meta/Storage configuration files as follows:</p> <pre><code>--enable_ssl=true\n--ca_path=xxxxxx\n--cert_path=xxxxxx\n--key_path=xxxxxx\n</code></pre> </li> <li> <p>When the changes are complete, restart these services to make the configuration take effect.</p> </li> <li> <p>To connect to the Graph service using NebulaGraph Python, you need to set up a secure socket and add a trusted CA. For code examples, see nebula-test-run.py.</p> </li> </ol>"},{"location":"7.data-security/1.authentication/1.authentication/","title":"Authentication","text":"<p>NebulaGraph replies on local authentication to implement access control.</p> <p>NebulaGraph creates a session when a client connects to it. The session stores information about the connection, including the user information. If the authentication system is enabled, the session will be mapped to corresponding users.</p> <p>Note</p> <p>By default, the authentication is disabled and NebulaGraph allows connections with the username <code>root</code> and any password.</p>"},{"location":"7.data-security/1.authentication/1.authentication/#local_authentication","title":"Local authentication","text":"<p>Local authentication indicates that usernames and passwords are stored locally on the server, with the passwords encrypted. Users will be authenticated when trying to visit NebulaGraph.</p>"},{"location":"7.data-security/1.authentication/1.authentication/#enable_local_authentication","title":"Enable local authentication","text":"<ol> <li> <p>Modify the <code>nebula-graphd.conf</code> file (<code>/usr/local/nebula/etc/</code> is the default path) to set the following parameters:</p> <ul> <li> <p><code>--enable_authorize</code>: Set its value to <code>true</code> to enable authentication.</p> <p>Note</p> <ul> <li>By default, the authentication is disabled and NebulaGraph allows connections with the username <code>root</code> and any password.</li> <li>You can use the username <code>root</code> and password <code>nebula</code> to log into NebulaGraph after enabling local authentication. This account has the build-in God role. For more information about roles, see Roles and privileges.</li> </ul> </li> </ul> <ul> <li><code>--failed_login_attempts</code>: This parameter is optional, and you need to add this parameter manually. Specify the attempts of continuously entering incorrect passwords for a single Graph service. When the number exceeds the limitation, your account will be locked. For multiple Graph services, the allowed attempts are <code>number of services * failed_login_attempts</code>.</li> </ul> <ul> <li><code>--password_lock_time_in_secs</code>: This parameter is optional, and you need to add this parameter manually. Specify the time how long your account is locked after multiple incorrect password entries are entered. Unit: second.</li> </ul> </li> <li> <p>Restart the NebulaGraph services. For how to restart, see Manage NebulaGraph services.</p> </li> </ol>"},{"location":"7.data-security/1.authentication/2.management-user/","title":"User management","text":"<p>User management is an indispensable part of NebulaGraph access control. This topic describes how to manage users and roles.</p> <p>After enabling authentication, only valid users can connect to NebulaGraph and access the resources according to the user roles.</p> <p>Note</p> <ul> <li>By default, the authentication is disabled. NebulaGraph allows connections with the username <code>root</code> and any password.</li> <li>Once the role of a user is modified, the user has to re-login to make the new role takes effect.</li> </ul>"},{"location":"7.data-security/1.authentication/2.management-user/#create_user","title":"CREATE USER","text":"<p>The <code>root</code> user with the GOD role can run <code>CREATE USER</code> to create a new user.</p> <ul> <li> <p>Syntax</p> <pre><code>CREATE USER [IF NOT EXISTS] &lt;user_name&gt; [WITH PASSWORD '&lt;password&gt;'];\n</code></pre> <ul> <li><code>IF NOT EXISTS</code>: Detects if the user name exists. The user will be created only if the user name does not exist.</li> <li><code>user_name</code>: Sets the name of the user. The maximum length is 16 characters.</li> <li><code>password</code>: Sets the password of the user. The default password is the empty string (<code>''</code>). The maximum length is 24 characters.</li> </ul> </li> </ul> <ul> <li> <p>Example</p> <pre><code>nebula&gt; CREATE USER user1 WITH PASSWORD 'nebula';\nnebula&gt; SHOW USERS;\n+---------+-------------------------------+\n| Account | IP Whitelist                  |\n+---------+-------------------------------+\n| \"root\"  | \"\"                            |\n| \"user1\" | \"\"                            |\n+---------+-------------------------------+\n</code></pre> </li> </ul>"},{"location":"7.data-security/1.authentication/2.management-user/#grant_role","title":"GRANT ROLE","text":"<p>Users with the GOD role or the ADMIN role can run <code>GRANT ROLE</code> to assign a built-in role in a graph space to a user. For more information about NebulaGraph built-in roles, see Roles and privileges.</p> <ul> <li> <p>Syntax</p> <pre><code>GRANT ROLE &lt;role_type&gt; ON &lt;space_name&gt; TO &lt;user_name&gt;;\n</code></pre> </li> </ul> <ul> <li> <p>Example</p> <pre><code>nebula&gt; GRANT ROLE USER ON basketballplayer TO user1;\n</code></pre> </li> </ul>"},{"location":"7.data-security/1.authentication/2.management-user/#revoke_role","title":"REVOKE ROLE","text":"<p>Users with the GOD role or the ADMIN role can run <code>REVOKE ROLE</code> to revoke the built-in role of a user in a graph space. For more information about NebulaGraph built-in roles, see Roles and privileges.</p> <ul> <li> <p>Syntax</p> <pre><code>REVOKE ROLE &lt;role_type&gt; ON &lt;space_name&gt; FROM &lt;user_name&gt;;\n</code></pre> </li> </ul> <ul> <li> <p>Example</p> <pre><code>nebula&gt; REVOKE ROLE USER ON basketballplayer FROM user1;\n</code></pre> </li> </ul>"},{"location":"7.data-security/1.authentication/2.management-user/#describe_user","title":"DESCRIBE USER","text":"<p>Users can run <code>DESCRIBE USER</code> to list the roles for a specified user.</p> <ul> <li> <p>Syntax</p> <pre><code>DESCRIBE USER &lt;user_name&gt;;\nDESC USER &lt;user_name&gt;;\n</code></pre> </li> </ul> <ul> <li> <p>Example</p> <pre><code>nebula&gt; DESCRIBE USER user1;\n+---------+--------------------+\n| role    | space              |\n+---------+--------------------+\n| \"ADMIN\" | \"basketballplayer\" |\n+---------+--------------------+\n</code></pre> </li> </ul>"},{"location":"7.data-security/1.authentication/2.management-user/#show_roles","title":"SHOW ROLES","text":"<p>Users can run <code>SHOW ROLES</code> to list the roles in a graph space.</p> <ul> <li> <p>Syntax</p> <pre><code>SHOW ROLES IN &lt;space_name&gt;;\n</code></pre> </li> </ul> <ul> <li> <p>Example</p> <pre><code>nebula&gt; SHOW ROLES IN basketballplayer;\n+---------+-----------+\n| Account | Role Type |\n+---------+-----------+\n| \"user1\" | \"ADMIN\"   |\n+---------+-----------+\n</code></pre> </li> </ul>"},{"location":"7.data-security/1.authentication/2.management-user/#change_password","title":"CHANGE PASSWORD","text":"<p>Users can run <code>CHANGE PASSWORD</code> to set a new password for a user. The old password is needed when setting a new one.</p> <ul> <li> <p>Syntax</p> <pre><code>CHANGE PASSWORD &lt;user_name&gt; FROM '&lt;old_password&gt;' TO '&lt;new_password&gt;';\n</code></pre> </li> </ul> <ul> <li> <p>Example</p> <pre><code>nebula&gt; CHANGE PASSWORD user1 FROM 'nebula' TO 'nebula123';\n</code></pre> </li> </ul>"},{"location":"7.data-security/1.authentication/2.management-user/#alter_user","title":"ALTER USER","text":"<p>The <code>root</code> user with the GOD role can run <code>ALTER USER</code> to set a new password. The old password is not needed when altering the user.</p> <ul> <li> <p>Syntax</p> <p><pre><code>ALTER USER &lt;user_name&gt; WITH PASSWORD '&lt;password&gt;';\n</code></pre> - Example</p> <pre><code>nebula&gt; ALTER USER user2 WITH PASSWORD 'nebula';\n</code></pre> </li> </ul>"},{"location":"7.data-security/1.authentication/2.management-user/#drop_user","title":"DROP USER","text":"<p>The <code>root</code> user with the GOD role can run <code>DROP USER</code> to remove a user.</p> <p>Note</p> <p>Removing a user does not close the current session of the user, and the user role still takes effect in the session until the session is closed.</p> <ul> <li> <p>Syntax</p> <pre><code>DROP USER [IF EXISTS] &lt;user_name&gt;;\n</code></pre> </li> </ul> <ul> <li> <p>Example</p> <pre><code>nebula&gt; DROP USER user1;\n</code></pre> </li> </ul>"},{"location":"7.data-security/1.authentication/2.management-user/#show_users","title":"SHOW USERS","text":"<p>The <code>root</code> user with the GOD role can run <code>SHOW USERS</code> to list all the users.</p> <ul> <li> <p>Syntax</p> <pre><code>SHOW USERS;\n</code></pre> </li> </ul> <ul> <li> <p>Example</p> <pre><code>nebula&gt; SHOW USERS;\n+---------+-----------------+\n| Account | IP Whitelist    |\n+---------+-----------------+\n| \"root\"  | \"\"              |\n| \"user1\" | \"\"              |\n| \"user2\" | \"192.168.10.10\" |\n+---------+-----------------+\n</code></pre> </li> </ul>"},{"location":"7.data-security/1.authentication/3.role-list/","title":"Roles and privileges","text":"<p>A role is a collection of privileges. You can assign a role to a user for access control.</p>"},{"location":"7.data-security/1.authentication/3.role-list/#built-in_roles","title":"Built-in roles","text":"<p>NebulaGraph does not support custom roles, but it has multiple built-in roles:</p> <ul> <li> <p>GOD</p> <ul> <li>GOD is the original role with all privileges not limited to graph spaces. It is similar to <code>root</code> in Linux and <code>administrator</code> in Windows.</li> </ul> <ul> <li>When the Meta Service is initialized, the one and only GOD role user <code>root</code> is automatically created with the password <code>nebula</code>.</li> </ul> <p>Caution</p> <p>Modify the password for <code>root</code> timely for security.</p> <ul> <li> <p>When the <code>--enable_authorize</code> parameter in the <code>nebula-graphd.conf</code> file (the default directory is <code>/usr/local/nebula/etc/</code>) is set to <code>true</code>:</p> <ul> <li>One cluster can only have one user with the GOD role. This user can manage all graph spaces in a cluster.</li> </ul> <ul> <li>Manual authorization of the God role is not supported. Only the <code>root</code> user with the default God role can be used.</li> </ul> </li> </ul> </li> </ul> <ul> <li> <p>ADMIN</p> <ul> <li>An ADMIN role can read and write both the Schema and the data in a specific graph space.</li> </ul> <ul> <li> <p>An ADMIN role of a graph space can grant DBA, USER, and GUEST roles in the graph space to other users.</p> <p>Note</p> <p>Only roles lower than ADMIN can be authorized to other users.</p> </li> </ul> </li> </ul> <ul> <li> <p>DBA</p> <ul> <li>A DBA role can read and write both the Schema and the data in a specific graph space.</li> </ul> <ul> <li>A DBA role of a graph space CANNOT grant roles to other users.</li> </ul> </li> </ul> <ul> <li> <p>USER</p> <ul> <li>A USER role can read and write data in a specific graph space.</li> </ul> <ul> <li>The Schema information is read-only to the USER roles in a graph space.</li> </ul> </li> </ul> <ul> <li>GUEST<ul> <li>A GUEST role can only read the Schema and the data in a specific graph space.</li> </ul> </li> </ul> <p>Note</p> <ul> <li>NebulaGraph does not support custom roles. Users can only use the default built-in roles.</li> <li>A user can have only one role in a graph space. For authenticated users, see User management.</li> </ul>"},{"location":"7.data-security/1.authentication/3.role-list/#role_privileges_and_allowed_ngql","title":"Role privileges and allowed nGQL","text":"<p>The privileges of roles and the nGQL statements that each role can use are listed as follows.</p> Privilege God Admin DBA User Guest Allowed nGQL Read space Y Y Y Y Y <code>USE</code>, <code>DESCRIBE SPACE</code> Read schema Y Y Y Y Y <code>DESCRIBE TAG</code>, <code>DESCRIBE EDGE</code>, <code>DESCRIBE TAG INDEX</code>, <code>DESCRIBE EDGE INDEX</code> Write schema Y Y Y Y <code>CREATE TAG</code>, <code>ALTER TAG</code>, <code>CREATE EDGE</code>, <code>ALTER EDGE</code>, <code>DROP TAG</code>, <code>DELETE TAG</code>, <code>DROP EDGE</code>, <code>CREATE TAG INDEX</code>, <code>CREATE EDGE INDEX</code>, <code>DROP TAG INDEX</code>, <code>DROP EDGE INDEX</code> Write user Y <code>CREATE USER</code>, <code>DROP USER</code>, <code>ALTER USER</code> Write role Y Y <code>GRANT</code>, <code>REVOKE</code> Read data Y Y Y Y Y <code>GO</code>, <code>SET</code>, <code>PIPE</code>, <code>MATCH</code>, <code>ASSIGNMENT</code>, <code>LOOKUP</code>, <code>YIELD</code>, <code>ORDER BY</code>, <code>FETCH VERTICES</code>, <code>Find</code>, <code>FETCH EDGES</code>, <code>FIND PATH</code>, <code>LIMIT</code>, <code>GROUP BY</code>, <code>RETURN</code> Write data Y Y Y Y <code>INSERT VERTEX</code>, <code>UPDATE VERTEX</code>, <code>INSERT EDGE</code>, <code>UPDATE EDGE</code>, <code>DELETE VERTEX</code>, <code>DELETE EDGES</code>, <code>DELETE TAG</code> Show operations Y Y Y Y Y <code>SHOW</code>, <code>CHANGE PASSWORD</code> Job Y Y Y Y <code>SUBMIT JOB COMPACT</code>, <code>SUBMIT JOB FLUSH</code>, <code>SUBMIT JOB STATS</code>, <code>STOP JOB</code>, <code>RECOVER JOB</code>, <code>BUILD TAG INDEX</code>, <code>BUILD EDGE INDEX</code>,<code>INGEST</code>, <code>DOWNLOAD</code> Write space Y <code>CREATE SPACE</code>, <code>DROP SPACE</code>, <code>CREATE SNAPSHOT</code>, <code>DROP SNAPSHOT</code>, <code>BALANCE</code>, <code>CONFIG</code> <p>Caution</p> <ul> <li>The results of <code>SHOW</code> operations are limited to the role of a user. For example, all users can run <code>SHOW SPACES</code>, but the results only include the graph spaces that the users have privileges.</li> <li>Only the GOD role can run <code>SHOW USERS</code> and <code>SHOW SNAPSHOTS</code>.</li> </ul>"},{"location":"8.service-tuning/2.graph-modeling/","title":"Graph data modeling suggestions","text":"<p>This topic provides general suggestions for modeling data in NebulaGraph.</p> <p>Note</p> <p>The following suggestions may not apply to some special scenarios. In these cases, find help in the NebulaGraph community.</p>"},{"location":"8.service-tuning/2.graph-modeling/#model_for_performance","title":"Model for performance","text":"<p>There is no perfect method to model in Nebula\u00a0Graph. Graph modeling depends on the questions that you want to know from the data. Your data drives your graph model. Graph data modeling is intuitive and convenient. Create your data model based on your business model. Test your model and gradually optimize it to fit your business. To get better performance, you can change or re-design your model multiple times.</p>"},{"location":"8.service-tuning/2.graph-modeling/#design_and_evaluate_the_most_important_queries","title":"Design and evaluate the most important queries","text":"<p>Usually, various types of queries are validated in test scenarios to assess the overall capabilities of the system. However, in most production scenarios, there are not many types of frequently used queries. You can optimize the data model based on key queries selected according to the Pareto (80/20) principle.</p>"},{"location":"8.service-tuning/2.graph-modeling/#full-graph_scanning_avoidance","title":"Full-graph scanning avoidance","text":"<p>Graph traversal can be performed after one or more vertices/edges are located through property indexes or VIDs. But for some query patterns, such as subgraph and path query patterns, the source vertex or edge of the traversal cannot be located through property indexes or VIDs. These queries find all the subgraphs that satisfy the query pattern by scanning the whole graph space which will have poor query performance. NebulaGraph does not implement indexing for the graph structures of subgraphs or paths. </p>"},{"location":"8.service-tuning/2.graph-modeling/#no_predefined_bonds_between_tags_and_edge_types","title":"No predefined bonds between Tags and Edge types","text":"<p>Define the bonds between Tags and Edge types in the application, not NebulaGraph. There are no statements that could get the bonds between Tags and Edge types.</p>"},{"location":"8.service-tuning/2.graph-modeling/#tagsedge_types_predefine_a_set_of_properties","title":"Tags/Edge types predefine a set of properties","text":"<p>While creating Tags or Edge types, you need to define a set of properties. Properties are part of the NebulaGraph Schema.</p>"},{"location":"8.service-tuning/2.graph-modeling/#control_changes_in_the_business_model_and_the_data_model","title":"Control changes in the business model and the data model","text":"<p>Changes here refer to changes in business models and data models (meta-information), not changes in the data itself.</p> <p>Some graph databases are designed to be Schema-free, so their data modeling, including the modeling of the graph topology and properties, can be very flexible. Properties can be re-modeled to graph topology, and vice versa. Such systems are often specifically optimized for graph topology access.</p> <p>NebulaGraph 3.8.0 is a strong-Schema (row storage) system, which means that the business model should not change frequently. For example, the property Schema should not change. It is similar to avoiding <code>ALTER TABLE</code> in MySQL.</p> <p>On the contrary, vertices and their edges can be added or deleted at low costs. Thus, the easy-to-change part of the business model should be transformed to vertices or edges, rather than properties.</p> <p>For example, in a business model, people have relatively fixed properties such as age, gender, and name. But their contact, place of visit, trade account, and login device are often changing. The former is suitable for modeling as properties and the latter as vertices or edges.</p>"},{"location":"8.service-tuning/2.graph-modeling/#set_temporary_properties_through_self-loop_edges","title":"Set temporary properties through self-loop edges","text":"<p>As a strong Schema system, NebulaGraph does not support List-type properties. And using <code>ALTER TAG</code> costs too much. If you need to add some temporary properties or List-type properties to a vertex, you can first create an edge type with the required properties, and then insert one or more edges that direct to the vertex itself. The figure is as follows.</p> <p></p> <p>To retrieve temporary properties of vertices, fetch from self-loop edges. For example:</p> <p><pre><code>//Create the edge type and insert the loop property.\nnebula&gt; CREATE EDGE IF NOT EXISTS temp(tmp int);\nnebula&gt; INSERT EDGE temp(tmp) VALUES \"player100\"-&gt;\"player100\"@1:(1);\nnebula&gt; INSERT EDGE temp(tmp) VALUES \"player100\"-&gt;\"player100\"@2:(2);\nnebula&gt; INSERT EDGE temp(tmp) VALUES \"player100\"-&gt;\"player100\"@3:(3);\n\n//After the data is inserted, you can query the loop property by general query statements, for example:\nnebula&gt; GO FROM \"player100\" OVER temp YIELD properties(edge).tmp;\n+----------------------+\n| properties(EDGE).tmp |\n+----------------------+\n| 1                    |\n| 2                    |\n| 3                    |\n+----------------------+\n\n//If you want the results to be returned in the form of a List, you can use a function, for example:\nnebula&gt; MATCH (v1:player)-[e:temp]-&gt;() return collect(e.tmp);\n+----------------+\n| collect(e.tmp) |\n+----------------+\n| [1, 2, 3]      |\n+----------------+\n</code></pre> Operations on loops are not encapsulated with any syntactic sugars and you can use them just like those on normal edges.</p>"},{"location":"8.service-tuning/2.graph-modeling/#about_dangling_edges","title":"About dangling edges","text":"<p>A dangling edge is an edge that only connects to a single vertex and only one part of the edge connects to the vertex.</p> <p>In NebulaGraph 3.8.0, dangling edges may appear in the following two cases.</p> <ol> <li> <p>Insert edges with INSERT EDGE statement before the source vertex or the destination vertex exists.</p> </li> <li> <p>Delete vertices with DELETE VERTEX statement and the <code>WITH EDGE</code> option is not used. At this time, the system does not delete the related outgoing and incoming edges of the vertices. There will be dangling edges by default.</p> </li> </ol> <p>Dangling edges may appear in NebulaGraph 3.8.0 as the design allow it to exist. And there is no MERGE statement like openCypher has. The existence of dangling edges depends entirely on the application level. You can use GO and LOOKUP statements to find a dangling edge, but cannot use the MATCH statement to find a dangling edge.</p> <p>Examples:</p> <pre><code>// Insert an edge that connects two vertices which do not exist in the graph. The source vertex's ID is '11'. The destination vertex's ID is'13'. \n\nnebula&gt; CREATE EDGE IF NOT EXISTS e1 (name string, age int);\nnebula&gt; INSERT EDGE e1 (name, age) VALUES \"11\"-&gt;\"13\":(\"n1\", 1);\n\n// Query using the `GO` statement\n\nnebula&gt; GO FROM \"11\" over e1 YIELD properties(edge);\n+----------------------+\n| properties(EDGE)     |\n+----------------------+\n| {age: 1, name: \"n1\"} |\n+----------------------+\n\n// Query using the `LOOKUP` statement\n\nnebula&gt; LOOKUP ON e1 YIELD EDGE AS r;\n+-------------------------------------------------------+\n| r                                                     |\n+-------------------------------------------------------+\n| [:e2 \"11\"-&gt;\"13\" @0 {age: 1, name: \"n1\"}]              |\n+-------------------------------------------------------+\n\n// Query using the `MATCH` statement\n\nnebula&gt; MATCH ()-[e:e1]-&gt;() RETURN e;\n+---+\n| e |\n+---+\n+---+\nEmpty set (time spent 3153/3573 us)\n</code></pre>"},{"location":"8.service-tuning/2.graph-modeling/#breadth-first_traversal_over_depth-first_traversal","title":"Breadth-first traversal over depth-first traversal","text":"<ul> <li>NebulaGraph has lower performance for depth-first traversal based on the Graph topology, and better performance for breadth-first traversal and obtaining properties. For example, if model A contains properties \"name\", \"age\", and \"eye color\", it is recommended to create a tag <code>person</code> and add properties <code>name</code>, <code>age</code>, and <code>eye_color</code> to it. If you create a tag <code>eye_color</code> and an edge type <code>has</code>, and then create an edge to represent the eye color owned by the person, the traversal performance will not be high.</li> </ul> <ul> <li>The performance of finding an edge by an edge property is close to that of finding a vertex by a vertex property. For some databases, it is recommended to re-model edge properties as those of the intermediate vertices. For example, model the pattern <code>(src)-[edge {P1, P2}]-&gt;(dst)</code> as <code>(src)-[edge1]-&gt;(i_node {P1, P2})-[edge2]-&gt;(dst)</code>. With NebulaGraph 3.8.0, you can use <code>(src)-[edge {P1, P2}]-&gt;(dst)</code> directly to decrease the depth of the traversal and increase the performance.</li> </ul>"},{"location":"8.service-tuning/2.graph-modeling/#edge_directions","title":"Edge directions","text":"<p>To query in the opposite direction of an edge, use the following syntax:</p> <p><code>(dst)&lt;-[edge]-(src)</code> or <code>GO FROM dst REVERSELY</code>.</p> <p>If you do not care about the directions or want to query against both directions, use the following syntax:</p> <p><code>(src)-[edge]-(dst)</code> or <code>GO FROM src BIDIRECT</code>.</p> <p>Therefore, there is no need to insert the same edge redundantly in the reversed direction.</p>"},{"location":"8.service-tuning/2.graph-modeling/#set_tag_properties_appropriately","title":"Set tag properties appropriately","text":"<p>Put a group of properties that are on the same level into the same tag. Different groups represent different concepts.</p>"},{"location":"8.service-tuning/2.graph-modeling/#use_indexes_correctly","title":"Use indexes correctly","text":"<p>Using property indexes helps find VIDs through properties, but can lead to great performance reduction. Only use an index when you need to find vertices or edges through their properties.</p>"},{"location":"8.service-tuning/2.graph-modeling/#design_vids_appropriately","title":"Design VIDs appropriately","text":"<p>See VID.</p>"},{"location":"8.service-tuning/2.graph-modeling/#long_texts","title":"Long texts","text":"<p>Do not use long texts to create edge properties. Edge properties are stored twice and long texts lead to greater write amplification. For how edges properties are stored, see Storage architecture. It is recommended to store long texts in HBase or Elasticsearch and store its address in NebulaGraph.</p>"},{"location":"8.service-tuning/2.graph-modeling/#dynamic_graphs_sequence_graphs_are_not_supported","title":"Dynamic graphs (sequence graphs) are not supported","text":"<p>In some scenarios, graphs need to have the time information to describe how the structure of the entire graph changes over time.<sup>1</sup></p> <p>The Rank field on Edges in NebulaGraph 3.8.0 can be used to store time in int64, but no field on vertices can do this because if you store the time information as property values, it will be covered by new insertion. Thus NebulaGraph does not support sequence graphs.</p> <p></p>"},{"location":"8.service-tuning/2.graph-modeling/#free_graph_data_modeling_tools","title":"Free graph data modeling tools","text":"<p>arrows.app</p> <ol> <li> <p>https://blog.twitter.com/engineering/en_us/topics/insights/2021/temporal-graph-networks\u00a0\u21a9</p> </li> </ol>"},{"location":"8.service-tuning/3.system-design/","title":"System design suggestions","text":""},{"location":"8.service-tuning/3.system-design/#qps_or_low-latency_first","title":"QPS or low-latency first","text":"<ul> <li>NebulaGraph 3.8.0 is good at handling small requests with high concurrency. In such scenarios, the whole graph is huge, containing maybe trillions of vertices or edges, but the subgraphs accessed by each request are not large (containing millions of vertices or edges), and the latency of a single request is low. The concurrent number of such requests, i.e., the QPS, can be huge.</li> </ul> <ul> <li>On the other hand, in interactive analysis scenarios, the request concurrency is usually not high, but the subgraphs accessed by each request are large, with thousands of millions of vertices or edges. To lower the latency of big requests in such scenarios, you can split big requests into multiple small requests in the application, and concurrently send them to multiple graphd processes. This can decrease the memory used by each graphd process as well. Besides, you can use NebulaGraph Algorithm for such scenarios.</li> </ul>"},{"location":"8.service-tuning/3.system-design/#data_transmission_and_optimization","title":"Data transmission and optimization","text":"<ul> <li>Read/write balance. NebulaGraph fits into OLTP scenarios with balanced read/write, i.e., concurrent write and read. It is not suitable for OLAP scenarios that usually need to write once and read many times.</li> <li>Select different write methods. For large batches of data writing, use SST files. For small batches of data writing, use <code>INSERT</code>.</li> <li>Run <code>COMPACTION</code> and <code>BALANCE</code> jobs to optimize data format and storage distribution at the right time.</li> <li>NebulaGraph 3.8.0 does not support transactions and isolation in the relational database and is closer to NoSQL.</li> </ul>"},{"location":"8.service-tuning/3.system-design/#query_preheating_and_data_preheating","title":"Query preheating and data preheating","text":"<p>Preheat on the application side:</p> <ul> <li>The Grapd process does not support pre-compiling queries and generating corresponding query plans, nor can it cache previous query results.</li> <li>The Storagd process does not support preheating data. Only the LSM-Tree and BloomFilter of RocksDB are loaded into memory at startup.</li> <li>Once accessed, vertices and edges are cached respectively in two types of LRU cache of the Storage Service.</li> </ul>"},{"location":"8.service-tuning/4.plan/","title":"Execution plan","text":"<p>NebulaGraph 3.8.0 applies rule-based execution plans. Users cannot change execution plans, pre-compile queries (and corresponding plan cache), or accelerate queries by specifying indexes.</p> <p>To view the execution plan and executive summary, see EXPLAIN and PROFILE.</p>"},{"location":"8.service-tuning/compaction/","title":"Compaction","text":"<p>This topic gives some information about compaction.</p> <p>In NebulaGraph, <code>Compaction</code> is the most important background process and has an important effect on performance.</p> <p><code>Compaction</code> reads the data that is written on the hard disk, then re-organizes the data structure and the indexes, and then writes back to the hard disk. The read performance can increase by times after compaction. Thus, to get high read performance, trigger <code>compaction</code> (full <code>compaction</code>) manually when writing a large amount of data into Nebula\u00a0Graph.</p> <p>Note</p> <p>Note that <code>compaction</code> leads to long-time hard disk IO. We suggest that users do compaction during off-peak hours (for example, early morning).</p> <p>NebulaGraph has two types of <code>compaction</code>: automatic <code>compaction</code> and full <code>compaction</code>.</p>"},{"location":"8.service-tuning/compaction/#automatic_compaction","title":"Automatic <code>compaction</code>","text":"<p>Automatic <code>compaction</code> is automatically triggered when the system reads data, writes data, or the system restarts. The read performance can increase in a short time. Automatic <code>compaction</code> is enabled by default. But once triggered during peak hours, it can cause unexpected IO occupancy that has an unwanted effect on the performance.</p>"},{"location":"8.service-tuning/compaction/#full_compaction","title":"Full <code>compaction</code>","text":"<p>Full <code>compaction</code> enables large-scale background operations for a graph space such as merging files, deleting the data expired by TTL. This operation needs to be initiated manually. Use the following statements to enable full <code>compaction</code>:</p> <p>Note</p> <p>We recommend you to do the full compaction during off-peak hours because full compaction has a lot of IO operations.</p> <pre><code>nebula&gt; USE &lt;your_graph_space&gt;;\nnebula&gt; SUBMIT JOB COMPACT;\n</code></pre> <p>The preceding statement returns the job ID. To show the <code>compaction</code> progress, use the following statement:</p> <pre><code>nebula&gt; SHOW JOB &lt;job_id&gt;;\n</code></pre>"},{"location":"8.service-tuning/compaction/#operation_suggestions","title":"Operation suggestions","text":"<p>These are some operation suggestions to keep Nebula\u00a0Graph performing well.</p> <ul> <li>After data import is done, run <code>SUBMIT JOB COMPACT</code>.</li> </ul> <ul> <li>Run <code>SUBMIT JOB COMPACT</code> periodically during off-peak hours (e.g. early morning).</li> </ul> <ul> <li> <p>To control the write traffic limitation for <code>compactions</code>, set the following parameter in the <code>nebula-storaged.conf</code> configuration file.</p> <p>Note</p> <p>This parameter limits the rate of all writes including normal writes and compaction writes. </p> <pre><code># Limit the write rate to 20MB/s.\n--rocksdb_rate_limit=20 (in MB/s)\n</code></pre> </li> </ul>"},{"location":"8.service-tuning/compaction/#faq","title":"FAQ","text":""},{"location":"8.service-tuning/compaction/#where_are_the_logs_related_to_compaction_stored","title":"\"Where are the logs related to <code>Compaction</code> stored?\"","text":"<p>By default, the logs are stored under the <code>LOG</code> file in the <code>/usr/local/nebula/data/storage/nebula/{1}/data/</code> directory, or similar to <code>LOG.old.1625797988509303</code>. You can find the following content.</p> <pre><code>** Compaction Stats [default] **\nLevel    Files   Size     Score Read(GB)  Rn(GB) Rnp1(GB) Write(GB) Wnew(GB) Moved(GB) W-Amp Rd(MB/s) Wr(MB/s) Comp(sec) CompMergeCPU(sec) Comp(cnt) Avg(sec) KeyIn KeyDrop\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  L0      2/0    2.46 KB   0.5      0.0     0.0      0.0       0.0      0.0       0.0   1.0      0.0      0.0      0.53              0.51         2    0.264       0      0\n Sum      2/0    2.46 KB   0.0      0.0     0.0      0.0       0.0      0.0       0.0   1.0      0.0      0.0      0.53              0.51         2    0.264       0      0\n Int      0/0    0.00 KB   0.0      0.0     0.0      0.0       0.0      0.0       0.0   0.0      0.0      0.0      0.00              0.00         0    0.000       0      0\n</code></pre> <p>If the number of <code>L0</code> files is large, the read performance will be greatly affected and compaction can be triggered.</p>"},{"location":"8.service-tuning/compaction/#can_i_do_full_compactions_for_multiple_graph_spaces_at_the_same_time","title":"\"Can I do full <code>compactions</code> for multiple graph spaces at the same time?\"","text":"<p>Yes, you can. But the IO is much larger at this time and the efficiency may be affected.</p>"},{"location":"8.service-tuning/compaction/#how_much_time_does_it_take_for_full_compactions","title":"\"How much time does it take for full <code>compactions</code>?\"","text":"<p>When <code>rocksdb_rate_limit</code> is set to <code>20</code>, you can estimate the full compaction time by dividing the hard disk usage by the <code>rocksdb_rate_limit</code>. If you do not set the <code>rocksdb_rate_limit</code> value, the empirical value is around 50 MB/s.</p>"},{"location":"8.service-tuning/compaction/#can_i_modify_--rocksdb_rate_limit_dynamically","title":"\"Can I modify <code>--rocksdb_rate_limit</code> dynamically?\"","text":"<p>No, you cannot.</p>"},{"location":"8.service-tuning/compaction/#can_i_stop_a_full_compaction_after_it_starts","title":"\"Can I stop a full <code>compaction</code> after it starts?\"","text":"<p>No, you cannot. When you start a full compaction, you have to wait till it is done. This is the limitation of RocksDB.</p>"},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/","title":"Enable AutoFDO for NebulaGraph","text":"<p>The AutoFDO can analyze the performance of an optimized program and use the program's performance information to guide the compiler to re-optimize the program. This document will help you to enable the AutoFDO for NebulaGraph.</p> <p>More information about the AutoFDO, please refer AutoFDO Wiki.</p>"},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#resource_preparations","title":"Resource Preparations","text":""},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#install_dependencies","title":"Install Dependencies","text":"<ul> <li> <p>Install perf</p> <pre><code>sudo apt-get update\nsudo apt-get install -y linux-tools-common \\\nlinux-tools-generic \\\nlinux-tools-`uname -r`\n</code></pre> </li> </ul> <ul> <li> <p>Install autofdo tool</p> <pre><code>sudo apt-get update\nsudo apt-get install -y autofdo\n</code></pre> <p>Or you can compile the autofdo tool from source.</p> </li> </ul>"},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#nebulagraph_binary_with_debug_version","title":"NebulaGraph Binary with Debug Version","text":"<p>For how to build NebulaGraph from source, please refer to the official document: Install NebulaGraph by compiling the source code. In the configure step, replace <code>CMAKE_BUILD_TYPE=Release</code> with <code>CMAKE_BUILD_TYPE=RelWithDebInfo</code> as below:</p> <pre><code>$ cmake -DCMAKE_INSTALL_PREFIX=/usr/local/nebula -DENABLE_TESTING=OFF -DCMAKE_BUILD_TYPE=RelWithDebInfo ..\n</code></pre>"},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#prepare_test_data","title":"Prepare Test Data","text":"<p>In our test environment, we use NebulaGraph Bench to prepare the test data and collect the profile data by running the FindShortestPath, Go1Step, Go2Step, Go3Step, InsertPersonScenario 5 scenarios. </p> <p>Note</p> <p>You can use your TopN queries in your production environment to collect the profile data, the performance can gain more in your environment.</p>"},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#prepare_profile_data","title":"Prepare Profile Data","text":""},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#collect_perf_data_for_autofdo_tool","title":"Collect Perf Data For AutoFdo Tool","text":"<ol> <li> <p>After the test data preparation work done. Collect the perf data for different scenarios. Get the pid of <code>storaged</code>, <code>graphd</code>, <code>metad</code>.</p> <pre><code>$ nebula.service status all\n[INFO] nebula-metad: Running as 305422, Listening on 9559\n[INFO] nebula-graphd: Running as 305516, Listening on 9669\n[INFO] nebula-storaged: Running as 305707, Listening on 9779\n</code></pre> </li> <li> <p>Start the perf record for nebula-graphd and nebula-storaged. </p> <pre><code>perf record -p 305516,305707 -b -e br_inst_retired.near_taken:pp -o ~/FindShortestPath.data\n</code></pre> <p>Note</p> <p>Because the <code>nebula-metad</code> service contribution percent is small compared with <code>nebula-graphd</code> and <code>nebula-storaged</code> services. To reduce effort, we didn't collect the perf data for <code>nebula-metad</code> service.</p> </li> <li> <p>Start the benchmark test for FindShortestPath scenario.</p> <pre><code>cd NebulaGraph-Bench \npython3 run.py stress run -s benchmark -scenario find_path.FindShortestPath -a localhost:9669 --args='-u 100 -i 100000'\n</code></pre> </li> <li> <p>After the benchmark finished, end the perf record by Ctrl + c.</p> </li> <li> <p>Repeat above steps to collect corresponding profile data for the rest  Go1Step, Go2Step, Go3Step and InsertPersonScenario scenarios.</p> </li> </ol>"},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#create_gcov_file","title":"Create Gcov File","text":"<pre><code>create_gcov --binary=$NEBULA_HOME/bin/nebula-storaged \\\n--profile=~/FindShortestPath.data \\\n--gcov=~/FindShortestPath-storaged.gcov \\\n-gcov_version=1\n\ncreate_gcov --binary=$NEBULA_HOME/bin/nebula-graphd \\\n--profile=~/FindShortestPath.data \\\n--gcov=~/FindShortestPath-graphd.gcov \\\n-gcov_version=1\n</code></pre> <p>Repeat for Go1Step, Go2Step, Go3Step and InsertPersonScenario scenarios.</p>"},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#merge_the_profile_data","title":"Merge the Profile Data","text":"<pre><code>profile_merger ~/FindShortestPath-graphd.gcov \\\n~/FindShortestPath-storaged.gcov \\\n~/go1step-storaged.gcov \\\n~/go1step-graphd.gcov \\\n~/go2step-storaged.gcov \\\n~/go2step-graphd.gcov \\\n~/go3step-storaged.gcov \\\n~/go3step-master-graphd.gcov \\\n~/InsertPersonScenario-storaged.gcov \\\n~/InsertPersonScenario-graphd.gcov\n</code></pre> <p>You will get a merged profile which is named <code>fbdata.afdo</code> after that.</p>"},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#recompile_graphnebula_binary_with_the_merged_profile","title":"Recompile GraphNebula Binary with the Merged Profile","text":"<p>Recompile the GraphNebula Binary by passing the profile with compile option <code>-fauto-profile</code>.</p> <pre><code>diff --git a/cmake/nebula/GeneralCompilerConfig.cmake b/cmake/nebula/GeneralCompilerConfig.cmake\n@@ -20,6 +20,8 @@ add_compile_options(-Wshadow)\n add_compile_options(-Wnon-virtual-dtor)\n add_compile_options(-Woverloaded-virtual)\n add_compile_options(-Wignored-qualifiers)\n+add_compile_options(-fauto-profile=~/fbdata.afdo)\n</code></pre> <p>Note</p> <p>When you use multiple fbdata.afdo to compile multiple times, please remember to <code>make clean</code> before re-compile, baucase only change the fbdata.afdo will not trigger re-compile.</p>"},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#performance_test_result","title":"Performance Test Result","text":""},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#hardware_software_environment","title":"Hardware &amp; Software Environment","text":"Key Value CPU Processor# 2 Sockets 2 NUMA 2 CPU Type Intel(R) Xeon(R) Platinum 8380 CPU @ 2.30GHz Cores per Processor 40C80T Cache L1 data: 48KB L1 i: 32KB  L2: 1.25MB per physical core  L3: shared 60MB per processor Memory Micron DDR4 3200MT/s 16GB16Micron DDR4 3200MT/s 16GB16 SSD Disk INTEL SSDPE2KE016T8 SSD R/W Sequential 3200 MB/s (read) / 2100 MB/s(write) Nebula Version master with commit id 51d84a4ed7d2a032a337e3b996c927e3bc5d1415 Kernel 4.18.0-408.el8.x86_64"},{"location":"8.service-tuning/enable_autofdo_for_nebulagraph/#test_results","title":"Test Results","text":"Scenario Average Latency(LiB) Default Binary Optimized Binary with AutoFDO P95 Latency (LiB) Default Binary Optimized Binary with AutoFDO FindShortestPath 1 8072.52 7260.10 1 22102.00 19108.00 2 8034.32 7218.59 2 22060.85 19006.00 3 8079.27 7257.24 3 22147.00 19053.00 4 8087.66 7221.39 4 22143.00 19050.00 5 8044.77 7239.85 5 22181.00 19055.00 STDDEVP 20.57 17.34 STDDEVP 41.41 32.36 Mean 8063.71 7239.43 Mean 22126.77 19054.40 STDDEVP/Mean 0.26% 0.24% STDDEVP/Mean 0.19% 0.17% Opt/Default 100.00% 10.22% Opt/Default 100.00% 13.89% Go1Step 1 422.53 418.37 1 838.00 850.00 2 432.37 402.44 2 866.00 815.00 3 437.45 407.98 3 874.00 836.00 4 429.16 408.38 4 858.00 838.00 5 446.38 411.32 5 901.00 837.00 STDDEVP 8.02 5.20 STDDEVP 20.63 11.30 Mean 433.58 409.70 Mean 867.40 835.20 STDDEVP/Mean 1.85% 1.27% STDDEVP/Mean 2.38% 1.35% Opt/Default 100.00% 5.51% Opt/Default 100.00% 3.71% Go2Step 1 2989.93 2824.29 1 10202.00 9656.95 2 2957.22 2834.55 2 10129.00 9632.40 3 2962.74 2818.62 3 10168.40 9624.70 4 2992.39 2817.27 4 10285.10 9647.50 5 2934.85 2834.91 5 10025.00 9699.65 STDDEVP 21.53 7.57 STDDEVP 85.62 26.25 Mean 2967.43 2825.93 Mean 10161.90 9652.24 STDDEVP/Mean 0.73% 0.27% STDDEVP/Mean 0.84% 0.27% Opt/Default 100.00% 4.77% Opt/Default 100.00% 5.02% Go3Step 1 93551.97 89406.96 1 371359.55 345433.50 2 92418.43 89977.25 2 368868.00 352375.20 3 92587.67 90339.25 3 365390.15 356198.55 4 93371.64 92458.95 4 373578.15 365177.75 5 94046.05 89943.44 5 373392.25 352576.00 STDDEVP 609.07 1059.54 STDDEVP 3077.38 6437.52 Mean 93195.15 90425.17 Mean 370517.62 354352.20 STDDEVP/Mean 0.65% 1.17% STDDEVP/Mean 0.83% 1.82% Opt/Default 100.00% 2.97% Opt/Default 100.00% 4.36% InsertPerson 1 2022.86 1937.36 1 2689.00 2633.45 2 1966.05 1935.41 2 2620.45 2555.00 3 1985.25 1953.58 3 2546.00 2593.00 4 2026.73 1887.28 4 2564.00 2394.00 5 2007.55 1964.41 5 2676.00 2581.00 STDDEVP 23.02 26.42 STDDEVP 57.45 82.62 Mean 2001.69 1935.61 Mean 2619.09 2551.29 STDDEVP/Mean 1.15% 1.37% STDDEVP/Mean 2.19% 3.24% Opt/Default 100.00% 3.30% Opt/Default 100.00% 2.59%"},{"location":"8.service-tuning/load-balance/","title":"Storage load balance","text":"<p>You can use the <code>SUBMIT JOB BALANCE</code> statement to balance the distribution of partitions and Raft leaders, or clear some Storage servers for easy maintenance. For details, see SUBMIT JOB BALANCE.</p> <p>Danger</p> <p>The <code>BALANCE</code> commands migrate data and balance the distribution of partitions by creating and executing a set of subtasks. DO NOT stop any machine in the cluster or change its IP address until all the subtasks finish. Otherwise, the follow-up subtasks fail.</p>"},{"location":"8.service-tuning/load-balance/#balance_leader_distribution","title":"Balance leader distribution","text":"<p>To balance the raft leaders, run <code>SUBMIT JOB BALANCE LEADER</code>. It will start a job to balance the distribution of all the storage leaders in all graph spaces.</p>"},{"location":"8.service-tuning/load-balance/#example","title":"Example","text":"<pre><code>nebula&gt; SUBMIT JOB BALANCE LEADER;\n</code></pre> <p>Run <code>SHOW HOSTS</code> to check the balance result.</p> <pre><code>nebula&gt; SHOW HOSTS;\n+------------------+------+----------+--------------+-----------------------------------+------------------------+----------------------+\n| Host             | Port | Status   | Leader count | Leader distribution               | Partition distribution | Version              |\n+------------------+------+----------+--------------+-----------------------------------+------------------------+----------------------+\n| \"192.168.10.101\" | 9779 | \"ONLINE\" | 8            | \"basketballplayer:3\"              | \"basketballplayer:8\"   | \"3.8.0\" |\n| \"192.168.10.102\" | 9779 | \"ONLINE\" | 3            | \"basketballplayer:3\"              | \"basketballplayer:8\"   | \"3.8.0\" |\n| \"192.168.10.103\" | 9779 | \"ONLINE\" | 0            | \"basketballplayer:2\"              | \"basketballplayer:7\"   | \"3.8.0\" |\n| \"192.168.10.104\" | 9779 | \"ONLINE\" | 0            | \"basketballplayer:2\"              | \"basketballplayer:7\"   | \"3.8.0\" |\n| \"192.168.10.105\" | 9779 | \"ONLINE\" | 0            | \"basketballplayer:2\"              | \"basketballplayer:7\"   | \"3.8.0\" |\n+------------------+------+----------+--------------+-----------------------------------+------------------------+----------------------+\n</code></pre> <p>Caution</p> <p>During leader partition replica switching in NebulaGraph, the leader replicas will be temporarily prohibited from being written to until the switch is completed. If there are a large number of write requests during the switching period, it will result in a request error (Storage Error <code>E_RPC_FAILURE</code>). See FAQ for error handling methods.</p> <p>You can set the value of <code>raft_heartbeat_interval_secs</code> in the Storage configuration file to control the timeout period for leader replica switching. For more information on the configuration file, see Storage configuration file.</p>"},{"location":"8.service-tuning/practice/","title":"Best practices","text":"<p>NebulaGraph is used in a variety of industries. This topic presents a few best practices for using NebulaGraph. For more best practices, see Blog.</p>"},{"location":"8.service-tuning/practice/#scenarios","title":"Scenarios","text":"<ul> <li>Use cases</li> </ul> <ul> <li>User review</li> </ul> <ul> <li>Performance</li> </ul>"},{"location":"8.service-tuning/practice/#kernel","title":"Kernel","text":"<ul> <li>What is a graph database and what are its use cases - Definition, examples &amp; trends</li> </ul> <ul> <li>NebulaGraph Source Code Explained: Variable-Length Pattern Matching</li> </ul> <ul> <li>Adding a Test Case for NebulaGraph</li> </ul> <ul> <li>BDD-Based Integration Testing Framework for NebulaGraph: Part \u2160</li> </ul> <ul> <li>BDD-Based Integration Testing Framework for NebulaGraph: Part II</li> </ul> <ul> <li>Understanding Subgraph in NebulaGraph</li> </ul> <ul> <li>Full-Text Indexing in NebulaGraph</li> </ul>"},{"location":"8.service-tuning/practice/#ecosystem_tool","title":"Ecosystem tool","text":"<ul> <li>Validating Import Performance of NebulaGraph Importer</li> </ul> <ul> <li>Ecosystem Tools: NebulaGraph Dashboard for Monitoring</li> </ul> <ul> <li>Visualizing Graph Data with NebulaGraph Explorer</li> </ul>"},{"location":"8.service-tuning/super-node/","title":"Processing super vertices","text":""},{"location":"8.service-tuning/super-node/#principle_introduction","title":"Principle introduction","text":"<p>In graph theory, a super vertex, also known as a dense vertex, is a vertex with an extremely high number of adjacent edges. The edges can be outgoing or incoming.</p> <p>Super vertices are very common because of the power-law distribution. For example, popular leaders in social networks (Internet celebrities), top stocks in the stock market, Big Four in the banking system, hubs in transportation networks, websites with high clicking rates on the Internet, and best sellers in E-commerce.</p> <p>In NebulaGraph 3.8.0, a <code>vertex</code> and its <code>properties</code> form a <code>key-value pair</code>, with its <code>VID</code> and other meta information as the <code>key</code>. Its <code>Out-Edge Key-Value</code> and <code>In-Edge Key-Value</code> are stored in the same partition in the form of LSM-trees in hard disks and caches.</p> <p>Therefore, <code>directed traversals from this vertex</code> and <code>directed traversals ending at this vertex</code> both involve either <code>a large number of sequential IO scans</code> (ideally, after Compaction or a large number of <code>random IO</code> (frequent writes to <code>the vertex</code> and its <code>ingoing and outgoing edges</code>).</p> <p>As a rule of thumb, a vertex is considered dense when the number of its edges exceeds 10,000. Some special cases require additional consideration.</p> <p>Note</p> <p>In NebulaGraph 3.8.0, there is not any data structure to store the out/in degree for each vertex. Therefore, there is no direct method to know whether it is a super vertex or not. You can try to use Spark to count the degrees periodically. </p>"},{"location":"8.service-tuning/super-node/#indexes_for_duplicate_properties","title":"Indexes for duplicate properties","text":"<p>In a property graph, there is another class of cases similar to super vertices: a property has a very high duplication rate, i.e., many vertices with the same <code>tag</code> but different <code>VIDs</code> have identical property and property values.</p> <p>Property indexes in NebulaGraph 3.8.0 are designed to reuse the functionality of RocksDB in the Storage Service, in which case indexes are modeled as <code>keys with the same prefix</code>. If the lookup of a property fails to hit the cache, it is processed as a random seek and a sequential prefix scan on the hard disk to find the corresponding VID. After that, the graph is usually traversed from this vertex, so that another random read and sequential scan for the corresponding key-value of this vertex will be triggered. The higher the duplication rate, the larger the scan range.</p> <p>For more information about property indexes, see How indexing works in NebulaGraph.</p> <p>Usually, special design and processing are required when the number of duplicate property values exceeds 10,000.</p>"},{"location":"8.service-tuning/super-node/#suggested_solutions","title":"Suggested solutions","text":""},{"location":"8.service-tuning/super-node/#solutions_at_the_database_end","title":"Solutions at the database end","text":"<ol> <li>Truncation: Only return a certain number (a threshold) of edges, and do not return other edges exceeding this threshold.</li> <li>Compact: Reorganize the order of data in RocksDB to reduce random reads and increase sequential reads.</li> </ol>"},{"location":"8.service-tuning/super-node/#solutions_at_the_application_end","title":"Solutions at the application end","text":"<p>Break up some of the super vertices according to their business significance:</p> <ul> <li> <p>Delete multiple edges and merge them into one.</p> <p>For example, in the transfer scenario <code>(Account_A)-[TRANSFER]-&gt;(Account_B)</code>, each transfer record is modeled as an edge between account A and account B, then there may be tens of thousands of transfer records between <code>(Account_A)</code> and <code>(Account_B)</code>.</p> <p>In such scenarios, merge obsolete transfer details on a daily, weekly, or monthly basis. That is, batch-delete old edges and replace them with a small number of edges representing <code>monthly total</code> and <code>times</code>. And keep the transfer details of the latest month.</p> </li> </ul> <ul> <li> <p>Split an edge into multiple edges of different types.</p> <p>For example, in the <code>(Airport)&lt;-[DEPART]-(Flight)</code> scenario, the departure of each flight is modeled as an edge between a flight and an airport. Departures from a big airport might be enormous.</p> <p>According to different airlines, divide the <code>DEPART</code> edge type into finer edge types, such as <code>DEPART_CEAIR</code>, <code>DEPART_CSAIR</code>, etc. Specify the departing airline in queries (graph traversal).</p> </li> </ul> <ul> <li> <p>Split vertices.</p> <p>For example, in the loan network <code>(person)-[BORROW]-&gt;(bank)</code>, large bank A will have a very large number of loans and borrowers.</p> <p>In such scenarios, you can split the large vertex A into connected sub-vertices A1, A2, and A3.</p> <pre><code>(Person1)-[BORROW]-&gt;(BankA1), (Person2)-[BORROW]-&gt;(BankA2), (Person2)-[BORROW]-&gt;(BankA3);\n(BankA1)-[BELONGS_TO]-&gt;(BankA), (BankA2)-[BELONGS_TO]-&gt;(BankA), (BankA3)-[BELONGS_TO]-&gt;(BankA).\n</code></pre> <p>A1, A2, and A3 can either be three real branches of bank A, such as Beijing branch, Shanghai branch, and Zhejiang branch, or three virtual branches set up according to certain rules, such as <code>A1: 1-1000, A2: 1001-10000 and A3: 10000+</code> according to the number of loans. In this way, any operation on A is converted into three separate operations on A1, A2, and A3.</p> </li> </ul>"},{"location":"backup-and-restore/3.manage-snapshot/","title":"Backup and restore data with snapshots","text":"<p>NebulaGraph supports using snapshots to back up and restore data. When data loss or misoperation occurs, the data will be restored through the snapshot.</p>"},{"location":"backup-and-restore/3.manage-snapshot/#prerequisites","title":"Prerequisites","text":"<p>NebulaGraph authentication is disabled by default. In this case, all users can use the snapshot feature.</p> <p>If authentication is enabled, only the GOD role user can use the snapshot feature. For more information about roles, see Roles and privileges.</p>"},{"location":"backup-and-restore/3.manage-snapshot/#precautions","title":"Precautions","text":"<ul> <li>To prevent data loss, create a snapshot as soon as the system structure changes, for example, after operations such as <code>ADD HOST</code>, <code>DROP HOST</code>, <code>CREATE SPACE</code>, <code>DROP SPACE</code>, and <code>BALANCE</code> are performed.</li> </ul> <ul> <li>NebulaGraph cannot automatically delete the invalid files created by a failed snapshot task. You have to manually delete them by using <code>DROP SNAPSHOT</code>.</li> </ul> <ul> <li>Customizing the storage path for snapshots is not supported for now.</li> </ul>"},{"location":"backup-and-restore/3.manage-snapshot/#create_snapshots","title":"Create snapshots","text":"<p>Run <code>CREATE SNAPSHOT</code> to create a snapshot for all the graph spaces based on the current time for NebulaGraph. Creating a snapshot for a specific graph space is not supported yet.</p> <p>Note</p> <p>If the creation fails, refer to the later section to delete the corrupted snapshot and then recreate the snapshot.</p> <pre><code>nebula&gt; CREATE SNAPSHOT;\n</code></pre>"},{"location":"backup-and-restore/3.manage-snapshot/#view_snapshots","title":"View snapshots","text":"<p>To view all existing snapshots, run <code>SHOW SNAPSHOTS</code>.</p> <pre><code>nebula&gt; SHOW SNAPSHOTS;\n+--------------------------------+---------+------------------+\n| Name                           | Status  | Hosts            |\n+--------------------------------+---------+------------------+\n| \"SNAPSHOT_2021_03_09_08_43_12\" | \"VALID\" | \"127.0.0.1:9779\" |\n| \"SNAPSHOT_2021_03_09_09_10_52\" | \"VALID\" | \"127.0.0.1:9779\" |\n+--------------------------------+---------+------------------+\n</code></pre> <p>The parameters in the return information are described as follows.</p> Parameter Description <code>Name</code> The name of the snapshot directory. The prefix <code>SNAPSHOT</code> indicates that the file is a snapshot file, and the suffix indicates the time the snapshot was created (UTC). <code>Status</code> The status of the snapshot. <code>VALID</code> indicates that the creation succeeded, while <code>INVALID</code> indicates that it failed. <code>Hosts</code> The IPs (or hostnames) and ports of all Storage servers at the time the snapshot was created."},{"location":"backup-and-restore/3.manage-snapshot/#snapshot_path","title":"Snapshot path","text":"<p>Snapshots are stored in the path specified by the <code>data_path</code> parameter in the Meta and Storage configuration files. When a snapshot is created, the <code>checkpoints</code> directory is checked in the datastore path of the leader Meta service and all Storage services for the existence, and if it is not there, it is automatically created. The newly created snapshot is stored as a subdirectory within the <code>checkpoints</code> directory. For example, <code>SNAPSHOT_2021_03_09_08_43_12</code>. The suffix <code>2021_03_09_08_43_12</code> is generated automatically based on the creation time (UTC).</p> <p>To fast locate the path where the snapshots are stored, you can use the Linux command <code>find</code> in the datastore path. For example:</p> <pre><code>$ cd /usr/local/nebula-graph-ent-3.8.0/data\n$ find |grep 'SNAPSHOT_2021_03_09_08_43_12'\n./data/meta2/nebula/0/checkpoints/SNAPSHOT_2021_03_09_08_43_12\n./data/meta2/nebula/0/checkpoints/SNAPSHOT_2021_03_09_08_43_12/data\n./data/meta2/nebula/0/checkpoints/SNAPSHOT_2021_03_09_08_43_12/data/000081.sst\n...\n</code></pre>"},{"location":"backup-and-restore/3.manage-snapshot/#delete_snapshots","title":"Delete snapshots","text":"<p>To delete a snapshot with the given name, run <code>DROP SNAPSHOT</code>.</p> <pre><code>DROP SNAPSHOT &lt;snapshot_name&gt;;\n</code></pre> <p>Example:</p> <pre><code>nebula&gt; DROP SNAPSHOT SNAPSHOT_2021_03_09_08_43_12;\nnebula&gt; SHOW SNAPSHOTS;\n+--------------------------------+---------+------------------+\n| Name                           | Status  | Hosts            |\n+--------------------------------+---------+------------------+\n| \"SNAPSHOT_2021_03_09_09_10_52\" | \"VALID\" | \"127.0.0.1:9779\" |\n+--------------------------------+---------+------------------+\n</code></pre> <p>Note</p> <p>Deleting the only snapshot within the <code>checkpoints</code> directory also deletes the <code>checkpoints</code> directory. </p>"},{"location":"backup-and-restore/3.manage-snapshot/#restore_data_with_snapshots","title":"Restore data with snapshots","text":"<p>Warning</p> <p>When you restore data with snapshots, make sure that the graph spaces backed up in the snapshot have not been dropped. Otherwise, the data of the graph spaces cannot be restored.</p> <p>Currently, there is no command to restore data with snapshots. You need to manually copy the snapshot file to the corresponding folder, or you can make it by using a shell script. The logic implements as follows:</p> <ol> <li> <p>After the snapshot is created, the <code>checkpoints</code> directory is generated in the installation directory of the leader Meta service and all Storage services, and saves the created snapshot. Taking this topic as an example, when there are two graph spaces, the snapshots created are saved in <code>/usr/local/nebula/data/meta/nebula/0/checkpoints</code>, <code>/usr/local/nebula/data/storage/ nebula/3/checkpoints</code> and <code>/usr/local/nebula/data/storage/nebula/4/checkpoints</code>.</p> <pre><code>$ ls /usr/local/nebula/data/meta/nebula/0/checkpoints/\nSNAPSHOT_2021_03_09_09_10_52\n$ ls /usr/local/nebula/data/storage/nebula/3/checkpoints/\nSNAPSHOT_2021_03_09_09_10_52\n$ ls /usr/local/nebula/data/storage/nebula/4/checkpoints/\nSNAPSHOT_2021_03_09_09_10_52\n</code></pre> </li> <li> <p>To restore the lost data through snapshots, you can take a snapshot at an appropriate time, copy the folders <code>data</code> and <code>wal</code> in the corresponding snapshot directory to its parent directory (at the same level with <code>checkpoints</code>) to overwrite the previous <code>data</code> and <code>wal</code>, and then restart the cluster.</p> <p>Warning</p> <p>The data and wal directories of all Meta services should be overwritten at the same time. Otherwise, the new leader Meta service will use the latest Meta data after a cluster is restarted. </p> </li> </ol>"},{"location":"backup-and-restore/nebula-br/1.what-is-br/","title":"What is Backup &amp; Restore","text":"<p>Backup &amp; Restore (BR for short) is a Command-Line Interface (CLI) tool to back up data of graph spaces of NebulaGraph and to restore data from the backup files.</p>"},{"location":"backup-and-restore/nebula-br/1.what-is-br/#features","title":"Features","text":"<p>The BR has the following features. It supports:</p> <ul> <li>Backing up and restoring data in a one-click operation.</li> <li>Restoring data in the following backup file types:<ul> <li>Local Disk (SSD or HDD). It is recommend to use local disk in test environment only.</li> <li>Amazon S3 compatible interface, such as Alibaba Cloud OSS, MinIO,Ceph RGW, etc.</li> </ul> </li> <li>Backing up and restoring the entire NebulaGraph cluster.</li> <li>Backing up data of specified graph spaces (experimental).</li> </ul>"},{"location":"backup-and-restore/nebula-br/1.what-is-br/#limitations","title":"Limitations","text":"<ul> <li>Supports NebulaGraph v3.x only.</li> <li>Supports full backup, but not incremental backup.</li> <li>Currently, NebulaGraph Listener and full-text indexes do not support backup.</li> <li>If you back up data to the local disk, the backup files will be saved in the local path of each server. You can also mount the NFS on your host to restore the backup data to a different host.</li> <li>Restoration requires that the number of the storage servers in the original cluster is the same as that of the storage servers in the target cluster and storage server IPs must be the same. Restoring the specified space will clear all the remaining spaces in the cluster.</li> <li>During the backup process, both DDL and DML statements in any specified graph spaces are blocked. We recommend that you do the operation within the low peak period of the business, for example, from 2:00 AM to 5:00 AM.</li> <li>During the restoration process, there is a time when NebulaGraph stops running.</li> <li>Using BR in a container-based NebulaGraph cluster is not supported.</li> </ul>"},{"location":"backup-and-restore/nebula-br/1.what-is-br/#how_to_use_br","title":"How to use BR","text":"<p>To use the BR, follow these steps:</p> <ol> <li>Install BR.</li> <li>Use BR to back up data.</li> <li>Use BR to restore data from backup files.</li> </ol>"},{"location":"backup-and-restore/nebula-br/2.compile-br/","title":"Install BR","text":"<p>This topic introduces the installation of BR in bare-metal deployment scenarios. </p>"},{"location":"backup-and-restore/nebula-br/2.compile-br/#notes","title":"Notes","text":"<p>To use the BR (Community Edition) tool, you need to install the NebulaGraph Agent service, which is taken as a daemon for each machine in the cluster that starts and stops the NebulaGraph service, and uploads and downloads backup files. The BR (Community Edition) tool and the Agent plug-in are installed as described below.</p>"},{"location":"backup-and-restore/nebula-br/2.compile-br/#version_compatibility","title":"Version compatibility","text":"NebulaGraph BR Agent 3.5.x ~ 3.8.0 3.6.0 3.6.x ~ 3.7.x 3.3.0 ~ 3.4.x 3.3.0 0.2.0 ~ 3.4.0 3.0.x ~ 3.2.x 0.6.1 0.1.0 ~ 0.2.0"},{"location":"backup-and-restore/nebula-br/2.compile-br/#install_br_with_a_binary_file","title":"Install BR with a binary file","text":"<ol> <li> <p>Install BR.</p> <pre><code>wget https://github.com/vesoft-inc/nebula-br/releases/download/v3.6.0/br-3.6.0-linux-amd64\n</code></pre> </li> <li> <p>Change the binary file name to <code>br</code>.</p> <pre><code>sudo mv br-3.6.0-linux-amd64 br\n</code></pre> </li> <li> <p>Grand execute permission to BR.</p> <pre><code>sudo chmod +x br\n</code></pre> </li> <li> <p>Run <code>./br version</code> to check BR version.</p> <pre><code>[nebula-br]$ ./br version\nNebula Backup And Restore Utility Tool,V-3.6.0\n</code></pre> </li> </ol>"},{"location":"backup-and-restore/nebula-br/2.compile-br/#install_br_with_the_source_code","title":"Install BR with the source code","text":"<p>Before compiling the BR, do a check of these:</p> <ul> <li>Go 1.14.x or a later version is installed.</li> <li>make is installed.</li> </ul> <p>To compile the BR, follow these steps:</p> <ol> <li> <p>Clone the <code>nebula-br</code> repository to your machine.</p> <pre><code>git clone https://github.com/vesoft-inc/nebula-br.git\n</code></pre> </li> <li> <p>Change to the <code>br</code> directory.</p> <pre><code>cd nebula-br\n</code></pre> </li> <li> <p>Compile the BR.</p> <pre><code>make\n</code></pre> </li> </ol> <p>Users can enter <code>bin/br version</code> on the command line. If the following results are returned, the BR is compiled successfully.</p> <pre><code>[nebula-br]$ bin/br version\nNebulaGraph Backup And Restore Utility Tool,V-3.6.0\n</code></pre>"},{"location":"backup-and-restore/nebula-br/2.compile-br/#install_agent","title":"Install Agent","text":"<p>NebulaGraph Agent is installed as a binary file in each machine and serves the BR tool with the RPC protocol.</p> <p>In each machine, follow these steps:</p> <ol> <li> <p>Install Agent.</p> <pre><code>wget https://github.com/vesoft-inc/nebula-agent/releases/download/v3.7.1/agent-3.7.1-linux-amd64\n</code></pre> </li> <li> <p>Rename the Agent file to <code>agent</code>.</p> <pre><code>sudo mv agent-3.7.1-linux-amd64 agent\n</code></pre> </li> <li> <p>Add execute permission to Agent. </p> <pre><code>sudo chmod +x agent\n</code></pre> </li> <li> <p>Start Agent.</p> <p>Note</p> <p>Before starting Agent, make sure that the Meta service has been started and Agent has read and write access to the corresponding NebulaGraph cluster directory and backup directory. </p> <pre><code>sudo nohup ./agent --agent=\"&lt;agent_node_ip&gt;:8888\" --meta=\"&lt;metad_node_ip&gt;:9559\" --ratelimit=&lt;file_size_bt&gt; &gt; nebula_agent.log 2&gt;&amp;1 &amp;\n</code></pre> <ul> <li><code>--agent</code>: The IP address and port number of Agent.</li> <li><code>--meta</code>: The IP address and access port of any Meta service in the cluster.</li> <li><code>--ratelimit</code>: (Optional) Limits the speed of file uploads and downloads to prevent bandwidth from being filled up and making other services unavailable. Unit: Bytes.</li> </ul> <p>For example: </p> <pre><code>sudo nohup ./agent --agent=\"192.168.8.129:8888\" --meta=\"192.168.8.129:9559\" --ratelimit=1048576 &gt; nebula_agent.log 2&gt;&amp;1 &amp;\n</code></pre> <p>Caution</p> <p>The IP address format for <code>--agent</code>should be the same as that of Meta and Storage services set in the configuration files. That is, use the real IP addresses or use <code>127.0.0.1</code>. Otherwise Agent does not run.</p> </li> <li> <p>Log into NebulaGraph and then run the following command to view the status of Agent.</p> <pre><code>nebula&gt; SHOW HOSTS AGENT;\n+-----------------+------+----------+---------+--------------+---------+\n| Host            | Port | Status   | Role    | Git Info Sha | Version |\n+-----------------+------+----------+---------+--------------+---------+\n| \"192.168.8.129\" | 8888 | \"ONLINE\" | \"AGENT\" | \"96646b8\"    |         |\n+-----------------+------+----------+---------+--------------+---------+  \n</code></pre> </li> </ol>"},{"location":"backup-and-restore/nebula-br/2.compile-br/#faq","title":"FAQ","text":""},{"location":"backup-and-restore/nebula-br/2.compile-br/#the_error_e_list_cluster_no_agent_failure","title":"The error `E_LIST_CLUSTER_NO_AGENT_FAILURE","text":"<p>If you encounter <code>E_LIST_CLUSTER_NO_AGENT_FAILURE</code> error, it may be due to the Agent service is not started or the Agent service is not registered to Meta service. First, execute <code>SHOW HOSTS AGENT</code> to check the status of the Agent service on all nodes in the cluster, when the status shows <code>OFFLINE</code>, it means the registration of Agent failed, then check whether the value of the <code>--meta</code> option in the command to start the Agent service is correct.</p>"},{"location":"backup-and-restore/nebula-br/3.br-backup-data/","title":"Use BR to back up data","text":"<p>After the BR is installed, you can back up data of the entire graph space. This topic introduces how to use the BR to back up data.</p>"},{"location":"backup-and-restore/nebula-br/3.br-backup-data/#prerequisites","title":"Prerequisites","text":"<p>To back up data with the BR, do a check of these:</p> <ul> <li>Install BR and Agent and run Agent on each host in the cluster.</li> </ul> <ul> <li>The NebulaGraph services are running.</li> </ul> <ul> <li> <p>If you store the backup files locally, create a directory with the same absolute path on the meta servers, the storage servers, and the BR machine for the backup files and get the absolute path. Make sure the account has write privileges for this directory.</p> <p>Warning</p> <p>In the production environment, we recommend that you mount Network File System (NFS) storage to the meta servers, the storage servers, and the BR machine for local backup, or use Amazon S3 or Alibaba Cloud OSS for remote backup. When you restore the data from local files, you must manually move these backup files to a specified directory, which causes redundant data and troubles. For more information, see Restore data from backup files.</p> </li> </ul>"},{"location":"backup-and-restore/nebula-br/3.br-backup-data/#procedure","title":"Procedure","text":"<p>In the BR installation directory (the default path of the compiled BR is <code>./bin/br</code>), run the following command to perform a full backup for the entire cluster.</p> <p>Note</p> <p>Make sure that the local path where the backup file is stored exists.</p> <pre><code>$ ./br backup full --meta &lt;ip_address&gt; --storage &lt;storage_path&gt;\n</code></pre> <p>For example: </p> <ul> <li> <p>Run the following command to perform a full backup for the entire cluster whose meta service address is <code>192.168.8.129:9559</code>, and save the backup file to <code>/home/nebula/backup/</code>.</p> <p>Caution</p> <p>If there are multiple metad addresses, you can use any one of them.</p> <p>Caution</p> <p>If you back up data to a local disk, only the data of the leader metad is backed up by default. So if there are multiple metad processes, you need to manually copy the directory of the leader metad (path <code>&lt;storage_path&gt;/meta</code>) and overwrite the corresponding directory of other follower meatd processes.</p> <pre><code>$ ./br backup full --meta \"192.168.8.129:9559\" --storage \"local:///home/nebula/backup/\"\n</code></pre> </li> </ul> <ul> <li> <p>Run the following command to perform a full backup for the entire cluster whose meta service address is <code>192.168.8.129:9559</code>, and save the backup file to <code>backup</code> in the <code>br-test</code> bucket of the object storage service compatible with S3 protocol.</p> <pre><code>$ ./br backup full --meta \"192.168.8.129:9559\" --s3.endpoint \"http://192.168.8.129:9000\" --storage=\"s3://br-test/backup/\" --s3.access_key=minioadmin --s3.secret_key=minioadmin --s3.region=default\n</code></pre> </li> </ul> <p>The parameters are as follows.</p> Parameter Data type Required Default value Description <code>-h,-help</code> - No None Checks help for restoration. <code>--debug</code> - No None Checks for more log information. <code>--log</code> string No <code>\"br.log\"</code> Specifies detailed log path for restoration and backup. <code>--meta</code> string Yes None The IP address and port of the meta service. <code>--space</code> string Yes None (Experimental feature) Specifies the names of the spaces to be backed up. All spaces will be backed up if not specified. Multiple spaces can be specified, and format is <code>--spaces nba_01 --spaces nba_02</code>. <code>--storage</code> string Yes None The target storage URL of BR backup data. The format is: \\&lt;Schema&gt;://\\&lt;PATH&gt;. Schema: Optional values are <code>local</code> and <code>s3</code>. When selecting s3, you need to fill in <code>s3.access_key</code>, <code>s3.endpoint</code>, <code>s3.region</code>, and <code>s3.secret_key</code>.PATH: The path of the storage location. <code>--s3.access_key</code> string No None Sets AccessKey ID. <code>--s3.endpoint</code> string No None Sets the S3 endpoint URL, please specify the HTTP or HTTPS scheme explicitly. <code>--s3.region</code> string No None Sets the region or location to upload or download the backup. <code>--s3.secret_key</code> string No None Sets SecretKey for AccessKey ID."},{"location":"backup-and-restore/nebula-br/3.br-backup-data/#next_to_do","title":"Next to do","text":"<p>After the backup files are generated, you can use the BR to restore them for NebulaGraph. For more information, see Use BR to restore data.</p>"},{"location":"backup-and-restore/nebula-br/4.br-restore-data/","title":"Use BR to restore data","text":"<p>If you use the BR to back up data, you can use it to restore the data to NebulaGraph. This topic introduces how to use the BR to restore data from backup files.</p> <p>Caution</p> <p>During the restoration process, the data on the target NebulaGraph cluster is removed and then is replaced with the data from the backup files. If necessary, back up the data on the target cluster.</p> <p>Caution</p> <p>The restoration process is performed OFFLINE.</p>"},{"location":"backup-and-restore/nebula-br/4.br-restore-data/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install BR and Agent and run Agent on each host in the cluster. </li> </ul> <ul> <li>No application is connected to the target NebulaGraph cluster.</li> </ul> <ul> <li>Make sure that the target and the source NebulaGraph clusters have the same topology, which means that they have exactly the same number of hosts. The number of data folders for each host is consistently distributed.</li> </ul>"},{"location":"backup-and-restore/nebula-br/4.br-restore-data/#procedures","title":"Procedures","text":"<p>In the BR installation directory (the default path of the compiled BR is <code>./br</code>), run the following command to perform a full backup for the entire cluster.</p> <ol> <li> <p>Users can use the following command to list the existing backup information:</p> <p><pre><code>$ ./br show --storage &lt;storage_path&gt;\n</code></pre> For example, run the following command to list the backup information in the local <code>/home/nebula/backup</code> path. <pre><code>$ ./br show --storage \"local:///home/nebula/backup\"\n+----------------------------+---------------------+------------------------+-------------+------------+\n|            NAME            |     CREATE TIME     |         SPACES         | FULL BACKUP | ALL SPACES |\n+----------------------------+---------------------+------------------------+-------------+------------+\n| BACKUP_2022_02_10_07_40_41 | 2022-02-10 07:40:41 | basketballplayer       | true        | true       |\n| BACKUP_2022_02_11_08_26_43 | 2022-02-11 08:26:47 | basketballplayer,foesa | true        | true       |\n+----------------------------+---------------------+------------------------+-------------+------------+\n</code></pre></p> <p>Or, you can run the following command to list the backup information stored in S3 URL <code>s3://192.168.8.129:9000/br-test/backup</code>. <pre><code>$ ./br show --s3.endpoint \"http://192.168.8.129:9000\" --storage=\"s3://br-test/backup/\" --s3.access_key=minioadmin --s3.secret_key=minioadmin --s3.region=default\n</code></pre></p> Parameter Data type Required Default value Description <code>-h,-help</code> - No None Checks help for restoration. <code>-debug</code> - No None Checks for more log information. <code>-log</code> string No <code>\"br.log\"</code> Specifies detailed log path for restoration and backup. <code>--storage</code> string Yes None The target storage URL of BR backup data. The format is: &lt;Schema&gt;://&lt;PATH&gt;. Schema: Optional values are <code>local</code> and <code>s3</code>. When selecting s3, you need to fill in <code>s3.access_key</code>, <code>s3.endpoint</code>, <code>s3.region</code>, and <code>s3.secret_key</code>.PATH: The path of the storage location. <code>--s3.access_key</code> string No None Sets AccessKey ID. <code>--s3.endpoint</code> string No None Sets the S3 endpoint URL, please specify the HTTP or HTTPS scheme explicitly. <code>--s3.region</code> string No None Sets the region or location to upload or download the backup. <code>--s3.secret_key</code> string No None Sets SecretKey for AccessKey ID. </li> <li> <p>Run the following command to restore data.</p> <pre><code>$ ./br restore full --meta &lt;ip_address&gt; --storage &lt;storage_path&gt; --name &lt;backup_name&gt;\n</code></pre> <p>For example, run the following command to upload the backup files from the local <code>/home/nebula/backup/</code> to the cluster where the meta service's address is <code>192.168.8.129:9559</code>.</p> <pre><code>$ ./br restore full --meta \"192.168.8.129:9559\" --storage \"local:///home/nebula/backup/\" --name BACKUP_2021_12_08_18_38_08\n</code></pre> <p>Or, you can run the following command to upload the backup files from the S3 URL <code>s3://192.168.8.129:9000/br-test/backup</code>. <pre><code>$ ./br restore full --meta \"192.168.8.129:9559\" --s3.endpoint \"http://192.168.8.129:9000\" --storage=\"s3://br-test/backup/\" --s3.access_key=minioadmin --s3.secret_key=minioadmin --s3.region=\"default\" --name BACKUP_2021_12_08_18_38_08\n</code></pre></p> <p>If the following information is returned, the data is restored successfully. <pre><code>Restore succeed.\n</code></pre></p> <p>Caution</p> <p>If your new cluster hosts' IPs are not all the same as the backup cluster, after restoration, you should run <code>add hosts</code> to add the Storage host IPs in the new cluster one by one.</p> <p>The parameters are as follows.</p> Parameter Data type Required Default value Description <code>-h,-help</code> - No None Checks help for restoration. <code>-debug</code> - No None Checks for more log information. <code>-log</code> string No <code>\"br.log\"</code> Specifies detailed log path for restoration and backup. <code>-meta</code> string Yes None The IP address and port of the meta service. <code>-name</code> string Yes None The name of backup. <code>--storage</code> string Yes None The target storage URL of BR backup data. The format is: \\&lt;Schema&gt;://\\&lt;PATH&gt;. Schema: Optional values are <code>local</code> and <code>s3</code>. When selecting s3, you need to fill in <code>s3.access_key</code>, <code>s3.endpoint</code>, <code>s3.region</code>, and <code>s3.secret_key</code>.PATH: The path of the storage location. <code>--s3.access_key</code> string No None Sets AccessKey ID. <code>--s3.endpoint</code> string No None Sets the S3 endpoint URL, please specify the HTTP or HTTPS scheme explicitly. <code>--s3.region</code> string No None Sets the region or location to upload or download the backup. <code>--s3.secret_key</code> string No None Sets SecretKey for AccessKey ID. </li> <li> <p>Run the following command to clean up temporary files if any error occurred during backup. It will clean the files in cluster and external storage. You could also use it to clean up old backups files in external storage.</p> <pre><code>$ ./br cleanup --meta &lt;ip_address&gt; --storage &lt;storage_path&gt; --name &lt;backup_name&gt;\n</code></pre> <p>The parameters are as follows.</p> Parameter Data type Required Default value Description <code>-h,-help</code> - No None Checks help for restoration. <code>-debug</code> - No None Checks for more log information. <code>-log</code> string No <code>\"br.log\"</code> Specifies detailed log path for restoration and backup. <code>-meta</code> string Yes None The IP address and port of the meta service. <code>-name</code> string Yes None The name of backup. <code>--storage</code> string Yes None The target storage URL of BR backup data. The format is: \\&lt;Schema&gt;://\\&lt;PATH&gt;. Schema: Optional values are <code>local</code> and <code>s3</code>. When selecting s3, you need to fill in <code>s3.access_key</code>, <code>s3.endpoint</code>, <code>s3.region</code>, and <code>s3.secret_key</code>.PATH: The path of the storage location. <code>--s3.access_key</code> string No None Sets AccessKey ID. <code>--s3.endpoint</code> string No None Sets the S3 endpoint URL, please specify the HTTP or HTTPS scheme explicitly. <code>--s3.region</code> string No None Sets the region or location to upload or download the backup. <code>--s3.secret_key</code> string No None Sets SecretKey for AccessKey ID. </li> </ol>"},{"location":"connector/nebula-flink-connector/","title":"NebulaGraph Flink Connector","text":"<p>NebulaGraph Flink Connector is a connector that helps Flink users quickly access NebulaGraph. NebulaGraph Flink Connector supports reading data from the NebulaGraph database or writing other external data to the NebulaGraph database.</p> <p>For more information, see NebulaGraph Flink Connector.</p>"},{"location":"connector/nebula-flink-connector/#use_cases","title":"Use cases","text":"<p>NebulaGraph Flink Connector applies to the following scenarios:</p> <ul> <li>Read data from NebulaGraph for analysis and computation.</li> <li>Write data back to NebulaGraph after analysis and computation.</li> <li>Migrate the data of NebulaGraph.</li> </ul>"},{"location":"connector/nebula-flink-connector/#release_note","title":"Release note","text":"<p>Release</p>"},{"location":"connector/nebula-flink-connector/#version_compatibility","title":"Version compatibility","text":"<p>The correspondence between the NebulaGraph Flink Connector version and the NebulaGraph core version is as follows.</p> Flink Connector version NebulaGraph version 3.0-SNAPSHOT nightly 3.8.0 3.x.x 3.5.0 3.x.x 3.3.0 3.x.x 3.0.0 3.x.x 2.6.1 2.6.0, 2.6.1 2.6.0 2.6.0, 2.6.1 2.5.0 2.5.0, 2.5.1 2.0.0 2.0.0, 2.0.1"},{"location":"connector/nebula-flink-connector/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 8 or later is installed.</li> <li>Flink 1.11.x is installed.</li> </ul>"},{"location":"connector/nebula-flink-connector/#get_nebulagraph_flink_connector","title":"Get NebulaGraph Flink Connector","text":""},{"location":"connector/nebula-flink-connector/#configure_maven_dependency","title":"Configure Maven dependency","text":"<p>Add the following dependency to the Maven configuration file <code>pom.xml</code> to automatically obtain the Flink Connector.</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.vesoft&lt;/groupId&gt;\n    &lt;artifactId&gt;nebula-flink-connector&lt;/artifactId&gt;\n    &lt;version&gt;3.8.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"connector/nebula-flink-connector/#compile_and_package","title":"Compile and package","text":"<p>Follow the steps below to compile and package the Flink Connector.</p> <ol> <li> <p>Clone repository <code>nebula-flink-connector</code>.</p> <pre><code>$ git clone -b release-3.8 https://github.com/vesoft-inc/nebula-flink-connector.git\n</code></pre> </li> <li> <p>Enter the <code>nebula-flink-connector</code> directory.</p> </li> <li> <p>Compile and package.</p> <pre><code>$ mvn clean package -Dmaven.test.skip=true\n</code></pre> </li> </ol> <p>After compilation, a file similar to <code>nebula-flink-connector-3.8.0.jar</code> is generated in the directory <code>connector/target</code> of the folder.</p>"},{"location":"connector/nebula-flink-connector/#how_to_use","title":"How to use","text":""},{"location":"connector/nebula-flink-connector/#write_data_into_nebulagraph","title":"Write data into NebulaGraph","text":"<pre><code>StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\nNebulaClientOptions nebulaClientOptions = new NebulaClientOptions.NebulaClientOptionsBuilder()\n                .setGraphAddress(\"127.0.0.1:9669\")\n                .setMetaAddress(\"127.0.0.1:9559\")\n                .build();\nNebulaGraphConnectionProvider graphConnectionProvider = new NebulaGraphConnectionProvider(nebulaClientOptions);\nNebulaMetaConnectionProvider metaConnectionProvider = new NebulaMetaConnectionProvider(nebulaClientOptions);\n\nVertexExecutionOptions executionOptions = new VertexExecutionOptions.ExecutionOptionBuilder()\n                .setGraphSpace(\"flinkSink\")\n                .setTag(\"player\")\n                .setIdIndex(0)\n                .setFields(Arrays.asList(\"name\", \"age\"))\n                .setPositions(Arrays.asList(1, 2))\n                .setBatchSize(2)\n                .build();\n\nNebulaVertexBatchOutputFormat outputFormat = new NebulaVertexBatchOutputFormat(\n                graphConnectionProvider, metaConnectionProvider, executionOptions);\nNebulaSinkFunction&lt;Row&gt; nebulaSinkFunction = new NebulaSinkFunction&lt;&gt;(outputFormat);\nDataStream&lt;Row&gt; dataStream = playerSource.map(row -&gt; {\n            Row record = new org.apache.flink.types.Row(row.size());\n            for (int i = 0; i &lt; row.size(); i++) {\n                record.setField(i, row.get(i));\n            }\n            return record;\n        });\ndataStream.addSink(nebulaSinkFunction);\nenv.execute(\"write nebula\")\n</code></pre>"},{"location":"connector/nebula-flink-connector/#read_data_from_nebulagraph","title":"Read data from NebulaGraph","text":"<pre><code>NebulaClientOptions nebulaClientOptions = new NebulaClientOptions.NebulaClientOptionsBuilder()\n        .setMetaAddress(\"127.0.0.1:9559\")\n        .build();\nstorageConnectionProvider = new NebulaStorageConnectionProvider(nebulaClientOptions);\nStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\nenv.setParallelism(1);\n\nVertexExecutionOptions vertexExecutionOptions = new VertexExecutionOptions.ExecutionOptionBuilder()\n        .setGraphSpace(\"flinkSource\")\n        .setTag(\"person\")\n        .setNoColumn(false)\n        .setFields(Arrays.asList())\n        .setLimit(100)\n        .build();\n\nNebulaSourceFunction sourceFunction = new NebulaSourceFunction(storageConnectionProvider)\n        .setExecutionOptions(vertexExecutionOptions);\nDataStreamSource&lt;BaseTableRow&gt; dataStreamSource = env.addSource(sourceFunction);\ndataStreamSource.map(row -&gt; {\n    List&lt;ValueWrapper&gt; values = row.getValues();\n    Row record = new Row(15);\n    record.setField(0, values.get(0).asLong());\n    record.setField(1, values.get(1).asString());\n    record.setField(2, values.get(2).asString());\n    record.setField(3, values.get(3).asLong());\n    record.setField(4, values.get(4).asLong());\n    record.setField(5, values.get(5).asLong());\n    record.setField(6, values.get(6).asLong());\n    record.setField(7, values.get(7).asDate());\n    record.setField(8, values.get(8).asDateTime().getUTCDateTimeStr());\n    record.setField(9, values.get(9).asLong());\n    record.setField(10, values.get(10).asBoolean());\n    record.setField(11, values.get(11).asDouble());\n    record.setField(12, values.get(12).asDouble());\n    record.setField(13, values.get(13).asTime().getUTCTimeStr());\n    record.setField(14, values.get(14).asGeography());\n    return record;\n}).print();\nenv.execute(\"NebulaStreamSource\");\n</code></pre>"},{"location":"connector/nebula-flink-connector/#parameter_descriptions","title":"Parameter descriptions","text":"<ul> <li> <p><code>NebulaClientOptions</code> is the configuration for connecting to NebulaGraph, as described below.</p> Parameter Type Required Description <code>setGraphAddress</code> String Yes The Graph service address of NebulaGraph. <code>setMetaAddress</code> String Yes The Meta service address of NebulaGraph. </li> </ul> <ul> <li> <p><code>VertexExecutionOptions</code> is the configuration for reading vertices from and writing vertices to NebulaGraph, as described below.</p> Parameter Type Required Description <code>setGraphSpace</code> String Yes The graph space name. <code>setTag</code> String Yes The tag name. <code>setIdIndex</code> Int Yes The subscript of the stream data field that is used as the VID when writing data to NebulaGraph. <code>setFields</code> List Yes A collection of the property names of a tag. It is used to write data to or read data from NebulaGraph. Make sure the <code>setNoColumn</code> is <code>false</code> when reading data; otherwise, the configuration is invalid. If this parameter is empty, all properties are read when reading data from NebulaGraph. <code>setPositions</code> List Yes A collection of the subscripts of the stream data fields. It indicates that the corresponding field values are written to NebulaGraph as property values. This parameter needs to correspond to <code>setFields</code>. <code>setBatchSize</code> String No The maximum number of data records to write to NebulaGraph at a time. The default value is <code>2000</code>. <code>setNoColumn</code> String No The properties are not to be read if set to <code>true</code> when reading data. The default value is <code>false</code>. <code>setLimit</code> String No The maximum number of data records to pull at a time when reading data. The default value is <code>2000</code>. </li> </ul> <ul> <li> <p><code>EdgeExecutionOptions</code> is the configuration for reading edges from and writing edges to NebulaGraph, as described below.</p> Parameter Type Required Description <code>setGraphSpace</code> String Yes The graph space name. <code>setEdge</code> String Yes The edge type name. <code>setSrcIndex</code> Int Yes The subscript of the stream data field that is used as the VID of the source vertex when writing data to NebulaGraph. <code>setDstIndex</code> Int Yes The subscript of the stream data field that is used as the VID of the destination vertex when writing data to NebulaGraph. <code>setRankIndex</code> Int Yes The subscript of the stream data field that is used as the rank of the edge when writing data to NebulaGraph. <code>setFields</code> List Yes A collection of the property names of an edge type. It is used to write data to or read data from NebulaGraph. Make sure the <code>setNoColumn</code> is <code>false</code> when reading data; otherwise, the configuration is invalid. If this parameter is empty, all properties are read when reading data from NebulaGraph. <code>setPositions</code> List Yes A collection of the subscripts of the stream data fields. It indicates that the corresponding field values are written to NebulaGraph as property values. This parameter needs to correspond to <code>setFields</code>. <code>setBatchSize</code> String No The maximum number of data records to write to NebulaGraph at a time. The default value is <code>2000</code>. <code>setNoColumn</code> String No The properties are not to be read if set to <code>true</code> when reading data. The default value is <code>false</code>. <code>setLimit</code> String No The maximum number of data records to pull at a time when reading data. The default value is <code>2000</code>. </li> </ul>"},{"location":"connector/nebula-flink-connector/#example","title":"Example","text":"<ol> <li> <p>Create a graph space.</p> <pre><code>NebulaCatalog nebulaCatalog = NebulaCatalogUtils.createNebulaCatalog(\n        \"NebulaCatalog\",\n        \"default\",\n        \"root\",\n        \"nebula\",\n        \"127.0.0.1:9559\",\n        \"127.0.0.1:9669\");\n\nEnvironmentSettings settings = EnvironmentSettings.newInstance()\n        .inStreamingMode()\n        .build();\nTableEnvironment tableEnv = TableEnvironment.create(settings);\n\ntableEnv.registerCatalog(CATALOG_NAME, nebulaCatalog);\ntableEnv.useCatalog(CATALOG_NAME);\n\nString createDataBase = \"CREATE DATABASE IF NOT EXISTS `db1`\"\n        + \" COMMENT 'space 1'\"\n        + \" WITH (\"\n        + \" 'partition_num' = '100',\"\n        + \" 'replica_factor' = '3',\"\n        + \" 'vid_type' = 'FIXED_STRING(10)'\"\n        + \")\";\ntableEnv.executeSql(createDataBase);\n</code></pre> </li> <li> <p>Create a tag.</p> <pre><code>tableEnvironment.executeSql(\"CREATE TABLE `person` (\"\n        + \" vid BIGINT,\"\n        + \" col1 STRING,\"\n        + \" col2 STRING,\"\n        + \" col3 BIGINT,\"\n        + \" col4 BIGINT,\"\n        + \" col5 BIGINT,\"\n        + \" col6 BIGINT,\"\n        + \" col7 DATE,\"\n        + \" col8 TIMESTAMP,\"\n        + \" col9 BIGINT,\"\n        + \" col10 BOOLEAN,\"\n        + \" col11 DOUBLE,\"\n        + \" col12 DOUBLE,\"\n        + \" col13 TIME,\"\n        + \" col14 STRING\"\n        + \") WITH (\"\n        + \" 'connector' = 'nebula',\"\n        + \" 'meta-address' = '127.0.0.1:9559',\"\n        + \" 'graph-address' = '127.0.0.1:9669',\"\n        + \" 'username' = 'root',\"\n        + \" 'password' = 'nebula',\"\n        + \" 'data-type' = 'vertex',\"\n        + \" 'graph-space' = 'flink_test',\"\n        + \" 'label-name' = 'person'\"\n        + \")\"\n);\n</code></pre> </li> <li> <p>Create an edge type.</p> <pre><code>tableEnvironment.executeSql(\"CREATE TABLE `friend` (\"\n        + \" sid BIGINT,\"\n        + \" did BIGINT,\"\n        + \" rid BIGINT,\"\n        + \" col1 STRING,\"\n        + \" col2 STRING,\"\n        + \" col3 BIGINT,\"\n        + \" col4 BIGINT,\"\n        + \" col5 BIGINT,\"\n        + \" col6 BIGINT,\"\n        + \" col7 DATE,\"\n        + \" col8 TIMESTAMP,\"\n        + \" col9 BIGINT,\"\n        + \" col10 BOOLEAN,\"\n        + \" col11 DOUBLE,\"\n        + \" col12 DOUBLE,\"\n        + \" col13 TIME,\"\n        + \" col14 STRING\"\n        + \") WITH (\"\n        + \" 'connector' = 'nebula',\"\n        + \" 'meta-address' = '127.0.0.1:9559',\"\n        + \" 'graph-address' = '127.0.0.1:9669',\"\n        + \" 'username' = 'root',\"\n        + \" 'password' = 'nebula',\"\n        + \" 'graph-space' = 'flink_test',\"\n        + \" 'label-name' = 'friend',\"\n        + \" 'data-type'='edge',\"\n        + \" 'src-id-index'='0',\"\n        + \" 'dst-id-index'='1',\"\n        + \" 'rank-id-index'='2'\"\n        + \")\"\n);\n</code></pre> </li> <li> <p>Queries the data of an edge type and inserts it into another edge type.</p> <pre><code>Table table = tableEnvironment.sqlQuery(\"SELECT * FROM `friend`\");\ntable.executeInsert(\"`friend_sink`\").await();\n</code></pre> </li> </ol>"},{"location":"connector/nebula-spark-connector/","title":"NebulaGraph Spark Connector","text":"<p>NebulaGraph Spark Connector is a Spark connector application for reading and writing NebulaGraph data in Spark standard format. NebulaGraph Spark Connector consists of two parts: Reader and Writer.</p> <ul> <li> <p>Reader</p> <p>Provides a Spark SQL interface. This interface can be used to read NebulaGraph data. It reads one vertex or edge type data at a time and assemble the result into a Spark DataFrame.</p> </li> </ul> <ul> <li> <p>Writer</p> <p>Provides a Spark SQL interface. This interface can be used to write DataFrames into NebulaGraph in a row-by-row or batch-import way.</p> </li> </ul> <p>For more information, see NebulaGraph Spark Connector.</p>"},{"location":"connector/nebula-spark-connector/#version_compatibility","title":"Version compatibility","text":"<p>The correspondence between the NebulaGraph Spark Connector version, the NebulaGraph core version and the Spark version is as follows.</p> Spark Connector version NebulaGraph version Spark version nebula-spark-connector_3.0-3.0-SNAPSHOT.jar nightly 3.x nebula-spark-connector_2.2-3.0-SNAPSHOT.jar nightly 2.2.x nebula-spark-connector-3.0-SNAPSHOT.jar nightly 2.4.x nebula-spark-connector_3.0-3.8.0.jar 3.x 3.x nebula-spark-connector_2.2-3.8.0.jar 3.x 2.2.x nebula-spark-connector-3.8.0.jar 3.x 2.4.x nebula-spark-connector_3.0-3.6.0.jar 3.x 3.x nebula-spark-connector_2.2-3.6.0.jar 3.x 2.2.x nebula-spark-connector-3.6.0.jar 3.x 2.4.x nebula-spark-connector_2.2-3.4.0.jar 3.x 2.2.x nebula-spark-connector-3.4.0.jar 3.x 2.4.x nebula-spark-connector_2.2-3.3.0.jar 3.x 2.2.x nebula-spark-connector-3.3.0.jar 3.x 2.4.x nebula-spark-connector-3.0.0.jar 3.x 2.4.x nebula-spark-connector-2.6.1.jar 2.6.0, 2.6.1 2.4.x nebula-spark-connector-2.6.0.jar 2.6.0, 2.6.1 2.4.x nebula-spark-connector-2.5.1.jar 2.5.0, 2.5.1 2.4.x nebula-spark-connector-2.5.0.jar 2.5.0, 2.5.1 2.4.x nebula-spark-connector-2.1.0.jar 2.0.0, 2.0.1 2.4.x nebula-spark-connector-2.0.1.jar 2.0.0, 2.0.1 2.4.x nebula-spark-connector-2.0.0.jar 2.0.0, 2.0.1 2.4.x"},{"location":"connector/nebula-spark-connector/#use_cases","title":"Use cases","text":"<p>NebulaGraph Spark Connector applies to the following scenarios:</p> <ul> <li>Read data from NebulaGraph for analysis and computation.</li> <li>Write data back to NebulaGraph after analysis and computation.</li> <li>Migrate the data of NebulaGraph.</li> <li>Graph computing with NebulaGraph Algorithm.</li> </ul>"},{"location":"connector/nebula-spark-connector/#benefits","title":"Benefits","text":"<p>The features of NebulaGraph Spark Connector 3.8.0 are as follows:</p> <ul> <li>Supports multiple connection settings, such as timeout period, number of connection retries, number of execution retries, etc.</li> </ul> <ul> <li>Supports multiple settings for data writing, such as setting the corresponding column as vertex ID, starting vertex ID, destination vertex ID or attributes.</li> </ul> <ul> <li>Supports non-attribute reading and full attribute reading.</li> </ul> <ul> <li>Supports reading NebulaGraph data into VertexRDD and EdgeRDD, and supports non-Long vertex IDs.</li> </ul> <ul> <li>Unifies the extended data source of SparkSQL, and uses DataSourceV2 to extend NebulaGraph data.</li> </ul> <ul> <li>Three write modes, <code>insert</code>, <code>update</code> and <code>delete</code>, are supported. <code>insert</code> mode will insert (overwrite) data, <code>update</code> mode will only update existing data, and <code>delete</code> mode will only delete data.</li> </ul>"},{"location":"connector/nebula-spark-connector/#release_note","title":"Release note","text":"<p>Release</p>"},{"location":"connector/nebula-spark-connector/#get_nebulagraph_spark_connector","title":"Get NebulaGraph Spark Connector","text":""},{"location":"connector/nebula-spark-connector/#compile_and_package","title":"Compile and package","text":"<ol> <li> <p>Clone repository <code>nebula-spark-connector</code>.</p> <pre><code>$ git clone -b release-3.8 https://github.com/vesoft-inc/nebula-spark-connector.git\n</code></pre> </li> <li> <p>Enter the <code>nebula-spark-connector</code> directory.</p> </li> <li> <p>Compile and package. The procedure varies with Spark versions.</p> </li> </ol> <p>Note<p>Spark of the corresponding version has been installed.</p> </p> <p>- Spark 2.4</p> <pre><code>```bash\n$ mvn clean package -Dmaven.test.skip=true -Dgpg.skip -Dmaven.javadoc.skip=true -pl nebula-spark-connector -am -Pscala-2.11 -Pspark-2.4\n```\n</code></pre> <p>- Spark 2.2</p> <pre><code>```bash\n$ mvn clean package -Dmaven.test.skip=true -Dgpg.skip -Dmaven.javadoc.skip=true -pl nebula-spark-connector_2.2 -am -Pscala-2.11 -Pspark-2.2\n```\n</code></pre> <p>- Spark 3.x</p> <pre><code>```bash\n$ mvn clean package -Dmaven.test.skip=true -Dgpg.skip -Dmaven.javadoc.skip=true -pl nebula-spark-connector_3.0 -am -Pscala-2.12 -Pspark-3.0\n```\n</code></pre> <p>After compilation, a file similar to <code>nebula-spark-connector-3.8.0-SHANPSHOT.jar</code> is generated in the directory <code>target</code> of the folder.</p>"},{"location":"connector/nebula-spark-connector/#download_maven_remote_repository","title":"Download maven remote repository","text":"<p>Download</p>"},{"location":"connector/nebula-spark-connector/#how_to_use","title":"How to use","text":"<p>When using NebulaGraph Spark Connector to reading and writing NebulaGraph data, You can refer to the following code.</p> <pre><code># Read vertex and edge data from NebulaGraph.\nspark.read.nebula().loadVerticesToDF()\nspark.read.nebula().loadEdgesToDF()\n\n# Write dataframe data into NebulaGraph as vertex and edges.\ndataframe.write.nebula().writeVertices()\ndataframe.write.nebula().writeEdges()\n</code></pre> <p><code>nebula()</code> receives two configuration parameters, including connection configuration and read-write configuration.</p> <p>Note</p> <p>If the value of the properties contains Chinese characters, the encoding error may appear. Please add the following options when submitting the Spark task:</p> <pre><code>--conf spark.driver.extraJavaOptions=-Dfile.encoding=utf-8\n--conf spark.executor.extraJavaOptions=-Dfile.encoding=utf-8\n</code></pre>"},{"location":"connector/nebula-spark-connector/#reading_data_from_nebulagraph","title":"Reading data from NebulaGraph","text":"<pre><code>val config = NebulaConnectionConfig\n  .builder()\n  .withMetaAddress(\"127.0.0.1:9559\")\n  .withConenctionRetry(2)\n  .withExecuteRetry(2)\n  .withTimeout(6000)\n  .build()\n\nval nebulaReadVertexConfig: ReadNebulaConfig = ReadNebulaConfig\n  .builder()\n  .withUser(\"root\")\n  .withPasswd(\"nebula\")\n  .withSpace(\"test\")\n  .withLabel(\"person\")\n  .withNoColumn(false)\n  .withReturnCols(List(\"birthday\"))\n  .withLimit(10)\n  .withPartitionNum(10)\n  .build()\nval vertex = spark.read.nebula(config, nebulaReadVertexConfig).loadVerticesToDF()\n\nval nebulaReadEdgeConfig: ReadNebulaConfig = ReadNebulaConfig\n  .builder()\n  .withUser(\"root\")\n  .withPasswd(\"nebula\")\n  .withSpace(\"test\")\n  .withLabel(\"knows\")\n  .withNoColumn(false)\n  .withReturnCols(List(\"degree\"))\n  .withLimit(10)\n  .withPartitionNum(10)\n  .build()\nval edge = spark.read.nebula(config, nebulaReadEdgeConfig).loadEdgesToDF()\n</code></pre> <ul> <li> <p><code>NebulaConnectionConfig</code> is the configuration for connecting to NebulaGraph, as described below.</p> Parameter Required Description <code>withMetaAddress</code> Yes Specifies the IP addresses and ports of all Meta Services. Separate multiple addresses with commas. The format is <code>ip1:port1,ip2:port2,...</code>. Read data is no need to configure <code>withGraphAddress</code>. <code>withConnectionRetry</code> No The number of retries that the NebulaGraph Java Client connected to NebulaGraph. The default value is <code>1</code>. <code>withExecuteRetry</code> No The number of retries that the NebulaGraph Java Client executed query statements. The default value is <code>1</code>. <code>withTimeout</code> No The timeout for the NebulaGraph Java Client request response. The default value is <code>6000</code>, Unit: ms. </li> </ul> <ul> <li> <p><code>ReadNebulaConfig</code> is the configuration to read NebulaGraph data, as described below.</p> Parameter Required Description <code>withUser</code> No NebulaGraph username. This parameter is required when the Storage services require authentication. This parameter is only supported in NebulaGraph Enterprise Edition. <code>withPasswd</code> No The password for the NebulaGraph username. This parameter is required when the Storage services require authentication. This parameter is only supported in NebulaGraph Enterprise Edition. <code>withSpace</code> Yes NebulaGraph space name. <code>withLabel</code> Yes The Tag or Edge type name within the NebulaGraph space. <code>withNoColumn</code> No Whether the property is not read. The default value is <code>false</code>, read property. If the value is <code>true</code>, the property is not read, the <code>withReturnCols</code> configuration is invalid. <code>withReturnCols</code> No Configures the set of properties for vertex or edges to read. the format is <code>List(property1,property2,...)</code>, The default value is <code>List()</code>, indicating that all properties are read. <code>withLimit</code> No Configure the number of rows of data read from the server by the NebulaGraph Java Storage Client at a time. The default value is <code>1000</code>. <code>withPartitionNum</code> No Configures the number of Spark partitions to read the NebulaGraph data. The default value is <code>100</code>. This value should not exceed the number of slices in the graph space (partition_num). </li> </ul>"},{"location":"connector/nebula-spark-connector/#write_data_into_nebulagraph","title":"Write data into NebulaGraph","text":"<p>Note</p> <ul> <li>The values of columns in a DataFrame are automatically written to NebulaGraph as property values.</li> <li>Make sure that the column names in the DataFrame are consistent with the property names in NebulaGraph. If they are inconsistent, you can use <code>DataFrame.withColumnRenamed</code> to rename the column names first.</li> </ul> <pre><code>val config = NebulaConnectionConfig\n  .builder()\n  .withMetaAddress(\"127.0.0.1:9559\")\n  .withGraphAddress(\"127.0.0.1:9669\")\n  .withConenctionRetry(2)\n  .build()\n\nval nebulaWriteVertexConfig: WriteNebulaVertexConfig = WriteNebulaVertexConfig      \n  .builder()\n  .withSpace(\"test\")\n  .withTag(\"person\")\n  .withVidField(\"id\")\n  .withVidPolicy(\"hash\")\n  .withVidAsProp(true)\n  .withUser(\"root\")\n  .withPasswd(\"nebula\")\n  .withBatch(1000)\n  .build()    \ndf.write.nebula(config, nebulaWriteVertexConfig).writeVertices()\n\nval nebulaWriteEdgeConfig: WriteNebulaEdgeConfig = WriteNebulaEdgeConfig      \n  .builder()\n  .withSpace(\"test\")\n  .withEdge(\"friend\")\n  .withSrcIdField(\"src\")\n  .withSrcPolicy(null)\n  .withDstIdField(\"dst\")\n  .withDstPolicy(null)\n  .withRankField(\"degree\")\n  .withSrcAsProperty(true)\n  .withDstAsProperty(true)\n  .withRankAsProperty(true)\n  .withUser(\"root\")\n  .withPasswd(\"nebula\")\n  .withBatch(1000)\n  .build()\ndf.write.nebula(config, nebulaWriteEdgeConfig).writeEdges()\n</code></pre> <p>The default write mode is <code>insert</code>, which can be changed to <code>update</code> or <code>delete</code> via <code>withWriteMode</code> configuration:</p> <pre><code>val config = NebulaConnectionConfig\n  .builder()\n  .withMetaAddress(\"127.0.0.1:9559\")\n  .withGraphAddress(\"127.0.0.1:9669\")\n  .build()\nval nebulaWriteVertexConfig = WriteNebulaVertexConfig\n  .builder()\n  .withSpace(\"test\")\n  .withTag(\"person\")\n  .withVidField(\"id\")\n  .withVidAsProp(true)\n  .withBatch(1000)\n  .withWriteMode(WriteMode.UPDATE)\n  .build()\ndf.write.nebula(config, nebulaWriteVertexConfig).writeVertices()\n</code></pre> <ul> <li> <p><code>NebulaConnectionConfig</code> is the configuration for connecting to the nebula graph, as described below.</p> Parameter Required Description <code>withMetaAddress</code> Yes Specifies the IP addresses and ports of all Meta Services. Separate multiple addresses with commas. The format is <code>ip1:port1,ip2:port2,...</code>. <code>withGraphAddress</code> Yes Specifies the IP addresses and ports of Graph Services. Separate multiple addresses with commas. The format is <code>ip1:port1,ip2:port2,...</code>. <code>withConnectionRetry</code> No Number of retries that the NebulaGraph Java Client connected to NebulaGraph. The default value is <code>1</code>. </li> </ul> <ul> <li> <p><code>WriteNebulaVertexConfig</code> is the configuration of the write vertex, as described below.</p> Parameter Required Description <code>withSpace</code> Yes NebulaGraph space name. <code>withTag</code> Yes The Tag name that needs to be associated when a vertex is written. <code>withVidField</code> Yes The column in the DataFrame as the vertex ID. <code>withVidPolicy</code> No When writing the vertex ID, NebulaGraph use mapping function, supports HASH only. No mapping is performed by default. <code>withVidAsProp</code> No Whether the column in the DataFrame that is the vertex ID is also written as an property. The default value is <code>false</code>. If set to <code>true</code>, make sure the Tag has the same property name as <code>VidField</code>. <code>withUser</code> No NebulaGraph username. If authentication is disabled, you do not need to configure the username and password. <code>withPasswd</code> No The password for the NebulaGraph username. <code>withBatch</code> Yes The number of rows of data written at a time. The default value is  <code>1000</code>. <code>withWriteMode</code> No Write mode. The optional values are <code>insert</code>, <code>update</code> and <code>delete</code>. The default value is <code>insert</code>. <code>withDeleteEdge</code> No Whether to delete the related edges synchronously when deleting a vertex. The default value is <code>false</code>. It takes effect when <code>withWriteMode</code> is <code>delete</code>. </li> </ul> <ul> <li> <p><code>WriteNebulaEdgeConfig</code> is the configuration of the write edge, as described below.</p> Parameter Required Description <code>withSpace</code> Yes NebulaGraph space name. <code>withEdge</code> Yes The Edge type name that needs to be associated when a edge is written. <code>withSrcIdField</code> Yes The column in the DataFrame as the vertex ID. <code>withSrcPolicy</code> No When writing the starting vertex ID, NebulaGraph use mapping function, supports HASH only. No mapping is performed by default. <code>withDstIdField</code> Yes The column in the DataFrame that serves as the destination vertex. <code>withDstPolicy</code> No When writing the destination vertex ID, NebulaGraph use mapping function, supports HASH only. No mapping is performed by default. <code>withRankField</code> No The column in the DataFrame as the rank. Rank is not written by default. <code>withSrcAsProperty</code> No Whether the column in the DataFrame that is the starting vertex is also written as an property.  The default value is <code>false</code>. If set to <code>true</code>, make sure Edge type has the same property name as <code>SrcIdField</code>. <code>withDstAsProperty</code> No Whether column that are destination vertex in the DataFrame are also written as property. The default value is <code>false</code>. If set to <code>true</code>, make sure Edge type has the same property name as <code>DstIdField</code>. <code>withRankAsProperty</code> No Whether column in the DataFrame that is the rank is also written as property.The default value is <code>false</code>. If set to <code>true</code>, make sure Edge type has the same property name as <code>RankField</code>. <code>withUser</code> No NebulaGraph username. If authentication is disabled, you do not need to configure the username and password. <code>withPasswd</code> No The password for the NebulaGraph username. <code>withBatch</code> Yes The number of rows of data written at a time. The default value is  <code>1000</code>. <code>withWriteMode</code> No Write mode. The optional values are <code>insert</code>, <code>update</code> and <code>delete</code>. The default value is <code>insert</code>. </li> </ul>"},{"location":"graph-computing/nebula-algorithm/","title":"NebulaGraph Algorithm","text":"<p>NebulaGraph Algorithm (Algorithm) is a Spark application based on GraphX. It uses a complete algorithm tool to perform graph computing on the data in the NebulaGraph database by submitting a Spark task. You can also programmatically use the algorithm under the lib repository to perform graph computing on DataFrame.</p>"},{"location":"graph-computing/nebula-algorithm/#version_compatibility","title":"Version compatibility","text":"<p>The correspondence between the NebulaGraph Algorithm release and the NebulaGraph core release is as follows.</p> NebulaGraph NebulaGraph Algorithm nightly 3.0-SNAPSHOT 3.0.0 ~ 3.8.x 3.x.0 2.6.x 2.6.x 2.5.0\u30012.5.1 2.5.0 2.0.0\u30012.0.1 2.1.0"},{"location":"graph-computing/nebula-algorithm/#prerequisites","title":"Prerequisites","text":"<p>Before using the NebulaGraph Algorithm, users need to confirm the following information:</p> <ul> <li>The NebulaGraph services have been deployed and started. For details, see NebulaGraph Installation.</li> </ul> <ul> <li>The Spark version is 2.4 or 3.x is installed.</li> </ul> <ul> <li>The Scala version is 2.11 (for Spark 2.4) or 2.12 (for Spark 3.x) is installed.</li> </ul> <ul> <li>(Optional) If users need to clone, compile, and package the latest Algorithm in Github, install Maven.</li> </ul>"},{"location":"graph-computing/nebula-algorithm/#limitations","title":"Limitations","text":"<p>Graph computing outputs vertex datasets, and the algorithm results are stored in DataFrames as the properties of vertices. You can do further operations such as statistics and filtering according to your business requirements.</p> <p>!!!</p> <pre><code>Before Algorithm v3.1.0, when submitting the algorithm package directly, the data of the vertex ID must be an integer. That is, the vertex ID can be INT or String, but the data itself is an integer.\n</code></pre>"},{"location":"graph-computing/nebula-algorithm/#supported_algorithms","title":"Supported algorithms","text":"<p>The graph computing algorithms supported by NebulaGraph Algorithm are as follows.</p> Algorithm Description Scenario Properties name Properties type PageRank The rank of pages Web page ranking, key node mining pagerank double/string Louvain Louvain Community mining, hierarchical clustering louvain int/string KCore K core Community discovery, financial risk control kcore int/string LabelPropagation Label propagation Information spreading, advertising, and community discovery lpa int/string Hanp Label propagation advanced Community discovery, recommendation system hanp int/string ConnectedComponent Weakly connected component Community discovery, island discovery cc int/string StronglyConnectedComponent Strongly connected component Community discovery scc int/string ShortestPath The shortest path Path planning, network planning shortestpath string TriangleCount Triangle counting Network structure analysis trianglecount int/string GraphTriangleCount Graph triangle counting Network structure and tightness analysis count int BetweennessCentrality Intermediate centrality Key node mining, node influence computing betweenness double/string ClosenessCentrality Closeness centrality Key node mining, node influence computing closeness double/string DegreeStatic Degree of statistical Graph structure analysis degree,inDegree,outDegree int/string ClusteringCoefficient Aggregation coefficient Recommendation system, telecom fraud analysis clustercoefficient double/string Jaccard Jaccard similarity Similarity computing, recommendation system jaccard string BFS Breadth-First Search Sequence traversal, shortest path planning bfs string DFS Depth-First Search Sequence traversal, shortest path planning dfs string Node2Vec - Graph classification node2vec string <p>Note</p> <p>When writing the algorithm results into the NebulaGraph, make sure that the tag in the corresponding graph space has properties names and data types corresponding to the table above.</p>"},{"location":"graph-computing/nebula-algorithm/#implementation_methods","title":"Implementation methods","text":"<p>NebulaGraph Algorithm implements the graph calculating as follows:</p> <ol> <li> <p>Read the graph data of DataFrame from the NebulaGraph database using the NebulaGraph Spark Connector.</p> </li> <li> <p>Transform the graph data of DataFrame to the GraphX graph.</p> </li> <li> <p>Use graph algorithms provided by GraphX (such as PageRank) or self-implemented algorithms (such as Louvain).</p> </li> </ol> <p>For detailed implementation methods, see Scala file.</p>"},{"location":"graph-computing/nebula-algorithm/#get_nebulagraph_algorithm","title":"Get NebulaGraph Algorithm","text":""},{"location":"graph-computing/nebula-algorithm/#compile_and_package","title":"Compile and package","text":"<ol> <li> <p>Clone the repository <code>nebula-algorithm</code>.</p> <pre><code>$ git clone -b v3.2.0 https://github.com/vesoft-inc/nebula-algorithm.git\n</code></pre> <p>If running Algorithm in a Spark 3.x environment, use the spark3 branch:</p> <pre><code>$ git clone -b spark3 https://github.com/vesoft-inc/nebula-algorithm.git\n</code></pre> </li> <li> <p>Enter the directory <code>nebula-algorithm</code>.</p> <pre><code>$ cd nebula-algorithm\n</code></pre> </li> <li> <p>Compile and package.</p> <pre><code>$ mvn clean package -Dgpg.skip -Dmaven.javadoc.skip=true -Dmaven.test.skip=true\n</code></pre> </li> </ol> <p>After the compilation, a similar file <code>nebula-algorithm-3.x.x.jar</code> is generated in the directory <code>nebula-algorithm/target</code>.</p>"},{"location":"graph-computing/nebula-algorithm/#download_maven_from_the_remote_repository","title":"Download maven from the remote repository","text":"<p>Download address</p>"},{"location":"graph-computing/nebula-algorithm/#how_to_use","title":"How to use","text":"<p>Note</p> <p>If the value of the properties contains Chinese characters, the encoding error may appear. Please add the following options when submitting the Spark task:</p> <pre><code>--conf spark.driver.extraJavaOptions=-Dfile.encoding=utf-8\n--conf spark.executor.extraJavaOptions=-Dfile.encoding=utf-8\n</code></pre>"},{"location":"graph-computing/nebula-algorithm/#use_algorithm_interface_recommended","title":"Use algorithm interface (recommended)","text":"<p>The <code>lib</code> repository provides 10 common graph algorithms.</p> <ol> <li> <p>Add dependencies to the file <code>pom.xml</code>.</p> <pre><code>&lt;dependency&gt;\n     &lt;groupId&gt;com.vesoft&lt;/groupId&gt;\n     &lt;artifactId&gt;nebula-algorithm&lt;/artifactId&gt;\n     &lt;version&gt;3.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li> <p>Use the algorithm (take PageRank as an example) by filling in parameters. For more examples, see example.</p> <p>Note</p> <p>By default, the DataFrame that executes the algorithm sets the first column as the starting vertex, the second column as the destination vertex, and the third column as the edge weights (not the rank in the NebulaGraph).</p> <pre><code>val prConfig = new PRConfig(5, 1.0)\nval prResult = PageRankAlgo.apply(spark, data, prConfig, false)\n</code></pre> <p>If your vertex IDs are Strings, see Pagerank Example for how to encoding and decoding them.</p> </li> </ol>"},{"location":"graph-computing/nebula-algorithm/#submit_the_algorithm_package_directly","title":"Submit the algorithm package directly","text":"<ol> <li> <p>Set the Configuration file.</p> <pre><code>{\n  # Configurations related to Spark\n  spark: {\n    app: {\n        name: LPA\n        # The number of partitions of Spark\n        partitionNum:100\n    }\n    master:local\n  }\n\n  data: {\n    # Data source. Optional values are nebula, csv, and json.\n    source: csv\n    # Data sink. The algorithm result will be written into this sink. Optional values are nebula, csv, and text.\n    sink: nebula\n    # Whether the algorithm has a weight.\n    hasWeight: false\n  }\n\n  # Configurations related to NebulaGraph\n  nebula: {\n    # Data source. When NebulaGraph is the data source of the graph computing, the configuration of `nebula.read` is valid.\n    read: {\n        # The IP addresses and ports of all Meta services. Multiple addresses are separated by commas (,). Example: \"ip1:port1,ip2:port2\".\n        # To deploy NebulaGraph by using Docker Compose, fill in the port with which Docker Compose maps to the outside.\n        # Check the status with `docker-compose ps`.\n        metaAddress: \"192.168.*.10:9559\"\n        # The name of the graph space in NebulaGraph.\n        space: basketballplayer\n        # Edge types in NebulaGraph. When there are multiple labels, the data of multiple edges will be merged.\n        labels: [\"serve\"]\n        # The property name of each edge type in NebulaGraph. This property will be used as the weight column of the algorithm. Make sure that it corresponds to the edge type.\n        weightCols: [\"start_year\"]\n    }\n\n    # Data sink. When the graph computing result sinks into NebulaGraph, the configuration of `nebula.write` is valid.\n    write:{\n        # The IP addresses and ports of all Graph services. Multiple addresses are separated by commas (,). Example: \"ip1:port1,ip2:port2\".\n        # To deploy by using Docker Compose, fill in the port with which Docker Compose maps to the outside.\n        # Check the status with `docker-compose ps`.\n        graphAddress: \"192.168.*.11:9669\"\n        # The IP addresses and ports of all Meta services. Multiple addresses are separated by commas (,). Example: \"ip1:port1,ip2:port2\".\n        # To deploy NebulaGraph by using Docker Compose, fill in the port with which Docker Compose maps to the outside.\n        # Check the staus with `docker-compose ps`.\n        metaAddress: \"192.168.*.12:9559\"\n        user:root\n        pswd:nebula\n        # Before submitting the graph computing task, create the graph space and tag.\n        # The name of the graph space in NebulaGraph.\n        space:nb\n        # The name of the tag in NebulaGraph. The graph computing result will be written into this tag. The property name of this tag is as follows.\n        # PageRank: pagerank\n        # Louvain: louvain\n        # ConnectedComponent: cc\n        # StronglyConnectedComponent: scc\n        # LabelPropagation: lpa\n        # ShortestPath: shortestpath\n        # DegreeStatic: degree,inDegree,outDegree\n        # KCore: kcore\n        # TriangleCount: tranglecpunt\n        # BetweennessCentrality: betweennedss\n        tag:pagerank\n    }\n    }  \n\n  local: {\n    # Data source. When the data source is csv or json, the configuration of `local.read` is valid.\n    read:{\n        filePath: \"hdfs://127.0.0.1:9000/edge/work_for.csv\"\n        # If the CSV file has a header or it is a json file, use the header. If not, use [_c0, _c1, _c2, ..., _cn] instead.\n        # The header of the source VID column.\n        srcId:\"_c0\"\n        # The header of the destination VID column.\n        dstId:\"_c1\"\n        # The header of the weight column.\n        weight: \"_c2\"\n        # Whether the csv file has a header.\n        header: false\n        # The delimiter in the csv file.\n        delimiter:\",\"\n    }\n\n    # Data sink. When the graph computing result sinks to the csv or text file, the configuration of `local.write` is valid.\n    write:{\n        resultPath:/tmp/\n    }\n    }\n\n\n  algorithm: {\n    # The algorithm to execute. Optional values are as follow: \n    # pagerank, louvain, connectedcomponent, labelpropagation, shortestpaths, \n    # degreestatic, kcore, stronglyconnectedcomponent, trianglecount ,\n    # betweenness, graphtriangleCount.\n    executeAlgo: pagerank\n\n    # PageRank\n    pagerank: {\n        maxIter: 10\n        resetProb: 0.15 \n        encodeId:false # Configure true if the VID is of string type.\n    }\n\n    # Louvain\n    louvain: {\n        maxIter: 20\n        internalIter: 10\n        tol: 0.5\n        encodeId:false # Configure true if the VID is of string type.\n    }\n\n   # ...\n\n}\n}\n</code></pre> <p>Note</p> <p>When <code>sink: nebula</code> is configured, it means that the algorithm results will be written back to the NebulaGraph cluster. The property names of the tag have implicit conventions. For details, see Supported algorithms section of this topic.</p> </li> <li> <p>Submit the graph computing task.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master &lt;mode&gt; --class com.vesoft.nebula.algorithm.Main &lt;nebula-algorithm-3.2.0.jar_path&gt; -p &lt;application.conf_path&gt;\n</code></pre> <p>Example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.algorithm.Main /root/nebula-algorithm/target/nebula-algorithm-3.0-SNAPSHOT.jar -p /root/nebula-algorithm/src/main/resources/application.conf\n</code></pre> </li> </ol>"},{"location":"import-export/use-importer/","title":"NebulaGraph Importer","text":"<p>NebulaGraph Importer (Importer) is a standalone tool for importing data from CSV files into NebulaGraph. Importer can read and batch import CSV file data from multiple data sources, and also supports batch update and delete operations.</p>"},{"location":"import-export/use-importer/#features","title":"Features","text":"<ul> <li>Support multiple data sources, including local, S3, OSS, HDFS, FTP, SFTP, and GCS.</li> <li>Support importing data from CSV format files. A single file can contain multiple tags, multiple edge types or a mix of both.</li> <li>Support filtering the data from source.</li> <li>Support batch operation, including insert, update, delete.</li> <li>Support connecting to multiple Graph services simultaneously for importing and dynamic load balancing.</li> <li>Support reconnect or retry after failure.</li> <li>Support displaying statistics in multiple dimensions, including import time, import percentage, etc. Support for printing statistics in Console or logs.</li> <li>Support SSL.</li> </ul>"},{"location":"import-export/use-importer/#advantage","title":"Advantage","text":"<ul> <li>Lightweight and fast: no complex environment can be used, fast data import.</li> </ul> <ul> <li>Flexible filtering: You can flexibly filter CSV data through configuration files.</li> </ul>"},{"location":"import-export/use-importer/#version_compatibility","title":"Version compatibility","text":"<p>The version correspondence between NebulaGraph and NebulaGraph Importer is as follows.</p> NebulaGraph version NebulaGraph Importer version 3.x.x 3.x.x, 4.x.x 2.x.x 2.x.x, 3.x.x <p>Note</p> <p>Importer 4.0.0 has redone the Importer for improved performance, but the configuration file is not compatible with older versions. It is recommended to use the new version of Importer.</p>"},{"location":"import-export/use-importer/#release_note","title":"Release note","text":"<p>Release</p>"},{"location":"import-export/use-importer/#prerequisites","title":"Prerequisites","text":"<p>Before using NebulaGraph Importer, make sure:</p> <ul> <li> <p>NebulaGraph service has been deployed. The deployment method is as follows:</p> <ul> <li>Deploy NebulaGraph with Docker Compose</li> </ul> <ul> <li>Install NebulaGraph with RPM or DEB package</li> </ul> <ul> <li>Install NebulaGraph by compiling the source code</li> </ul> </li> </ul> <ul> <li>Schema is created in NebulaGraph, including space, Tag and Edge type, or set by parameter <code>manager.hooks.before.statements</code>.</li> </ul>"},{"location":"import-export/use-importer/#steps","title":"Steps","text":"<p>Prepare the CSV file to be imported and configure the YAML file to use the tool to batch write data into NebulaGraph.</p> <p>Note</p> <p>For details about the YAML configuration file, see Configuration File Description at the end of topic.</p>"},{"location":"import-export/use-importer/#download_binary_package_and_run","title":"Download binary package and run","text":"<ol> <li> <p>Download the executable binary package.</p> <p>Note</p> <p>The file installation path based on the RPM/DEB package is <code>/usr/bin/nebula-importer</code>. </p> </li> <li> <p>Under the directory where the binary file is located, run the following command to start importing data.</p> <pre><code>./&lt;binary_file_name&gt; --config &lt;yaml_config_file_path&gt;\n</code></pre> </li> </ol>"},{"location":"import-export/use-importer/#source_code_compile_and_run","title":"Source code compile and run","text":"<p>Compiling the source code requires deploying a Golang environment. For details, see Build Go environment.</p> <ol> <li> <p>Clone repository.</p> <pre><code>git clone -b release-4.1 https://github.com/vesoft-inc/nebula-importer.git\n</code></pre> <p>Note</p> <p>Use the correct branch. Different branches have different RPC protocols.</p> </li> <li> <p>Access the directory <code>nebula-importer</code>.</p> <pre><code>cd nebula-importer\n</code></pre> </li> <li> <p>Compile the source code.</p> <pre><code>make build\n</code></pre> </li> <li> <p>Start the service.</p> <pre><code>./bin/nebula-importer --config &lt;yaml_config_file_path&gt;\n</code></pre> </li> </ol>"},{"location":"import-export/use-importer/#run_in_docker_mode","title":"Run in Docker mode","text":"<p>Instead of installing the Go locale locally, you can use Docker to pull the image of the NebulaGraph Importer and mount the local configuration file and CSV data file into the container. The command is as follows:</p> <pre><code>docker pull vesoft/nebula-importer:&lt;version&gt;\ndocker run --rm -ti \\\n      --network=host \\\n      -v &lt;config_file&gt;:&lt;config_file&gt; \\\n      -v &lt;data_dir&gt;:&lt;data_dir&gt; \\\n      vesoft/nebula-importer:&lt;version&gt; \\\n      --config &lt;config_file&gt;\n</code></pre> <ul> <li><code>&lt;config_file&gt;</code>: The absolute path to the YAML configuration file.</li> <li><code>&lt;data_dir&gt;</code>: The absolute path to the CSV data file. If the file is not local, ignore this parameter.</li> <li><code>&lt;version&gt;</code>: NebulaGraph 3.x Please fill in 'v3'.</li> </ul> <p>Note</p> <p>A relative path is recommended. If you use a local absolute path, check that the path maps to the path in the Docker.</p> <p>Example:</p> <pre><code>docker pull vesoft/nebula-importer:v4\ndocker run --rm -ti \\\n      --network=host \\\n      -v /home/user/config.yaml:/home/user/config.yaml \\\n      -v /home/user/data:/home/user/data \\\n      vesoft/nebula-importer:v4 \\\n      --config /home/user/config.yaml\n</code></pre>"},{"location":"import-export/use-importer/#configuration_file_description","title":"Configuration File Description","text":"<p>Various example configuration files are available within the Github of the NebulaGraph Importer. The configuration files are used to describe information about the files to be imported, NebulaGraph server information, etc. The following section describes the fields within the configuration file in categories.</p> <p>Note</p> <p>If users download a binary package, create the configuration file manually.</p>"},{"location":"import-export/use-importer/#client_configuration","title":"Client configuration","text":"<p>Client configuration stores the configuration associated with the client's connection to the NebulaGraph.</p> <p>The example configuration is as follows:</p> <pre><code>client:\n  version: v3\n  address: \"192.168.1.100:9669,192.168.1.101:9669\"\n  user: root\n  password: nebula\n  ssl:\n    enable: true\n    certPath: \"/home/xxx/cert/importer.crt\"\n    keyPath: \"/home/xxx/cert/importer.key\"\n    caPath: \"/home/xxx/cert/root.crt\"\n    insecureSkipVerify: false\n  concurrencyPerAddress: 10\n  reconnectInitialInterval: 1s\n  retry: 3\n  retryInitialInterval: 1s\n</code></pre> Parameter Default value Required Description <code>client.version</code> <code>v3</code> Yes Specifies the major version of the NebulaGraph. Currently only <code>v3</code> is supported. <code>client.address</code> <code>\"127.0.0.1:9669\"</code> Yes Specifies the address of the NebulaGraph. Multiple addresses are separated by commas. <code>client.user</code> <code>root</code> No NebulaGraph user name. <code>client.password</code> <code>nebula</code> No The password for the NebulaGraph user name. <code>client.ssl.enable</code> <code>false</code> No Specifies whether to enable SSL authentication. <code>client.ssl.certPath</code> - No Specifies the storage path for the SSL public key certificate.This parameter is required when SSL authentication is enabled. <code>client.ssl.keyPath</code> - No S pecifies the storage path for the SSL key.This parameter is required when SSL authentication is enabled. <code>client.ssl.caPath</code> - No Specifies the storage path for the CA root certificate.This parameter is required when SSL authentication is enabled. <code>client.ssl.insecureSkipVerify</code> <code>false</code> No Specifies whether the client skips verifying the server's certificate chain and hostname. If set to <code>true</code>, any certificate chain and hostname provided by the server is accepted. <code>client.concurrencyPerAddress</code> <code>10</code> No The number of concurrent client connections for a single graph service. <code>client.reconnectInitialInterval</code> <code>1s</code> No Reconnect interval time. <code>client.retry</code> <code>3</code> No The number of retries for failed execution of the nGQL statement. <code>client.retryInitialInterval</code> <code>1s</code> No Retry interval time."},{"location":"import-export/use-importer/#manager_configuration","title":"Manager configuration","text":"<p>Manager configuration is a human-controlled configuration after connecting to the database.</p> <p>The example configuration is as follows:</p> <pre><code>manager:\n  spaceName: basic_string_examples\n  batch: 128\n  readerConcurrency: 50\n  importerConcurrency: 512\n  statsInterval: 10s\n  hooks:\n    before:\n      - statements:\n        - UPDATE CONFIGS storage:wal_ttl=3600;\n        - UPDATE CONFIGS storage:rocksdb_column_family_options = { disable_auto_compactions = true };\n      - statements:\n        - |\n            DROP SPACE IF EXISTS basic_string_examples;\n            CREATE SPACE IF NOT EXISTS basic_string_examples(partition_num=5, replica_factor=1, vid_type=int);\n            USE basic_string_examples;\n        wait: 10s\n    after:\n      - statements:\n          - |\n            UPDATE CONFIGS storage:wal_ttl=86400;\n            UPDATE CONFIGS storage:rocksdb_column_family_options = { disable_auto_compactions = false };\n</code></pre> Parameter Default value Required Description <code>manager.spaceName</code> - Yes Specifies the NebulaGraph space to import the data into. Do not support importing multiple map spaces at the same time. <code>manager.batch</code> <code>128</code> No The batch size for executing statements (global configuration).Setting the batch size individually for a data source can using the parameter <code>sources.batch</code> below. <code>manager.readerConcurrency</code> <code>50</code> No The number of concurrent reads of the data source by the reader. <code>manager.importerConcurrency</code> <code>512</code> No The number of concurrent nGQL statements generated to be executed, and then will call the client to execute these nGQL statements. <code>manager.statsInterval</code> <code>10s</code> No The time interval for printing statistical information <code>manager.hooks.before.[].statements</code> - No The command to execute in the graph space before importing. <code>manager.hooks.before.[].wait</code> - No The wait time after <code>statements</code> are executed. <code>manager.hooks.after.[].statements</code> - No The commands  to execute in the graph space after importing. <code>manager.hooks.after.[].wait</code> - No The wait time after <code>statements</code> are executed."},{"location":"import-export/use-importer/#log_configuration","title":"Log configuration","text":"<p>Log configuration is the logging-related configuration.</p> <p>The example configuration is as follows:</p> <pre><code>log:\n  level: INFO\n  console: true\n  files:\n    - logs/nebula-importer.log\n</code></pre> Parameter Default value Required Description <code>log.level</code> <code>INFO</code> No Specifies the log level. Optional values are <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, <code>PANIC</code>, <code>FATAL</code>. <code>log.console</code> <code>true</code> No Whether to print the logs to console synchronously when storing logs. <code>log.files</code> - No The log file path. The log directory must exist."},{"location":"import-export/use-importer/#source_configuration","title":"Source configuration","text":"<p>The Source configuration requires the configuration of data source information, data processing methods, and Schema mapping.</p> <p>The example configuration is as follows:</p> <pre><code>sources:\n  - path: ./person.csv  # Required. Specifies the path where the data files are stored. If a relative path is used, the path and current configuration file directory are spliced. Wildcard filename is also supported, for example: ./follower-*.csv, please make sure that all matching files with the same schema.\n#  - s3: # AWS S3\n#      endpoint: endpoint    # Optional. The endpoint of S3 service, can be omitted if using AWS S3.\n#      region: us-east-1     # Required. The region of S3 service.\n#      bucket: gdelt-open-data    # Required. The bucket of file in S3 service.\n#      key: events/20190918.export.csv     # Required. The object key of file in S3 service.\n#      accessKeyID: \"\"    # Optional. The access key of S3 service. If it is public data, no need to configure.\n#      accessKeySecret: \"\"     # Optional. The secret key of S3 service. If it is public data, no need to configure.\n#  - oss:\n#      endpoint: https://oss-cn-hangzhou.aliyuncs.com    # Required. The endpoint of OSS service.\n#      bucket: bucketName    # Required. The bucket of file in OSS service.\n#      key: objectKey    # Required. The object key of file in OSS service.\n#      accessKeyID: accessKey    # Required. The access key of OSS service.\n#      accessKeySecret: secretKey    # Required. The secret key of OSS service.\n#  - ftp:\n#      host: 192.168.0.10    # Required. The host of FTP service.\n#      port: 21    # Required. The port of FTP service.\n#      user: user    # Required. The user of FTP service.\n#      password: password    # Required. The password of FTP service.\n#      path: \"/events/20190918.export.csv\"    # Required. The path of file in the FTP service.\n#  - sftp:\n#      host: 192.168.0.10    # Required. The host of SFTP service.\n#      port: 22    # Required. The port of SFTP service.\n#      user: user    # Required. The user of SFTP service.\n#      password: password    # Optional. The password of SFTP service.\n#      keyFile: keyFile    # Optional. The ssh key file path of SFTP service.\n#      keyData: keyData    $ Optional. The ssh key file content of SFTP service.\n#      passphrase: passphrase    # Optional. The ssh key passphrase of SFTP service.\n#      path: \"/events/20190918.export.csv\"    # Required. The path of file in the SFTP service.\n#  - hdfs:\n#      address: \"127.0.0.1:8020\"    # Required. The address of HDFS service.\n#      user: \"hdfs\"    # Optional. The user of HDFS service.\n#      servicePrincipalName: &lt;Kerberos Service Principal Name&gt;  # Optional. The name of the Kerberos service instance for the HDFS service when Kerberos authentication is enabled.\n#      krb5ConfigFile: &lt;Kerberos config file&gt;  # Optional. The path to the Kerberos configuration file for the HDFS service when Kerberos authentication is enabled. Defaults to `/etc/krb5.conf`.\n#      ccacheFile: &lt;Kerberos ccache file&gt;  # Optional. The path to the Kerberos ccache file for the HDFS service when Kerberos authentication is enabled.\n#      keyTabFile: &lt;Kerberos keytab file&gt;  # Optional. The path to the Kerberos keytab file for the HDFS service when Kerberos authentication is enabled.\n#      password: &lt;Kerberos password&gt;  # Optional. The Kerberos password for the HDFS service when Kerberos authentication is enabled.\n#      dataTransferProtection: &lt;Kerberos Data Transfer Protection&gt;  # Optional. The type of transport encryption when Kerberos authentication is enabled. Optional values are `authentication`, `integrity`, `privacy`.\n#      disablePAFXFAST: false  # Optional. Whether to disable the use of PA_FX_FAST for clients.\n#      path: \"/events/20190918.export.csv\"    # Required. The path to the file in the HDFS service. Wildcard filenames are also supported, e.g. `/events/*.export.csv`, make sure all matching files have the same schema.\n#  - gcs: # Google Cloud Storage\n#      bucket: chicago-crime-sample  # Required. The name of the bucket in the GCS service.\n#      key: stats/000000000000.csv  # Required. The path to the file in the GCS service.\n#      withoutAuthentication: false  # Optional. Whether to anonymize access. Defaults to false, which means access with credentials.\n#      # When using credentials access, one of the credentialsFile and credentialsJSON parameters is sufficient.\n#      credentialsFile: \"/path/to/your/credentials/file\"  # Optional. The path to the credentials file for the GCS service.\n#      credentialsJSON: '{  # Optional. The JSON content of the credentials for the GCS service.\n#        \"type\": \"service_account\",\n#        \"project_id\": \"your-project-id\",\n#        \"private_key_id\": \"key-id\",\n#        \"private_key\": \"-----BEGIN PRIVATE KEY-----\\nxxxxx\\n-----END PRIVATE KEY-----\\n\",\n#        \"client_email\": \"your-client@your-project-id.iam.gserviceaccount.com\",\n#        \"client_id\": \"client-id\",\n#        \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\",\n#        \"token_uri\": \"https://oauth2.googleapis.com/token\",\n#        \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\",\n#        \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/your-client%40your-project-id.iam.gserviceaccount.com\",\n#        \"universe_domain\": \"googleapis.com\"\n#      }'\n    batch: 256\n    csv:\n      delimiter: \"|\"\n      withHeader: false\n      lazyQuotes: false\n    tags:\n    - name: Person\n#      mode: INSERT\n#      filter:  \n#        expr: Record[1] == \"XXX\"    \n      id:\n        type: \"STRING\"\n        function: \"hash\"\n#       index: 0        \n        concatItems:\n          - person_\n          - 0\n          - _id\n      props:\n        - name: \"firstName\"\n          type: \"STRING\"\n          index: 1\n        - name: \"lastName\"\n          type: \"STRING\"\n          index: 2\n        - name: \"gender\"\n          type: \"STRING\"\n          index: 3\n          nullable: true\n          defaultValue: female\n        - name: \"birthday\"\n          type: \"DATE\"\n          index: 4\n          nullable: true\n          nullValue: _NULL_\n        - name: \"creationDate\"\n          type: \"DATETIME\"\n          index: 5\n        - name: \"locationIP\"\n          type: \"STRING\"\n          index: 6\n        - name: \"browserUsed\"\n          type: \"STRING\"\n          index: 7\n  - path: ./knows.csv\n    batch: 256\n    edges:\n    - name: KNOWS # person_knows_person\n#      mode: INSERT\n#      filter:  \n#        expr: Record[1] == \"XXX\"\n      src:\n        id:\n          type: \"STRING\"\n          concatItems:\n            - person_\n            - 0\n            - _id\n      dst:\n        id:\n          type: \"STRING\"\n          concatItems:\n            - person_\n            - 1\n            - _id\n      props:\n        - name: \"creationDate\"\n          type: \"DATETIME\"\n          index: 2\n          nullable: true\n          nullValue: _NULL_\n          defaultValue: 0000-00-00T00:00:00\n</code></pre> <p>The configuration mainly includes the following parts:</p> <ul> <li>Specify the data source information.</li> <li>Specifies the batch size for executing statements.</li> <li>Specifies the CSV file format information.</li> <li>Specifies the schema mapping for Tag.</li> <li>Specifies the schema mapping for Edge type.</li> </ul> Parameter Default value Required Description <code>sources.path</code><code>sources.s3</code><code>sources.oss</code><code>sources.ftp</code><code>sources.sftp</code><code>sources.hdfs</code> - No Specify data source information, such as local file, HDFS, and S3. Only one source can be configured for the <code>source</code>. Configure multiple sources in multiple <code>source</code>.See the comments in the example for configuration items for different data sources. <code>sources.batch</code> <code>256</code> No The batch size for executing statements when importing this data source. The priority is higher than <code>manager.batch</code>. <code>sources.csv.delimiter</code> <code>,</code> No Specifies the delimiter for the CSV file. Only 1-character string separators are supported. Special characters like tabs (<code>\\t</code>) and hexadecimal values (e.g., <code>0x03</code> or <code>Ctrl+C</code>) must be properly escaped and enclosed in double quotes, such as <code>\"\\t\"</code> for tabs and <code>\"\\x03\"</code> or <code>\"\\u0003\"</code> for hexadecimal values, instead of using single quotes. For details on escaping special characters in yaml format, see Escaped Characters. <code>sources.csv.withHeader</code> <code>false</code> No Whether to ignore the first record in the CSV file. <code>sources.csv.lazyQuotes</code> <code>false</code> No Whether to allow lazy quotes. If <code>lazyQuotes</code> is true, a quote may appear in an unquoted field and a non-doubled quote may appear in a quoted field. <code>sources.tags.name</code> - Yes The tag name. <code>sources.tags.mode</code> <code>INSERT</code> No Batch operation types, including insert, update and delete. Optional values are <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code>. <code>sources.tags.filter.expr</code> - No Filter the data and only import if the filter conditions are met. Supported comparison characters are <code>==</code>, <code>! =</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. Logical operators supported are <code>not</code> (!) , <code>and</code> (&amp;&amp;) and <code>or</code> (||). For example <code>(Record[0] == \"Mahinda\" or Record[0] == \"Michael\") and Record[3] == \"male\"</code>. <code>sources.tags.id.type</code> <code>STRING</code> No The type of the VID. <code>sources.tags.id.function</code> - No Functions to generate the VID. Currently, only function <code>hash</code> are supported. <code>sources.tags.id.index</code> - No The column number corresponding to the VID in the data file. If <code>sources.tags.id.concatItems</code> is not configured, this parameter must be configured. <code>sources.tags.id.concatItems</code> - No Used to concatenate two or more arrays, the concatenated items can be <code>string</code>, <code>int</code> or mixed. <code>string</code> stands for a constant, <code>int</code> for an index column. If this parameter is set, the <code>sources.tags.id.index</code> parameter will not take effect. <code>sources.tags.ignoreExistedIndex</code> <code>true</code> No Whether to enable <code>IGNORE_EXISTED_INDEX</code>, that is, do not update index after insertion vertex. <code>sources.tags.props.name</code> - Yes The tag property name, which must match the Tag property in the database. <code>sources.tags.props.type</code> <code>STRING</code> No Property data type, supporting <code>BOOL</code>, <code>INT</code>, <code>FLOAT</code>, <code>DOUBLE</code>, <code>STRING</code>, <code>TIME</code>, <code>TIMESTAMP</code>, <code>DATE</code>, <code>DATETIME</code>, <code>GEOGRAPHY</code>, <code>GEOGRAPHY(POINT)</code>, <code>GEOGRAPHY(LINESTRING)</code> and <code>GEOGRAPHY(POLYGON)</code>. <code>sources.tags.props.index</code> - Yes The property corresponds to the column number in the data file. <code>sources.tags.props.nullable</code> <code>false</code> No Whether this prop property can be <code>NULL</code>, optional values is <code>true</code> or <code>false</code>. <code>sources.tags.props.nullValue</code> - No Ignored when <code>nullable</code> is <code>false</code>. The value used to determine whether it is a <code>NULL</code>. The property is set to <code>NULL</code> when the value is equal to <code>nullValue</code>. <code>sources.tags.props.alternativeIndices</code> - No Ignored when <code>nullable</code> is <code>false</code>. The property is fetched from records according to the indices in order until not equal to <code>nullValue</code>. <code>sources.tags.props.defaultValue</code> - No Ignored when <code>nullable</code> is <code>false</code>. The property default value, when all the values obtained by <code>index</code> and <code>alternativeIndices</code> are <code>nullValue</code>. <code>sources.edges.name</code> - Yes The edge type name. <code>sources.edges.mode</code> <code>INSERT</code> No Batch operation types, including insert, update and delete. Optional values are <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code>. <code>sources.edges.filter.expr</code> - No Filter the data and only import if the filter conditions are met. Supported comparison characters are <code>==</code>, <code>! =</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. Logical operators supported are <code>not</code> (!) , <code>and</code> (&amp;&amp;) and <code>or</code> (||). For example <code>(Record[0] == \"Mahinda\" or Record[0] == \"Michael\") and Record[3] == \"male\"</code>. <code>sources.edges.src.id.type</code> <code>STRING</code> No The data type of the VID at the starting vertex on the edge. <code>sources.edges.src.id.index</code> - Yes The column number in the data file corresponding to the VID at the starting vertex on the edge. <code>sources.edges.dst.id.type</code> <code>STRING</code> No The data type of the VID at the destination vertex on the edge. <code>sources.edges.dst.id.index</code> - Yes The column number in the data file corresponding to the VID at the destination vertex on the edge. <code>sources.edges.rank.index</code> - No The column number in the data file corresponding to the rank on the edge. <code>sources.edges.ignoreExistedIndex</code> <code>true</code> No Whether to enable <code>IGNORE_EXISTED_INDEX</code>, that is, do not update index after insertion vertex. <code>sources.edges.props.name</code> - No The edge type property name, which must match the Tag property in the database. <code>sources.edges.props.type</code> <code>STRING</code> No Property data type, supporting <code>BOOL</code>, <code>INT</code>, <code>FLOAT</code>, <code>DOUBLE</code>, <code>STRING</code>, <code>TIME</code>, <code>TIMESTAMP</code>, <code>DATE</code>, <code>DATETIME</code>, <code>GEOGRAPHY</code>, <code>GEOGRAPHY(POINT)</code>, <code>GEOGRAPHY(LINESTRING)</code> and <code>GEOGRAPHY(POLYGON)</code>. <code>sources.edges.props.index</code> - No The property corresponds to the column number in the data file. <code>sources.edges.props.nullable</code> - No Whether this prop property can be <code>NULL</code>, optional values is <code>true</code> or <code>false</code>. <code>sources.edges.props.nullValue</code> - No Ignored when <code>nullable</code> is <code>false</code>. The value used to determine whether it is a <code>NULL</code>. The property is set to <code>NULL</code> when the value is equal to <code>nullValue</code>. <code>sources.edges.props.defaultValue</code> - No Ignored when <code>nullable</code> is <code>false</code>. The property default value, when all the values obtained by <code>index</code> and <code>alternativeIndices</code> are <code>nullValue</code>. <p>Note</p> <p>The sequence numbers of the columns in the CSV file start from 0, that is, the sequence numbers of the first column are 0, and the sequence numbers of the second column are 1.</p>"},{"location":"import-export/use-importer/#faq","title":"FAQ","text":""},{"location":"import-export/use-importer/#what_are_the_descriptions_of_the_fields_in_the_log_output","title":"What are the descriptions of the fields in the log output?","text":"<p>The following is an example of a log entry:</p> <pre><code>\u201cmsg\u201d: \u201c44m20s 2h7m10s 25.85%(129 GiB/498 GiB) Records{Finished: 302016726, Failed: 0, Rate: 113538.13/s}, Requests{Finished: 181786, Failed: 0, Latency: 4.046496736s/4.06694393s, Rate: 68.34/s}, Processed{Finished: 908575178, Failed: 0, Rate: 341563.62/s}\u201d\n</code></pre> <p>The fields are described below:</p> <ul> <li><code>44m20s 2h7m10s 25.85%(129 GiB/498 GiB)</code> corresponds to basic information about the importing process.<ul> <li>The consumed time.</li> <li>The expected remaining time.</li> <li>The percentage of data processed.</li> <li>The size of data processed.</li> <li>The total data size.</li> </ul> </li> <li><code>Records</code> corresponds to the records of the CSV files.<ul> <li><code>Finished</code>: The number of the completed records.</li> <li><code>Failed</code>: The number of the failed records.</li> <li><code>Rate</code>: The number of records imported per second.</li> </ul> </li> <li><code>Requests</code> corresponds to the requests.<ul> <li><code>Finished</code>: The number of the completed requests.</li> <li><code>Failed</code>: The number of the failed requests.</li> <li><code>Latency</code>: The time consumed by server-side requests / The time consumed by client-side requests.</li> <li><code>Rate</code>: The number of requests processed per second.</li> </ul> </li> <li><code>Processed</code> corresponds to nodes and edges.<ul> <li><code>Finished</code>: The number of the completed nodes and edges.</li> <li><code>Failed</code>: The number of the failed nodes and edges.</li> <li><code>Rate</code>: The number of nodes and edges processed per second.</li> </ul> </li> </ul>"},{"location":"import-export/write-tools/","title":"Import and export tools overview","text":""},{"location":"import-export/write-tools/#import_tools","title":"Import tools","text":"<p>There are many ways to write NebulaGraph 3.8.0:</p> <ul> <li>Import with the command -f: This method imports a small number of prepared nGQL files, which is suitable to prepare for a small amount of manual test data.</li> <li>Import with Studio: This method uses a browser to import multiple CSV files of this machine. A single file cannot exceed 100 MB, and its format is limited.</li> <li>Import with Importer: This method imports multiple CSV files on a single machine with unlimited size and flexible format. Suitable for scenarios with less than one billion records of data.</li> <li>Import with Exchange: This method imports from various distribution sources, such as Neo4j, Hive, MySQL, etc., which requires a Spark cluster. Suitable for scenarios with more than one billion records of data.</li> <li>Read and write APIs with Spark-connector/Flink-connector: This method requires you to write a small amount of code to make use of the APIs provided by Spark/Flink connector.</li> <li>Import with C++/GO/Java/Python SDK: This method imports in the way of writing programs, which requires certain programming and tuning skills.</li> </ul> <p>The following figure shows the positions of these ways:</p> <p></p>"},{"location":"import-export/write-tools/#export_tools","title":"Export tools","text":"<ul> <li>Read and write APIs with Spark-connector/Flink-connector: This method requires you to write a small amount of code to make use of the APIs provided by Spark/Flink connector.</li> <li> <p>Export the data in database to a CSV file or another graph space (different NebulaGraph database clusters are supported) using the export function of the Exchange.</p> <p>Enterpriseonly</p> <p>The export function is exclusively available in the Enterprise Edition. If you require access to this version, please contact us.</p> </li> </ul>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/","title":"Exchange FAQ","text":""},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#compilation","title":"Compilation","text":""},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_some_packages_not_in_central_repository_failed_to_download_error_could_not_resolve_dependencies_for_project_xxx","title":"Q: Some packages not in central repository failed to download, error: <code>Could not resolve dependencies for project xxx</code>","text":"<p>Please check the <code>mirror</code> part of Maven installation directory <code>libexec/conf/settings.xml</code>:</p> <pre><code>&lt;mirror&gt;\n    &lt;id&gt;alimaven&lt;/id&gt;\n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n    &lt;name&gt;aliyun maven&lt;/name&gt;\n    &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;\n&lt;/mirror&gt;\n</code></pre> <p>Check whether the value of <code>mirrorOf</code> is configured to <code>*</code>. If it is, change it to <code>central</code> or <code>*,!SparkPackagesRepo,!bintray-streamnative-maven</code>.</p> <p>Reason: There are two dependency packages in Exchange's <code>pom.xml</code> that are not in Maven's central repository. <code>pom.xml</code> configures the repository address for these two dependencies. If the <code>mirrorOf</code> value for the mirror address configured in Maven is <code>*</code>, all dependencies will be downloaded from the Central repository, causing the download to fail.</p>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_unable_to_download_snapshot_packages_when_compiling_exchange","title":"Q: Unable to download SNAPSHOT packages when compiling Exchange","text":"<p>Problem description: The system reports <code>Could not find artifact com.vesoft:client:jar:xxx-SNAPSHOT</code> when compiling.</p> <p>Cause: There is no local Maven repository for storing or downloading SNAPSHOT packages. The default central repository in Maven only stores official releases, not development versions (SNAPSHOT).</p> <p>Solution: Add the following configuration in the <code>profiles</code> scope of Maven's <code>setting.xml</code> file:</p> <pre><code>  &lt;profile&gt;\n     &lt;activation&gt;\n        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\n     &lt;/activation&gt;\n     &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;snapshots&lt;/id&gt;\n            &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;\n            &lt;snapshots&gt;\n               &lt;enabled&gt;true&lt;/enabled&gt;\n            &lt;/snapshots&gt;\n      &lt;/repository&gt;\n     &lt;/repositories&gt;\n  &lt;/profile&gt;\n</code></pre>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#execution","title":"Execution","text":""},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_error_javalangclassnotfoundexception_comvesoftnebulaexchangeexchange","title":"Q: Error: <code>java.lang.ClassNotFoundException: com.vesoft.nebula.exchange.Exchange</code>","text":"<p>To submit a task in Yarn-Cluster mode, run the following command, especially the two '--conf' commands in the example.</p> <pre><code>$SPARK_HOME/bin/spark-submit --class com.vesoft.nebula.exchange.Exchange \\\n--master yarn-cluster \\\n--files application.conf \\\n--conf spark.driver.extraClassPath=./ \\\n--conf spark.executor.extraClassPath=./ \\\nnebula-exchange-3.0.0.jar \\\n-c application.conf\n</code></pre>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_error_method_name_xxx_not_found","title":"Q: Error: <code>method name xxx not found</code>","text":"<p>Generally, the port configuration is incorrect. Check the port configuration of the Meta service, Graph service, and Storage service.</p>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_error_nosuchmethod_methodnotfound_exception_in_thread_main_javalangnosuchmethoderror_etc","title":"Q: Error: NoSuchMethod, MethodNotFound (<code>Exception in thread \"main\" java.lang.NoSuchMethodError</code>, etc)","text":"<p>Most errors are caused by JAR package conflicts or version conflicts. Check whether the version of the error reporting service is the same as that used in Exchange, especially Spark, Scala, and Hive.</p>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_when_exchange_imports_hive_data_error_exception_in_thread_main_orgapachesparksqlanalysisexception_table_or_view_not_found","title":"Q: When Exchange imports Hive data, error: <code>Exception in thread \"main\" org.apache.spark.sql.AnalysisException: Table or view not found</code>","text":"<p>Check whether the <code>-h</code> parameter is omitted in the command for submitting the Exchange task and whether the table and database are correct, and run the user-configured exec statement in spark-SQL to verify the correctness of the exec statement.</p>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_run_error_comfacebookthriftprotocoltprotocolexception_expected_protocol_id_xxx","title":"Q: Run error: <code>com.facebook.thrift.protocol.TProtocolException: Expected protocol id xxx</code>","text":"<p>Check that the NebulaGraph service port is configured correctly.</p> <ul> <li>For source, RPM, or DEB installations, configure the port number corresponding to <code>--port</code> in the configuration file for each service.</li> </ul> <ul> <li>For docker installation, configure the docker mapped port number as follows:<p>Execute <code>docker-compose ps</code> in the <code>nebula-docker-compose</code> directory, for example:</p> <pre><code>$ docker-compose ps\n              Name                             Command                  State                                                         Ports\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nnebula-docker-compose_graphd_1      /usr/local/nebula/bin/nebu ...   Up (healthy)   0.0.0.0:33205-&gt;19669/tcp, 0.0.0.0:33204-&gt;19670/tcp, 0.0.0.0:9669-&gt;9669/tcp\nnebula-docker-compose_metad0_1      ./bin/nebula-metad --flagf ...   Up (healthy)   0.0.0.0:33165-&gt;19559/tcp, 0.0.0.0:33162-&gt;19560/tcp, 0.0.0.0:33167-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_metad1_1      ./bin/nebula-metad --flagf ...   Up (healthy)   0.0.0.0:33166-&gt;19559/tcp, 0.0.0.0:33163-&gt;19560/tcp, 0.0.0.0:33168-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_metad2_1      ./bin/nebula-metad --flagf ...   Up (healthy)   0.0.0.0:33161-&gt;19559/tcp, 0.0.0.0:33160-&gt;19560/tcp, 0.0.0.0:33164-&gt;9559/tcp, 9560/tcp\nnebula-docker-compose_storaged0_1   ./bin/nebula-storaged --fl ...   Up (healthy)   0.0.0.0:33180-&gt;19779/tcp, 0.0.0.0:33178-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:33183-&gt;9779/tcp, 9780/tcp\nnebula-docker-compose_storaged1_1   ./bin/nebula-storaged --fl ...   Up (healthy)   0.0.0.0:33175-&gt;19779/tcp, 0.0.0.0:33172-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:33177-&gt;9779/tcp, 9780/tcp\nnebula-docker-compose_storaged2_1   ./bin/nebula-storaged --fl ...   Up (healthy)   0.0.0.0:33184-&gt;19779/tcp, 0.0.0.0:33181-&gt;19780/tcp, 9777/tcp, 9778/tcp, 0.0.0.0:33185-&gt;9779/tcp, 9780/tcp\n</code></pre> <p>Check the <code>Ports</code> column to find the docker mapped port number, for example:</p> <p>- The port number available for Graph service is 9669.</p> <p>- The port number for Meta service are 33167, 33168, 33164.</p> <p>- The port number for Storage service are 33183, 33177, 33185.</p> </li> </ul>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_error_exception_in_thread_main_comfacebookthriftprotocoltprotocolexception_the_field_code_has_been_assigned_the_invalid_value_-4","title":"Q: Error: <code>Exception in thread \"main\" com.facebook.thrift.protocol.TProtocolException: The field 'code' has been assigned the invalid value -4</code>","text":"<p>Check whether the version of Exchange is the same as that of NebulaGraph. For more information, see Limitations.</p>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_how_to_correct_the_encoding_error_when_importing_data_in_a_spark_environment","title":"Q: How to correct the encoding error when importing data in a Spark environment?","text":"<p>It may happen if the property value of the data contains Chinese characters. The solution is to add the following options before the JAR package path in the import command:</p> <pre><code>--conf spark.driver.extraJavaOptions=-Dfile.encoding=utf-8\n--conf spark.executor.extraJavaOptions=-Dfile.encoding=utf-8\n</code></pre> <p>Namely:</p> <pre><code>&lt;spark_install_path&gt;/bin/spark-submit --master \"local\" \\\n--conf spark.driver.extraJavaOptions=-Dfile.encoding=utf-8 \\\n--conf spark.executor.extraJavaOptions=-Dfile.encoding=utf-8 \\\n--class com.vesoft.nebula.exchange.Exchange \\\n&lt;nebula-exchange-3.x.y.jar_path&gt; -c &lt;application.conf_path&gt;\n</code></pre> <p>In YARN, use the following command:</p> <pre><code>&lt;spark_install_path&gt;/bin/spark-submit \\\n--class com.vesoft.nebula.exchange.Exchange \\\n--master yarn-cluster \\\n--files &lt;application.conf_path&gt; \\\n--conf spark.driver.extraClassPath=./ \\\n--conf spark.executor.extraClassPath=./ \\\n--conf spark.driver.extraJavaOptions=-Dfile.encoding=utf-8 \\\n--conf spark.executor.extraJavaOptions=-Dfile.encoding=utf-8 \\\n&lt;nebula-exchange-3.x.y.jar_path&gt; \\\n-c application.conf\n</code></pre>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_orgrocksdbrocksdbexception_while_open_a_file_for_appending_pathsst1-xxxsst_no_such_file_or_directory","title":"Q: org.rocksdb.RocksDBException: While open a file for appending: /path/sst/1-xxx.sst: No such file or directory","text":"<p>Solution:</p> <ol> <li>Check if <code>/path</code> exists. If not, or if the path is set incorrectly, create or correct it.</li> <li>Check if Spark's current user on each machine has the operation permission on <code>/path</code>. If not, grant the permission.</li> </ol>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#configuration","title":"Configuration","text":""},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_which_configuration_fields_will_affect_import_performance","title":"Q: Which configuration fields will affect import performance?","text":"<ul> <li>batch: The number of data contained in each nGQL statement sent to the NebulaGraph service.</li> </ul> <ul> <li>partition: The number of partitions to be created when the data is written to NebulaGraph, indicating the number of concurrent data imports.</li> </ul> <ul> <li>nebula.rate: Get a token from the token bucket before sending a request to NebulaGraph.<p>- limit: Represents the size of the token bucket.</p> <p>- timeout: Represents the timeout period for obtaining the token.</p> </li> </ul> <p>The values of these four parameters can be adjusted appropriately according to the machine performance. If the leader of the Storage service changes during the import process, you can adjust the values of these four parameters to reduce the import speed.</p>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#others","title":"Others","text":""},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_which_versions_of_nebulagraph_are_supported_by_exchange","title":"Q: Which versions of NebulaGraph are supported by Exchange?","text":"<p>See Limitations.</p>"},{"location":"import-export/nebula-exchange/ex-ug-FAQ/#q_what_is_the_relationship_between_exchange_and_spark_writer","title":"Q: What is the relationship between Exchange and Spark Writer?","text":"<p>Exchange is the Spark application developed based on Spark Writer. Both are suitable for bulk migration of cluster data to NebulaGraph in a distributed environment, but later maintenance work will be focused on Exchange. Compared with Spark Writer, Exchange has the following improvements:</p> <ul> <li>It supports more abundant data sources, such as MySQL, Neo4j, Hive, HBase, Kafka, Pulsar, etc.</li> </ul> <ul> <li>It fixed some problems of Spark Writer. For example, when Spark reads data from HDFS, the default source data is String, which may be different from the NebulaGraph's Schema. So Exchange adds automatic data type matching and type conversion. When the data type in the NebulaGraph's Schema is non-String (e.g. double), Exchange converts the source data of String type to the corresponding type.</li> </ul>"},{"location":"import-export/nebula-exchange/ex-ug-compile/","title":"Get Exchange","text":"<p>This topic introduces how to get the JAR file of NebulaGraph Exchange.</p>"},{"location":"import-export/nebula-exchange/ex-ug-compile/#download_the_jar_file_directly","title":"Download the JAR file directly","text":"<p>The JAR file of Exchange Community Edition can be downloaded directly.</p> <p>To download Exchange Enterprise Edition, contact us.</p>"},{"location":"import-export/nebula-exchange/ex-ug-compile/#get_the_jar_file_by_compiling_the_source_code","title":"Get the JAR file by compiling the source code","text":"<p>You can get the JAR file of Exchange Community Edition by compiling the source code. The following introduces how to compile the source code of Exchange.</p> <p>Enterpriseonly</p> <p>You can get Exchange Enterprise Edition in NebulaGraph Enterprise Edition Package only.</p>"},{"location":"import-export/nebula-exchange/ex-ug-compile/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install Maven.</li> </ul> <ul> <li>Install the correct version of Apache Spark. Exporting data from different sources requires different Spark versions. For more information, see Software dependencies.</li> </ul>"},{"location":"import-export/nebula-exchange/ex-ug-compile/#steps","title":"Steps","text":"<ol> <li> <p>Clone the repository <code>nebula-exchange</code> in the <code>/</code> directory.</p> <pre><code>git clone -b release-3.8 https://github.com/vesoft-inc/nebula-exchange.git\n</code></pre> </li> <li> <p>Switch to the directory <code>nebula-exchange</code>.</p> <pre><code>cd nebula-exchange\n</code></pre> </li> <li> <p>Package NebulaGraph Exchange. Run the following command based on the Spark version:</p> <ul> <li> <p>For Spark 2.2\uff1a</p> <pre><code>mvn clean package -Dmaven.test.skip=true -Dgpg.skip -Dmaven.javadoc.skip=true \\\n-pl nebula-exchange_spark_2.2 -am -Pscala-2.11 -Pspark-2.2\n</code></pre> </li> </ul> <ul> <li> <p>For Spark 2.4\uff1a</p> <pre><code>mvn clean package -Dmaven.test.skip=true -Dgpg.skip -Dmaven.javadoc.skip=true \\\n-pl nebula-exchange_spark_2.4 -am -Pscala-2.11 -Pspark-2.4\n</code></pre> </li> </ul> <ul> <li> <p>For Spark 3.0\uff1a</p> <pre><code>mvn clean package -Dmaven.test.skip=true -Dgpg.skip -Dmaven.javadoc.skip=true \\\n-pl nebula-exchange_spark_3.0 -am -Pscala-2.12 -Pspark-3.0\n</code></pre> </li> </ul> </li> </ol> <p>After the compilation is successful, you can find the <code>nebula-exchange_spark_x.x-release-3.8.jar</code> file in the <code>nebula-exchange_spark_x.x/target/</code> directory. <code>x.x</code> indicates the Spark version, for example, <code>2.4</code>.</p> <p>Note</p> <p>The JAR file version changes with the release of the NebulaGraph Java Client. Users can view the latest version on the Releases page.</p> <p>When migrating data, you can refer to configuration file <code>target/classes/application.conf</code>.</p>"},{"location":"import-export/nebula-exchange/ex-ug-compile/#failed_to_download_the_dependency_package","title":"Failed to download the dependency package","text":"<p>If downloading dependencies fails when compiling:</p> <ul> <li>Check the network settings and ensure that the network is normal.</li> </ul> <ul> <li> <p>Modify the <code>mirror</code> part of Maven installation directory <code>libexec/conf/settings.xml</code>:</p> <pre><code>&lt;mirror&gt;\n &lt;id&gt;alimaven&lt;/id&gt;\n &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\n &lt;name&gt;aliyun maven&lt;/name&gt;\n &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;\n&lt;/mirror&gt;\n</code></pre> </li> </ul>"},{"location":"import-export/nebula-exchange/about-exchange/ex-ug-limitations/","title":"Limitations","text":"<p>This topic describes some of the limitations of using Exchange 3.x.</p>"},{"location":"import-export/nebula-exchange/about-exchange/ex-ug-limitations/#environment","title":"Environment","text":"<p>Exchange 3.x supports the following operating systems:</p> <ul> <li>CentOS 7</li> <li>macOS</li> </ul>"},{"location":"import-export/nebula-exchange/about-exchange/ex-ug-limitations/#software_dependencies","title":"Software dependencies","text":"<p>To ensure the healthy operation of Exchange, ensure that the following software has been installed on the machine:</p> <ul> <li>Java version 1.8</li> </ul> <ul> <li>Scala version 2.10.7, 2.11.12, or 2.12.10</li> </ul> <ul> <li> <p>Apache Spark. The requirements for Spark versions when using Exchange to export data from data sources are as follows. In the following table, Y means that the corresponding Spark version is supported, and N means not supported.</p> <p>Note</p> <p>Use the correct Exchange JAR file based on the Spark version. For example, for Spark version 2.4, use nebula-exchange_spark_2.4-3.8.0.jar.</p> Data source Spark 2.2 Spark 2.4 Spark 3 CSV file Y N Y JSON file Y Y Y ORC file Y Y Y Parquet file Y Y Y HBase Y Y Y MySQL Y Y Y PostgreSQL Y Y Y Oracle Y Y Y ClickHouse Y Y Y Neo4j N Y N Hive Y Y Y MaxCompute N Y N Pulsar N Y Untested Kafka N Y Untested NebulaGraph N Y N </li> </ul> <p>Hadoop Distributed File System (HDFS) needs to be deployed in the following scenarios:</p> <ul> <li>Migrate HDFS data</li> <li>Generate SST files</li> </ul>"},{"location":"import-export/nebula-exchange/about-exchange/ex-ug-what-is-exchange/","title":"What is NebulaGraph Exchange","text":"<p>NebulaGraph Exchange (Exchange) is an Apache Spark\u2122 application for bulk migration of cluster data to NebulaGraph in a distributed environment, supporting batch and streaming data migration in a variety of formats.</p> <p>Exchange consists of Reader, Processor, and Writer. After Reader reads data from different sources and returns a DataFrame, the Processor iterates through each row of the DataFrame and obtains the corresponding value based on the mapping between <code>fields</code> in the configuration file. After iterating through the number of rows in the specified batch, Writer writes the captured data to the NebulaGraph at once. The following figure illustrates the process by which Exchange completes the data conversion and migration.</p> <p></p>"},{"location":"import-export/nebula-exchange/about-exchange/ex-ug-what-is-exchange/#editions","title":"Editions","text":"<p>Exchange has two editions, the Community Edition and the Enterprise Edition. The Community Edition is open source developed on GitHub. The Enterprise Edition supports not only the functions of the Community Edition but also adds additional features. For details, see Comparisons.</p>"},{"location":"import-export/nebula-exchange/about-exchange/ex-ug-what-is-exchange/#scenarios","title":"Scenarios","text":"<p>Exchange applies to the following scenarios:</p> <ul> <li>Streaming data from Kafka and Pulsar platforms, such as log files, online shopping data, activities of game players, information on social websites, financial transactions or geospatial services, and telemetry data from connected devices or instruments in the data center, are required to be converted into the vertex or edge data of the property graph and import them into the NebulaGraph database.</li> </ul> <ul> <li>Batch data, such as data from a time period, needs to be read from a relational database (such as MySQL) or a distributed file system (such as HDFS), converted into vertex or edge data for a property graph, and imported into the NebulaGraph database.</li> </ul> <ul> <li>A large volume of data needs to be generated into SST files that NebulaGraph can recognize and then imported into the NebulaGraph database.</li> </ul> <ul> <li> <p>The data saved in NebulaGraph needs to be exported.</p> <p>Enterpriseonly</p> <p>Exporting the data saved in NebulaGraph is supported by Exchange Enterprise Edition only.</p> </li> </ul>"},{"location":"import-export/nebula-exchange/about-exchange/ex-ug-what-is-exchange/#advantages","title":"Advantages","text":"<p>Exchange has the following advantages:</p> <ul> <li>High adaptability: It supports importing data into the NebulaGraph database in a variety of formats or from a variety of sources, making it easy to migrate data.</li> </ul> <ul> <li>SST import: It supports converting data from different sources into SST files for data import.</li> </ul> <ul> <li>SSL encryption: It supports establishing the SSL encryption between Exchange and NebulaGraph to ensure data security.</li> </ul> <ul> <li> <p>Resumable data import: It supports resumable data import to save time and improve data import efficiency.</p> <p>Note</p> <p>Resumable data import is currently supported when migrating Neo4j data only.</p> </li> </ul> <ul> <li>Asynchronous operation: An insert statement is generated in the source data and sent to the Graph service. Then the insert operation is performed.</li> </ul> <ul> <li>Great flexibility: It supports importing multiple Tags and Edge types at the same time. Different Tags and Edge types can be from different data sources or in different formats.</li> </ul> <ul> <li>Statistics: It uses the accumulator in Apache Spark\u2122 to count the number of successful and failed insert operations.</li> </ul> <ul> <li>Easy to use: It adopts the Human-Optimized Config Object Notation (HOCON) configuration file format and has an object-oriented style, which is easy to understand and operate.</li> </ul>"},{"location":"import-export/nebula-exchange/about-exchange/ex-ug-what-is-exchange/#version_compatibility","title":"Version compatibility","text":"<p>Exchange supports Spark versions 2.2.x, 2.4.x, and 3.x.x, which are named <code>nebula-exchange_spark_2.2</code>, <code>nebula-exchange_spark_2.4</code>, and <code>nebula-exchange_spark_3.0</code> for different Spark versions.</p> <p>The correspondence between the NebulaGraph Exchange version (the JAR version), the NebulaGraph core version and the Spark version is as follows.</p> Exchange version NebulaGraph version Spark version nebula-exchange_spark_3.0-3.0-SNAPSHOT.jar nightly 3.3.x\u30013.2.x\u30013.1.x\u30013.0.x nebula-exchange_spark_2.4-3.0-SNAPSHOT.jar nightly 2.4.x nebula-exchange_spark_2.2-3.0-SNAPSHOT.jar nightly 2.2.x nebula-exchange_spark_3.0-3.4.0.jar 3.x.x 3.3.x\u30013.2.x\u30013.1.x\u30013.0.x nebula-exchange_spark_2.4-3.4.0.jar 3.x.x 2.4.x nebula-exchange_spark_2.2-3.4.0.jar 3.x.x 2.2.x nebula-exchange_spark_3.0-3.3.0.jar 3.x.x 3.3.x\u30013.2.x\u30013.1.x\u30013.0.x nebula-exchange_spark_2.4-3.3.0.jar 3.x.x 2.4.x nebula-exchange_spark_2.2-3.3.0.jar 3.x.x 2.2.x nebula-exchange_spark_3.0-3.0.0.jar 3.x.x 3.3.x\u30013.2.x\u30013.1.x\u30013.0.x nebula-exchange_spark_2.4-3.0.0.jar 3.x.x 2.4.x nebula-exchange_spark_2.2-3.0.0.jar 3.x.x 2.2.x nebula-exchange-2.6.3.jar 2.6.1\u30012.6.0 2.4.x nebula-exchange-2.6.2.jar 2.6.1\u30012.6.0 2.4.x nebula-exchange-2.6.1.jar 2.6.1\u30012.6.0 2.4.x nebula-exchange-2.6.0.jar 2.6.1\u30012.6.0 2.4.x nebula-exchange-2.5.2.jar 2.5.1\u30012.5.0 2.4.x nebula-exchange-2.5.1.jar 2.5.1\u30012.5.0 2.4.x nebula-exchange-2.5.0.jar 2.5.1\u30012.5.0 2.4.x nebula-exchange-2.1.0.jar 2.0.1\u30012.0.0 2.4.x nebula-exchange-2.0.1.jar 2.0.1\u30012.0.0 2.4.x nebula-exchange-2.0.0.jar 2.0.1\u30012.0.0 2.4.x"},{"location":"import-export/nebula-exchange/about-exchange/ex-ug-what-is-exchange/#data_source","title":"Data source","text":"<p>Exchange 3.8.0 supports converting data from the following formats or sources into vertexes and edges that NebulaGraph can recognize, and then importing them into NebulaGraph in the form of nGQL statements:</p> <ul> <li>Data stored in HDFS or locally:<ul> <li>Apache Parquet</li> <li>Apache ORC</li> <li>JSON</li> <li>CSV</li> </ul> </li> </ul> <ul> <li>Apache HBase\u2122</li> </ul> <ul> <li> <p>Data repository:</p> <ul> <li>Hive</li> <li>MaxCompute</li> </ul> </li> </ul> <ul> <li>Graph database: Neo4j (Client version 2.4.5-M1)</li> </ul> <ul> <li>Relational database:<ul> <li>MySQL</li> <li>PostgreSQL</li> <li>Oracle</li> </ul> </li> </ul> <ul> <li>Column database: ClickHouse</li> </ul> <ul> <li>Stream processing software platform: Apache Kafka\u00ae</li> </ul> <ul> <li>Publish/Subscribe messaging platform: Apache Pulsar 2.4.5</li> </ul> <ul> <li>JDBC</li> </ul> <p>In addition to importing data as nGQL statements, Exchange supports generating SST files for data sources and then importing SST files via Console.</p>"},{"location":"import-export/nebula-exchange/about-exchange/ex-ug-what-is-exchange/#release_note","title":"Release note","text":"<p>Release</p>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-para-import-command/","title":"Options for import","text":"<p>After editing the configuration file, run the following commands to import specified source data into the NebulaGraph database.</p>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-para-import-command/#import_data","title":"Import data","text":"<pre><code>&lt;spark_install_path&gt;/bin/spark-submit --master \"spark://HOST:PORT\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange-2.x.y.jar_path&gt; -c &lt;application.conf_path&gt; \n</code></pre> <p>Note</p> <p>If the value of the properties contains Chinese characters, the encoding error may appear. Please add the following options when submitting the Spark task:</p> <pre><code>--conf spark.driver.extraJavaOptions=-Dfile.encoding=utf-8\n--conf spark.executor.extraJavaOptions=-Dfile.encoding=utf-8\n</code></pre> <p>The following table lists command parameters.</p> Parameter Required Default value Description <code>--class</code> Yes - Specify the main class of the driver. <code>--master</code> Yes - Specify the URL of the master process in a Spark cluster. For more information, see master-urls. Optional values are:<code>local</code>: Local Mode. Run Spark applications on a single thread. Suitable for importing small data sets in a test environment.<code>yarn</code>: Run Spark applications on a YARN cluster. Suitable for importing large data sets in a production environment.<code>spark://HOST:PORT</code>: Connect to the specified Spark standalone cluster.<code>mesos://HOST:PORT</code>: Connect to the specified Mesos cluster.<code>k8s://HOST:PORT</code>: Connect to the specified Kubernetes cluster. <code>-c</code>/<code>--config</code> Yes - Specify the path of the configuration file. <code>-h</code>/<code>--hive</code> No <code>false</code> Specify whether importing Hive data is supported. <code>-D</code>/<code>--dry</code> No <code>false</code> Specify whether to check the format of the configuration file. This parameter is used to check the format of the configuration file only, it does not check the validity of <code>tags</code> and <code>edges</code> configurations and does not import data. Don't add this parameter if you need to import data. <code>-r</code>/<code>--reload</code> No - Specify the path of the reload file that needs to be reloaded. <p>For more Spark parameter configurations, see Spark Configuration.</p> <p>Note</p> <ul> <li>The version number of a JAR file is subject to the name of the JAR file that is actually compiled.</li> </ul> <ul> <li>If users use the yarn mode to submit a job, see the following command, especially the two '--conf' commands in the example.</li> </ul> <pre><code>$SPARK_HOME/bin/spark-submit     --master yarn \\\n--class com.vesoft.nebula.exchange.Exchange \\\n--files application.conf \\\n--conf spark.driver.extraClassPath=./ \\\n--conf spark.executor.extraClassPath=./ \\\nnebula-exchange-3.8.0.jar \\\n-c application.conf\n</code></pre>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-para-import-command/#import_the_reload_file","title":"Import the reload file","text":"<p>If some data fails to be imported during the import, the failed data will be stored in the reload file. Use the parameter <code>-r</code> to import the data in reload file.</p> <pre><code>&lt;spark_install_path&gt;/bin/spark-submit --master \"spark://HOST:PORT\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange-2.x.y.jar_path&gt; -c &lt;application.conf_path&gt; -r \"&lt;reload_file_path&gt;\" \n</code></pre> <p>If the import still fails, go to Official Forum for consultation.</p>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/","title":"Parameters in the configuration file","text":"<p>This topic describes how to automatically generate a template configuration file when users use NebulaGraph Exchange, and introduces the configuration file <code>application.conf</code>.</p>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#generate_template_configuration_file_automatically","title":"Generate template configuration file automatically","text":"<p>Specify the data source to be imported with the following command to get the template configuration file corresponding to the data source.</p> <pre><code>java -cp &lt;exchange_jar_package&gt; com.vesoft.exchange.common.GenerateConfigTemplate -s &lt;source_type&gt; -p &lt;config_file_save_path&gt;\n</code></pre> <p>Example:</p> <pre><code>java -cp nebula-exchange_spark_2.4-3.0-SNAPSHOT.jar com.vesoft.exchange.common.GenerateConfigTemplate -s csv -p /home/nebula/csv_application.conf\n</code></pre>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#using_an_encrypted_password","title":"Using an encrypted password","text":"<p>You can use either a plaintext password or an RSA encrypted password when setting the password for connecting to NebulaGraph in the configuration file.</p> <p>To use an RSA-encrypted password, you need to configure the following settings in the configuration file:</p> <ul> <li><code>nebula.pswd</code> is configured as the RSA encrypted password.</li> <li><code>nebula.privateKey</code> is configured as the key for RSA encryption.</li> <li><code>nebula.enableRSA</code> is configured as <code>true</code>.</li> </ul> <p>Users can use their own tools for encryption, or they can use the encryption tool provided in Exchange's JAR package, for example:</p> <pre><code>spark-submit --master local --class com.vesoft.exchange.common.PasswordEncryption nebula-exchange_spark_2.4-3.0-SNAPSHOT.jar -p nebula\n</code></pre> <p>The results returned are as follows:</p> <pre><code>=================== public key begin ===================\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCLl7LaNSEXlZo2hYiJqzxgyFBQdkxbQXYU/xQthsBJwjOPhkiY37nokzKnjNlp6mv5ZUomqxLsoNQHEJ6BZD4VPiaiElFAkTD+gyul1v8f3A446Fr2rnVLogWHnz8ECPt7X8jwmpiKOXkOPIhqU5E0Cua+Kk0nnVosbos/VShfiQIDAQAB\n=================== public key end ===================\n\n\n=================== private key begin ===================\nMIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAIuXsto1IReVmjaFiImrPGDIUFB2TFtBdhT/FC2GwEnCM4+GSJjfueiTMqeM2Wnqa/llSiarEuyg1AcQnoFkPhU+JqISUUCRMP6DK6XW/x/cDjjoWvaudUuiBYefPwQI+3tfyPCamIo5eQ48iGpTkTQK5r4qTSedWixuiz9VKF+JAgMBAAECgYADWbfEPwQ1UbTq3Bej3kVLuWMcG0rH4fFYnaq5UQOqgYvFRR7W9H+80lOj6+CIB0ViLgkylmaU4WNVbBOx3VsUFFWSqIIIviKubg8m8ey7KAd9X2wMEcUHi4JyS2+/WSacaXYS5LOmMevvuaOwLEV0QmyM+nNGRIjUdzCLR1935QJBAM+IF8YD5GnoAPPjGIDS1Ljhu/u/Gj6/YBCQKSHQ5+HxHEKjQ/YxQZ/otchmMZanYelf1y+byuJX3NZ04/KSGT8CQQCsMaoFO2rF5M84HpAXPi6yH2chbtz0VTKZworwUnpmMVbNUojf4VwzAyOhT1U5o0PpFbpi+NqQhC63VUN5k003AkEArI8vnVGNMlZbvG7e5/bmM9hWs2viSbxdB0inOtv2g1M1OV+B2gp405ru0/PNVcRV0HQFfCuhVfTSxmspQoAihwJBAJW6EZa/FZbB4JVxreUoAr6Lo8dkeOhT9M3SZbGWZivaFxot/Cp/8QXCYwbuzrJxjqlsZUeOD6694Uk08JkURn0CQQC8V6aRa8ylMhLJFkGkMDHLqHcQCmY53Kd73mUu4+mjMJLZh14zQD9ydFtc0lbLXTeBAMWV3uEdeLhRvdAo3OwV\n=================== private key end ===================\n\n\n=================== encrypted  password begin ===================\nIo+3y3mLOMnZJJNUPHZ8pKb4VfTvg6wUh6jSu5xdmLAoX/59tK1HTwoN40aOOWJwa1a5io7S4JqcX/jEcAorw7pelITr+F4oB0AMCt71d+gJuu3/lw9bjUEl9tF4Raj82y2Dg39wYbagN84fZMgCD63TPiDIevSr6+MFKASpGrY=\n=================== encrypted  password end ===================\ncheck: the real password decrypted by private key and encrypted password is: nebula\n</code></pre>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#configuration_instructions","title":"Configuration instructions","text":"<p>Before configuring the <code>application.conf</code> file, it is recommended to copy the file name <code>application.conf</code> and then edit the file name according to the file type of a data source. For example, change the file name to <code>csv_application.conf</code> if the file type of the data source is CSV.</p> <p>The <code>application.conf</code> file contains the following content types:</p> <ul> <li>Spark configurations</li> </ul> <ul> <li>Hive configurations (optional)</li> </ul> <ul> <li>NebulaGraph configurations</li> </ul> <ul> <li>Vertex configurations</li> </ul> <ul> <li>Edge configurations</li> </ul>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#spark_configurations","title":"Spark configurations","text":"<p>This topic lists only some Spark parameters. For more information, see Spark Configuration.</p> Parameter Type Default value Required Description <code>spark.app.name</code> string - No The drive name in Spark. <code>spark.driver.cores</code> int <code>1</code> No The number of CPU cores used by a driver, only applicable to a cluster mode. <code>spark.driver.maxResultSize</code> string <code>1G</code> No The total size limit (in bytes) of the serialized results of all partitions in a single Spark operation (such as collect). The minimum value is 1M, and 0 means unlimited. <code>spark.executor.memory</code> string <code>1G</code> No The amount of memory used by a Spark driver which can be specified in units, such as 512M or 1G. <code>spark.cores.max</code> int <code>16</code> No The maximum number of CPU cores of applications requested across clusters (rather than from each node) when a driver runs in a coarse-grained sharing mode on a standalone cluster or a Mesos cluster. The default value is <code>spark.deploy.defaultCores</code> on a Spark standalone cluster manager or the value of the <code>infinite</code> parameter (all available cores) on Mesos."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#hive_configurations_optional","title":"Hive configurations (optional)","text":"<p>Users only need to configure parameters for connecting to Hive if Spark and Hive are deployed in different clusters. Otherwise, please ignore the following configurations.</p> Parameter Type Default value Required Description <code>hive.warehouse</code> string - Yes The warehouse path in HDFS. Enclose the path in double quotes and start with <code>hdfs://</code>. <code>hive.connectionURL</code> string - Yes The URL of a JDBC connection. For example, <code>\"jdbc:mysql://127.0.0.1:3306/hive_spark?characterEncoding=UTF-8\"</code>. <code>hive.connectionDriverName</code> string <code>\"com.mysql.jdbc.Driver\"</code> Yes The driver name. <code>hive.connectionUserName</code> list[string] - Yes The username for connections. <code>hive.connectionPassword</code> list[string] - Yes The account password."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#nebulagraph_configurations","title":"NebulaGraph configurations","text":"Parameter Type Default value Required Description <code>nebula.address.graph</code> list[string] <code>[\"127.0.0.1:9669\"]</code> Yes The addresses of all Graph services, including IPs and ports, separated by commas (,). Example: <code>[\"ip1:port1\",\"ip2:port2\",\"ip3:port3\"]</code>. <code>nebula.address.meta</code> list[string] <code>[\"127.0.0.1:9559\"]</code> Yes The addresses of all Meta services, including IPs and ports, separated by commas (,). Example: <code>[\"ip1:port1\",\"ip2:port2\",\"ip3:port3\"]</code>. <code>nebula.user</code> string - Yes The username with write permissions for NebulaGraph. <code>nebula.pswd</code> string - Yes The account password. The password can be plaintext or RSA encrypted. To use an RSA encrypted password, you need to set <code>enableRSA</code> and <code>privateKey</code>. For how to encrypt a password, see Using an encrypted password above. <code>nebula.enableRSA</code> bool <code>false</code> No Whether to use an RSA encrypted password. <code>nebula.privateKey</code> string - No The key used to encrypt the password using RSA. <code>nebula.space</code> string - Yes The name of the graph space where data needs to be imported. <code>nebula.ssl.enable.graph</code> bool <code>false</code> Yes Enables the SSL encryption between Exchange and Graph services. If the value is <code>true</code>, the SSL encryption is enabled and the following SSL parameters take effect. If Exchange is run on a multi-machine cluster, you need to store the corresponding files in the same path on each machine when setting the following SSL-related paths. <code>nebula.ssl.sign</code> string <code>ca</code> Yes Specifies the SSL sign. Optional values are <code>ca</code> and <code>self</code>. <code>nebula.ssl.ca.param.caCrtFilePath</code> string Specifies the storage path of the CA certificate. It takes effect when the value of <code>nebula.ssl.sign</code> is <code>ca</code>. <code>nebula.ssl.ca.param.crtFilePath</code> string <code>\"/path/crtFilePath\"</code> Yes Specifies the storage path of the CRT certificate. It takes effect when the value of <code>nebula.ssl.sign</code> is <code>ca</code>. <code>nebula.ssl.ca.param.keyFilePath</code> string <code>\"/path/keyFilePath\"</code> Yes Specifies the storage path of the key file. It takes effect when the value of <code>nebula.ssl.sign</code> is <code>ca</code>. <code>nebula.ssl.self.param.crtFilePath</code> string <code>\"/path/crtFilePath\"</code> Yes Specifies the storage path of the CRT certificate. It takes effect when the value of <code>nebula.ssl.sign</code> is <code>self</code>. <code>nebula.ssl.self.param.keyFilePath</code> string <code>\"/path/keyFilePath\"</code> Yes Specifies the storage path of the key file. It takes effect when the value of <code>nebula.ssl.sign</code> is <code>self</code>. <code>nebula.ssl.self.param.password</code> string <code>\"nebula\"</code> Yes Specifies the storage path of the password. It takes effect when the value of <code>nebula.ssl.sign</code> is <code>self</code>. <code>nebula.path.local</code> string <code>\"/tmp\"</code> No The local SST file path which needs to be set when users import SST files. <code>nebula.path.remote</code> string <code>\"/sst\"</code> No The remote SST file path which needs to be set when users import SST files. <code>nebula.path.hdfs.namenode</code> string <code>\"hdfs://name_node:9000\"</code> No The NameNode path which needs to be set when users import SST files. <code>nebula.connection.timeout</code> int <code>3000</code> No The timeout set for Thrift connections. Unit: ms. <code>nebula.connection.retry</code> int <code>3</code> No Retries set for Thrift connections. <code>nebula.execution.retry</code> int <code>3</code> No Retries set for executing nGQL statements. <code>nebula.error.max</code> int <code>32</code> No The maximum number of failures during the import process. When the number of failures reaches the maximum, the Spark job submitted will stop automatically . <code>nebula.error.output</code> string <code>/tmp/errors</code> No The path to output error logs. Failed nGQL statement executions are saved in the error log. <code>nebula.rate.limit</code> int <code>1024</code> No The limit on the number of tokens in the token bucket when importing data. <code>nebula.rate.timeout</code> int <code>1000</code> No The timeout period for getting tokens from a token bucket. Unit: milliseconds. <p>Note</p> <p>NebulaGraph doesn't support vertices without tags by default. To import vertices without tags, enable vertices without tags in the NebulaGraph cluster and then add parameter <code>nebula.enableTagless</code> to the Exchange configuration with the value <code>true</code>. For example:</p> <pre><code>nebula: {\n    address:{\n      graph:[\"127.0.0.1:9669\"]\n      meta:[\"127.0.0.1:9559\"]\n    }\n    user: root\n    pswd: nebula\n    space: test\n    enableTagless: true\n    ......\n\n }\n</code></pre>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#vertex_configurations","title":"Vertex configurations","text":"<p>For different data sources, the vertex configurations are different. There are many general parameters and some specific parameters. General parameters and specific parameters of different data sources need to be configured when users configure vertices.</p>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#general_parameters","title":"General parameters","text":"Parameter Type Default value Required Description <code>tags.name</code> string - Yes The tag name defined in NebulaGraph. <code>tags.type.source</code> string - Yes Specify a data source. For example, <code>csv</code>. <code>tags.type.sink</code> string <code>client</code> Yes Specify an import method. Optional values are <code>client</code> and <code>SST</code>. <code>tags.writeMode</code> string <code>INSERT</code> No Types of batch operations on data, including batch inserts, updates, and deletes. Optional values are <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>. <code>tags.deleteEdge</code> string <code>false</code> No Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when <code>tags.writeMode</code> is <code>DELETE</code>. <code>tags.fields</code> list[string] - Yes The header or column name of the column corresponding to properties. If there is a header or a column name, please use that name directly. If a CSV file does not have a header, use the form of <code>[_c0, _c1, _c2]</code> to represent the first column, the second column, the third column, and so on. <code>tags.nebula.fields</code> list[string] - Yes Property names defined in NebulaGraph, the order of which must correspond to <code>tags.fields</code>. For example, <code>[_c1, _c2]</code> corresponds to <code>[name, age]</code>, which means that values in the second column are the values of the property <code>name</code>, and values in the third column are the values of the property <code>age</code>. <code>tags.vertex.field</code> string - Yes The column of vertex IDs. For example, when a CSV file has no header, users can use <code>_c0</code> to indicate values in the first column are vertex IDs. <code>tags.vertex.udf.separator</code> string - No Support merging multiple columns by custom rules. This parameter specifies the join character. <code>tags.vertex.udf.oldColNames</code> list - No Support merging multiple columns by custom rules. This parameter specifies the names of the columns to be merged. Multiple columns are separated by commas. <code>tags.vertex.udf.newColName</code> string - No Support merging multiple columns by custom rules. This parameter specifies the new column name. <code>tags.vertex.prefix</code> string - No Add the specified prefix to the VID. For example, if the VID is <code>12345</code>, adding the prefix <code>tag1</code> will result in <code>tag1_12345</code>. The underscore cannot be modified. <code>tags.vertex.policy</code> string - No Supports only the value <code>hash</code>. Performs hashing operations on VIDs of type string. <code>tags.batch</code> int <code>256</code> Yes The maximum number of vertices written into NebulaGraph in a single batch. <code>tags.partition</code> int <code>32</code> Yes The number of partitions to be created when the data is written to NebulaGraph. If <code>tags.partition \u2264 1</code>, the number of partitions to be created in NebulaGraph is the same as that in the data source. <code>tags.filter</code> string - No The filtering rule. The data that matches the filter rule is imported into NebulaGraph. For information about filtering formats, see Dataset."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_parquetjsonorc_data_sources","title":"Specific parameters of Parquet/JSON/ORC data sources","text":"Parameter Type Default value Required Description <code>tags.path</code> string - Yes The path of vertex data files in HDFS. Enclose the path in double quotes and start with <code>hdfs://</code>."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_csv_data_sources","title":"Specific parameters of CSV data sources","text":"Parameter Type Default value Required Description <code>tags.path</code> string - Yes The path of vertex data files in HDFS. Enclose the path in double quotes and start with <code>hdfs://</code>. <code>tags.separator</code> string <code>,</code> Yes The separator. The default value is a comma (,). For special characters, such as the control character <code>^A</code>, you can use ASCII octal <code>\\001</code> or UNICODE encoded hexadecimal <code>\\u0001</code>, for the control character <code>^B</code>, use ASCII octal <code>\\002</code> or UNICODE encoded hexadecimal <code>\\u0002</code>, for the control character <code>^C</code>, use ASCII octal <code>\\003</code> or UNICODE encoded hexadecimal <code>\\u0003</code>. <code>tags.header</code> bool <code>true</code> Yes Whether the file has a header."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_hive_data_sources","title":"Specific parameters of Hive data sources","text":"Parameter Type Default value Required Description <code>tags.exec</code> string - Yes The statement to query data sources. For example, <code>select name,age from mooc.users</code>."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_maxcompute_data_sources","title":"Specific parameters of MaxCompute data sources","text":"Parameter Type Default value Required Description <code>tags.table</code> string - Yes The table name of the MaxCompute. <code>tags.project</code> string - Yes The project name of the MaxCompute. <code>tags.odpsUrl</code> string - Yes The odpsUrl of the MaxCompute service. For more information about odpsUrl, see Endpoints. <code>tags.tunnelUrl</code> string - Yes The tunnelUrl of the MaxCompute service. For more information about tunnelUrl, see Endpoints. <code>tags.accessKeyId</code> string - Yes The accessKeyId of the MaxCompute service. <code>tags.accessKeySecret</code> string - Yes The accessKeySecret of the MaxCompute service. <code>tags.partitionSpec</code> string - No Partition descriptions of MaxCompute tables. <code>tags.sentence</code> string - No Statements to query data sources. The table name in the SQL statement is the same as the value of the table above."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_neo4j_data_sources","title":"Specific parameters of Neo4j data sources","text":"Parameter Type Default value Required Description <code>tags.exec</code> string - Yes Statements to query data sources. For example: <code>match (n:label) return n.neo4j-field-0</code>. <code>tags.server</code> string <code>\"bolt://127.0.0.1:7687\"</code> Yes The server address of Neo4j. <code>tags.user</code> string - Yes The Neo4j username with read permissions. <code>tags.password</code> string - Yes The account password. <code>tags.database</code> string - Yes The name of the database where source data is saved in Neo4j. <code>tags.check_point_path</code> string <code>/tmp/test</code> No The directory set to import progress information, which is used for resuming transfers. If not set, the resuming transfer is disabled."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_mysqlpostgresql_data_sources","title":"Specific parameters of MySQL/PostgreSQL data sources","text":"Parameter Type Default value Required Description <code>tags.host</code> string - Yes The MySQL/PostgreSQL server address. <code>tags.port</code> string - Yes The MySQL/PostgreSQL server port. <code>tags.database</code> string - Yes The database name. <code>tags.table</code> string - Yes The name of a table used as a data source. <code>tags.user</code> string - Yes The MySQL/PostgreSQL username with read permissions. <code>tags.password</code> string - Yes The account password. <code>tags.sentence</code> string - Yes Statements to query data sources. For example: <code>\"select teamid, name from team order by teamid\"</code>."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_oracle_data_sources","title":"Specific parameters of Oracle data sources","text":"Parameter Type Default value Required Description <code>tags.url</code> string - Yes The Oracle server address. <code>tags.driver</code> string - Yes The Oracle driver address. <code>tags.user</code> string - Yes The Oracle username with read permissions. <code>tags.password</code> string - Yes The account password. <code>tags.table</code> string - Yes The name of a table used as a data source. <code>tags.sentence</code> string - Yes Statements to query data sources. For example: <code>\"select playerid, name, age from player\"</code>."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_clickhouse_data_sources","title":"Specific parameters of ClickHouse data sources","text":"Parameter Type Default value Required Description <code>tags.url</code> string - Yes The JDBC URL of ClickHouse. <code>tags.user</code> string - Yes The ClickHouse username with read permissions. <code>tags.password</code> string - Yes The account password. <code>tags.numPartition</code> string - Yes The number of ClickHouse partitions. <code>tags.sentence</code> string - Yes Statements to query data sources."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_hbase_data_sources","title":"Specific parameters of Hbase data sources","text":"Parameter Type Default value Required Description <code>tags.host</code> string <code>127.0.0.1</code> Yes The Hbase server address. <code>tags.port</code> string <code>2181</code> Yes The Hbase server port. <code>tags.table</code> string - Yes The name of a table used as a data source. <code>tags.columnFamily</code> string - Yes The column family to which a table belongs."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_pulsar_data_sources","title":"Specific parameters of Pulsar data sources","text":"Parameter Type Default value Required Description <code>tags.service</code> string <code>\"pulsar://localhost:6650\"</code> Yes The Pulsar server address. <code>tags.admin</code> string <code>\"http://localhost:8081\"</code> Yes The admin URL used to connect pulsar. <code>tags.options.&lt;topic|topics| topicsPattern&gt;</code> string - Yes Options offered by Pulsar, which can be configured by choosing one from <code>topic</code>, <code>topics</code>, and <code>topicsPattern</code>. <code>tags.interval.seconds</code> int <code>10</code> Yes The interval for reading messages. Unit: seconds."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_of_kafka_data_sources","title":"Specific parameters of Kafka data sources","text":"Parameter Type Default value Required Description <code>tags.service</code> string - Yes The Kafka server address. <code>tags.topic</code> string - Yes The message type. <code>tags.interval.seconds</code> int <code>10</code> Yes The interval for reading messages. Unit: seconds. <code>tags.securityProtocol</code> string - No Kafka security protocol. <code>tags.mechanism</code> string - No The security certification mechanism provided by SASL of Kafka. <code>tags.kerberos</code> bool <code>false</code> No Whether to enable Kerberos for security certification. If <code>tags.mechanism</code> is <code>kerberos</code>, this parameter must be set to <code>true</code>. <code>tags.kerberosServiceName</code> string - No Kerberos service name. If <code>tags.kerberos</code> is <code>true</code>, this parameter must be set."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_for_generating_sst_files","title":"Specific parameters for generating SST files","text":"Parameter Type Default value Required Description <code>tags.path</code> string - Yes The path of the source file specified to generate SST files. <code>tags.repartitionWithNebula</code> bool <code>true</code> No Whether to repartition data based on the number of partitions of graph spaces in NebulaGraph when generating the SST file. Enabling this function can reduce the time required to DOWNLOAD and INGEST SST files."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#edge_configurations","title":"Edge configurations","text":"<p>For different data sources, configurations of edges are also different. There are general parameters and some specific parameters. General parameters and specific parameters of different data sources need to be configured when users configure edges.</p> <p>For the specific parameters of different data sources for edge configurations, please refer to the introduction of specific parameters of different data sources above, and pay attention to distinguishing tags and edges.</p>"},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#general_parameters_1","title":"General parameters","text":"Parameter Type Default value Required Description <code>edges.name</code> string - Yes The edge type name defined in NebulaGraph. <code>edges.type.source</code> string - Yes The data source of edges. For example, <code>csv</code>. <code>edges.type.sink</code> string <code>client</code> Yes The method specified to import data. Optional values are <code>client</code> and <code>SST</code>. <code>edges.writeMode</code> string <code>INSERT</code> No Types of batch operations on data, including batch inserts, updates, and deletes. Optional values are <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>. <code>edges.fields</code> list[string] - Yes The header or column name of the column corresponding to properties. If there is a header or column name, please use that name directly. If a CSV file does not have a header, use the form of <code>[_c0, _c1, _c2]</code> to represent the first column, the second column, the third column, and so on. <code>edges.nebula.fields</code> list[string] - Yes Edge names defined in NebulaGraph, the order of which must correspond to <code>edges.fields</code>. For example, <code>[_c2, _c3]</code> corresponds to <code>[start_year, end_year]</code>, which means that values in the third column are the values of the start year, and values in the fourth column are the values of the end year. <code>edges.source.field</code> string - Yes The column of source vertices of edges. For example, <code>_c0</code> indicates a value in the first column that is used as the source vertex of an edge. <code>edges.source.prefix</code> string - No Add the specified prefix to the VID. For example, if the VID is <code>12345</code>, adding the prefix <code>tag1</code> will result in <code>tag1_12345</code>. The underscore cannot be modified. <code>edges.source.policy</code> string - No Supports only the value <code>hash</code>. Performs hashing operations on VIDs of type string. <code>edges.target.field</code> string - Yes The column of destination vertices of edges. For example, <code>_c0</code> indicates a value in the first column that is used as the destination vertex of an edge. <code>edges.target.prefix</code> string - No Add the specified prefix to the VID. For example, if the VID is <code>12345</code>, adding the prefix <code>tag1</code> will result in <code>tag1_12345</code>. The underscore cannot be modified. <code>edges.target.policy</code> string - No Supports only the value <code>hash</code>. Performs hashing operations on VIDs of type string. <code>edges.ranking</code> int - No The column of rank values. If not specified, all rank values are <code>0</code> by default. <code>edges.batch</code> int <code>256</code> Yes The maximum number of edges written into NebulaGraph in a single batch. <code>edges.partition</code> int <code>32</code> Yes The number of partitions to be created when the data is written to NebulaGraph. If <code>edges.partition \u2264 1</code>, the number of partitions to be created in NebulaGraph is the same as that in the data source. <code>edges.filter</code> string - No The filtering rule. The data that matches the filter rule is imported into NebulaGraph. For information about filtering formats, see Dataset."},{"location":"import-export/nebula-exchange/parameter-reference/ex-ug-parameter/#specific_parameters_for_generating_sst_files_1","title":"Specific parameters for generating SST files","text":"Parameter Type Default value Required Description <code>edges.path</code> string - Yes The path of the source file specified to generate SST files. <code>edges.repartitionWithNebula</code> bool <code>true</code> No Whether to repartition data based on the number of partitions of graph spaces in NebulaGraph when generating the SST file. Enabling this function can reduce the time required to DOWNLOAD and INGEST SST files."},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-clickhouse/","title":"Import data from ClickHouse","text":"<p>This topic provides an example of how to use Exchange to import data stored on ClickHouse into NebulaGraph.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-clickhouse/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-clickhouse/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>ClickHouse: docker deployment yandex/clickhouse-server tag: latest(2021.07.01)</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-clickhouse/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-clickhouse/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-clickhouse/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-clickhouse/#step_2_modify_configuration_files","title":"Step 2: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set ClickHouse data source configuration. In this example, the copied file is called <code>clickhouse_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    cores: {\n      max: 16\n    }\n  }\n\n# NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n      name: player\n      type: {\n        # Specify the data source file format to ClickHouse.\n        source: clickhouse\n        # Specify how to import the data of vertexes into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # JDBC URL of ClickHouse\n      url:\"jdbc:clickhouse://192.168.*.*:8123/basketballplayer\"\n\n      user:\"user\"\n      password:\"123456\"\n\n      # The number of ClickHouse partitions\n      numPartition:\"5\"\n\n      sentence:\"select * from player\"\n\n      # Specify the column names in the player table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [name,age]\n      nebula.fields: [name,age]\n\n      # Specify a column of data in the table as the source of vertex VID in the NebulaGraph.\n      vertex: {\n        field:playerid\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Tag Team.\n    {\n      name: team\n      type: {\n        source: clickhouse\n        sink: client\n      }\n      url:\"jdbc:clickhouse://192.168.*.*:8123/basketballplayer\"\n      user:\"user\"\n      password:\"123456\"\n      numPartition:\"5\"\n      sentence:\"select * from team\"\n      fields: [name]\n      nebula.fields: [name]\n      vertex: {\n        field:teamid\n      }\n      batch: 256\n      partition: 32\n    }\n  ]\n\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # The corresponding Edge Type name in NebulaGraph.\n      name: follow\n\n      type: {\n        # Specify the data source file format to ClickHouse.\n        source: clickhouse\n\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # JDBC URL of ClickHouse\n      url:\"jdbc:clickhouse://192.168.*.*:8123/basketballplayer\"\n\n      user:\"user\"\n      password:\"123456\"\n\n      # The number of ClickHouse partitions.\n      numPartition:\"5\"\n\n      sentence:\"select * from follow\"\n\n      # Specify the column names in the follow table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [degree]\n      nebula.fields: [degree]\n\n      # In source, use a column in the follow table as the source of the edge's source vertexes.\n      source: {\n        field:src_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # In target, use a column in the follow table as the source of the edge's destination vertexes.\n      target: {\n        field:dst_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Edge Type serve.\n    {\n      name: serve\n      type: {\n        source: clickhouse\n        sink: client\n      }\n      url:\"jdbc:clickhouse://192.168.*.*:8123/basketballplayer\"\n      user:\"user\"\n      password:\"123456\"\n      numPartition:\"5\"\n      sentence:\"select * from serve\"\n      fields: [start_year,end_year]\n      nebula.fields: [start_year,end_year]\n      source: {\n        field:playerid\n      }\n      target: {\n        field:teamid\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      batch: 256\n      partition: 32\n    }\n  ]\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-clickhouse/#step_3_import_data_into_nebulagraph","title":"Step 3: Import data into NebulaGraph","text":"<p>Run the following command to import ClickHouse data into NebulaGraph. For descriptions of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;clickhouse_application.conf_path&gt;\n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/clickhouse_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-clickhouse/#step_4_optional_validate_data","title":"Step 4: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the SHOW STATS command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-clickhouse/#step_5_optional_rebuild_indexes_in_nebulagraph","title":"Step 5: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/","title":"Import data from CSV files","text":"<p>This topic provides an example of how to use Exchange to import NebulaGraph data stored in HDFS or local CSV files.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>Hadoop: 2.9.2, pseudo-distributed deployment</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul> <ul> <li>If files are stored in HDFS, ensure that the Hadoop service is running normally.</li> </ul> <ul> <li>If files are stored locally and NebulaGraph is a cluster architecture, you need to place the files in the same directory locally on each machine in the cluster.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#step_2_process_csv_files","title":"Step 2: Process CSV files","text":"<p>Confirm the following information:</p> <ol> <li> <p>Process CSV files to meet Schema requirements.</p> <p>Note</p> <p>Exchange supports uploading CSV files with or without headers.</p> </li> <li> <p>Obtain the CSV file storage path.</p> </li> </ol>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#step_3_modify_configuration_files","title":"Step 3: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set CSV data source configuration. In this example, the copied file is called <code>csv_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    executor: {\n        memory:1G\n    }\n\n    cores: {\n      max: 16\n    }\n  }\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n      # Specify the Tag name defined in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to CSV.\n        source: csv\n\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Specify the path to the CSV file.\n      # If the file is stored in HDFS, use double quotation marks to enclose the file path, starting with hdfs://. For example: \"hdfs://ip:port/xx/xx\".\n      # If the file is stored locally, use double quotation marks to enclose the file path, starting with file://. For example: \"file:///tmp/xx.csv\".\n      path: \"hdfs://192.168.*.*:9000/data/vertex_player.csv\"\n\n      # If the CSV file does not have a header, use [_c0, _c1, _c2, ..., _cn] to represent its header and indicate the columns as the source of the property values.\n      # If the CSV file has headers, use the actual column names.\n      fields: [_c1, _c2]\n\n      # Specify the column names in the player table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      nebula.fields: [age, name]\n\n      # Specify a column of data in the table as the source of vertex VID in the NebulaGraph.\n      # The value of vertex must be the same as the column names in the above fields or csv.fields.\n      # Currently, NebulaGraph 3.8.0 supports only strings or integers of VID.\n      vertex: {\n        field:_c0\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The delimiter specified. The default value is comma.\n      separator: \",\"\n\n      # If the CSV file has a header, set the header to true.\n      # If the CSV file does not have a header, set the header to false. The default value is false.\n      header: false\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Tag Team.\n    {\n      name: team\n      type: {\n        source: csv\n        sink: client\n      }\n      path: \"hdfs://192.168.*.*:9000/data/vertex_team.csv\"\n      fields: [_c1]\n      nebula.fields: [name]\n      vertex: {\n        field:_c0\n      }\n      separator: \",\"\n      header: false\n      batch: 256\n      partition: 32\n    }\n\n\n    # If more vertexes need to be added, refer to the previous configuration to add them.\n  ]\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # Specify the Edge Type name defined in NebulaGraph.\n      name: follow\n      type: {\n        # Specify the data source file format to CSV.\n        source: csv\n\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Specify the path to the CSV file.\n      # If the file is stored in HDFS, use double quotation marks to enclose the file path, starting with hdfs://. For example: \"hdfs://ip:port/xx/xx\".\n      # If the file is stored locally, use double quotation marks to enclose the file path, starting with file://. For example: \"file:///tmp/xx.csv\".\n      path: \"hdfs://192.168.*.*:9000/data/edge_follow.csv\"\n\n      # If the CSV file does not have a header, use [_c0, _c1, _c2, ..., _cn] to represent its header and indicate the columns as the source of the property values.\n      # If the CSV file has headers, use the actual column names.\n      fields: [_c2]\n\n      # Specify the column names in the edge table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      nebula.fields: [degree]\n\n      # Specify a column as the source for the source and destination vertexes.\n      # The value of vertex must be the same as the column names in the above fields or csv.fields.\n      # Currently, NebulaGraph 3.8.0 supports only strings or integers of VID.\n      source: {\n        field: _c0\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n      target: {\n        field: _c1\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The delimiter specified. The default value is comma.\n      separator: \",\"\n\n      # Specify a column as the source of the rank (optional).\n\n      #ranking: rank\n\n      # If the CSV file has a header, set the header to true.\n      # If the CSV file does not have a header, set the header to false. The default value is false.\n      header: false\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Edge Type serve.\n    {\n      name: serve\n      type: {\n        source: csv\n        sink: client\n      }\n      path: \"hdfs://192.168.*.*:9000/data/edge_serve.csv\"\n      fields: [_c2,_c3]\n      nebula.fields: [start_year, end_year]\n      source: {\n        field: _c0\n      }\n      target: {\n        field: _c1\n      }\n      separator: \",\"\n      header: false\n      batch: 256\n      partition: 32\n    }\n\n  ]\n    # If more edges need to be added, refer to the previous configuration to add them.\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#step_4_import_data_into_nebulagraph","title":"Step 4: Import data into NebulaGraph","text":"<p>Run the following command to import CSV data into NebulaGraph. For descriptions of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;csv_application.conf_path&gt; \n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/csv_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#access_hdfs_data_with_kerberos_certification","title":"Access HDFS data with Kerberos certification","text":"<p>When using Kerberos for security certification, you can access the HDFS data in one of the following ways.</p> <ul> <li> <p>Configure the Kerberos configuration file in a command</p> <p>Configure <code>--conf</code> and <code>--files</code> in the command, for example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master xxx  --num-executors 2 --executor-cores 2 --executor-memory 1g \\\n--conf \"spark.driver.extraJavaOptions=-Djava.security.krb5.conf=./krb5.conf\" \\\n--conf \"spark.executor.extraJavaOptions=-Djava.security.krb5.conf=./krb5.conf\" \\\n--files /local/path/to/xxx.keytab,/local/path/to/krb5.conf \\\n--class  com.vesoft.nebula.exchange.Exchange  \\\nexchange.jar -c xx.conf\n</code></pre> <p>The file path in <code>--conf</code> can be configured in two ways as follows:</p> <ul> <li>Configure the absolute path to the file. All YARN or Spark machines are required to have the corresponding file in the same path.</li> <li>(Recommended in YARN mode) Configure the relative path to the file (e.g. <code>./krb5.conf</code>). The resource files uploaded via <code>--files</code> are located in the working directory of the Java virtual machine or JAR.</li> </ul> <p>The files in <code>--files</code> must be stored on the machine where the <code>spark-submit</code> command is executed.</p> </li> </ul> <ul> <li> <p>Without commands</p> <p>Deploy the Spark and Kerberos-certified Hadoop in a same cluster to make them share HDFS and YARN, and then add the configuration <code>export HADOOP_HOME=&lt;hadoop_home_path&gt;</code> to <code>spark-env.sh</code> in Spark.</p> </li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#step_5_optional_validate_data","title":"Step 5: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the <code>SHOW STATS</code> command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-csv/#step_6_optional_rebuild_indexes_in_nebulagraph","title":"Step 6: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hbase/","title":"Import data from HBase","text":"<p>This topic provides an example of how to use Exchange to import NebulaGraph data stored in HBase.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hbase/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p> <p>In this example, the data set has been stored in HBase. All vertexes and edges are stored in the <code>player</code>, <code>team</code>, <code>follow</code>, and <code>serve</code> tables. The following are some of the data for each table.</p> <pre><code>hbase(main):002:0&gt; scan \"player\"\nROW                                COLUMN+CELL\n player100                         column=cf:age, timestamp=1618881347530, value=42\n player100                         column=cf:name, timestamp=1618881354604, value=Tim Duncan\n player101                         column=cf:age, timestamp=1618881369124, value=36\n player101                         column=cf:name, timestamp=1618881379102, value=Tony Parker\n player102                         column=cf:age, timestamp=1618881386987, value=33\n player102                         column=cf:name, timestamp=1618881393370, value=LaMarcus Aldridge\n player103                         column=cf:age, timestamp=1618881402002, value=32\n player103                         column=cf:name, timestamp=1618881407882, value=Rudy Gay\n ...\n\nhbase(main):003:0&gt; scan \"team\"\nROW                                COLUMN+CELL\n team200                           column=cf:name, timestamp=1618881445563, value=Warriors\n team201                           column=cf:name, timestamp=1618881453636, value=Nuggets\n ...\n\nhbase(main):004:0&gt; scan \"follow\"\nROW                                COLUMN+CELL\n player100                         column=cf:degree, timestamp=1618881804853, value=95\n player100                         column=cf:dst_player, timestamp=1618881791522, value=player101\n player101                         column=cf:degree, timestamp=1618881824685, value=90\n player101                         column=cf:dst_player, timestamp=1618881816042, value=player102\n ...\n\nhbase(main):005:0&gt; scan \"serve\"\nROW                                COLUMN+CELL\n player100                         column=cf:end_year, timestamp=1618881899333, value=2016\n player100                         column=cf:start_year, timestamp=1618881890117, value=1997\n player100                         column=cf:teamid, timestamp=1618881875739, value=team204\n ...\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hbase/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>HBase: 2.2.7</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hbase/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hbase/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hbase/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hbase/#step_2_modify_configuration_files","title":"Step 2: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set HBase data source configuration. In this example, the copied file is called <code>hbase_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    cores: {\n      max: 16\n    }\n  }\n\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and all Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n  # Processing vertexes\n  tags: [\n    # Set information about Tag player.\n    # If you want to set RowKey as the data source, enter rowkey and the actual column name of the column family.\n    {\n      # The Tag name in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to HBase.\n        source: hbase\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n      host:192.168.*.*\n      port:2181\n      table:\"player\"\n      columnFamily:\"cf\"\n\n      # Specify the column names in the player table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [age,name]\n      nebula.fields: [age,name]\n\n      # Specify a column of data in the table as the source of vertex VID in the NebulaGraph.\n      # For example, if rowkey is the source of the VID, enter rowkey.\n      vertex:{\n          field:rowkey\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # Number of pieces of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n    # Set Tag Team information.\n    {\n      name: team\n      type: {\n        source: hbase\n        sink: client\n      }\n      host:192.168.*.*\n      port:2181\n      table:\"team\"\n      columnFamily:\"cf\"\n      fields: [name]\n      nebula.fields: [name]\n      vertex:{\n          field:rowkey\n      }\n      batch: 256\n      partition: 32\n    }\n\n  ]\n\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # The corresponding Edge Type name in NebulaGraph.\n      name: follow\n\n      type: {\n        # Specify the data source file format to HBase.\n        source: hbase\n\n        # Specify how to import the Edge type data into NebulaGraph.\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      host:192.168.*.*\n      port:2181\n      table:\"follow\"\n      columnFamily:\"cf\"\n\n      # Specify the column names in the follow table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [degree]\n      nebula.fields: [degree]\n\n      # In source, use a column in the follow table as the source of the edge's source vertex.\n      # In target, use a column in the follow table as the source of the edge's destination vertex.\n      source:{\n          field:rowkey\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n\n      target:{\n          field:dst_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Edge Type serve.\n    {\n      name: serve\n      type: {\n        source: hbase\n        sink: client\n      }\n      host:192.168.*.*\n      port:2181\n      table:\"serve\"\n      columnFamily:\"cf\"\n\n      fields: [start_year,end_year]\n      nebula.fields: [start_year,end_year]\n      source:{\n          field:rowkey\n      }\n\n      target:{\n          field:teamid\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      batch: 256\n      partition: 32\n    }\n  ]\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hbase/#step_3_import_data_into_nebulagraph","title":"Step 3: Import data into NebulaGraph","text":"<p>Run the following command to import HBase data into NebulaGraph. For descriptions of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;hbase_application.conf_path&gt;\n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/hbase_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hbase/#step_4_optional_validate_data","title":"Step 4: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the SHOW STATS command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hbase/#step_5_optional_rebuild_indexes_in_nebulagraph","title":"Step 5: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/","title":"Import data from Hive","text":"<p>This topic provides an example of how to use Exchange to import NebulaGraph data stored in Hive.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p> <p>In this example, the data set has been stored in Hive. All vertexes and edges are stored in the <code>player</code>, <code>team</code>, <code>follow</code>, and <code>serve</code> tables. The following are some of the data for each table.</p> <pre><code>scala&gt; spark.sql(\"describe basketball.player\").show\n+--------+---------+-------+\n|col_name|data_type|comment|\n+--------+---------+-------+\n|playerid|   string|   null|\n|     age|   bigint|   null|\n|    name|   string|   null|\n+--------+---------+-------+\n\nscala&gt; spark.sql(\"describe basketball.team\").show\n+----------+---------+-------+\n|  col_name|data_type|comment|\n+----------+---------+-------+\n|    teamid|   string|   null|\n|      name|   string|   null|\n+----------+---------+-------+\n\nscala&gt; spark.sql(\"describe basketball.follow\").show\n+----------+---------+-------+\n|  col_name|data_type|comment|\n+----------+---------+-------+\n|src_player|   string|   null|\n|dst_player|   string|   null|\n|    degree|   bigint|   null|\n+----------+---------+-------+\n\nscala&gt; spark.sql(\"describe basketball.serve\").show\n+----------+---------+-------+\n|  col_name|data_type|comment|\n+----------+---------+-------+\n|  playerid|   string|   null|\n|    teamid|   string|   null|\n|start_year|   bigint|   null|\n|  end_year|   bigint|   null|\n+----------+---------+-------+\n</code></pre> <p>Note</p> <p>The Hive data type <code>bigint</code> corresponds to the NebulaGraph <code>int</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>Hadoop: 2.9.2, pseudo-distributed deployment</li> </ul> <ul> <li>Hive: 2.3.7, Hive Metastore database is MySQL 8.0.22</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul> <ul> <li>The Hive Metastore database (MySQL in this example) has been started.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#step_2_use_spark_sql_to_confirm_hive_sql_statements","title":"Step 2: Use Spark SQL to confirm Hive SQL statements","text":"<p>After the Spark-shell environment is started, run the following statements to ensure that Spark can read data in Hive.</p> <pre><code>scala&gt; sql(\"select playerid, age, name from basketball.player\").show\nscala&gt; sql(\"select teamid, name from basketball.team\").show\nscala&gt; sql(\"select src_player, dst_player, degree from basketball.follow\").show\nscala&gt; sql(\"select playerid, teamid, start_year, end_year from basketball.serve\").show\n</code></pre> <p>The following is the result read from the table <code>basketball.player</code>.</p> <pre><code>+---------+----+-----------------+\n| playerid| age|             name|\n+---------+----+-----------------+\n|player100|  42|       Tim Duncan|\n|player101|  36|      Tony Parker|\n|player102|  33|LaMarcus Aldridge|\n|player103|  32|         Rudy Gay|\n|player104|  32|  Marco Belinelli|\n+---------+----+-----------------+\n...\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#step_3_modify_configuration_file","title":"Step 3: Modify configuration file","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set Hive data source configuration. In this example, the copied file is called <code>hive_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    cores: {\n      max: 16\n    }\n  }\n\n  # If Spark and Hive are deployed in different clusters, you need to configure the parameters for connecting to Hive. Otherwise, skip these configurations.\n  #hive: {\n  #  waredir: \"hdfs://NAMENODE_IP:9000/apps/svr/hive-xxx/warehouse/\"\n  #  connectionURL: \"jdbc:mysql://your_ip:3306/hive_spark?characterEncoding=UTF-8\"\n  #  connectionDriverName: \"com.mysql.jdbc.Driver\"\n  #  connectionUserName: \"user\"\n  #  connectionPassword: \"password\"\n  #}\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and all Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n      # The Tag name in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to Hive.\n        source: hive\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Set the SQL statement to read the data of player table in basketball database.\n      exec: \"select playerid, age, name from basketball.player\"\n\n      # Specify the column names in the player table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [age,name]\n      nebula.fields: [age,name]\n\n      # Specify a column of data in the table as the source of vertex VID in the NebulaGraph.\n      vertex:{\n        field:playerid\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n    # Set the information about the Tag Team.\n    {\n      name: team\n      type: {\n        source: hive\n        sink: client\n      }\n      exec: \"select teamid, name from basketball.team\"\n      fields: [name]\n      nebula.fields: [name]\n      vertex: {\n        field: teamid\n      }\n      batch: 256\n      partition: 32\n    }\n\n  ]\n\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # The corresponding Edge Type name in NebulaGraph.\n      name: follow\n\n      type: {\n        # Specify the data source file format to Hive.\n        source: hive\n\n        # Specify how to import the Edge type data into NebulaGraph.\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Set the SQL statement to read the data of follow table in the basketball database.\n      exec: \"select src_player, dst_player, degree from basketball.follow\"\n\n      # Specify the column names in the follow table in Fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [degree]\n      nebula.fields: [degree]\n\n      # In source, use a column in the follow table as the source of the edge's starting vertex.\n      # In target, use a column in the follow table as the source of the edge's destination vertex.\n      source: {\n        field: src_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      target: {\n        field: dst_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Edge Type serve.\n    {\n      name: serve\n      type: {\n        source: hive\n        sink: client\n      }\n      exec: \"select playerid, teamid, start_year, end_year from basketball.serve\"\n      fields: [start_year,end_year]\n      nebula.fields: [start_year,end_year]\n      source: {\n        field: playerid\n      }\n      target: {\n        field: teamid\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      batch: 256\n      partition: 32\n    }\n  ]\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#step_4_import_data_into_nebulagraph","title":"Step 4: Import data into NebulaGraph","text":"<p>Run the following command to import Hive data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;hive_application.conf_path&gt; -h\n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/hive_application.conf -h\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#access_hdfs_data_with_kerberos_certification","title":"Access HDFS data with Kerberos certification","text":"<p>When using Kerberos for security certification, you can access the HDFS data in one of the following ways.</p> <ul> <li> <p>Configure the Kerberos configuration file in a command</p> <p>Configure <code>--conf</code> and <code>--files</code> in the command, for example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master xxx  --num-executors 2 --executor-cores 2 --executor-memory 1g \\\n--conf \"spark.driver.extraJavaOptions=-Djava.security.krb5.conf=./krb5.conf\" \\\n--conf \"spark.executor.extraJavaOptions=-Djava.security.krb5.conf=./krb5.conf\" \\\n--files /local/path/to/xxx.keytab,/local/path/to/krb5.conf \\\n--class  com.vesoft.nebula.exchange.Exchange  \\\nexchange.jar -c xx.conf\n</code></pre> <p>The file path in <code>--conf</code> can be configured in two ways as follows:</p> <ul> <li>Configure the absolute path to the file. All YARN or Spark machines are required to have the corresponding file in the same path.</li> <li>(Recommended in YARN mode) Configure the relative path to the file (e.g. <code>./krb5.conf</code>). The resource files uploaded via <code>--files</code> are located in the working directory of the Java virtual machine or JAR.</li> </ul> <p>The files in <code>--files</code> must be stored on the machine where the <code>spark-submit</code> command is executed.</p> </li> </ul> <ul> <li> <p>Without commands</p> <p>Deploy the Spark and Kerberos-certified Hadoop in a same cluster to make them share HDFS and YARN, and then add the configuration <code>export HADOOP_HOME=&lt;hadoop_home_path&gt;</code> to <code>spark-env.sh</code> in Spark.</p> </li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#step_5_optional_validate_data","title":"Step 5: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the SHOW STATS command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-hive/#step_6_optional_rebuild_indexes_in_nebulagraph","title":"Step 6: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/","title":"Import data from general JDBC","text":"<p>JDBC data refers to the data of various databases accessed through the JDBC interface. This topic provides an example of how to use Exchange to export MySQL data and import to NebulaGraph.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p> <p>In this example, the data set has been stored in MySQL. All vertexes and edges are stored in the <code>player</code>, <code>team</code>, <code>follow</code>, and <code>serve</code> tables. The following are some of the data for each table.</p> <pre><code>mysql&gt; desc player;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| playerid | int         | YES  |     | NULL    |       |\n| age      | int         | YES  |     | NULL    |       |\n| name     | varchar(30) | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n\nmysql&gt; desc team;\n+--------+-------------+------+-----+---------+-------+\n| Field  | Type        | Null | Key | Default | Extra |\n+--------+-------------+------+-----+---------+-------+\n| teamid | int         | YES  |     | NULL    |       |\n| name   | varchar(30) | YES  |     | NULL    |       |\n+--------+-------------+------+-----+---------+-------+\n\nmysql&gt; desc follow;\n+------------+-------------+------+-----+---------+-------+\n| Field      | Type        | Null | Key | Default | Extra |\n+------------+-------------+------+-----+---------+-------+\n| src_player | int         | YES  |     | NULL    |       |\n| dst_player | int         | YES  |     | NULL    |       |\n| degree     | int         | YES  |     | NULL    |       |\n+------------+-------------+------+-----+---------+-------+\n\nmysql&gt; desc serve;\n+------------+-------------+------+-----+---------+-------+\n| Field      | Type        | Null | Key | Default | Extra |\n+------------+-------------+------+-----+---------+-------+\n| playerid   | int         | YES  |     | NULL    |       |\n| teamid     | int         | YES  |     | NULL    |       |\n| start_year | int         | YES  |     | NULL    |       |\n| end_year   | int         | YES  |     | NULL    |       |\n+------------+-------------+------+-----+---------+-------+\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>MySQL: 8.0.23</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul> <ul> <li>The Hadoop service has been installed and started.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/#precautions","title":"Precautions","text":"<p>nebula-exchange_spark_2.2 supports only single table queries, not multi-table queries.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/#step_2_modify_configuration_files","title":"Step 2: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set JDBC data source configuration. In this case, the copied file is called <code>jdbc_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    cores: {\n      max: 16\n    }\n  }\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n      # The Tag name in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to JDBC.\n        source: jdbc\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # URL of the JDBC data source. The example is MySql database.\n      url:\"jdbc:mysql://127.0.0.1:3306/basketball?useUnicode=true&amp;characterEncoding=utf-8\"\n\n      # JDBC driver \n      driver:\"com.mysql.cj.jdbc.Driver\"\n\n      # Database user name and password\n      user:\"root\"\n      password:\"12345\"\n\n      # Scanning a single table to read data.\n      # nebula-exchange_spark_2.2 must configure this parameter, and can additionally configure sentence.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as sentence.\n      table:\"basketball.player\"\n\n      # Use query statement to read data.\n      # nebula-exchange_spark_2.2 can configure this parameter. Multi-table queries are not supported. Only the table name needs to be written after from. The form `db.table` is not supported.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as table. Multi-table queries are supported.\n      # sentence:\"select playerid, age, name from player, team order by playerid\"\n\n      # (optional)Multiple connections read parameters. See https://spark.apache.org/docs/latest/sql-data-sources-jdbc.html\n      partitionColumn:playerid    # optional. Must be a numeric, date, or timestamp column from the table in question.\n      lowerBound:1                # optional\n      upperBound:5                # optional\n      numPartitions:5             # optional\n\n\n      fetchSize:2           # The JDBC fetch size, which determines how many rows to fetch per round trip.\n\n      # Specify the column names in the player table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [age,name]\n      nebula.fields: [age,name]\n\n      # Specify a column of data in the table as the source of VIDs in the NebulaGraph.\n      vertex: {\n        field:playerid\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n    # Set the information about the Tag Team.\n    {\n      name: team\n      type: {\n        source: jdbc\n        sink: client\n      }\n\n      url:\"jdbc:mysql://127.0.0.1:3306/basketball?useUnicode=true&amp;characterEncoding=utf-8\"\n      driver:\"com.mysql.cj.jdbc.Driver\"\n      user:root\n      password:\"12345\"\n      table:team\n      sentence:\"select teamid, name from team order by teamid\"\n      partitionColumn:teamid    \n      lowerBound:1                \n      upperBound:5                \n      numPartitions:5             \n      fetchSize:2  \n\n      fields: [name]\n      nebula.fields: [name]\n      vertex: {\n        field: teamid\n      }\n      batch: 256\n      partition: 32\n    }\n\n  ]\n\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # The corresponding Edge Type name in NebulaGraph.\n      name: follow\n\n      type: {\n        # Specify the data source file format to JDBC.\n        source: jdbc\n\n        # Specify how to import the Edge type data into NebulaGraph.\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      url:\"jdbc:mysql://127.0.0.1:3306/basketball?useUnicode=true&amp;characterEncoding=utf-8\"\n      driver:\"com.mysql.cj.jdbc.Driver\"\n      user:root\n      password:\"12345\"\n\n      # Scanning a single table to read data.\n      # nebula-exchange_spark_2.2 must configure this parameter, and can additionally configure sentence.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as sentence.\n      table:\"basketball.follow\"\n\n      # Use query statement to read data.\n      # nebula-exchange_spark_2.2 can configure this parameter. Multi-table queries are not supported. Only the table name needs to be written after from. The form `db.table` is not supported.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as table. Multi-table queries are supported.\n      # sentence:\"select src_player,dst_player,degree from follow order by src_player\"\n\n      partitionColumn:src_player    \n      lowerBound:1                \n      upperBound:5                \n      numPartitions:5             \n      fetchSize:2  \n\n      # Specify the column names in the follow table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [degree]\n      nebula.fields: [degree]\n\n      # In source, use a column in the follow table as the source of the edge's source vertex.\n      # In target, use a column in the follow table as the source of the edge's destination vertex.\n      source: {\n        field: src_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      target: {\n        field: dst_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Edge Type serve.\n    {\n      name: serve\n      type: {\n        source: jdbc\n        sink: client\n      }\n\n      url:\"jdbc:mysql://127.0.0.1:3306/basketball?useUnicode=true&amp;characterEncoding=utf-8\"\n      driver:\"com.mysql.cj.jdbc.Driver\"\n      user:root\n      password:\"12345\"\n      table:serve\n      sentence:\"select playerid,teamid,start_year,end_year from serve order by playerid\"\n      partitionColumn:playerid    \n      lowerBound:1                \n      upperBound:5                \n      numPartitions:5             \n      fetchSize:2\n\n      fields: [start_year,end_year]\n      nebula.fields: [start_year,end_year]\n      source: {\n        field: playerid\n      }\n      target: {\n        field: teamid\n      }\n      batch: 256\n      partition: 32\n    }\n  ]\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/#step_3_import_data_into_nebulagraph","title":"Step 3: Import data into NebulaGraph","text":"<p>Run the following command to import general JDBC data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;jdbc_application.conf_path&gt;\n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/jdbc_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/#step_4_optional_validate_data","title":"Step 4: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the SHOW STATS command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-jdbc/#step_5_optional_rebuild_indexes_in_nebulagraph","title":"Step 5: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/","title":"Import data from JSON files","text":"<p>This topic provides an example of how to use Exchange to import NebulaGraph data stored in HDFS or local JSON files.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example. Some sample data are as follows:</p> <ul> <li> <p>player</p> <pre><code>{\"id\":\"player100\",\"age\":42,\"name\":\"Tim Duncan\"}\n{\"id\":\"player101\",\"age\":36,\"name\":\"Tony Parker\"}\n{\"id\":\"player102\",\"age\":33,\"name\":\"LaMarcus Aldridge\"}\n{\"id\":\"player103\",\"age\":32,\"name\":\"Rudy Gay\"}\n...\n</code></pre> </li> </ul> <ul> <li> <p>team</p> <pre><code>{\"id\":\"team200\",\"name\":\"Warriors\"}\n{\"id\":\"team201\",\"name\":\"Nuggets\"}\n...\n</code></pre> </li> </ul> <ul> <li> <p>follow</p> <pre><code>{\"src\":\"player100\",\"dst\":\"player101\",\"degree\":95}\n{\"src\":\"player101\",\"dst\":\"player102\",\"degree\":90}\n...\n</code></pre> </li> </ul> <ul> <li> <p>serve</p> <pre><code>{\"src\":\"player100\",\"dst\":\"team204\",\"start_year\":\"1997\",\"end_year\":\"2016\"}\n{\"src\":\"player101\",\"dst\":\"team204\",\"start_year\":\"1999\",\"end_year\":\"2018\"}\n...\n</code></pre> </li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>Hadoop: 2.9.2, pseudo-distributed deployment</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul> <ul> <li>If files are stored in HDFS, ensure that the Hadoop service is running properly.</li> </ul> <ul> <li>If files are stored locally and NebulaGraph is a cluster architecture, you need to place the files in the same directory locally on each machine in the cluster.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#step_2_process_json_files","title":"Step 2: Process JSON files","text":"<p>Confirm the following information:</p> <ol> <li> <p>Process JSON files to meet Schema requirements.</p> </li> <li> <p>Obtain the JSON file storage path.</p> </li> </ol>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#step_3_modify_configuration_files","title":"Step 3: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set JSON data source configuration. In this example, the copied file is called <code>json_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    executor: {\n        memory:1G\n    }\n\n    cores: {\n      max: 16\n    }\n  }\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and all Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"    \n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n      # Specify the Tag name defined in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to JSON.\n        source: json\n\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Specify the path to the JSON file.\n      # If the file is stored in HDFS, use double quotation marks to enclose the file path, starting with hdfs://. For example, \"hdfs://ip:port/xx/xx\".\n      # If the file is stored locally, use double quotation marks to enclose the file path, starting with file://. For example, \"file:///tmp/xx.json\".\n      path: \"hdfs://192.168.*.*:9000/data/vertex_player.json\"\n\n      # Specify the key name in the JSON file in fields, and its corresponding value will serve as the data source for the properties specified in the NebulaGraph.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [age,name]\n\n      # Specify the column names in the player table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      nebula.fields: [age, name]\n\n      # Specify a column of data in the table as the source of vertex VID in the NebulaGraph.\n      # The value of vertex must be the same as that in the JSON file.\n      # Currently, NebulaGraph 3.8.0 supports only strings or integers of VID.\n      vertex: {\n        field:id\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Tag Team.\n{\n      name: team\n      type: {\n        source: json\n        sink: client\n      }\n      path: \"hdfs://192.168.*.*:9000/data/vertex_team.json\"\n      fields: [name]\n      nebula.fields: [name]\n      vertex: {\n        field:id\n      }\n      batch: 256\n      partition: 32\n    }\n\n\n    # If more vertexes need to be added, refer to the previous configuration to add them.\n  ]\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # Specify the Edge Type name defined in NebulaGraph.\n      name: follow\n      type: {\n        # Specify the data source file format to JSON.\n        source: json\n\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Specify the path to the JSON file.\n      # If the file is stored in HDFS, use double quotation marks to enclose the file path, starting with hdfs://. For example, \"hdfs://ip:port/xx/xx\".\n      # If the file is stored locally, use double quotation marks to enclose the file path, starting with file://. For example, \"file:///tmp/xx.json\".\n      path: \"hdfs://192.168.*.*:9000/data/edge_follow.json\"\n\n      # Specify the key name in the JSON file in fields, and its corresponding value will serve as the data source for the properties specified in the NebulaGraph.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [degree]\n\n      # Specify the column names in the edge table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      nebula.fields: [degree]\n\n      # Specify a column as the source for the source and destination vertexes.\n      # The value of vertex must be the same as that in the JSON file.\n      # Currently, NebulaGraph 3.8.0 supports only strings or integers of VID.\n      source: {\n        field: src\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n      target: {\n        field: dst\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Edge Type serve.\n    {\n      name: serve\n      type: {\n        source: json\n        sink: client\n      }\n      path: \"hdfs://192.168.*.*:9000/data/edge_serve.json\"\n      fields: [start_year,end_year]\n      nebula.fields: [start_year, end_year]\n      source: {\n        field: src\n      }\n      target: {\n        field: dst\n      }\n      batch: 256\n      partition: 32\n    }\n\n  ]\n  # If more edges need to be added, refer to the previous configuration to add them.\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#step_4_import_data_into_nebulagraph","title":"Step 4: Import data into NebulaGraph","text":"<p>Run the following command to import JSON data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;json_application.conf_path&gt; \n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-echange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/json_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#access_hdfs_data_with_kerberos_certification","title":"Access HDFS data with Kerberos certification","text":"<p>When using Kerberos for security certification, you can access the HDFS data in one of the following ways.</p> <ul> <li> <p>Configure the Kerberos configuration file in a command</p> <p>Configure <code>--conf</code> and <code>--files</code> in the command, for example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master xxx  --num-executors 2 --executor-cores 2 --executor-memory 1g \\\n--conf \"spark.driver.extraJavaOptions=-Djava.security.krb5.conf=./krb5.conf\" \\\n--conf \"spark.executor.extraJavaOptions=-Djava.security.krb5.conf=./krb5.conf\" \\\n--files /local/path/to/xxx.keytab,/local/path/to/krb5.conf \\\n--class  com.vesoft.nebula.exchange.Exchange  \\\nexchange.jar -c xx.conf\n</code></pre> <p>The file path in <code>--conf</code> can be configured in two ways as follows:</p> <ul> <li>Configure the absolute path to the file. All YARN or Spark machines are required to have the corresponding file in the same path.</li> <li>(Recommended in YARN mode) Configure the relative path to the file (e.g. <code>./krb5.conf</code>). The resource files uploaded via <code>--files</code> are located in the working directory of the Java virtual machine or JAR.</li> </ul> <p>The files in <code>--files</code> must be stored on the machine where the <code>spark-submit</code> command is executed.</p> </li> </ul> <ul> <li> <p>Without commands</p> <p>Deploy the Spark and Kerberos-certified Hadoop in a same cluster to make them share HDFS and YARN, and then add the configuration <code>export HADOOP_HOME=&lt;hadoop_home_path&gt;</code> to <code>spark-env.sh</code> in Spark.</p> </li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#step_5_optional_validate_data","title":"Step 5: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the <code>SHOW STATS</code> command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-json/#step_6_optional_rebuild_indexes_in_nebulagraph","title":"Step 6: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-kafka/","title":"Import data from Kafka","text":"<p>This topic provides a simple guide to importing Data stored on Kafka into NebulaGraph using Exchange.</p> <p>Compatibility</p> <p>Please use Exchange 3.5.0/3.3.0/3.0.0 when importing Kafka data. In version 3.4.0, caching of imported data was added, and streaming data import is not supported.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-kafka/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-kafka/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li> <p>The following JAR files have been downloaded and placed in the directory <code>SPARK_HOME/jars</code> of Spark:</p> <ul> <li>spark-streaming-kafka_xxx.jar</li> </ul> <ul> <li>spark-sql-kafka-0-10_xxx.jar</li> </ul> <ul> <li>kafka-clients-xxx.jar</li> </ul> </li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul> <ul> <li>The Kafka service has been installed and started.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-kafka/#precautions","title":"Precautions","text":"<ul> <li>Only client mode is supported when importing Kafka data, i.e. the value of parameters <code>tags.type.sink</code> and <code>edges.type.sink</code> is <code>client</code>.</li> </ul> <ul> <li>When importing Kafka data, do not use Exchange version 3.4.0, which adds caching of imported data and does not support streaming data import. Use Exchange versions 3.0.0, 3.3.0, or 3.5.0.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-kafka/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-kafka/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-kafka/#step_2_modify_configuration_files","title":"Step 2: Modify configuration files","text":"<p>Note</p> <p>If some data is stored in Kafka's value field, you need to modify the source code, get the value from Kafka, parse the value through the from_JSON function, and return it as a Dataframe.</p> <p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set Kafka data source configuration. In this example, the copied file is called <code>kafka_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <p>Note</p> <p>When importing Kafka data, a configuration file can only handle one tag or edge type. If there are multiple tag or edge types, you need to create multiple configuration files.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    cores: {\n      max: 16\n    }\n  }\n\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and all Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n\n      # The corresponding Tag name in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to Kafka.\n        source: kafka\n        # Specify how to import the data into NebulaGraph. Only client is supported.\n        sink: client\n      }\n      # Kafka server address.\n      service: \"127.0.0.1:9092\"\n      # Message category.\n      topic: \"topic_name1\"\n\n      # If Kafka uses Kerberos for security certification, the following parameters need to be set. If Kafka uses SASL or SASL_PLAINTEXT for security certification, you do not need to set kerberos or kerberosServiceName.\n      #securityProtocol: SASL_PLAINTEXT\n      #mechanism: GASSAPI\n      #kerberos: true\n      #kerberosServiceName: kafka\n\n      # Kafka data has a fixed domain name: key, value, topic, partition, offset, timestamp, timestampType.\n      # If multiple fields need to be specified after Spark reads as DataFrame, separate them with commas.\n      # Specify the field name in fields. For example, use key for name in NebulaGraph and value for age in Nebula, as shown in the following.\n      fields: [key,value]\n      nebula.fields: [name,age]\n\n      # Specify a column of data in the table as the source of vertex VID in the NebulaGraph.\n      # The key is the same as the value above, indicating that key is used as both VID and property name.\n      vertex:{\n          field:key\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 10\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 10\n      # The interval for message reading. Unit: second.\n      interval.seconds: 10\n      # The consumer offsets. The default value is latest. Optional value are latest and earliest.\n      startingOffsets: latest\n      # Flow control, with a rate limit on the maximum offset processed per trigger interval, may not be configured.\n      # maxOffsetsPerTrigger:10000\n    }\n  ]\n\n  # Processing edges\n  #edges: [\n  #  # Set the information about the Edge Type follow.\n  #  {\n  #    # The corresponding Edge Type name in NebulaGraph.\n  #    name: follow\n\n  #    type: {\n  #      # Specify the data source file format to Kafka.\n  #      source: kafka\n\n  #      # Specify how to import the Edge type data into NebulaGraph.\n  #      # Specify how to import the data into NebulaGraph. Only client is supported.\n  #      sink: client\n  #    }\n\n  #    # Kafka server address.\n  #    service: \"127.0.0.1:9092\"\n  #    # Message category.\n  #    topic: \"topic_name3\"\n\n  #    # If Kafka uses Kerberos for security certification, the following parameters need to be set. If Kafka uses SASL or SASL_PLAINTEXT for security certification, you do not need to set kerberos or kerberosServiceName.\n  #    #securityProtocol: SASL_PLAINTEXT\n  #    #mechanism: GASSAPI\n  #    #kerberos: true\n  #    #kerberosServiceName: kafka\n\n  #    # Kafka data has a fixed domain name: key, value, topic, partition, offset, timestamp, timestampType.\n  #    # If multiple fields need to be specified after Spark reads as DataFrame, separate them with commas.\n  #    # Specify the field name in fields. For example, use key for degree in Nebula, as shown in the following.\n  #    fields: [key]\n  #    nebula.fields: [degree]\n\n  #    # In source, use a column in the topic as the source of the edge's source vertex.\n  #    # In target, use a column in the topic as the source of the edge's destination vertex.\n  #    source:{\n  #        field:timestamp\n  #    # udf:{\n  #    #            separator:\"_\"\n  #    #            oldColNames:[field-0,field-1,field-2]\n  #    #            newColName:new-field\n  #    #        }\n  #    # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n  #    # prefix:\"tag1\"\n  #    # Performs hashing operations on VIDs of type string.\n  #    # policy:hash\n  #    }\n\n\n  #    target:{\n  #        field:offset\n  #    # udf:{\n  #    #            separator:\"_\"\n  #    #            oldColNames:[field-0,field-1,field-2]\n  #    #            newColName:new-field\n  #    #        }\n  #    # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n  #    # prefix:\"tag1\"\n  #    # Performs hashing operations on VIDs of type string.\n  #    # policy:hash\n  #    }\n\n  #    # (Optional) Specify a column as the source of the rank.\n  #    #ranking: rank\n\n  #    # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n  #    #writeMode: INSERT\n\n  #    # The number of data written to NebulaGraph in a single batch.\n  #    batch: 10\n\n  #    # The number of partitions to be created when the data is written to NebulaGraph.\n  #    partition: 10\n\n  #    # The interval for message reading. Unit: second.\n  #    interval.seconds: 10\n  #    # The consumer offsets. The default value is latest. Optional value are latest and earliest.\n  #    startingOffsets: latest\n  #    # Flow control, with a rate limit on the maximum offset processed per trigger interval, may not be configured.\n  #    # maxOffsetsPerTrigger:10000\n  #  }\n  #]\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-kafka/#step_3_import_data_into_nebulagraph","title":"Step 3: Import data into NebulaGraph","text":"<p>Run the following command to import Kafka data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;kafka_application.conf_path&gt;\n</code></pre> <p>Note</p> <ul> <li>The JAR package needs to be obtained from the NebulaGraph Enterprise Edition Package.</li> <li>If Kafka's security certification is enabled, you need to configure the driver and executor when importing data. See the example below.</li> </ul> <p>Example:</p> <ul> <li> <p>No security certification</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" \\\n--class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  \\\n-c /root/nebula-exchange/target/classes/kafka_application.conf\n</code></pre> </li> </ul> <ul> <li> <p>Enable Kerberos security certification</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" \\\n--conf \"spark.driver.extraJavaOptions=-Djava.security.auth.login.config=/path/kafka_client_jaas.conf -Djava.security.krb5.conf=/path/krb5.conf\" \\\n--conf \"spark.executor.extraJavaOptions=-Djava.security.auth.login.config=/path/kafka_client_jaas.conf -Djava.security.krb5.conf=/path/krb5.conf\" \\\n--files /local/path/kafka_client_jaas.conf,/local/path/kafka.keytab,/local/path/krb5.conf \\\n--class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  \\\n-c /root/nebula-exchange/target/classes/kafka_application.conf\n</code></pre> </li> </ul> <ul> <li> <p>Enable SASL/SASL_PLAINTEXT security certification</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" \\\n--conf \"spark.driver.extraJavaOptions=-Djava.security.auth.login.config=/path/kafka_client_jaas.conf\" \\\n--conf \"spark.executor.extraJavaOptions=-Djava.security.auth.login.config=/path/kafka_client_jaas.conf\" \\\n--files /local/path/kafka_client_jaas.conf \\\n--class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  \\\n-c /root/nebula-exchange/target/classes/kafka_application.conf\n</code></pre> </li> </ul> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-kafka/#step_4_optional_validate_data","title":"Step 4: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the SHOW STATS command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-kafka/#step_5_optional_rebuild_indexes_in_nebulagraph","title":"Step 5: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-maxcompute/","title":"Import data from MaxCompute","text":"<p>This topic provides an example of how to use Exchange to import NebulaGraph data stored in MaxCompute.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-maxcompute/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-maxcompute/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>MaxCompute: Alibaba Cloud official version</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-maxcompute/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-maxcompute/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-maxcompute/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-maxcompute/#step_2_modify_configuration_files","title":"Step 2: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set MaxCompute data source configuration. In this example, the copied file is called <code>maxcompute_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    cores: {\n      max: 16\n    }\n  }\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n      name: player\n      type: {\n        # Specify the data source file format to MaxCompute.\n        source: maxcompute\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Table name of MaxCompute.\n      table:player\n\n      # Project name of MaxCompute.\n      project:project\n\n      # OdpsUrl and tunnelUrl for the MaxCompute service.\n      # The address is https://help.aliyun.com/document_detail/34951.html.\n      odpsUrl:\"http://service.cn-hangzhou.maxcompute.aliyun.com/api\"\n      tunnelUrl:\"http://dt.cn-hangzhou.maxcompute.aliyun.com\"\n\n      # AccessKeyId and accessKeySecret of the MaxCompute service.\n      accessKeyId:xxx\n      accessKeySecret:xxx\n\n      # Partition description of the MaxCompute table. This configuration is optional.\n      partitionSpec:\"dt='partition1'\"\n\n      # Ensure that the table name in the SQL statement is the same as the value of the table above. This configuration is optional.\n      sentence:\"select id, name, age, playerid from player where id &lt; 10\"\n\n      # Specify the column names in the player table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields:[name, age]\n      nebula.fields:[name, age]\n\n      # Specify a column of data in the table as the source of vertex VID in the NebulaGraph.\n      vertex:{\n        field: playerid\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Tag Team.\n    {\n      name: team\n      type: {\n        source: maxcompute\n        sink: client\n      }\n      table:team\n      project:project\n      odpsUrl:\"http://service.cn-hangzhou.maxcompute.aliyun.com/api\"\n      tunnelUrl:\"http://dt.cn-hangzhou.maxcompute.aliyun.com\"\n      accessKeyId:xxx\n      accessKeySecret:xxx\n      partitionSpec:\"dt='partition1'\"\n      sentence:\"select id, name, teamid from team where id &lt; 10\"\n      fields:[name]\n      nebula.fields:[name]\n      vertex:{\n        field: teamid\n      }\n      batch: 256\n      partition: 32\n    }\n  ]\n\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # The corresponding Edge Type name in NebulaGraph.\n      name: follow\n\n      type:{\n        # Specify the data source file format to MaxCompute.\n        source:maxcompute\n\n        # Specify how to import the Edge type data into NebulaGraph.\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink:client\n      }\n\n      # Table name of MaxCompute.\n      table:follow\n\n      # Project name of MaxCompute.\n      project:project\n\n      # OdpsUrl and tunnelUrl for MaxCompute service.\n      # The address is https://help.aliyun.com/document_detail/34951.html.\n      odpsUrl:\"http://service.cn-hangzhou.maxcompute.aliyun.com/api\"\n      tunnelUrl:\"http://dt.cn-hangzhou.maxcompute.aliyun.com\"\n\n      # AccessKeyId and accessKeySecret of the MaxCompute service.\n      accessKeyId:xxx\n      accessKeySecret:xxx\n\n      # Partition description of the MaxCompute table. This configuration is optional.\n      partitionSpec:\"dt='partition1'\"\n\n      # Ensure that the table name in the SQL statement is the same as the value of the table above. This configuration is optional.\n      sentence:\"select * from follow\"\n\n      # Specify the column names in the follow table in Fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields:[degree]\n      nebula.fields:[degree]\n\n      # In source, use a column in the follow table as the source of the edge's source vertex.\n      source:{\n        field: src_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # In target, use a column in the follow table as the source of the edge's destination vertex.\n      target:{\n        field: dst_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition:10\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch:10\n    }\n\n    # Set the information about the Edge Type serve.\n    {\n      name: serve\n      type:{\n        source:maxcompute\n        sink:client\n      }\n      table:serve\n      project:project\n      odpsUrl:\"http://service.cn-hangzhou.maxcompute.aliyun.com/api\"\n      tunnelUrl:\"http://dt.cn-hangzhou.maxcompute.aliyun.com\"\n      accessKeyId:xxx\n      accessKeySecret:xxx\n      partitionSpec:\"dt='partition1'\"\n      sentence:\"select * from serve\"\n      fields:[start_year,end_year]\n      nebula.fields:[start_year,end_year]\n      source:{\n        field: playerid\n      }\n      target:{\n        field: teamid\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      partition:10\n      batch:10\n    }\n  ]\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-maxcompute/#step_3_import_data_into_nebulagraph","title":"Step 3: Import data into NebulaGraph","text":"<p>Run the following command to import MaxCompute data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;maxcompute_application.conf_path&gt;\n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/maxcompute_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-maxcompute/#step_4_optional_validate_data","title":"Step 4: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the <code>SHOW STATS</code> command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-maxcompute/#step_5_optional_rebuild_indexes_in_nebulagraph","title":"Step 5: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/","title":"Import data from MySQL/PostgreSQL","text":"<p>This topic provides an example of how to use Exchange to export MySQL data and import to NebulaGraph. It also applies to exporting data from PostgreSQL into NebulaGraph.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p> <p>In this example, the data set has been stored in MySQL. All vertexes and edges are stored in the <code>player</code>, <code>team</code>, <code>follow</code>, and <code>serve</code> tables. The following are some of the data for each table.</p> <pre><code>mysql&gt; desc player;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| playerid | varchar(30) | YES  |     | NULL    |       |\n| age      | int         | YES  |     | NULL    |       |\n| name     | varchar(30) | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n\nmysql&gt; desc team;\n+--------+-------------+------+-----+---------+-------+\n| Field  | Type        | Null | Key | Default | Extra |\n+--------+-------------+------+-----+---------+-------+\n| teamid | varchar(30) | YES  |     | NULL    |       |\n| name   | varchar(30) | YES  |     | NULL    |       |\n+--------+-------------+------+-----+---------+-------+\n\nmysql&gt; desc follow;\n+------------+-------------+------+-----+---------+-------+\n| Field      | Type        | Null | Key | Default | Extra |\n+------------+-------------+------+-----+---------+-------+\n| src_player | varchar(30) | YES  |     | NULL    |       |\n| dst_player | varchar(30) | YES  |     | NULL    |       |\n| degree     | int         | YES  |     | NULL    |       |\n+------------+-------------+------+-----+---------+-------+\n\nmysql&gt; desc serve;\n+------------+-------------+------+-----+---------+-------+\n| Field      | Type        | Null | Key | Default | Extra |\n+------------+-------------+------+-----+---------+-------+\n| playerid   | varchar(30) | YES  |     | NULL    |       |\n| teamid     | varchar(30) | YES  |     | NULL    |       |\n| start_year | int         | YES  |     | NULL    |       |\n| end_year   | int         | YES  |     | NULL    |       |\n+------------+-------------+------+-----+---------+-------+\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>MySQL: 8.0.23</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>mysql-connector-java-xxx.jar has been downloaded and placed in the directory <code>SPARK_HOME/jars</code> of Spark.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul> <ul> <li>The Hadoop service has been installed and started.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/#precautions","title":"Precautions","text":"<p>nebula-exchange_spark_2.2 supports only single table queries, not multi-table queries.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/#step_2_modify_configuration_files","title":"Step 2: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set MySQL data source configuration. In this case, the copied file is called <code>mysql_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    cores: {\n      max: 16\n    }\n  }\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n      # The Tag name in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to MySQL.\n        source: mysql\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      host:192.168.*.*\n      port:3306\n      user:\"test\"\n      password:\"123456\"\n      database:\"basketball\"\n\n      # Scanning a single table to read data.\n      # nebula-exchange_spark_2.2 must configure this parameter. Sentence is not supported.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as sentence.\n      table:\"basketball.player\"\n\n      # Use query statement to read data.\n      # This parameter is not supported by nebula-exchange_spark_2.2.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as table. Multi-table queries are supported.\n      # sentence: \"select * from people, player, team\"\n\n      # Specify the column names in the player table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [age,name]\n      nebula.fields: [age,name]\n\n      # Specify a column of data in the table as the source of VIDs in the NebulaGraph.\n      vertex: {\n        field:playerid\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n    # Set the information about the Tag Team.\n    {\n      name: team\n      type: {\n        source: mysql\n        sink: client\n      }\n\n      host:192.168.*.*\n      port:3306\n      database:\"basketball\"\n      table:\"team\"\n      user:\"test\"\n      password:\"123456\"\n      sentence:\"select teamid, name from team order by teamid;\"\n\n      fields: [name]\n      nebula.fields: [name]\n      vertex: {\n        field: teamid\n      }\n      batch: 256\n      partition: 32\n    }\n\n  ]\n\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # The corresponding Edge Type name in NebulaGraph.\n      name: follow\n\n      type: {\n        # Specify the data source file format to MySQL.\n        source: mysql\n\n        # Specify how to import the Edge type data into NebulaGraph.\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      host:192.168.*.*\n      port:3306\n      user:\"test\"\n      password:\"123456\"\n      database:\"basketball\"\n\n      # Scanning a single table to read data.\n      # nebula-exchange_spark_2.2 must configure this parameter. Sentence is not supported.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as sentence.\n      table:\"basketball.follow\"\n\n      # Use query statement to read data.\n      # This parameter is not supported by nebula-exchange_spark_2.2.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as table. Multi-table queries are supported.\n      # sentence: \"select * from follow, serve\"\n\n      # Specify the column names in the follow table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [degree]\n      nebula.fields: [degree]\n\n      # In source, use a column in the follow table as the source of the edge's source vertex.\n      # In target, use a column in the follow table as the source of the edge's destination vertex.\n      source: {\n        field: src_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      target: {\n        field: dst_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Edge Type serve.\n    {\n      name: serve\n      type: {\n        source: mysql\n        sink: client\n      }\n\n      host:192.168.*.*\n      port:3306\n      database:\"basketball\"\n      table:\"serve\"\n      user:\"test\"\n      password:\"123456\"\n      sentence:\"select playerid,teamid,start_year,end_year from serve order by playerid;\"\n      fields: [start_year,end_year]\n      nebula.fields: [start_year,end_year]\n      source: {\n        field: playerid\n      }\n      target: {\n        field: teamid\n      }\n      batch: 256\n      partition: 32\n    }\n  ]\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/#step_3_import_data_into_nebulagraph","title":"Step 3: Import data into NebulaGraph","text":"<p>Run the following command to import MySQL data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;mysql_application.conf_path&gt;\n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/mysql_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/#step_4_optional_validate_data","title":"Step 4: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the SHOW STATS command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-mysql/#step_5_optional_rebuild_indexes_in_nebulagraph","title":"Step 5: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/","title":"Import data from Neo4j","text":"<p>This topic provides an example of how to use Exchange to import NebulaGraph data stored in Neo4j.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#implementation_method","title":"Implementation method","text":"<p>Exchange uses Neo4j Driver 4.0.1 to read Neo4j data. Before batch export, you need to write Cypher statements that are automatically executed based on labels and relationship types and the number of Spark partitions in the configuration file to improve data export performance.</p> <p>When Exchange reads Neo4j data, it needs to do the following:</p> <ol> <li> <p>The Reader in Exchange replaces the statement following the Cypher <code>RETURN</code> statement in the <code>exec</code> part of the configuration file with <code>COUNT(*)</code>, and executes this statement to get the total amount of data, then calculates the starting offset and size of each partition based on the number of Spark partitions.</p> </li> <li> <p>(Optional) If the user has configured the <code>check_point_path</code> directory, Reader reads the files in the directory. In the transferring state, Reader calculates the offset and size that each Spark partition should have.</p> </li> <li> <p>In each Spark partition, the Reader in Exchange adds different <code>SKIP</code> and <code>LIMIT</code> statements to the Cypher statement and calls the Neo4j Driver for parallel execution to distribute data to different Spark partitions.</p> </li> <li> <p>The Reader finally processes the returned data into a DataFrame.</p> </li> </ol> <p>At this point, Exchange has finished exporting the Neo4j data. The data is then written in parallel to the NebulaGraph database.</p> <p>The whole process is illustrated below.</p> <p></p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li> <p>Hardware specifications:</p> <ul> <li>CPU\uff1aIntel(R) Xeon(R) CPU E5-2697 v3 @ 2.60GHz</li> </ul> <ul> <li>CPU cores: 14</li> </ul> <ul> <li>Memory: 251 GB</li> </ul> </li> </ul> <ul> <li>Spark: Stand-alone, 2.4.6 pre-build for Hadoop 2.7</li> </ul> <ul> <li>Neo4j: 3.5.20 Community Edition</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with NebulaGraph write permission.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#step_2_configuring_source_data","title":"Step 2: Configuring source data","text":"<p>To speed up the export of Neo4j data, create indexes for the corresponding properties in the Neo4j database. For more information, refer to the Neo4j manual.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#step_3_modify_configuration_files","title":"Step 3: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set Neo4j data source configuration. In this example, the copied file is called <code>neo4j_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n\n    executor: {\n        memory:1G\n    }\n\n    cores: {\n      max: 16\n    }\n  }\n\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    space: basketballplayer\n\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n\n    execution: {\n      retry: 3\n    }\n\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n\n  # Processing vertexes\n  tags: [\n\n\n    # Set the information about the Tag player\n    {\n      name: player\n      type: {\n        source: neo4j\n        sink: client\n      }\n      server: \"bolt://192.168.*.*:7687\"\n      user: neo4j\n      password:neo4j\n      # bolt 3 does not support multiple databases, do not configure database names. 4 and above can configure database names.\n      # database:neo4j\n      exec: \"match (n:player) return n.id as id, n.age as age, n.name as name\"\n      fields: [age,name]\n      nebula.fields: [age,name]\n      vertex: {\n        field:id\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      partition: 10\n      batch: 1000\n      check_point_path: /tmp/test\n   }\n  # Set the information about the Tag Team\n  {\n      name: team\n      type: {\n        source: neo4j\n        sink: client\n      }\n      server: \"bolt://192.168.*.*:7687\"\n      user: neo4j\n      password:neo4j\n      database:neo4j\n      exec: \"match (n:team) return n.id as id,n.name as name\"\n      fields: [name]\n      nebula.fields: [name]\n      vertex: {\n        field:id\n      }\n      partition: 10\n      batch: 1000\n      check_point_path: /tmp/test\n   }\n  ]\n\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow\n    {\n      name: follow\n      type: {\n        source: neo4j\n        sink: client\n      }\n      server: \"bolt://192.168.*.*:7687\"\n      user: neo4j\n      password:neo4j\n      # bolt 3 does not support multiple databases, do not configure database names. 4 and above can configure database names.\n      # database:neo4j\n      exec: \"match (a:player)-[r:follow]-&gt;(b:player) return a.id as src, b.id as dst, r.degree as degree  order by id(r)\"\n      fields: [degree]\n      nebula.fields: [degree]\n      source: {\n        field: src\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n      target: {\n        field: dst\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n      #ranking: rank\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      partition: 10\n      batch: 1000\n      check_point_path: /tmp/test\n    }\n   # Set the information about the Edge Type serve\n   {\n      name: serve\n      type: {\n        source: neo4j\n        sink: client\n      }\n      server: \"bolt://192.168.*.*:7687\"\n      user: neo4j\n      password:neo4j\n      database:neo4j\n      exec: \"match (a:player)-[r:serve]-&gt;(b:team) return a.id as src, b.id as dst, r.start_year as start_year, r.end_year as end_year  order by id(r)\"\n      fields: [start_year,end_year]\n      nebula.fields: [start_year,end_year]\n      source: {\n        field: src\n      }\n      target: {\n        field: dst\n      }\n      #ranking: rank\n      partition: 10\n      batch: 1000\n      check_point_path: /tmp/test\n    }\n   ]\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#exec_configuration","title":"Exec configuration","text":"<p>When configuring either the <code>tags.exec</code> or <code>edges.exec</code> parameters, you need to fill in the Cypher query. To prevent loss of data during import, it is strongly recommended to include <code>ORDER BY</code> clause in Cypher queries. Meanwhile, in order to improve data import efficiency, it is better to select indexed properties for ordering. If there is no index, users can also observe the default order and select the appropriate properties for ordering to improve efficiency. If the pattern of the default order cannot be found, users can order them by the ID of the vertex or relationship and set the <code>partition</code> to a small value to reduce the ordering pressure of Neo4j.</p> <p>Note</p> <p>Using the <code>ORDER BY</code> clause lengthens the data import time.</p> <p>Exchange needs to execute different <code>SKIP</code> and <code>LIMIT</code> Cypher statements on different Spark partitions, so <code>SKIP</code> and <code>LIMIT</code> clauses cannot be included in the Cypher statements corresponding to <code>tags.exec</code> and <code>edges.exec</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#tagsvertex_or_edgesvertex_configuration","title":"tags.vertex or edges.vertex configuration","text":"<p>NebulaGraph uses ID as the unique primary key when creating vertexes and edges, overwriting the data in that primary key if it already exists. So, if a Neo4j property value is given as the NebulaGraph'S ID and the value is duplicated in Neo4j, duplicate IDs will be generated. One and only one of their corresponding data will be stored in the NebulaGraph, and the others will be overwritten. Because the data import process is concurrently writing data to NebulaGraph, the final saved data is not guaranteed to be the latest data in Neo4j.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#check_point_path_configuration","title":"check_point_path configuration","text":"<p>If breakpoint transfers are enabled, to avoid data loss, the state of the database should not change between the breakpoint and the transfer. For example, data cannot be added or deleted, and the <code>partition</code> quantity configuration should not be changed.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#step_4_import_data_into_nebulagraph","title":"Step 4: Import data into NebulaGraph","text":"<p>Run the following command to import Neo4j data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;neo4j_application.conf_path&gt; \n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/neo4j_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#step_5_optional_validate_data","title":"Step 5: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the <code>SHOW STATS</code> command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-neo4j/#step_6_optional_rebuild_indexes_in_nebulagraph","title":"Step 6: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/","title":"Import data from Oracle","text":"<p>This topic provides an example of how to use Exchange to export Oracle data and import to NebulaGraph.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p> <p>In this example, the data set has been stored in Oracle. All vertexes and edges are stored in the <code>player</code>, <code>team</code>, <code>follow</code>, and <code>serve</code> tables. The following are some of the data for each table.</p> <pre><code>oracle&gt; desc player;\n+-----------+-------+---------------+ \n| Column    | Null  | Type          |\n+-----------+-------+---------------+ \n| PLAYERID  |  -    | VARCHAR2(30)  |\n| NAME      |  -    | VARCHAR2(30)  |\n| AGE       |  -    | NUMBER        |\n+-----------+-------+---------------+ \n\noracle&gt; desc team;\n+-----------+-------+---------------+ \n| Column    | Null  | Type          |\n+-----------+-------+---------------+ \n| TEAMID    |  -    | VARCHAR2(30)  |\n| NAME      |  -    | VARCHAR2(30)  |\n+-----------+-------+---------------+ \n\noracle&gt; desc follow;\n+-------------+-------+---------------+ \n| Column      | Null  | Type          |\n+-------------+-------+---------------+ \n| SRC_PLAYER  |  -    | VARCHAR2(30)  |\n| DST_PLAYER  |  -    | VARCHAR2(30)  |\n| DEGREE      |  -    | NUMBER        |\n+-------------+-------+---------------+ \n\noracle&gt; desc serve;\n+------------+-------+---------------+ \n| Column     | Null  | Type          |\n+------------+-------+---------------+ \n| PLAYERID   |  -    | VARCHAR2(30)  |\n| TEAMID     |  -    | VARCHAR2(30)  |\n| START_YEAR |  -    | NUMBER        |\n| END_YEAR   |  -    | NUMBER        |\n+------------+-------+---------------+ \n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul> <ul> <li>The Hadoop service has been installed and started.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/#precautions","title":"Precautions","text":"<p>nebula-exchange_spark_2.2 supports only single table queries, not multi-table queries.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/#step_2_modify_configuration_files","title":"Step 2: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set Oracle data source configuration. In this case, the copied file is called <code>oracle_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    cores: {\n      max: 16\n    }\n  }\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n      # The Tag name in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to Oracle.\n        source: oracle\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      url:\"jdbc:oracle:thin:@host:1521:basketball\"\n      driver: \"oracle.jdbc.driver.OracleDriver\"\n      user: \"root\"\n      password: \"123456\"\n\n      # Scanning a single table to read data.\n      # nebula-exchange_spark_2.2 must configure this parameter. Sentence is not supported.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as sentence.\n      table:\"basketball.player\"\n\n      # Use query statement to read data.\n      # This parameter is not supported by nebula-exchange_spark_2.2.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as table. Multi-table queries are supported.\n      # sentence: \"select * from people, player, team\"\n\n      # Specify the column names in the player table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [age,name]\n      nebula.fields: [age,name]\n\n      # Specify a column of data in the table as the source of VIDs in the NebulaGraph.\n      vertex: {\n        field:playerid\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n    # Set the information about the Tag Team.\n    {\n      name: team\n      type: {\n        source: oracle\n        sink: client\n      }\n\n      url:\"jdbc:oracle:thin:@host:1521:basketball\"\n      driver: \"oracle.jdbc.driver.OracleDriver\"\n      user: \"root\"\n      password: \"123456\"\n      table: \"basketball.team\"\n      sentence: \"select teamid, name from team\"\n\n      fields: [name]\n      nebula.fields: [name]\n      vertex: {\n        field: teamid\n      }\n      batch: 256\n      partition: 32\n    }\n\n  ]\n\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # The corresponding Edge Type name in NebulaGraph.\n      name: follow\n\n      type: {\n        # Specify the data source file format to Oracle.\n        source: oracle\n\n        # Specify how to import the Edge type data into NebulaGraph.\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      url:\"jdbc:oracle:thin:@host:1521:basketball\"\n      driver: \"oracle.jdbc.driver.OracleDriver\"\n      user: \"root\"\n      password: \"123456\"\n\n      # Scanning a single table to read data.\n      # nebula-exchange_spark_2.2 must configure this parameter. Sentence is not supported.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as sentence.\n      table:\"basketball.follow\"\n\n      # Use query statement to read data.\n      # This parameter is not supported by nebula-exchange_spark_2.2.\n      # nebula-exchange_spark_2.4 and nebula-exchange_spark_3.0 can configure this parameter, but not at the same time as table. Multi-table queries are supported.\n      # sentence: \"select * from follow, serve\"\n\n      # Specify the column names in the follow table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [degree]\n      nebula.fields: [degree]\n\n      # In source, use a column in the follow table as the source of the edge's source vertex.\n      # In target, use a column in the follow table as the source of the edge's destination vertex.\n      source: {\n        field: src_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      target: {\n        field: dst_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Edge Type serve.\n    {\n      name: serve\n      type: {\n        source: oracle\n        sink: client\n      }\n\n      url:\"jdbc:oracle:thin:@host:1521:basketball\"\n      driver: \"oracle.jdbc.driver.OracleDriver\"\n      user: \"root\"\n      password: \"123456\"\n      table: \"basketball.serve\"\n      sentence: \"select playerid, teamid, start_year, end_year from serve\"\n\n      fields: [start_year,end_year]\n      nebula.fields: [start_year,end_year]\n      source: {\n        field: playerid\n      }\n      target: {\n        field: teamid\n      }\n      batch: 256\n      partition: 32\n    }\n  ]\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/#step_3_import_data_into_nebulagraph","title":"Step 3: Import data into NebulaGraph","text":"<p>Run the following command to import Oracle data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;oracle_application.conf_path&gt;\n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/oracle_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/#step_4_optional_validate_data","title":"Step 4: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the SHOW STATS command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-oracle/#step_5_optional_rebuild_indexes_in_nebulagraph","title":"Step 5: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/","title":"Import data from ORC files","text":"<p>This topic provides an example of how to use Exchange to import NebulaGraph data stored in HDFS or local ORC files.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>Hadoop: 2.9.2, pseudo-distributed deployment</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul> <ul> <li>If files are stored in HDFS, ensure that the Hadoop service is running properly.</li> </ul> <ul> <li>If files are stored locally and NebulaGraph is a cluster architecture, you need to place the files in the same directory locally on each machine in the cluster.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#step_2_process_orc_files","title":"Step 2: Process ORC files","text":"<p>Confirm the following information:</p> <ol> <li> <p>Process ORC files to meet Schema requirements.</p> </li> <li> <p>Obtain the ORC file storage path.</p> </li> </ol>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#step_3_modify_configuration_files","title":"Step 3: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set ORC data source configuration. In this example, the copied file is called <code>orc_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    executor: {\n        memory:1G\n    }\n\n    cores: {\n      max: 16\n    }\n  }\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and all Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n      name: player\n      type: {\n        # Specify the data source file format to ORC.\n        source: orc\n\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Specify the path to the ORC file.\n      # If the file is stored in HDFS, use double quotation marks to enclose the file path, starting with hdfs://. For example, \"hdfs://ip:port/xx/xx\".\n      # If the file is stored locally, use double quotation marks to enclose the file path, starting with file://. For example, \"file:///tmp/xx.orc\".\n      path: \"hdfs://192.168.*.*:9000/data/vertex_player.orc\"\n\n      # Specify the key name in the ORC file in fields, and its corresponding value will serve as the data source for the properties specified in the NebulaGraph.\n      # If multiple values need to be specified, separate them with commas.\n      fields: [age,name]\n\n      # Specify the property names defined in NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      nebula.fields: [age, name]\n\n      # Specify a column of data in the table as the source of VIDs in the NebulaGraph.\n      # The value of vertex must be consistent with the field in the ORC file.\n      # Currently, NebulaGraph 3.8.0 supports only strings or integers of VID.\n      vertex: {\n        field:id\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Tag team.\n    {\n      name: team\n      type: {\n        source: orc\n        sink: client\n      }\n      path: \"hdfs://192.168.*.*:9000/data/vertex_team.orc\"\n      fields: [name]\n      nebula.fields: [name]\n      vertex: {\n        field:id\n      }\n      batch: 256\n      partition: 32\n    }\n\n\n\n    # If more vertexes need to be added, refer to the previous configuration to add them.\n  ]\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # Specify the Edge Type name defined in NebulaGraph.\n      name: follow\n      type: {\n        # Specify the data source file format to ORC.\n        source: orc\n\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Specify the path to the ORC file.\n      # If the file is stored in HDFS, use double quotation marks to enclose the file path, starting with hdfs://. For example, \"hdfs://ip:port/xx/xx\".\n      # If the file is stored locally, use double quotation marks to enclose the file path, starting with file://. For example, \"file:///tmp/xx.orc\".\n      path: \"hdfs://192.168.*.*:9000/data/edge_follow.orc\"\n\n      # Specify the key name in the ORC file in fields, and its corresponding value will serve as the data source for the properties specified in the NebulaGraph.\n      # If multiple values need to be specified, separate them with commas.\n      fields: [degree]\n\n      # Specify the property names defined in NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      nebula.fields: [degree]\n\n      # Specify a column as the source for the source and destination vertexes.\n      # The value of vertex must be consistent with the field in the ORC file.\n      # Currently, NebulaGraph 3.8.0 supports only strings or integers of VID.\n      source: {\n        field: src\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n      target: {\n        field: dst\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Edge type serve.\n    {\n      name: serve\n      type: {\n        source: orc\n        sink: client\n      }\n      path: \"hdfs://192.168.*.*:9000/data/edge_serve.orc\"\n      fields: [start_year,end_year]\n      nebula.fields: [start_year, end_year]\n      source: {\n        field: src\n      }\n      target: {\n        field: dst\n      }\n      batch: 256\n      partition: 32\n    }\n\n  # If more edges need to be added, refer to the previous configuration to add them.\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#step_4_import_data_into_nebulagraph","title":"Step 4: Import data into NebulaGraph","text":"<p>Run the following command to import ORC data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;orc_application.conf_path&gt; \n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/orc_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#access_hdfs_data_with_kerberos_certification","title":"Access HDFS data with Kerberos certification","text":"<p>When using Kerberos for security certification, you can access the HDFS data in one of the following ways.</p> <ul> <li> <p>Configure the Kerberos configuration file in a command</p> <p>Configure <code>--conf</code> and <code>--files</code> in the command, for example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master xxx  --num-executors 2 --executor-cores 2 --executor-memory 1g \\\n--conf \"spark.driver.extraJavaOptions=-Djava.security.krb5.conf=./krb5.conf\" \\\n--conf \"spark.executor.extraJavaOptions=-Djava.security.krb5.conf=./krb5.conf\" \\\n--files /local/path/to/xxx.keytab,/local/path/to/krb5.conf \\\n--class  com.vesoft.nebula.exchange.Exchange  \\\nexchange.jar -c xx.conf\n</code></pre> <p>The file path in <code>--conf</code> can be configured in two ways as follows:</p> <ul> <li>Configure the absolute path to the file. All YARN or Spark machines are required to have the corresponding file in the same path.</li> <li>(Recommended in YARN mode) Configure the relative path to the file (e.g. <code>./krb5.conf</code>). The resource files uploaded via <code>--files</code> are located in the working directory of the Java virtual machine or JAR.</li> </ul> <p>The files in <code>--files</code> must be stored on the machine where the <code>spark-submit</code> command is executed.</p> </li> </ul> <ul> <li> <p>Without commands</p> <p>Deploy the Spark and Kerberos-certified Hadoop in a same cluster to make them share HDFS and YARN, and then add the configuration <code>export HADOOP_HOME=&lt;hadoop_home_path&gt;</code> to <code>spark-env.sh</code> in Spark.</p> </li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#step_5_optional_validate_data","title":"Step 5: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the <code>SHOW STATS</code> command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-orc/#step_6_optional_rebuild_indexes_in_nebulagraph","title":"Step 6: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/","title":"Import data from Parquet files","text":"<p>This topic provides an example of how to use Exchange to import NebulaGraph data stored in HDFS or local Parquet files.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>Hadoop: 2.9.2, pseudo-distributed deployment</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul> <ul> <li>If files are stored in HDFS, ensure that the Hadoop service is running properly.</li> </ul> <ul> <li>If files are stored locally and NebulaGraph is a cluster architecture, you need to place the files in the same directory locally on each machine in the cluster.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space.\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer.\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player.\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team.\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow.\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve.\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#step_2_process_parquet_files","title":"Step 2: Process Parquet files","text":"<p>Confirm the following information:</p> <ol> <li> <p>Process Parquet files to meet Schema requirements.</p> </li> <li> <p>Obtain the Parquet file storage path.</p> </li> </ol>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#step_3_modify_configuration_files","title":"Step 3: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set Parquet data source configuration. In this example, the copied file is called <code>parquet_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    executor: {\n        memory:1G\n    }\n\n    cores: {\n      max: 16\n    }\n  }\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and all Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n\n  # Processing vertexes\n  tags: [\n    # Set the information about the Tag player.\n    {\n      # Specify the Tag name defined in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to Parquet.\n        source: parquet\n\n        # Specifies how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Specify the path to the Parquet file.\n      # If the file is stored in HDFS, use double quotation marks to enclose the file path, starting with hdfs://. For example, \"hdfs://ip:port/xx/xx\".\n      # If the file is stored locally, use double quotation marks to enclose the file path, starting with file://. For example, \"file:///tmp/xx.parquet\".\n      path: \"hdfs://192.168.*.13:9000/data/vertex_player.parquet\"\n\n      # Specify the key name in the Parquet file in fields, and its corresponding value will serve as the data source for the properties specified in the NebulaGraph.\n      # If multiple values need to be specified, separate them with commas.\n      fields: [age,name]\n\n      # Specify the property name defined in NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      nebula.fields: [age, name]\n\n      # Specify a column of data in the table as the source of VIDs in the NebulaGraph.\n      # The value of vertex must be consistent with the field in the Parquet file.\n      # Currently, NebulaGraph 3.8.0 supports only strings or integers of VID.\n      vertex: {\n        field:id\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Tag team.\n    {\n      name: team\n      type: {\n        source: parquet\n        sink: client\n      }\n      path: \"hdfs://192.168.11.13:9000/data/vertex_team.parquet\"\n      fields: [name]\n      nebula.fields: [name]\n      vertex: {\n        field:id\n      }\n      batch: 256\n      partition: 32\n    }\n\n\n    # If more vertexes need to be added, refer to the previous configuration to add them.\n  ]\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # Specify the Edge Type name defined in NebulaGraph.\n      name: follow\n      type: {\n        # Specify the data source file format to Parquet.\n        source: parquet\n\n        # Specifies how to import the data into NebulaGraph: Client or SST.\n        sink: client\n      }\n\n      # Specify the path to the Parquet file.\n      # If the file is stored in HDFS, use double quotation marks to enclose the file path, starting with hdfs://. For example, \"hdfs://ip:port/xx/xx\".\n      # If the file is stored locally, use double quotation marks to enclose the file path, starting with file://. For example, \"file:///tmp/xx.parquet\".\n      path: \"hdfs://192.168.11.13:9000/data/edge_follow.parquet\"\n\n      # Specify the key name in the Parquet file in fields, and its corresponding value will serve as the data source for the properties specified in the NebulaGraph.\n      # If multiple values need to be specified, separate them with commas.\n      fields: [degree]\n\n      # Specify the property name defined in NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      nebula.fields: [degree]\n\n      # Specify a column as the source for the source and destination vertexes.\n      # The values of vertex must be consistent with the fields in the Parquet file.\n      # Currently, NebulaGraph 3.8.0 supports only strings or integers of VID.\n      source: {\n        field: src\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n      target: {\n        field: dst\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n    }\n\n    # Set the information about the Edge type serve.\n    {\n      name: serve\n      type: {\n        source: parquet\n        sink: client\n      }\n      path: \"hdfs://192.168.11.13:9000/data/edge_serve.parquet\"\n      fields: [start_year,end_year]\n      nebula.fields: [start_year, end_year]\n      source: {\n        field: src\n      }\n      target: {\n        field: dst\n      }\n      batch: 256\n      partition: 32\n    }\n\n  ]\n  # If more edges need to be added, refer to the previous configuration to add them.\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#step_4_import_data_into_nebulagraph","title":"Step 4: Import data into NebulaGraph","text":"<p>Run the following command to import Parquet data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;parquet_application.conf_path&gt; \n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/parquet_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#access_hdfs_data_with_kerberos_certification","title":"Access HDFS data with Kerberos certification","text":"<p>When using Kerberos for security certification, you can access the HDFS data in one of the following ways.</p> <ul> <li> <p>Configure the Kerberos configuration file in a command</p> <p>Configure <code>--conf</code> and <code>--files</code> in the command, for example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master xxx  --num-executors 2 --executor-cores 2 --executor-memory 1g \\\n--conf \"spark.driver.extraJavaOptions=-Djava.security.krb5.conf=./krb5.conf\" \\\n--conf \"spark.executor.extraJavaOptions=-Djava.security.krb5.conf=./krb5.conf\" \\\n--files /local/path/to/xxx.keytab,/local/path/to/krb5.conf \\\n--class  com.vesoft.nebula.exchange.Exchange  \\\nexchange.jar -c xx.conf\n</code></pre> <p>The file path in <code>--conf</code> can be configured in two ways as follows:</p> <ul> <li>Configure the absolute path to the file. All YARN or Spark machines are required to have the corresponding file in the same path.</li> <li>(Recommended in YARN mode) Configure the relative path to the file (e.g. <code>./krb5.conf</code>). The resource files uploaded via <code>--files</code> are located in the working directory of the Java virtual machine or JAR.</li> </ul> <p>The files in <code>--files</code> must be stored on the machine where the <code>spark-submit</code> command is executed.</p> </li> </ul> <ul> <li> <p>Without commands</p> <p>Deploy the Spark and Kerberos-certified Hadoop in a same cluster to make them share HDFS and YARN, and then add the configuration <code>export HADOOP_HOME=&lt;hadoop_home_path&gt;</code> to <code>spark-env.sh</code> in Spark.</p> </li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#step_5_optional_validate_data","title":"Step 5: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the <code>SHOW STATS</code> command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-parquet/#step_6_optional_rebuild_indexes_in_nebulagraph","title":"Step 6: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-pulsar/","title":"Import data from Pulsar","text":"<p>This topic provides an example of how to use Exchange to import NebulaGraph data stored in Pulsar.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-pulsar/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>NebulaGraph: 3.8.0. Deploy NebulaGraph with Docker Compose.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-pulsar/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>Learn about the Schema created in NebulaGraph, including names and properties of Tags and Edge types, and more.</li> </ul> <ul> <li>The Pulsar service has been installed and started.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-pulsar/#precautions","title":"Precautions","text":"<ul> <li>Only client mode is supported when importing Pulsar data, i.e. the value of parameters <code>tags.type.sink</code> and <code>edges.type.sink</code> is <code>client</code>.</li> </ul> <ul> <li>When importing Pulsar data, do not use Exchange version 3.4.0, which adds caching of imported data and does not support streaming data import. Use Exchange versions 3.0.0, 3.3.0, or 3.5.0.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-pulsar/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-pulsar/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-pulsar/#step_2_modify_configuration_files","title":"Step 2: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set Pulsar data source configuration. In this example, the copied file is called <code>pulsar_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n    cores: {\n      max: 16\n    }\n  }\n\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      # Specify the IP addresses and ports for Graph and all Meta services.\n      # If there are multiple addresses, the format is \"ip1:port\",\"ip2:port\",\"ip3:port\".\n      # Addresses are separated by commas.\n      graph:[\"127.0.0.1:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"127.0.0.1:9559\"]\n    }\n\n    # The account entered must have write permission for the NebulaGraph space.\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    # Fill in the name of the graph space you want to write data to in the NebulaGraph.\n    space: basketballplayer\n    connection: {\n      timeout: 3000\n      retry: 3\n    }\n    execution: {\n      retry: 3\n    }\n    error: {\n      max: 32\n      output: /tmp/errors\n    }\n    rate: {\n      limit: 1024\n      timeout: 1000\n    }\n  }\n  # Processing vertices\n  tags: [\n    # Set the information about the Tag player.\n    {\n      # The corresponding Tag name in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to Pulsar.\n        source: pulsar\n        # Specify how to import the data into NebulaGraph. Only client is supported.\n        sink: client\n      }\n      # The address of the Pulsar server.\n      service: \"pulsar://127.0.0.1:6650\"\n      # admin.url of pulsar.\n      admin: \"http://127.0.0.1:8081\"\n      # The Pulsar option can be configured from topic, topics or topicsPattern.\n      options: {\n        topics: \"topic1,topic2\"\n      }\n\n      # Specify the column names in the player table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [age,name]\n      nebula.fields: [age,name]\n\n      # Specify a column of data in the table as the source of VIDs in the NebulaGraph.\n      vertex:{\n          field:playerid\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # Whether or not to delete the related incoming and outgoing edges of the vertices when performing a batch delete operation. This parameter takes effect when `writeMode` is `DELETE`.\n      #deleteEdge: false\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 10\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 10\n      # The interval for message reading. Unit: second.\n      interval.seconds: 10\n    }\n    # Set the information about the Tag Team.\n    {\n      name: team\n      type: {\n        source: pulsar\n        sink: client\n      }\n      service: \"pulsar://127.0.0.1:6650\"\n      admin: \"http://127.0.0.1:8081\"\n      options: {\n        topics: \"topic1,topic2\"\n      }\n      fields: [name]\n      nebula.fields: [name]\n      vertex:{\n          field:teamid\n      }\n      batch: 10\n      partition: 10\n      interval.seconds: 10\n    }\n\n  ]\n\n  # Processing edges\n  edges: [\n    # Set the information about Edge Type follow\n    {\n      # The corresponding Edge Type name in NebulaGraph.\n      name: follow\n\n      type: {\n        # Specify the data source file format to Pulsar.\n        source: pulsar\n\n        # Specify how to import the Edge type data into NebulaGraph.\n        # Specify how to import the data into NebulaGraph. Only client is supported.\n        sink: client\n      }\n\n      # The address of the Pulsar server.\n      service: \"pulsar://127.0.0.1:6650\"\n      # admin.url of pulsar.\n      admin: \"http://127.0.0.1:8081\"\n      # The Pulsar option can be configured from topic, topics or topicsPattern.\n      options: {\n        topics: \"topic1,topic2\"\n      }\n\n      # Specify the column names in the follow table in fields, and their corresponding values are specified as properties in the NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      # If multiple column names need to be specified, separate them by commas.\n      fields: [degree]\n      nebula.fields: [degree]\n\n      # In source, use a column in the follow table as the source of the edge's source vertex.\n      # In target, use a column in the follow table as the source of the edge's destination vertex.\n      source:{\n          field:src_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      target:{\n          field:dst_player\n      # udf:{\n      #            separator:\"_\"\n      #            oldColNames:[field-0,field-1,field-2]\n      #            newColName:new-field\n      #        }\n      # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 10\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 10\n\n      # The interval for message reading. Unit: second.\n      interval.seconds: 10\n    }\n\n    # Set the information about the Edge Type serve\n    {\n      name: serve\n      type: {\n        source: Pulsar\n        sink: client\n      }\n      service: \"pulsar://127.0.0.1:6650\"\n      admin: \"http://127.0.0.1:8081\"\n      options: {\n        topics: \"topic1,topic2\"\n      }\n\n      fields: [start_year,end_year]\n      nebula.fields: [start_year,end_year]\n      source:{\n          field:playerid\n      }\n\n      target:{\n          field:teamid\n      }\n\n      # (Optional) Specify a column as the source of the rank.\n      #ranking: rank\n\n      batch: 10\n      partition: 10\n      interval.seconds: 10\n    }\n  ]\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-pulsar/#step_3_import_data_into_nebulagraph","title":"Step 3: Import data into NebulaGraph","text":"<p>Run the following command to import Pulsar data into NebulaGraph. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;pulsar_application.conf_path&gt;\n</code></pre> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/pulsar_application.conf\n</code></pre> <p>You can search for <code>batchSuccess.&lt;tag_name/edge_name&gt;</code> in the command output to check the number of successes. For example, <code>batchSuccess.follow: 300</code>.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-pulsar/#step_4_optional_validate_data","title":"Step 4: (optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the <code>SHOW STATS</code> command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-pulsar/#step_5_optional_rebuild_indexes_in_nebulagraph","title":"Step 5: (optional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/","title":"Import data from SST files","text":"<p>This topic provides an example of how to generate the data from the data source into an SST (Sorted String Table) file and save it on HDFS, and then import it into NebulaGraph. The sample data source is a CSV file.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#precautions","title":"Precautions","text":"<ul> <li>The SST file can be imported only in Linux.</li> </ul> <ul> <li>The default value of the property is not supported.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#background_information","title":"Background information","text":"<p>Exchange supports two data import modes:</p> <ul> <li>Import the data from the data source directly into NebulaGraph as nGQL statements.</li> </ul> <ul> <li>Generate the SST file from the data source, and use Console to import the SST file into NebulaGraph.</li> </ul> <p>The following describes the scenarios, implementation methods, prerequisites, and steps for generating an SST file and importing data.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#scenarios","title":"Scenarios","text":"<ul> <li> <p>Suitable for online services, because the generation almost does not affect services (just reads the Schema), and the import speed is fast.</p> <p>Caution</p> <p>Although the import speed is fast, write operations in the corresponding space are blocked during the import period (about 10 seconds). Therefore, you are advised to import data in off-peak hours.</p> </li> </ul> <ul> <li>Suitable for scenarios with a large amount of data from data sources for its fast import speed.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#implementation_methods","title":"Implementation methods","text":"<p>The underlying code in NebulaGraph uses RocksDB as the key-value storage engine. RocksDB is a storage engine based on the hard disk, providing a series of APIs for creating and importing SST files to help quickly import massive data.</p> <p>The SST file is an internal file containing an arbitrarily long set of ordered key-value pairs for efficient storage of large amounts of key-value data. The entire process of generating SST files is mainly done by Exchange Reader, sstProcessor, and sstWriter. The whole data processing steps are as follows:</p> <ol> <li> <p>Reader reads data from the data source.</p> </li> <li> <p>sstProcessor generates the SST file from the NebulaGraph's Schema information and uploads it to the HDFS. For details about the format of the SST file, see Data Storage Format.</p> </li> <li> <p>sstWriter opens a file and inserts data. When generating SST files, keys must be written in sequence.</p> </li> <li> <p>After the SST file is generated, RocksDB imports the SST file into NebulaGraph using the <code>IngestExternalFile()</code> method. For example:</p> <pre><code>IngestExternalFileOptions ifo;\n# Import two SST files\nStatus s = db_-&gt;IngestExternalFile({\"/home/usr/file1.sst\", \"/home/usr/file2.sst\"}, ifo);\nif (!s.ok()) {\n  printf(\"Error while adding file %s and %s, Error %s\\n\",\n         file_path1.c_str(), file_path2.c_str(), s.ToString().c_str());\n  return 1;\n}\n</code></pre> <p>When the <code>IngestExternalFile()</code> method is called, RocksDB copies the file to the data directory by default and blocks the RocksDB write operation. If the key range in the SST file overwrites the Memtable key range, flush the Memtable to the hard disk. After placing the SST file in an optimal location in the LSM tree, assign a global serial number to the file and turn on the write operation.</p> </li> </ol>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#data_set","title":"Data set","text":"<p>This topic takes the basketballplayer dataset as an example.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#environment","title":"Environment","text":"<p>This example is done on MacOS. Here is the environment configuration information:</p> <ul> <li>Hardware specifications:<ul> <li>CPU: 1.7 GHz Quad-Core Intel Core i7</li> <li>Memory: 16 GB</li> </ul> </li> </ul> <ul> <li>Spark: 2.4.7, stand-alone</li> </ul> <ul> <li>Hadoop: 2.9.2, pseudo-distributed deployment</li> </ul> <ul> <li>NebulaGraph: 3.8.0.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#prerequisites","title":"Prerequisites","text":"<p>Before importing data, you need to confirm the following information:</p> <ul> <li> <p>NebulaGraph has been installed and deployed with the following information:</p> <ul> <li>IP addresses and ports of Graph and Meta services.</li> </ul> <ul> <li>The user name and password with write permission to NebulaGraph.</li> </ul> <ul> <li><code>--ws_storage_http_port</code> in the Meta service configuration file is the same as <code>--ws_http_port</code> in the Storage service configuration file. For example, <code>19779</code>.</li> </ul> <ul> <li><code>--ws_meta_http_port</code> in the Graph service configuration file is the same as <code>--ws_http_port</code> in the Meta service configuration file. For example, <code>19559</code>.</li> </ul> <ul> <li>The information about the Schema, including names and properties of Tags and Edge types, and more.</li> </ul> </li> </ul> <ul> <li>Exchange has been compiled, or download the compiled <code>.jar</code> file directly.</li> </ul> <ul> <li>Spark has been installed.</li> </ul> <ul> <li>JDK 1.8 or the later version has been installed and the environment variable <code>JAVA_HOME</code> has been configured.</li> </ul> <ul> <li> <p>The Hadoop service has been installed and started.</p> <p>Note</p> <ul> <li>To generate SST files of other data sources, see documents of the corresponding data source and check the prerequisites.</li> </ul> <ul> <li>To generate SST files only, users do not need to install the Hadoop service on the machine where the Storage service is deployed.</li> </ul> <ul> <li>To delete the SST file after the ingest (data import) operation, add the configuration <code>-- move_Files =true</code> to the Storage Service configuration file.</li> </ul> </li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#steps","title":"Steps","text":""},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#step_1_create_the_schema_in_nebulagraph","title":"Step 1: Create the Schema in NebulaGraph","text":"<p>Analyze the data to create a Schema in NebulaGraph by following these steps:</p> <ol> <li> <p>Identify the Schema elements. The Schema elements in the NebulaGraph are shown in the following table.</p> Element Name Property Tag <code>player</code> <code>name string, age int</code> Tag <code>team</code> <code>name string</code> Edge Type <code>follow</code> <code>degree int</code> Edge Type <code>serve</code> <code>start_year int, end_year int</code> </li> <li> <p>Create a graph space basketballplayer in the NebulaGraph and create a Schema as shown below.</p> <pre><code>## Create a graph space\nnebula&gt; CREATE SPACE basketballplayer \\\n        (partition_num = 10, \\\n        replica_factor = 1, \\\n        vid_type = FIXED_STRING(30));\n\n## Use the graph space basketballplayer\nnebula&gt; USE basketballplayer;\n\n## Create the Tag player\nnebula&gt; CREATE TAG player(name string, age int);\n\n## Create the Tag team\nnebula&gt; CREATE TAG team(name string);\n\n## Create the Edge type follow\nnebula&gt; CREATE EDGE follow(degree int);\n\n## Create the Edge type serve\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>For more information, see Quick start workflow.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#step_2_process_csv_files","title":"Step 2: Process CSV files","text":"<p>Confirm the following information:</p> <ol> <li> <p>Process CSV files to meet Schema requirements.</p> <p>Note</p> <p>Exchange supports uploading CSV files with or without headers.</p> </li> <li> <p>Obtain the CSV file storage path.</p> </li> </ol>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#step_3_modify_configuration_files","title":"Step 3: Modify configuration files","text":"<p>After Exchange is compiled, copy the conf file <code>target/classes/application.conf</code> to set SST data source configuration. In this example, the copied file is called <code>sst_application.conf</code>. For details on each configuration item, see Parameters in the configuration file.</p> <pre><code>{\n  # Spark configuration\n  spark: {\n    app: {\n      name: NebulaGraph Exchange 3.8.0\n    }\n\n    master:local\n\n    driver: {\n      cores: 1\n      maxResultSize: 1G\n    }\n\n    executor: {\n        memory:1G\n    }\n\n    cores:{\n      max: 16\n    }\n  }\n\n  # NebulaGraph configuration\n  nebula: {\n    address:{\n      graph:[\"192.8.168.XXX:9669\"]\n      # the address of any of the meta services.\n      # if your NebulaGraph server is in virtual network like k8s, please config the leader address of meta.\n      meta:[\"192.8.168.XXX:9559\"]\n    }\n    user: root\n    pswd: nebula\n    # Whether to use a password encrypted with RSA.\n    # enableRSA: true\n    # The key used to encrypt the password using RSA.\n    # privateKey: \"\"\n\n    space: basketballplayer\n\n    # SST file configuration\n    path:{\n        # The local directory that temporarily stores generated SST files\n        local:\"/tmp\"\n\n        # The path for storing the SST file in the HDFS\n        remote:\"/sst\"\n\n        # The NameNode address of HDFS, for example, \"hdfs://&lt;ip/hostname&gt;:&lt;port&gt;\"\n        hdfs.namenode: \"hdfs://*.*.*.*:9000\"\n    }\n\n    # The connection parameters of clients\n    connection: {\n      # The timeout duration of socket connection and execution. Unit: milliseconds.\n      timeout: 30000\n    }\n\n    error: {\n      # The maximum number of failures that will exit the application.\n      max: 32\n      # Failed import jobs are logged in the output path.\n      output: /tmp/errors\n    }\n\n    # Use Google's RateLimiter to limit requests to NebulaGraph.\n    rate: {\n      # Steady throughput of RateLimiter.\n      limit: 1024\n\n      # Get the allowed timeout duration from RateLimiter. Unit: milliseconds.\n      timeout: 1000\n    }\n  }\n\n\n  # Processing vertices\n  tags: [\n    # Set the information about the Tag player.\n    {\n      # Specify the Tag name defined in NebulaGraph.\n      name: player\n      type: {\n        # Specify the data source file format to CSV.\n        source: csv\n\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: sst\n      }\n\n      # Specify the path to the CSV file.\n      # If the file is stored in HDFS, use double quotation marks to enclose the file path, starting with hdfs://. For example, \"hdfs://&lt;ip/hostname&gt;:port/xx/xx.csv\".\n      path: \"hdfs://*.*.*.*:9000/dataset/vertex_player.csv\"\n\n      # If the CSV file does not have a header, use [_c0, _c1, _c2, ..., _cn] to represent its header and indicate the columns as the source of the property values.\n      # If the CSV file has a header, use the actual column name.\n      fields: [_c1, _c2]\n\n      # Specify the property name defined in NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      nebula.fields: [age, name]\n\n      # Specify a column of data in the table as the source of VIDs in NebulaGraph.\n      # The value of vertex must be consistent with the column name in the above fields or csv.fields.\n      # Currently, NebulaGraph 3.8.0 supports only strings or integers of VID.\n      vertex: {\n        field:_c0\n        # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The delimiter specified. The default value is comma.\n      separator: \",\"\n\n      # If the CSV file has a header, set the header to true.\n      # If the CSV file does not have a header, set the header to false. The default value is false.\n      header: false\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n\n      # Whether to repartition data based on the number of partitions of graph spaces in NebulaGraph when generating the SST file.\n      repartitionWithNebula: false\n    }\n\n    # Set the information about the Tag Team.\n    {\n      name: team\n      type: {\n        source: csv\n        sink: sst\n      }\n      path: \"hdfs://*.*.*.*:9000/dataset/vertex_team.csv\"\n      fields: [_c1]\n      nebula.fields: [name]\n      vertex: {\n        field:_c0\n      }\n      separator: \",\"\n      header: false\n      batch: 256\n      partition: 32\n      repartitionWithNebula: false\n    }\n    # If more vertices need to be added, refer to the previous configuration to add them.\n  ]\n  # Processing edges\n  edges: [\n    # Set the information about the Edge Type follow.\n    {\n      # The Edge Type name defined in NebulaGraph.\n      name: follow\n      type: {\n        # Specify the data source file format to CSV.\n        source: csv\n\n        # Specify how to import the data into NebulaGraph: Client or SST.\n        sink: sst\n      }\n\n      # Specify the path to the CSV file.\n      # If the file is stored in HDFS, use double quotation marks to enclose the file path, starting with hdfs://. For example, \"hdfs://&lt;ip/hostname&gt;:port/xx/xx.csv\".\n      path: \"hdfs://*.*.*.*:9000/dataset/edge_follow.csv\"\n\n      # If the CSV file does not have a header, use [_c0, _c1, _c2, ..., _cn] to represent its header and indicate the columns as the source of the property values.\n      # If the CSV file has a header, use the actual column name.\n      fields: [_c2]\n\n      # Specify the property name defined in NebulaGraph.\n      # The sequence of fields and nebula.fields must correspond to each other.\n      nebula.fields: [degree]\n\n      # Specify a column as the source for the source and destination vertices.\n      # The value of vertex must be consistent with the column name in the above fields or csv.fields.\n      # Currently, NebulaGraph 3.8.0 supports only strings or integers of VID.\n      source: {\n        field: _c0\n        # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n      target: {\n        field: _c1\n        # Add the specified prefix to the VID. For example, if the VID is `12345`, adding the prefix `tag1` will result in `tag1_12345`. The underscore cannot be modified.\n      # prefix:\"tag1\"\n      # Performs hashing operations on VIDs of type string.\n      # policy:hash\n      }\n\n      # The delimiter specified. The default value is comma.\n      separator: \",\"\n\n      # (Optional) Specify a column as the source of the rank.\n\n      #ranking: rank\n\n      # If the CSV file has a header, set the header to true.\n      # If the CSV file does not have a header, set the header to false. The default value is false.\n      header: false\n\n      # The filtering rule. The data that matches the filter rule is imported into NebulaGraph.\n      # filter: \"name='Tom'\"\n\n      # Batch operation types, including INSERT, UPDATE, and DELETE. defaults to INSERT.\n      #writeMode: INSERT\n\n      # The number of data written to NebulaGraph in a single batch.\n      batch: 256\n\n      # The number of partitions to be created when the data is written to NebulaGraph.\n      partition: 32\n\n      # Whether to repartition data based on the number of partitions of graph spaces in NebulaGraph when generating the SST file.\n      repartitionWithNebula: false\n    }\n\n    # Set the information about the Edge Type serve.\n    {\n      name: serve\n      type: {\n        source: csv\n        sink: sst\n      }\n      path: \"hdfs://*.*.*.*:9000/dataset/edge_serve.csv\"\n      fields: [_c2,_c3]\n      nebula.fields: [start_year, end_year]\n      source: {\n        field: _c0\n      }\n      target: {\n        field: _c1\n      }\n      separator: \",\"\n      header: false\n      batch: 256\n      partition: 32\n      repartitionWithNebula: false\n    }\n\n  ]\n  # If more edges need to be added, refer to the previous configuration to add them.\n}\n</code></pre>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#step_4_generate_the_sst_file","title":"Step 4: Generate the SST file","text":"<p>Run the following command to generate the SST file from the CSV source file. For a description of the parameters, see Options for import.</p> <pre><code>${SPARK_HOME}/bin/spark-submit --master \"local\" --conf spark.sql.shuffle.partition=&lt;shuffle_concurrency&gt; --class com.vesoft.nebula.exchange.Exchange &lt;nebula-exchange.jar_path&gt; -c &lt;sst_application.conf_path&gt; \n</code></pre> <p>Note</p> <p>When generating SST files, the shuffle operation of Spark will be involved. Note that the configuration of <code>spark.sql.shuffle.partition</code> should be added when you submit the command.</p> <p>Note</p> <p>JAR packages are available in two ways: compiled them yourself, or download the compiled <code>.jar</code> file directly.</p> <p>For example:</p> <pre><code>${SPARK_HOME}/bin/spark-submit  --master \"local\" --conf spark.sql.shuffle.partition=200 --class com.vesoft.nebula.exchange.Exchange  /root/nebula-exchange/nebula-exchange/target/nebula-exchange_spark_2.4-3.8.0.jar  -c /root/nebula-exchange/nebula-exchange/target/classes/sst_application.conf\n</code></pre> <p>After the task is complete, you can view the generated SST file in the <code>/sst</code> directory (specified by the <code>nebula.path.remote</code> parameter) on HDFS.</p> <p>Note</p> <p>If you modify the Schema, such as rebuilding the graph space, modifying the Tag, or modifying the Edge type, you need to regenerate the SST file because the SST file verifies the space ID, Tag ID, and Edge ID.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#step_5_import_the_sst_file","title":"Step 5: Import the SST file","text":"<p>Note</p> <p>Confirm the following information before importing:</p> <ul> <li>Confirm that the Hadoop service has been deployed on all the machines where the Storage service is deployed, and configure <code>HADOOP_HOME</code> and <code>JAVA_HOME</code>.</li> </ul> <ul> <li>The <code>--ws_storage_http_port</code> in the Meta service configuration file (add it manually if it does not exist) is the same as the <code>--ws_http_port</code> in the Storage service configuration file. For example, both are <code>19779</code>.</li> </ul> <ul> <li>The <code>--ws_meta_http_port</code> in the Graph service configuration file (add it manually if it does not exist) is the same as the <code>--ws_http_port</code> in the Meta service configuration file. For example, both are <code>19559</code>.</li> </ul> <p>Connect to the NebulaGraph database using the client tool and import the SST file as follows:</p> <ol> <li> <p>Run the following command to select the graph space you created earlier.</p> <pre><code>nebula&gt; USE basketballplayer;\n</code></pre> </li> <li> <p>Run the following command to download the SST file:</p> <pre><code>nebula&gt; SUBMIT JOB DOWNLOAD HDFS \"hdfs://&lt;hadoop_address&gt;:&lt;hadoop_port&gt;/&lt;sst_file_path&gt;\";\n</code></pre> <p>For example:</p> <pre><code>nebula&gt; SUBMIT JOB DOWNLOAD HDFS \"hdfs://*.*.*.*:9000/sst\";\n</code></pre> </li> <li> <p>Run the following command to import the SST file:</p> <pre><code>nebula&gt; SUBMIT JOB INGEST;\n</code></pre> </li> </ol> <p>Note</p> <ul> <li>To download the SST file again, delete the <code>download</code> folder in the space ID in the <code>data/storage/nebula</code> directory in the NebulaGraph installation path, and then download the SST file again. If the space has multiple copies, the <code>download</code> folder needs to be deleted on all machines where the copies are saved.</li> </ul> <ul> <li>If there is a problem with the import and re-importing is required, re-execute <code>SUBMIT JOB INGEST;</code>.</li> </ul>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#step_6_optional_validate_data","title":"Step 6: (Optional) Validate data","text":"<p>Users can verify that data has been imported by executing a query in the NebulaGraph client (for example, NebulaGraph Studio). For example:</p> <pre><code>LOOKUP ON player YIELD id(vertex);\n</code></pre> <p>Users can also run the <code>SHOW STATS</code> command to view statistics.</p>"},{"location":"import-export/nebula-exchange/use-exchange/ex-ug-import-from-sst/#step_7_conditional_rebuild_indexes_in_nebulagraph","title":"Step 7: (Conditional) Rebuild indexes in NebulaGraph","text":"<p>With the data imported, users can recreate and rebuild indexes in NebulaGraph. For details, see Index overview.</p>"},{"location":"k8s-operator/1.introduction-to-nebula-operator/","title":"What is NebulaGraph Operator","text":""},{"location":"k8s-operator/1.introduction-to-nebula-operator/#concept","title":"Concept","text":"<p>NebulaGraph Operator is a tool to automate the deployment, operation, and maintenance of NebulaGraph clusters on Kubernetes. Building upon the excellent scalability mechanism of Kubernetes, NebulaGraph introduced its operation and maintenance knowledge into the Kubernetes system, which makes NebulaGraph a real cloud-native graph database.</p> <p></p>"},{"location":"k8s-operator/1.introduction-to-nebula-operator/#how_it_works","title":"How it works","text":"<p>For resource types that do not exist within Kubernetes, you can register them by adding custom API objects. The common way is to use the CustomResourceDefinition.</p> <p>NebulaGraph Operator abstracts the deployment management of NebulaGraph clusters as a CRD. By combining multiple built-in API objects including StatefulSet, Service, and ConfigMap, the routine management and maintenance of a NebulaGraph cluster are coded as a control loop in the Kubernetes system. When a CR instance is submitted, NebulaGraph Operator drives database clusters to the final state according to the control process.</p>"},{"location":"k8s-operator/1.introduction-to-nebula-operator/#features","title":"Features","text":"<p>The following features are already available in NebulaGraph Operator:</p> <ul> <li>Cluster deployment and deletion: NebulaGraph Operator simplifies the process of deploying and uninstalling clusters for users. NebulaGraph Operator allows you to quickly create, update, or delete a NebulaGraph cluster by simply providing the corresponding CR file. For more information, see Install NebulaGraph Clusters.</li> </ul> <ul> <li>Cluster Upgrade: NebulaGraph Operator supports cluster upgrading from version 3.5.0 to version 3.6.0.</li> </ul> <ul> <li>Self-Healing: NebulaGraph Operator calls interfaces provided by NebulaGraph clusters to dynamically sense cluster service status. Once an exception is detected, NebulaGraph Operator performs fault tolerance. For more information, see Self-Healing.</li> </ul> <ul> <li>Balance Scheduling: Based on the scheduler extension interface, the scheduler provided by NebulaGraph Operator evenly distributes Pods in a NebulaGraph cluster across all nodes.</li> </ul>"},{"location":"k8s-operator/1.introduction-to-nebula-operator/#limitations","title":"Limitations","text":""},{"location":"k8s-operator/1.introduction-to-nebula-operator/#version_limitations","title":"Version limitations","text":"<p>NebulaGraph Operator does not support the v1.x version of NebulaGraph. NebulaGraph Operator version and the corresponding NebulaGraph version are as follows:</p> NebulaGraph NebulaGraph Operator 3.5.x ~ 3.8.0 1.5.0 ~ 1.8.0 3.0.0 ~ 3.4.1 1.3.0, 1.4.0 ~ 1.4.2 3.0.0 ~ 3.3.x 1.0.0, 1.1.0, 1.2.0 2.5.x ~ 2.6.x 0.9.0 2.5.x 0.8.0 <p>Legacy version compatibility</p> <ul> <li>The 1.x version NebulaGraph Operator is not compatible with NebulaGraph of version below v3.x.</li> <li>Starting from NebulaGraph Operator 0.9.0, logs and data are stored separately. Using NebulaGraph Operator 0.9.0 or later versions to manage a NebulaGraph 2.5.x cluster created with Operator 0.8.0 can cause compatibility issues. You can backup the data of the NebulaGraph 2.5.x cluster and then create a 2.6.x cluster with Operator 0.9.0.</li> </ul>"},{"location":"k8s-operator/1.introduction-to-nebula-operator/#release_note","title":"Release note","text":"<p>Release</p>"},{"location":"k8s-operator/5.FAQ/","title":"FAQ","text":""},{"location":"k8s-operator/5.FAQ/#does_nebulagraph_operator_support_the_v1x_version_of_nebulagraph","title":"Does NebulaGraph Operator support the v1.x version of NebulaGraph?","text":"<p>No, because the v1.x version of NebulaGraph does not support DNS, and NebulaGraph Operator requires the use of DNS.</p>"},{"location":"k8s-operator/5.FAQ/#is_cluster_stability_guaranteed_if_using_local_storage","title":"Is cluster stability guaranteed if using local storage?","text":"<p>There is no guarantee. Using local storage means that the Pod is bound to a specific node, and NebulaGraph Operator does not currently support failover in the event of a failure of the bound node.</p>"},{"location":"k8s-operator/5.FAQ/#how_to_ensure_the_stability_of_a_cluster_when_scaling_the_cluster","title":"How to ensure the stability of a cluster when scaling the cluster?","text":"<p>It is suggested to back up data in advance so that you can roll back data in case of failure.</p>"},{"location":"k8s-operator/5.FAQ/#is_the_replica_in_the_operator_docs_the_same_as_the_replica_in_the_nebulagraph_core_docs","title":"Is the replica in the Operator docs the same as the replica in the NebulaGraph core docs?","text":"<p>They are different concepts. A replica in the Operator docs indicates a pod replica in K8s, while a replica in the core docs is a replica of a NebulaGraph storage partition.</p>"},{"location":"k8s-operator/5.FAQ/#how_to_view_the_logs_of_each_service_in_the_nebulagraph_cluster","title":"How to view the logs of each service in the NebulaGraph cluster?","text":"<p>To obtain the logs of each cluster service, you need to access the container and view the log files that are stored inside.</p> <p>Steps to view the logs of each service in the NebulaGraph cluster:</p> <pre><code># To view the name of the pod where the container you want to access is located. \n# Replace &lt;cluster-name&gt; with the name of the cluster.\nkubectl get pods -l app.kubernetes.io/cluster=&lt;cluster-name&gt;\n\n# To access the container within the pod, such as the nebula-graphd-0 container.\nkubectl exec -it nebula-graphd-0 -- /bin/bash\n\n# To go to /usr/local/nebula/logs directory to view the logs.\ncd /usr/local/nebula/logs\n</code></pre>"},{"location":"k8s-operator/5.FAQ/#how_to_resolve_the_host_not_foundnebula-metadstoragedgraphd-0nebulametadstoragedgraphd-headlessdefaultsvcclusterlocal_error","title":"How to resolve the <code>host not found:nebula-&lt;metad|storaged|graphd&gt;-0.nebula.&lt;metad|storaged|graphd&gt;-headless.default.svc.cluster.local</code> error?","text":"<p>This error is generally caused by a DNS resolution failure, and you need to check whether the cluster domain has been modified. If the cluster domain has been modified, you need to modify the <code>kubernetesClusterDomain</code> field in the NebulaGraph Operator configuration file accordingly. The steps for modifying the Operator configuration file are as follows:</p> <ol> <li> <p>View the Operator configuration file.</p> <pre><code>[abby@master ~]$ helm show values nebula-operator/nebula-operator   \nimage:\n  nebulaOperator:\n    image: vesoft/nebula-operator:v1.8.0\n    imagePullPolicy: Always\n  kubeRBACProxy:\n    image: bitnami/kube-rbac-proxy:0.14.2\n    imagePullPolicy: Always\n  kubeScheduler:\n    image: registry.k8s.io/kube-scheduler:v1.24.11\n    imagePullPolicy: Always\n\nimagePullSecrets: []\nkubernetesClusterDomain: \"\"  # The cluster domain name, and the default is cluster.local.\n</code></pre> </li> <li> <p>Modify the value of the <code>kubernetesClusterDomain</code> field to the updated cluster domain name.</p> <p><pre><code>helm upgrade nebula-operator nebula-operator/nebula-operator --namespace=&lt;nebula-operator-system&gt; --version=1.8.0 --set kubernetesClusterDomain=&lt;cluster-domain&gt;\n</code></pre>  is the namespace where Operator is located and  is the updated domain name."},{"location":"k8s-operator/2.get-started/2.1.install-operator/","title":"Install NebulaGraph Operator","text":"<p>You can deploy NebulaGraph Operator with Helm.</p>"},{"location":"k8s-operator/2.get-started/2.1.install-operator/#background","title":"Background","text":"<p>NebulaGraph Operator automates the management of NebulaGraph clusters, and eliminates the need for you to install, scale, upgrade, and uninstall NebulaGraph clusters, which lightens the burden on managing different application versions.</p>"},{"location":"k8s-operator/2.get-started/2.1.install-operator/#prerequisites","title":"Prerequisites","text":"<p>Before installing NebulaGraph Operator, you need to install the following software and ensure the correct version of the software :</p> Software Requirement Kubernetes &gt;= 1.18 Helm &gt;= 3.2.0 CoreDNS &gt;= 1.6.0 <p>Note</p> <ul> <li>If using a role-based access control policy, you need to enable RBAC (optional).</li> </ul> <ul> <li>CoreDNS is a flexible and scalable DNS server that is installed for Pods in NebulaGraph clusters.</li> </ul>"},{"location":"k8s-operator/2.get-started/2.1.install-operator/#steps","title":"Steps","text":"<ol> <li> <p>Add the NebulaGraph Operator Helm repository.</p> <pre><code>helm repo add nebula-operator https://vesoft-inc.github.io/nebula-operator/charts\n</code></pre> </li> <li> <p>Update information of available charts locally from repositories.</p> <pre><code>helm repo update\n</code></pre> <p>For more information about <code>helm repo</code>, see Helm Repo.</p> </li> <li> <p>Create a namespace for NebulaGraph Operator.</p> <pre><code>kubectl create namespace &lt;namespace_name&gt;\n</code></pre> <p>For example, run the following command to create a namespace named <code>nebula-operator-system</code>.</p> <pre><code>kubectl create namespace nebula-operator-system\n</code></pre> <p>All the resources of NebulaGraph Operator are deployed in this namespace.</p> </li> <li> <p>Install NebulaGraph Operator.</p> <pre><code>helm install nebula-operator nebula-operator/nebula-operator --namespace=&lt;namespace_name&gt; --version=${chart_version}\n</code></pre> <p>For example, the command to install NebulaGraph Operator of version 1.8.0 is as follows.</p> <pre><code>helm install nebula-operator nebula-operator/nebula-operator --namespace=nebula-operator-system --version=1.8.0\n</code></pre> <p><code>1.8.0</code> is the version of the nebula-operator chart. When not specifying <code>--version</code>, the latest version of the nebula-operator chart is used by default. </p> <p>Run <code>helm search repo -l nebula-operator</code> to see chart versions.</p> <p>You can customize the configuration items of the NebulaGraph Operator chart before running the installation command. For more information, see Customize installation defaults.</p> </li> <li> <p>View the information about the default-created CRD.</p> <pre><code>kubectl get crd\n</code></pre> <p>Output:</p> <pre><code>NAME                                                 CREATED AT\nnebulaautoscalers.autoscaling.nebula-graph.io        2023-11-01T04:16:51Z\nnebulaclusters.apps.nebula-graph.io                  2023-10-12T07:55:32Z\nnebularestores.apps.nebula-graph.io                  2023-02-04T23:01:00Z\n</code></pre> </li> </ol>"},{"location":"k8s-operator/2.get-started/2.1.install-operator/#whats_next","title":"What's next","text":"<p>Create a NebulaGraph cluster</p>"},{"location":"k8s-operator/2.get-started/2.3.create-cluster/","title":"Create a NebulaGraph cluster","text":"<p>This topic introduces how to create a NebulaGraph cluster with the following two methods:</p> <ul> <li>Create a NebulaGraph cluster with Helm</li> <li>Create a NebulaGraph cluster with Kubectl</li> </ul>"},{"location":"k8s-operator/2.get-started/2.3.create-cluster/#prerequisites","title":"Prerequisites","text":"<ul> <li>NebulaGraph Operator is installed.</li> </ul> <ul> <li>A StorageClass is created.</li> </ul>"},{"location":"k8s-operator/2.get-started/2.3.create-cluster/#create_a_nebulagraph_cluster_with_helm","title":"Create a NebulaGraph cluster with Helm","text":"<p>Legacy version compatibility</p> <p>The 1.x version NebulaGraph Operator is not compatible with NebulaGraph of version below v3.x.</p> <ol> <li> <p>Add the NebulaGraph Operator Helm repository.</p> <pre><code>helm repo add nebula-operator https://vesoft-inc.github.io/nebula-operator/charts\n</code></pre> </li> <li> <p>Update information of available charts locally from chart repositories.</p> <pre><code>helm repo update\n</code></pre> </li> <li> <p>Set environment variables to your desired values.</p> <pre><code>export NEBULA_CLUSTER_NAME=nebula         # The desired NebulaGraph cluster name.\nexport NEBULA_CLUSTER_NAMESPACE=nebula    # The desired namespace where your NebulaGraph cluster locates.\nexport STORAGE_CLASS_NAME=fast-disks             # The name of the StorageClass that has been created.\n</code></pre> </li> <li> <p>Create a namespace for your NebulaGraph cluster (If you have created one, skip this step).</p> <pre><code>kubectl create namespace \"${NEBULA_CLUSTER_NAMESPACE}\"\n</code></pre> </li> <li> <p>Apply the variables to the Helm chart to create a NebulaGraph cluster.</p> <pre><code>helm install \"${NEBULA_CLUSTER_NAME}\" nebula-operator/nebula-cluster \\\n    --set nameOverride=\"${NEBULA_CLUSTER_NAME}\" \\\n    --set nebula.storageClassName=\"${STORAGE_CLASS_NAME}\" \\\n    # Specify the version of the NebulaGraph cluster. \n    --set nebula.version=v3.8.0 \\  \n    # Specify the version of the nebula-cluster chart. If not specified, the latest version of the chart is installed by default.\n    # Run 'helm search repo nebula-operator/nebula-cluster' to view the available versions of the chart.     \n    --version=1.8.0 \\\n    --namespace=\"${NEBULA_CLUSTER_NAMESPACE}\" \\\n</code></pre> </li> </ol>"},{"location":"k8s-operator/2.get-started/2.3.create-cluster/#create_a_nebulagraph_cluster_with_kubectl","title":"Create a NebulaGraph cluster with Kubectl","text":"<p>Legacy version compatibility</p> <p>The 1.x version NebulaGraph Operator is not compatible with NebulaGraph of version below v3.x.</p> <p>The following example shows how to create a NebulaGraph cluster by creating a cluster named <code>nebula</code>.</p> <ol> <li> <p>Create a namespace, for example, <code>nebula</code>. If not specified, the <code>default</code> namespace is used.</p> <pre><code>kubectl create namespace nebula\n</code></pre> </li> <li> <p>Define the cluster configuration file <code>nebulacluster.yaml</code>.</p> Expand to see an example configuration for the cluster <pre><code>apiVersion: apps.nebula-graph.io/v1alpha1\nkind: NebulaCluster\nmetadata:\n  name: nebula\n  namespace: default\nspec:\n  topologySpreadConstraints:\n  - topologyKey: \"kubernetes.io/hostname\"\n    whenUnsatisfiable: \"ScheduleAnyway\"\n  graphd:\n    # Container image for the Graph service.\n    image: vesoft/nebula-graphd\n    logVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      # Storage class name for storing Graph service logs.\n      storageClassName: local-sc\n    replicas: 1\n    resources:\n      limits:\n        cpu: \"1\"\n        memory: 1Gi\n      requests:\n        cpu: 500m\n        memory: 500Mi\n    version: v3.8.0\n  imagePullPolicy: Always\n  metad:\n    # Container image for the Meta service.\n    image: vesoft/nebula-metad\n    logVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: local-sc\n    dataVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: local-sc\n    replicas: 1\n    resources:\n      limits:\n        cpu: \"1\"\n        memory: 1Gi\n      requests:\n        cpu: 500m\n        memory: 500Mi\n    version: v3.8.0\n  reference:\n    name: statefulsets.apps\n    version: v1\n  schedulerName: default-scheduler\n  storaged:\n    # Container image for the Storage service.\n    image: vesoft/nebula-storaged\n    logVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: local-sc\n    dataVolumeClaims:\n    - resources:\n        requests:\n          storage: 2Gi\n      storageClassName: local-sc\n    replicas: 1\n    resources:\n      limits:\n        cpu: \"1\"\n        memory: 1Gi\n      requests:\n        cpu: 500m\n        memory: 500Mi\n    version: v3.8.0\n</code></pre> <p>For more information about the other parameters, see Install NebulaGraph clusters.</p> </li> <li> <p>Create a NebulaGraph cluster.</p> <pre><code>kubectl create -f nebulacluster.yaml\n</code></pre> <p>Output:</p> <pre><code>nebulacluster.apps.nebula-graph.io/nebula created\n</code></pre> </li> <li> <p>Check the status of the NebulaGraph cluster.</p> <pre><code>kubectl get nc nebula\n</code></pre> <p>Output:</p> <pre><code>NAME     READY     GRAPHD-DESIRED   GRAPHD-READY   METAD-DESIRED   METAD-READY   STORAGED-DESIRED   STORAGED-READY   AGE\nnebula    True     1                1              1               1             1                  1                86s\n</code></pre> </li> </ol>"},{"location":"k8s-operator/2.get-started/2.3.create-cluster/#whats_next","title":"What's next","text":"<p>Connect to a cluster</p>"},{"location":"k8s-operator/2.get-started/2.4.connect-to-cluster/","title":"Connect to a NebulaGraph cluster","text":"<p>After creating a NebulaGraph cluster with NebulaGraph Operator on Kubernetes, you can connect to NebulaGraph databases from within the cluster and outside the cluster.</p>"},{"location":"k8s-operator/2.get-started/2.4.connect-to-cluster/#prerequisites","title":"Prerequisites","text":"<p>A NebulaGraph cluster is created on Kubernetes. For more information, see Create a NebulaGraph cluster.</p>"},{"location":"k8s-operator/2.get-started/2.4.connect-to-cluster/#connect_to_nebulagraph_databases_from_within_a_nebulagraph_cluster","title":"Connect to NebulaGraph databases from within a NebulaGraph cluster","text":"<p>You can create a <code>ClusterIP</code> type Service to provide an access point to the NebulaGraph database for other Pods within the cluster. By using the Service's IP and the Graph service's port number (9669), you can connect to the NebulaGraph database. For more information, see ClusterIP.</p> <ol> <li> <p>Create a file named <code>graphd-clusterip-service.yaml</code>. The file contents are as follows:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app.kubernetes.io/cluster: nebula\n    app.kubernetes.io/component: graphd\n    app.kubernetes.io/managed-by: nebula-operator\n    app.kubernetes.io/name: nebula-graph\n  name: nebula-graphd-svc\n  namespace: default\nspec:\n  ports:\n  - name: thrift\n    port: 9669\n    protocol: TCP\n    targetPort: 9669\n  - name: http\n    port: 19669\n    protocol: TCP\n    targetPort: 19669\n  selector:\n    app.kubernetes.io/cluster: nebula\n    app.kubernetes.io/component: graphd\n    app.kubernetes.io/managed-by: nebula-operator\n    app.kubernetes.io/name: nebula-graph\n  type: ClusterIP  # Set the type to ClusterIP.\n</code></pre> <ul> <li>NebulaGraph uses port <code>9669</code> by default. <code>19669</code> is the HTTP port of the Graph service in a NebulaGraph cluster.</li> <li><code>targetPort</code> is the port mapped to the database Pods, which can be customized.</li> </ul> </li> <li> <p>Create a ClusterIP Service.</p> <pre><code>kubectl create -f graphd-clusterip-service.yaml     \n</code></pre> </li> <li> <p>Check the IP of the Service:</p> <pre><code>$ kubectl get service -l app.kubernetes.io/cluster=&lt;nebula&gt;  # &lt;nebula&gt; is the name of your NebulaGraph cluster.\nNAME                       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                                          AGE\nnebula-graphd-svc          ClusterIP   10.98.213.34   &lt;none&gt;        9669/TCP,19669/TCP,19670/TCP                     23h\n...\n</code></pre> </li> <li> <p>Run the following command to connect to the NebulaGraph database using the IP of the <code>&lt;cluster-name&gt;-graphd-svc</code> Service above:</p> <pre><code>kubectl run -ti --image vesoft/nebula-console:v3.8.0 --restart=Never -- &lt;nebula_console_name&gt; -addr &lt;cluster_ip&gt;  -port &lt;service_port&gt; -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <p>For example:</p> <pre><code>kubectl run -ti --image vesoft/nebula-console:v3.8.0 --restart=Never -- nebula-console -addr 10.98.213.34  -port 9669 -u root -p vesoft\n</code></pre> <ul> <li><code>--image</code>: The image for the tool NebulaGraph Console used to connect to NebulaGraph databases.</li> <li><code>&lt;nebula-console&gt;</code>: The custom Pod name.</li> <li><code>-addr</code>: The IP of the <code>ClusterIP</code> Service, used to connect to Graphd services.</li> <li><code>-port</code>: The port to connect to Graphd services, the default port of which is <code>9669</code>.</li> <li><code>-u</code>: The username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is root.</li> <li><code>-p</code>: The password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password.</li> </ul> <p>A successful connection to the database is indicated if the following is returned:</p> <pre><code>If you don't see a command prompt, try pressing enter.\n\n(root@nebula) [(none)]&gt;\n</code></pre> <p>You can also connect to NebulaGraph databases with Fully Qualified Domain Name (FQDN). The domain format is <code>&lt;cluster-name&gt;-graphd.&lt;cluster-namespace&gt;.svc.&lt;CLUSTER_DOMAIN&gt;</code>. The default value of <code>CLUSTER_DOMAIN</code> is <code>cluster.local</code>.</p> <pre><code>kubectl run -ti --image vesoft/nebula-console:v3.8.0 --restart=Never -- &lt;nebula_console_name&gt; -addr &lt;cluster_name&gt;-graphd-svc.default.svc.cluster.local -port &lt;service_port&gt; -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <p><code>service_port</code> is the port to connect to Graphd services, the default port of which is <code>9669</code>.</p> <p>Note</p> <p>If the <code>spec.console</code> field is set in the cluster configuration file, you can also connect to NebulaGraph databases with the following command:</p> <pre><code># Enter the nebula-console Pod.\nkubectl exec -it nebula-console -- /bin/sh\n\n# Connect to NebulaGraph databases.\nnebula-console -addr nebula-graphd-svc.default.svc.cluster.local -port 9669 -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <p>For information about the nebula-console container, see nebula-console.</p> </li> </ol>"},{"location":"k8s-operator/2.get-started/2.4.connect-to-cluster/#connect_to_nebulagraph_databases_from_within_a_nebulagraph_cluster_1","title":"Connect to NebulaGraph databases from within a NebulaGraph cluster","text":"<p>You can also create a <code>ClusterIP</code> type Service to provide an access point to the NebulaGraph database for other Pods within the cluster. By using the Service's IP and the Graph service's port number (9669), you can connect to the NebulaGraph database. For more information, see ClusterIP.</p> <ol> <li> <p>Create a file named <code>graphd-clusterip-service.yaml</code>. The file contents are as follows:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app.kubernetes.io/cluster: nebula\n    app.kubernetes.io/component: graphd\n    app.kubernetes.io/managed-by: nebula-operator\n    app.kubernetes.io/name: nebula-graph\n  name: nebula-graphd-svc\n  namespace: default\nspec:\n  externalTrafficPolicy: Local\n  ports:\n  - name: thrift\n    port: 9669\n    protocol: TCP\n    targetPort: 9669\n  - name: http\n    port: 19669\n    protocol: TCP\n    targetPort: 19669\n  selector:\n    app.kubernetes.io/cluster: nebula\n    app.kubernetes.io/component: graphd\n    app.kubernetes.io/managed-by: nebula-operator\n    app.kubernetes.io/name: nebula-graph\n  type: ClusterIP  # Set the type to ClusterIP.\n</code></pre> <ul> <li>NebulaGraph uses port <code>9669</code> by default. <code>19669</code> is the HTTP port of the Graph service in a NebulaGraph cluster.</li> <li><code>targetPort</code> is the port mapped to the database Pods, which can be customized.</li> </ul> </li> <li> <p>Create a ClusterIP Service.</p> <pre><code>kubectl create -f graphd-clusterip-service.yaml     \n</code></pre> </li> <li> <p>Check the IP of the Service:</p> <pre><code>$ kubectl get service -l app.kubernetes.io/cluster=&lt;nebula&gt;  # &lt;nebula&gt; is the name of your NebulaGraph cluster.\nNAME                       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                                          AGE\nnebula-graphd-svc          ClusterIP   10.98.213.34   &lt;none&gt;        9669/TCP,19669/TCP,19670/TCP                     23h\n...\n</code></pre> </li> <li> <p>Run the following command to connect to the NebulaGraph database using the IP of the <code>&lt;cluster-name&gt;-graphd-svc</code> Service above:</p> <pre><code>kubectl run -ti --image vesoft/nebula-console:v3.8.0 --restart=Never -- &lt;nebula_console_name&gt; -addr &lt;cluster_ip&gt;  -port &lt;service_port&gt; -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <p>For example:</p> <pre><code>kubectl run -ti --image vesoft/nebula-console:v3.8.0 --restart=Never -- nebula-console -addr 10.98.213.34  -port 9669 -u root -p vesoft\n</code></pre> <ul> <li><code>--image</code>: The image for the tool NebulaGraph Console used to connect to NebulaGraph databases.</li> <li><code>&lt;nebula-console&gt;</code>: The custom Pod name.</li> <li><code>-addr</code>: The IP of the <code>ClusterIP</code> Service, used to connect to Graphd services.</li> <li><code>-port</code>: The port to connect to Graphd services, the default port of which is <code>9669</code>.</li> <li><code>-u</code>: The username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is root.</li> <li><code>-p</code>: The password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password.</li> </ul> <p>A successful connection to the database is indicated if the following is returned:</p> <pre><code>If you don't see a command prompt, try pressing enter.\n\n(root@nebula) [(none)]&gt;\n</code></pre> <p>You can also connect to NebulaGraph databases with Fully Qualified Domain Name (FQDN). The domain format is <code>&lt;cluster-name&gt;-graphd.&lt;cluster-namespace&gt;.svc.&lt;CLUSTER_DOMAIN&gt;</code>. The default value of <code>CLUSTER_DOMAIN</code> is <code>cluster.local</code>.</p> <pre><code>kubectl run -ti --image vesoft/nebula-console:v3.8.0 --restart=Never -- &lt;nebula_console_name&gt; -addr &lt;cluster_name&gt;-graphd-svc.default.svc.cluster.local -port &lt;service_port&gt; -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <p><code>service_port</code> is the port to connect to Graphd services, the default port of which is <code>9669</code>.</p> <p>Note</p> <p>If the <code>spec.console</code> field is set in the cluster configuration file, you can also connect to NebulaGraph databases with the following command:</p> <pre><code># Enter the nebula-console Pod.\nkubectl exec -it nebula-console -- /bin/sh\n\n# Connect to NebulaGraph databases.\nnebula-console -addr nebula-graphd-svc.default.svc.cluster.local -port 9669 -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <p>For information about the nebula-console container, see nebula-console.</p> </li> </ol>"},{"location":"k8s-operator/2.get-started/2.4.connect-to-cluster/#connect_to_nebulagraph_databases_from_outside_a_nebulagraph_cluster_via_nodeport","title":"Connect to NebulaGraph databases from outside a NebulaGraph cluster via <code>NodePort</code>","text":"<p>You can create a <code>NodePort</code> type Service to access internal cluster services from outside the cluster using any node IP and the exposed node port. You can also utilize load balancing services provided by cloud vendors (such as Azure, AWS, etc.) by setting the Service type to <code>LoadBalancer</code>. This allows external access to internal cluster services through the public IP and port of the load balancer provided by the cloud vendor.</p> <p>The Service of type <code>NodePort</code> forwards the front-end requests via the label selector <code>spec.selector</code> to Graphd pods with labels <code>app.kubernetes.io/cluster: &lt;cluster-name&gt;</code> and <code>app.kubernetes.io/component: graphd</code>.</p> <p>After creating a NebulaGraph cluster based on the example template, where <code>spec.graphd.service.type=NodePort</code>, the NebulaGraph Operator will automatically create a NodePort type Service named <code>&lt;cluster-name&gt;-graphd-svc</code> in the same namespace. You can directly connect to the NebulaGraph database through any node IP and the exposed node port (see step 4 below). You can also create a custom Service according to your needs.</p> <p>Steps:</p> <ol> <li> <p>Create a YAML file named <code>graphd-nodeport-service.yaml</code>. The file contents are as follows:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app.kubernetes.io/cluster: nebula\n    app.kubernetes.io/component: graphd\n    app.kubernetes.io/managed-by: nebula-operator\n    app.kubernetes.io/name: nebula-graph\n  name: nebula-graphd-svc-nodeport\n  namespace: default\nspec:\n  externalTrafficPolicy: Local\n  ports:\n  - name: thrift\n    port: 9669\n    protocol: TCP\n    targetPort: 9669\n  - name: http\n    port: 19669\n    protocol: TCP\n    targetPort: 19669\n  selector:\n    app.kubernetes.io/cluster: nebula\n    app.kubernetes.io/component: graphd\n    app.kubernetes.io/managed-by: nebula-operator\n    app.kubernetes.io/name: nebula-graph\n  type: NodePort   # Set the type to NodePort.\n</code></pre> <ul> <li>NebulaGraph uses port <code>9669</code> by default. <code>19669</code> is the HTTP port of the Graph service in a NebulaGraph cluster.</li> <li>The value of <code>targetPort</code> is the port mapped to the database Pods, which can be customized.</li> </ul> </li> <li> <p>Run the following command to create a NodePort Service.</p> <pre><code>kubectl create -f graphd-nodeport-service.yaml\n</code></pre> </li> <li> <p>Check the port mapped on all of your cluster nodes.</p> <pre><code>kubectl get services -l app.kubernetes.io/cluster=&lt;nebula&gt; # &lt;nebula&gt; is the name of your NebulaGraph cluster.\n</code></pre> <p>Output:</p> <pre><code>NAME                           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                                          AGE\nnebula-graphd-svc-nodeport     NodePort    10.107.153.129 &lt;none&gt;        9669:32236/TCP,19669:31674/TCP,19670:31057/TCP   24h\n...\n</code></pre> <p>As you see, the mapped port of NebulaGraph databases on all cluster nodes is <code>32236</code>.</p> </li> <li> <p>Connect to NebulaGraph databases with your node IP and the node port above.</p> <pre><code>kubectl run -ti --image vesoft/nebula-console:v3.8.0 --restart=Never -- &lt;nebula_console_name&gt; -addr &lt;node_ip&gt; -port &lt;node_port&gt; -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <p>For example:</p> <pre><code>kubectl run -ti --image vesoft/nebula-console:v3.8.0 --restart=Never -- nebula-console -addr 192.168.8.24 -port 32236 -u root -p vesoft\nIf you don't see a command prompt, try pressing enter.\n\n(root@nebula) [(none)]&gt;\n</code></pre> <ul> <li><code>--image</code>: The image for the tool NebulaGraph Console used to connect to NebulaGraph databases.</li> <li><code>&lt;nebula-console&gt;</code>: The custom Pod name. The above example uses <code>nebula-console</code>.</li> <li><code>-addr</code>: The IP of any node in a NebulaGraph cluster. The above example uses <code>192.168.8.24</code>.</li> <li><code>-port</code>: The mapped port of NebulaGraph databases on all cluster nodes. The above example uses <code>32236</code>.</li> <li><code>-u</code>: The username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is root.</li> <li><code>-p</code>: The password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password.</li> </ul> <p>Note</p> <p>If the <code>spec.console</code> field is set in the cluster configuration file, you can also connect to NebulaGraph databases with the following command:</p> <pre><code># Enter the nebula-console Pod.\nkubectl exec -it nebula-console -- /bin/sh\n\n# Connect to NebulaGraph databases.\nnebula-console -addr &lt;node_ip&gt; -port &lt;node_port&gt; -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <p>For information about the nebula-console container, see nebula-console.</p> </li> </ol>"},{"location":"k8s-operator/2.get-started/2.4.connect-to-cluster/#connect_to_nebulagraph_databases_from_outside_a_nebulagraph_cluster_via_ingress","title":"Connect to NebulaGraph databases from outside a NebulaGraph cluster via Ingress","text":"<p>When dealing with multiple pods in a cluster, managing services for each pod separately is not a good practice. Ingress is a Kubernetes resource that provides a unified entry point for accessing multiple services. Ingress can be used to expose multiple services under a single IP address.</p> <p>Nginx Ingress is an implementation of Kubernetes Ingress. Nginx Ingress watches the Ingress resource of a Kubernetes cluster and generates the Ingress rules into Nginx configurations that enable Nginx to forward 7 layers of traffic.</p> <p>You can use Nginx Ingress to connect to a NebulaGraph cluster from outside the cluster using a combination of the host network and DaemonSet pattern.</p> <p>Due to the use of <code>HostNetwork</code>, Nginx Ingress pods may be scheduled on the same node (port conflicts will occur when multiple pods try to listen on the same port on the same node). To avoid this situation, Nginx Ingress is deployed on these nodes in DaemonSet mode (ensuring that a pod replica runs on each node in the cluster). You first need to select some nodes and label them for the specific deployment of Nginx Ingress.</p> <p>Ingress does not support TCP or UDP services. For this reason, the nginx-ingress-controller pod uses the flags <code>--tcp-services-configmap</code> and <code>--udp-services-configmap</code> to point to an existing ConfigMap where the key refers to the external port to be used and the value refers to the format of the service to be exposed. The format of the value is <code>&lt;namespace/service_name&gt;:&lt;service_port&gt;</code>.</p> <p>For example, the configurations of the ConfigMap named as <code>tcp-services</code> is as follows:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: tcp-services\n  namespace: nginx-ingress\ndata:\n  # update \n  9769: \"default/nebula-graphd-svc:9669\"\n</code></pre> <p>Steps are as follows.</p> <ol> <li> <p>Create a file named <code>nginx-ingress-daemonset-hostnetwork.yaml</code>. </p> <p>Click on nginx-ingress-daemonset-hostnetwork.yaml to view the complete content of the example YAML file.</p> <p>Note</p> <p>The resource objects in the YAML file above use the namespace <code>nginx-ingress</code>. You can run <code>kubectl create namespace nginx-ingress</code> to create this namespace, or you can customize the namespace.</p> </li> <li> <p>Label a node where the DaemonSet named <code>nginx-ingress-controller</code> in the above YAML file (The node used in this example is named <code>worker2</code> with an IP of <code>192.168.8.160</code>) runs.</p> <pre><code>kubectl label node worker2 nginx-ingress=true\n</code></pre> </li> <li> <p>Run the following command to enable Nginx Ingress in the cluster you created. </p> <pre><code>kubectl create -f nginx-ingress-daemonset-hostnetwork.yaml\n</code></pre> <p>Output:</p> <pre><code>configmap/nginx-ingress-controller created\nconfigmap/tcp-services created\nserviceaccount/nginx-ingress created\nserviceaccount/nginx-ingress-backend created\nclusterrole.rbac.authorization.k8s.io/nginx-ingress created\nclusterrolebinding.rbac.authorization.k8s.io/nginx-ingress created\nrole.rbac.authorization.k8s.io/nginx-ingress created\nrolebinding.rbac.authorization.k8s.io/nginx-ingress created\nservice/nginx-ingress-controller-metrics created\nservice/nginx-ingress-default-backend created\nservice/nginx-ingress-proxy-tcp created\ndaemonset.apps/nginx-ingress-controller created\n</code></pre> <p>Since the network type that is configured in Nginx Ingress is <code>hostNetwork</code>, after successfully deploying Nginx Ingress, with the IP (<code>192.168.8.160</code>) of the node where Nginx Ingress is deployed and with the external port (<code>9769</code>) you define, you can access NebulaGraph. </p> </li> <li> <p>Use the IP address and the port configured in the preceding steps. You can connect to NebulaGraph with NebulaGraph Console. </p> <pre><code>kubectl run -ti --image vesoft/nebula-console:v3.8.0 --restart=Never -- &lt;nebula_console_name&gt; -addr &lt;host_ip&gt; -port &lt;external_port&gt; -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <p>Output:</p> <pre><code>kubectl run -ti --image vesoft/nebula-console:v3.8.0 --restart=Never -- nebula-console -addr 192.168.8.160 -port 9769 -u root -p vesoft\n</code></pre> <ul> <li><code>--image</code>: The image for the tool NebulaGraph Console used to connect to NebulaGraph databases.</li> <li><code>&lt;nebula-console&gt;</code> The custom Pod name. The above example uses <code>nebula-console</code>.</li> <li><code>-addr</code>: The IP of the node where Nginx Ingress is deployed. The above example uses <code>192.168.8.160</code>.</li> <li><code>-port</code>: The port used for external network access. The above example uses <code>9769</code>.</li> <li><code>-u</code>: The username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is root.</li> <li><code>-p</code>: The password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password.</li> </ul> <p>A successful connection to the database is indicated if the following is returned:</p> <pre><code>If you don't see a command prompt, try pressing enter.\n(root@nebula) [(none)]&gt;\n</code></pre> <p>Note</p> <p>If the <code>spec.console</code> field is set in the cluster configuration file, you can also connect to NebulaGraph databases with the following command:</p> <pre><code># Enter the nebula-console Pod.\nkubectl exec -it nebula-console -- /bin/sh\n\n# Connect to NebulaGraph databases.\nnebula-console -addr &lt;ingress_host_ip&gt; -port &lt;external_port&gt; -u &lt;username&gt; -p &lt;password&gt;\n</code></pre> <p>For information about the nebula-console container, see nebula-console. </p> </li> </ol>"},{"location":"k8s-operator/3.operator-management/3.1.customize-installation/","title":"Customize installation defaults","text":"<p>This topic introduces how to customize the default configurations when installing NebulaGraph Operator.</p>"},{"location":"k8s-operator/3.operator-management/3.1.customize-installation/#customizable_parameters","title":"Customizable parameters","text":"<p>When executing the <code>helm install [NAME] [CHART] [flags]</code> command to install a chart, you can specify the chart configuration. For more information, see Customizing the Chart Before Installing.</p> <p>You can view the configurable options in the nebula-operator chart configuration file. Alternatively, you can view the configurable options through the command <code>helm show values nebula-operator/nebula-operator</code>, as shown below.</p> <pre><code>[root@master ~]$ helm show values nebula-operator/nebula-operator   \nimage:\n  nebulaOperator:\n    image: vesoft/nebula-operator:v1.8.0\n    imagePullPolicy: Always\n\nimagePullSecrets: [ ]\nkubernetesClusterDomain: \"\"\n\ncontrollerManager:\n  create: true\n  replicas: 2\n  env: [ ]\n  resources:\n    limits:\n      cpu: 200m\n      memory: 200Mi\n    requests:\n      cpu: 100m\n      memory: 100Mi\n  verbosity: 0\n  ## Additional InitContainers to initialize the pod\n  # Example:\n  #  extraInitContainers:\n  #  - name: init-auth-sidecar\n  #    command:\n  #    - /bin/sh\n  #    - -c\n  #    args:\n  #    - cp -R /certs/* /credentials/\n  #    imagePullPolicy: Always\n  #    image: reg.vesoft-inc.com/nebula-certs:latest\n  #    volumeMounts:\n  #    - name: credentials\n  #      mountPath: /credentials\n  extraInitContainers: []\n\n  # sidecarContainers - add more containers to controller-manager\n  # Key/Value where Key is the sidecar `- name: &lt;Key&gt;`\n  # Example:\n  #   sidecarContainers:\n  #      webserver:\n  #        image: nginx\n  # OR for adding netshoot to controller manager\n  #  sidecarContainers:\n  #    netshoot:\n  #      args:\n  #      - -c\n  #      - while true; do ping localhost; sleep 60;done\n  #      command:\n  #      - /bin/bash\n  #      image: nicolaka/netshoot\n  #      imagePullPolicy: Always\n  #      name: netshoot\n  #      resources: {}\n  sidecarContainers: {}\n\n  ## Additional controller-manager Volumes\n  extraVolumes: []\n\n  ## Additional controller-manager Volume mounts\n  extraVolumeMounts: []\n\n  securityContext: {}\n  #  runAsNonRoot: true\n\nadmissionWebhook:\n  create: false\n  # The TCP port the Webhook server binds to. (default 9443)\n  webhookBindPort: 9443\n\nscheduler:\n  create: true\n  schedulerName: nebula-scheduler\n  replicas: 2\n  env: [ ]\n  resources:\n    limits:\n      cpu: 200m\n      memory: 200Mi\n    requests:\n      cpu: 100m\n      memory: 100Mi\n  verbosity: 0\n  plugins:\n    enabled: [\"NodeZone\"]\n    disabled: [] # Only in-tree plugins need to be defined here\n...\n</code></pre> <p>Part of the above parameters are described as follows:</p> Parameter Default value Description <code>image.nebulaOperator.image</code> <code>vesoft/nebula-operator:v1.8.0</code> The image of NebulaGraph Operator, version of which is 1.8.0. <code>image.nebulaOperator.imagePullPolicy</code> <code>IfNotPresent</code> The image pull policy in Kubernetes. <code>imagePullSecrets</code> - The image pull secret in Kubernetes. For example <code>imagePullSecrets[0].name=\"vesoft\"</code>. <code>kubernetesClusterDomain</code> <code>cluster.local</code> The cluster domain. <code>controllerManager.create</code> <code>true</code> Whether to enable the controller-manager component. <code>controllerManager.replicas</code> <code>2</code> The number of controller-manager replicas. <code>controllerManager.env</code> <code>[]</code> The environment variables for the controller-manager component. <code>controllerManager.extraInitContainers</code> <code>[]</code> Runs an init container. <code>controllerManager.sidecarContainers</code> <code>{}</code> Runs a sidecar container. <code>controllerManager.extraVolumes</code> <code>[]</code> Sets a storage volume. <code>controllerManager.extraVolumeMounts</code> <code>[]</code> Sets the storage volume mount path. <code>controllerManager.securityContext</code> <code>{}</code> Configures the access and control settings for NebulaGraph Operator. <code>admissionWebhook.create</code> <code>false</code> Whether to enable Admission Webhook. This option is disabled. To enable it, set the value to <code>true</code> and you will need to install cert-manager. For details, see Enable admission control. <code>admissionWebhook.webhookBindPort</code> <code>9443</code> The TCP port the Webhook server binds to. It is 9443 by default. <code>shceduler.create</code> <code>true</code> Whether to enable Scheduler. <code>shceduler.schedulerName</code> <code>nebula-scheduler</code> The name of the scheduler customized by NebulaGraph Operator. <code>shceduler.replicas</code> <code>2</code> The number of nebula-scheduler replicas."},{"location":"k8s-operator/3.operator-management/3.1.customize-installation/#example","title":"Example","text":"<p>The following example shows how to enable AdmissionWebhook when you install NebulaGraph Operator (AdmissionWebhook is disabled by default):</p> <pre><code>helm install nebula-operator nebula-operator/nebula-operator --namespace=&lt;nebula-operator-system&gt; --set admissionWebhook.create=true\n</code></pre> <p>Check whether the specified configuration of NebulaGraph Operator is installed successfully:</p> <pre><code>helm get values nebula-operator -n &lt;nebula-operator-system&gt;\n</code></pre> <p>Example output:</p> <pre><code>USER-SUPPLIED VALUES:\nadmissionWebhook:\n  create: true\n</code></pre> <p>For more information about <code>helm install</code>, see Helm Install.</p>"},{"location":"k8s-operator/3.operator-management/3.2.update-operator/","title":"Update NebulaGraph Operator","text":"<p>This topic introduces how to update the configuration of NebulaGraph Operator.</p>"},{"location":"k8s-operator/3.operator-management/3.2.update-operator/#steps","title":"Steps","text":"<ol> <li> <p>Update the information of available charts locally from chart repositories.</p> <pre><code>helm repo update\n</code></pre> </li> <li> <p>View the default values of NebulaGraph Operator.</p> <pre><code>helm show values nebula-operator/nebula-operator\n</code></pre> </li> <li> <p>Update NebulaGraph Operator by passing configuration parameters via <code>--set</code>.</p> <ul> <li><code>--set</code>\uff1aOverrides values using the command line. For more configurable items, see Customize installation defaults.</li> </ul> <p>For example, to enable the AdmissionWebhook, run the following command:</p> <pre><code>helm upgrade nebula-operator nebula-operator/nebula-operator --namespace=nebula-operator-system --version=1.8.0 --set admissionWebhook.create=true\n</code></pre> <p>For more information, see Helm upgrade.</p> </li> <li> <p>Check whether the configuration of NebulaGraph Operator is updated successfully.</p> <pre><code>helm get values nebula-operator -n nebula-operator-system\n</code></pre> <p>Example output:</p> <pre><code>USER-SUPPLIED VALUES:\nadmissionWebhook:\n  create: true\n</code></pre> </li> </ol>"},{"location":"k8s-operator/3.operator-management/3.3.upgrade-operator/","title":"Upgrade NebulaGraph Operator","text":"<p>Legacy version compatibility</p> <ul> <li>Does not support upgrading 0.9.0 and below version NebulaGraph Operator to 1.x.</li> <li>The 1.x version NebulaGraph Operator is not compatible with NebulaGraph of version below v3.x.</li> </ul>"},{"location":"k8s-operator/3.operator-management/3.3.upgrade-operator/#steps","title":"Steps","text":"<ol> <li> <p>View the current version of NebulaGraph Operator.</p> <pre><code>helm list --all-namespaces\n</code></pre> <p>Example output:</p> <pre><code>NAME              NAMESPACE               REVISION    UPDATED                                 STATUS      CHART                   APP VERSION\nnebula-operator   nebula-operator-system  3           2023-11-06 12:06:24.742397418 +0800 CST deployed    nebula-operator-1.7.0   1.7.0\n</code></pre> </li> <li> <p>Update the information of available charts locally from chart repositories.</p> <pre><code>helm repo update\n</code></pre> </li> <li> <p>View the latest version of NebulaGraph Operator.</p> <pre><code>helm search repo nebula-operator/nebula-operator\n</code></pre> <p>Example output:</p> <pre><code>NAME                              CHART VERSION   APP VERSION DESCRIPTION\nnebula-operator/nebula-operator   1.8.0           1.8.0       Nebula Operator Helm chart for Kubernetes\n</code></pre> </li> <li> <p>Upgrade NebulaGraph Operator to version 1.8.0.</p> <pre><code>helm upgrade nebula-operator nebula-operator/nebula-operator --namespace=&lt;namespace_name&gt; --version=1.8.0\n</code></pre> <p>For example:</p> <pre><code>helm upgrade nebula-operator nebula-operator/nebula-operator --namespace=nebula-operator-system --version=1.8.0\n</code></pre> <p>Output:</p> <pre><code>Release \"nebula-operator\" has been upgraded. Happy Helming!\nNAME: nebula-operator\nLAST DEPLOYED: Tue Apr 16 02:21:08 2022\nNAMESPACE: nebula-operator-system\nSTATUS: deployed\nREVISION: 3\nTEST SUITE: None\nNOTES:\nNebulaGraph Operator installed!\n</code></pre> </li> <li> <p>Pull the latest CRD configuration file.</p> <p>Note</p> <p>You need to upgrade the corresponding CRD configurations after NebulaGraph Operator is upgraded. Otherwise, the creation of NebulaGraph clusters will fail. For information about the CRD configurations, see apps.nebula-graph.io_nebulaclusters.yaml.</p> <ol> <li> <p>Pull the NebulaGraph Operator chart package.</p> <pre><code>helm pull nebula-operator/nebula-operator --version=1.8.0\n</code></pre> <ul> <li><code>--version</code>: The NebulaGraph Operator version you want to upgrade to. If not specified, the latest version will be pulled.</li> </ul> </li> <li> <p>Run <code>tar -zxvf</code> to unpack the charts.</p> <p>For example: To unpack v1.8.0 chart to the <code>/tmp</code> path, run the following command:</p> <pre><code>tar -zxvf nebula-operator-1.8.0.tgz -C /tmp\n</code></pre> <ul> <li><code>-C /tmp</code>: If not specified, the chart files will be unpacked to the current directory.</li> </ul> </li> </ol> </li> <li> <p>Apply the latest CRD configuration file in the <code>nebula-operator</code> directory.</p> <pre><code>kubectl apply -f crds/nebulaclusters.yaml\n</code></pre> <p>Output:</p> <pre><code>customresourcedefinition.apiextensions.k8s.io/nebulaclusters.apps.nebula-graph.io configured\n</code></pre> </li> </ol>"},{"location":"k8s-operator/3.operator-management/3.4.unistall-operator/","title":"Uninstall NebulaGraph Operator","text":"<p>This topic introduces how to uninstall NebulaGraph Operator.</p>"},{"location":"k8s-operator/3.operator-management/3.4.unistall-operator/#steps","title":"Steps","text":"<ol> <li> <p>Uninstall the NebulaGraph Operator chart.</p> <pre><code>helm uninstall nebula-operator --namespace=&lt;nebula-operator-system&gt;\n</code></pre> </li> <li> <p>View the information about the default-created CRD.</p> <pre><code>kubectl get crd\n</code></pre> <p>Output:</p> <pre><code>NAME                                                 CREATED AT\nnebulaautoscalers.autoscaling.nebula-graph.io        2023-11-01T04:16:51Z\nnebulaclusters.apps.nebula-graph.io                  2023-10-12T07:55:32Z\nnebularestores.apps.nebula-graph.io                  2023-02-04T23:01:00Z\n</code></pre> </li> <li> <p>Delete CRD.</p> <pre><code>kubectl delete crd nebulaclusters.apps.nebula-graph.io nebularestores.apps.nebula-graph.io nebulaautoscalers.autoscaling.nebula-graph.io\n</code></pre> </li> </ol>"},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/","title":"Use NebulaGraph Operator to manage specific clusters","text":"<p>NebulaGraph Operator supports the management of multiple NebulaGraph clusters. By default, NebulaGraph Operator manages all NebulaGraph clusters. However, you can specify the clusters managed by NebulaGraph Operator. This topic describes how to specify the clusters managed by NebulaGraph Operator.</p>"},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/#application_scenarios","title":"Application scenarios","text":"<ul> <li>Gray release of NebulaGraph Operator: You want to run the new Nebula Operator version on a part of the clusters first to test and verify its performance before fully releasing it.</li> <li>Manage specific clusters: You want NebulaGraph Operator to manage only specific NebulaGraph clusters.</li> </ul>"},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/#configurations","title":"Configurations","text":"<p>NebulaGraph Operator supports specifying the clusters managed by controller-manager through startup parameters. The supported parameters are as follows:</p> <ul> <li><code>watchNamespaces</code>: Specifies the namespace where the NebulaGraph cluster is located. To specify multiple namespaces, separate them with commas (<code>,</code>). For example, <code>watchNamespaces=default,nebula</code>. If this parameter is not specified, NebulaGraph Operator manages all NebulaGraph clusters in all namespaces.</li> </ul> <ul> <li><code>nebulaObjectSelector</code>: Allows you to set specific labels and values to select the NebulaGraph clusters to be managed. It supports three label operation symbols: <code>=</code>, <code>==</code>, and <code>!=</code>. Both <code>=</code> and <code>==</code> mean that the label's value is equal to the specified value, while <code>!=</code> means the tag's value is not equal to the specified value. Multiple labels are separated by commas (<code>,</code>), and the comma needs to be escaped with <code>\\\\</code>. For example, <code>nebulaObjectSelector=key1=value1\\\\,key2=value2</code>, which selects only the NebulaGraph clusters with labels <code>key1=value1</code> and <code>key2=value2</code>. If this parameter is not specified, NebulaGraph Operator manages all NebulaGraph clusters.</li> </ul>"},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/#examples","title":"Examples","text":""},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/#specify_the_managed_clusters_by_namespace","title":"Specify the managed clusters by namespace","text":"<p>Run the following command to make NebulaGraph Operator manage only the NebulaGraph clusters in the <code>default</code> and <code>nebula</code> namespaces. Ensure that the current Helm Chart version supports this parameter. For more information, see Update the configuration.</p> <pre><code>helm upgrade nebula-operator nebula-operator/nebula-operator --set watchNamespaces=default,nebula\n</code></pre>"},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/#specify_the_managed_clusters_by_label","title":"Specify the managed clusters by label","text":"<p>Run the following command to make NebulaGraph Operator manage only the NebulaGraph clusters with the labels <code>key1=value1</code> and <code>key2=value2</code>. Ensure that the current Helm Chart version supports this parameter. For more information, see Update the configuration.</p> <pre><code>helm upgrade nebula-operator nebula-operator/nebula-operator --set nebulaObjectSelector=key1=value1\\\\,key2=value2\n</code></pre>"},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/#faq","title":"FAQ","text":""},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/#how_to_set_labels_for_nebulagraph_clusters","title":"How to set labels for NebulaGraph clusters?","text":"<p>Run the following command to set a label for the NebulaGraph cluster:</p> <pre><code>kubectl label nc &lt;cluster_name&gt; -n &lt;namespace&gt; &lt;key&gt;=&lt;value&gt;\n</code></pre> <p>For example, set the label <code>env=test</code> for the NebulaGraph cluster named <code>nebula</code> in the <code>nebulaspace</code> namespace:</p> <pre><code>kubectl label nc nebula -n nebulaspace env=test\n</code></pre>"},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/#how_to_view_the_labels_of_nebulagraph_clusters","title":"How to view the labels of NebulaGraph clusters?","text":"<p>Run the following command to view the labels of NebulaGraph clusters:</p> <pre><code>kubectl get nc &lt;cluster_name&gt; -n &lt;namespace&gt; --show-labels\n</code></pre> <p>For example, view the labels of the NebulaGraph cluster named <code>nebula</code> in the <code>nebulaspace</code> namespace:</p> <pre><code>kubectl get nc nebula -n nebulaspace --show-labels\n</code></pre>"},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/#how_to_delete_the_labels_of_nebulagraph_clusters","title":"How to delete the labels of NebulaGraph clusters?","text":"<p>Run the following command to delete the label of NebulaGraph clusters:</p> <pre><code>kubectl label nc &lt;cluster_name&gt; -n &lt;namespace&gt; &lt;key&gt;-\n</code></pre> <p>For example, delete the label <code>env=test</code> of the NebulaGraph cluster named <code>nebula</code> in the <code>nebulaspace</code> namespace:</p> <pre><code>kubectl label nc nebula -n nebulaspace env-\n</code></pre>"},{"location":"k8s-operator/3.operator-management/3.5.cluster-scope-config/#how_to_view_the_namespace_where_the_nebulagraph_cluster_is_located","title":"How to view the namespace where the NebulaGraph cluster is located?","text":"<p>Run the following command to list all namespaces where the NebulaGraph clusters are located:</p> <pre><code>kubectl get nc --all-namespaces\n</code></pre>"},{"location":"k8s-operator/4.cluster-administration/4.2.configuration/","title":"Customize the configuration of the NebulaGraph cluster","text":"<p>The Meta, Storage, and Graph services each have their default configurations within the NebulaGraph cluster. NebulaGraph Operator allows for the customization of these cluster service configurations. This topic describes how to update the settings of the NebulaGraph cluster.</p> <p>Note</p> <p>Configuring the parameters of the NebulaGraph cluster via Helm isn't currently supported.</p>"},{"location":"k8s-operator/4.cluster-administration/4.2.configuration/#prerequisites","title":"Prerequisites","text":"<p>A cluster is created using NebulaGraph Operator. For details, see Create a NebulaGraph Cluster.</p>"},{"location":"k8s-operator/4.cluster-administration/4.2.configuration/#configuration_method","title":"Configuration method","text":"<p>You can update the configurations of cluster services by customizing parameters through <code>spec.&lt;metad|graphd|storaged&gt;.config</code>. NebulaGraph Operator loads the configurations from <code>config</code> into the corresponding service's ConfigMap, which is then mounted into the service's configuration file directory (<code>/usr/local/nebula/etc/</code>) at the time of the service launch.</p> <p>The structure of <code>config</code> is as follows:</p> <pre><code>Config map[string]string `json:\"config,omitempty\"`\n</code></pre> <p>For instance, when updating the Graph service's <code>enable_authorize</code> parameter settings, the <code>spec.graphd.config</code> parameter can be specified at the time of cluster creation, or during cluster runtime.</p> <pre><code>apiVersion: apps.nebula-graph.io/v1alpha1\nkind: NebulaCluster\nmetadata:\n  name: nebula\n  namespace: default\nspec:\n  graphd:\n    ...\n    config: // Custom-defined parameters for the Graph service.\n      \"enable_authorize\": \"true\"  // Enable authorization. Default value is false.\n...\n</code></pre> <p>If you need to configure <code>config</code> for the Meta and Storage services, add corresponding configuration items to <code>spec.metad.config</code> and <code>spec.storaged.config</code>.</p>"},{"location":"k8s-operator/4.cluster-administration/4.2.configuration/#configurable_parameters","title":"Configurable parameters","text":"<p>For more detailed information on the parameters that can be set under the <code>config</code> field, see the following:</p> <ul> <li>Meta Service Configuration Parameters</li> <li>Storage Service Configuration Parameters</li> <li>Graph Service Configuration Parameters</li> </ul>"},{"location":"k8s-operator/4.cluster-administration/4.2.configuration/#parameter_updates_pod_restart_rules","title":"Parameter updates &amp; Pod restart rules","text":"<p>Configuration parameters for cluster services fall into two categories: those which require a service restart for any updates; and those which can be dynamically updated during service runtime. For the latter type, the updates will not be saved; subsequent to a service restart, configurations will revert to the state as shown in the configuration file.</p> <p>Regarding if the configuration parameters support dynamic updates during service runtime, please verify the information within the Whether supports runtime dynamic modifications column on each of the service configuration parameter detail pages linked above or see Dynamic runtime flags.</p> <p>During the update of cluster service configurations, keep the following points in mind:</p> <ul> <li>If the updated parameters under <code>config</code> all allow for dynamic runtime updates, a service Pod restart will not be triggered and the configuration parameter updates will not be saved.</li> <li>If the updated parameters under <code>config</code> include one or more that don\u2019t allow for dynamic runtime updates, a service Pod restart will be triggered, but only updates to those parameters that don\u2019t allow for dynamic updates will be saved.</li> </ul> <p>Note</p> <p>If you wish to modify the parameter settings during cluster runtime without triggering a Pod restart, make sure that all the parameters support dynamic updates during runtime.</p>"},{"location":"k8s-operator/4.cluster-administration/4.2.configuration/#customize_port_configuration","title":"Customize port configuration","text":"<p>The following example demonstrates how to customize the port configurations for the Meta, Storage, and Graph services.</p> <p>You can add <code>port</code> and <code>ws_http_port</code> parameters to the <code>config</code> field in order to set custom ports. For detailed information regarding these two parameters, see the networking configuration sections at Meta Service Configuration Parameters, Storage Service Configuration Parameters, Graph Service Configuration Parameters.</p> <p>Note</p> <ul> <li>After customizing the <code>port</code> and <code>ws_http_port</code> parameter settings, a Pod restart is triggered and then the updated settings take effect after the restart.</li> <li>Once the cluster is started, it is not recommended to modify the <code>port</code> parameter.</li> </ul> <ol> <li> <p>Modify the cluster configuration file.</p> <ol> <li> <p>Open the cluster configuration file.</p> <pre><code>kubectl edit nc nebula\n</code></pre> </li> <li> <p>Modify the configuration file as follows. </p> <p>Add the <code>config</code> field to the <code>graphd</code>, <code>metad</code>, and <code>storaged</code> sections to customize the port configurations for the Graph, Meta, and Storage services, respectively.</p> <pre><code>apiVersion: apps.nebula-graph.io/v1alpha1\nkind: NebulaCluster\nmetadata:\n  name: nebula\n  namespace: default\nspec:\n  graphd:\n    config:  // Custom port configuration for the Graph service.\n      port: \"3669\"\n      ws_http_port: \"8080\"\n    resources:\n      requests:\n        cpu: \"200m\"\n        memory: \"500Mi\"\n      limits:\n        cpu: \"1\"\n        memory: \"1Gi\"\n    replicas: 1\n    image: vesoft/nebula-graphd\n    version: v3.8.0\n  metad: \n    config:  // Custom port configuration for the Meta service.\n      ws_http_port: 8081\n    resources:\n      requests:\n        cpu: \"300m\"\n        memory: \"500Mi\"\n      limits:\n        cpu: \"1\"\n        memory: \"1Gi\"\n    replicas: 1\n    image: vesoft/nebula-metad\n    version: v3.8.0\n    dataVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: local-path\n  storaged:  \n    config:  // Custom port configuration for the Storage service.\n      ws_http_port: 8082\n    resources:\n      requests:\n        cpu: \"300m\"\n        memory: \"500Mi\"\n      limits:\n        cpu: \"1\"\n        memory: \"1Gi\"\n    replicas: 1\n    image: vesoft/nebula-storaged\n    version: v3.8.0\n    dataVolumeClaims:\n    - resources:\n        requests:\n          storage: 2Gi\n      storageClassName: local-path\n    enableAutoBalance: true\n  reference:\n    name: statefulsets.apps\n    version: v1\n  schedulerName: default-scheduler\n  imagePullPolicy: IfNotPresent\n  imagePullSecrets:\n  - name: nebula-image\n  enablePVReclaim: true\n  topologySpreadConstraints:\n  - topologyKey: kubernetes.io/hostname\n    whenUnsatisfiable: \"ScheduleAnyway\"\n</code></pre> </li> </ol> </li> <li> <p>Save the changes.</p> <p>Changes will be saved automatically after saving the file.</p> <ol> <li>Press <code>Esc</code> to enter command mode.</li> <li>Enter <code>:wq</code> to save and exit.</li> </ol> </li> <li> <p>Validate that the configurations have taken effect.</p> <pre><code>kubectl get svc\n</code></pre> <p>Example output:</p> <pre><code>NAME                        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE\nnebula-graphd-headless      ClusterIP   None             &lt;none&gt;        3669/TCP,8080/TCP            10m\nnebula-graphd-svc           ClusterIP   10.102.13.115    &lt;none&gt;        3669/TCP,8080/TCP            10m\nnebula-metad-headless       ClusterIP   None             &lt;none&gt;        9559/TCP,8081/TCP            11m\nnebula-storaged-headless    ClusterIP   None             &lt;none&gt;        9779/TCP,8082/TCP,9778/TCP   11m\n</code></pre> <p>As can be noticed, the Graph service's RPC daemon port is changed to <code>3669</code> (default <code>9669</code>), the HTTP port to <code>8080</code> (default <code>19669</code>); the Meta service's HTTP port is changed to <code>8081</code> (default <code>19559</code>); the Storage service's HTTP port is changed to <code>8082</code> (default <code>19779</code>).</p> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.5.logging/","title":"Manage cluster logs","text":"<p>Running logs of NebulaGraph cluster services (graphd, metad, storaged) are generated and stored in the <code>/usr/local/nebula/logs</code> directory of each service container by default.</p>"},{"location":"k8s-operator/4.cluster-administration/4.5.logging/#view_logs","title":"View logs","text":"<p>To view the running logs of a NebulaGraph cluster, you can use the <code>kubectl logs</code> command. </p> <p>For example, to view the running logs of the Storage service:</p> <pre><code>// View the name of the Storage service Pod, nebula-storaged-0.\n$ kubectl get pods -l app.kubernetes.io/component=storaged\nNAME                               READY   STATUS    RESTARTS      AGE\nnebula-storaged-0                  1/1     Running   0             45h\n...\n\n// Enter the container storaged of the Storage service.\n$ kubectl exec -it nebula-storaged-0 -c storaged -- /bin/bash\n\n// View the running logs of the Storage service.\n$ cd /usr/local/nebula/logs\n</code></pre>"},{"location":"k8s-operator/4.cluster-administration/4.5.logging/#clean_logs","title":"Clean logs","text":"<p>Running logs generated by cluster services during runtime will occupy disk space. To avoid occupying too much disk space, the NebulaGraph Operator uses a sidecar container to periodically clean and archive logs.</p> <p>To facilitate log collection and management, each NebulaGraph service deploys a sidecar container responsible for collecting logs generated by the service container and sending them to the specified log disk. The sidecar container automatically cleans and archives logs using the logrotate tool.</p> <p>In the YAML configuration file of the cluster instance, set <code>spec.logRotate</code> to enable log rotation and set <code>timestamp_in_logfile_name</code> to <code>false</code> to disable the timestamp in the log file name to implement log rotation for the target service. The <code>timestamp_in_logfile_name</code> parameter is configured under the <code>spec.&lt;graphd|metad|storaged&gt;.config</code> field. By default, the log rotation feature is turned off. Here is an example of enabling log rotation for all services:</p> <pre><code>...\nspec:\n  graphd:\n    config:\n      # Whether to include a timestamp in the log file name. \n      # You must set this parameter to false to enable log rotation. \n      # It is set to true by default.\n      \"timestamp_in_logfile_name\": \"false\"\n  metad:\n    config:\n      \"timestamp_in_logfile_name\": \"false\"\n  storaged:\n    config:\n      \"timestamp_in_logfile_name\": \"false\"\n  logRotate: # Log rotation configuration\n    # The number of times a log file is rotated before being deleted.\n    # The default value is 5, and 0 means the log file will not be rotated before being deleted.\n    rotate: 5\n    # The log file is rotated only if it grows larger than the specified size. The default value is 200M.\n    size: \"200M\"\n</code></pre>"},{"location":"k8s-operator/4.cluster-administration/4.5.logging/#collect_logs","title":"Collect logs","text":"<p>If you don't want to mount additional log disks to back up log files, or if you want to collect logs and send them to a log center using services like fluent-bit, you can configure logs to be output to standard error. The Operator uses the glog tool to log to standard error output.</p> <p>Note</p> <p>Currently, NebulaGraph Operator only collects standard error logs.</p> <p>In the YAML configuration file of the cluster instance, you can configure logging to standard error output in the <code>config</code> and <code>env</code> fields of each service.</p> <pre><code>...\nspec:\n  graphd:\n    config:\n      # Whether to redirect standard error to a separate output file. The default value is false, which means it is not redirected.\n      redirect_stdout: \"false\"\n      # The severity level of log content: INFO, WARNING, ERROR, and FATAL. The corresponding values are 0, 1, 2, and 3.\n      stderrthreshold: \"0\"\n    env: \n    - name: GLOG_logtostderr # Write log to standard error output instead of a separate file.\n      value: \"1\" # 1 represents writing to standard error output, and 0 represents writing to a file.\n    image: vesoft/nebula-graphd\n    replicas: 1\n    resources:\n      requests:\n        cpu: 500m\n        memory: 500Mi\n    service:\n      externalTrafficPolicy: Local\n      type: NodePort\n    version: v3.8.0\n  metad:\n    config:\n      redirect_stdout: \"false\"\n      stderrthreshold: \"0\"\n    dataVolumeClaim:\n      resources:\n        requests:\n          storage: 1Gi\n      storageClassName: ebs-sc\n    env:\n    - name: GLOG_logtostderr\n      value: \"1\"\n    image: vesoft/nebula-metad\n  ...\n</code></pre>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.1.cluster-install/","title":"Install a NebulaGraph cluster using NebulaGraph Operator","text":"<p>Using NebulaGraph Operator to install NebulaGraph clusters enables automated cluster management with automatic error recovery. This topic covers two methods, <code>kubectl apply</code> and <code>helm</code>, for installing clusters using NebulaGraph Operator.</p> <p>Historical version compatibility</p> <p>NebulaGraph Operator versions 1.x are not compatible with NebulaGraph versions below 3.x.</p>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.1.cluster-install/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install NebulaGraph Operator</li> <li>Create a StorageClass</li> </ul>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.1.cluster-install/#use_kubectl_apply","title":"Use <code>kubectl apply</code>","text":"<ol> <li> <p>Create a namespace for storing NebulaGraph cluster-related resources. For example, create the <code>nebula</code> namespace.</p> <pre><code>kubectl create namespace nebula\n</code></pre> </li> <li> <p>Create a YAML configuration file <code>nebulacluster.yaml</code> for the cluster. For example, create a cluster named <code>nebula</code>.</p> Expand to view an example configuration for the <code>nebula</code> cluster <pre><code>apiVersion: apps.nebula-graph.io/v1alpha1\nkind: NebulaCluster\nmetadata:\n  name: nebula\n  namespace: default\nspec:\n  # Control the Pod scheduling strategy.\n  topologySpreadConstraints:\n  - topologyKey: \"kubernetes.io/hostname\"\n    whenUnsatisfiable: \"ScheduleAnyway\"\n  # Enable PV recycling.\n  enablePVReclaim: false\n  # Enable monitoring.\n  exporter:\n    image: vesoft/nebula-stats-exporter\n    version: v3.3.0\n    replicas: 1\n    maxRequests: 20\n  # Custom Agent image for cluster backup and restore, and log cleanup.\n  agent:\n    image: vesoft/nebula-agent\n    version: latest\n    resources:\n      requests:\n        cpu: \"100m\"\n        memory: \"128Mi\"\n      limits:\n        cpu: \"200m\"\n        memory: \"256Mi\"  \n  # Configure the image pull policy.\n  imagePullPolicy: Always\n  # Select the nodes for Pod scheduling.\n  nodeSelector:\n    nebula: cloud\n  # Dependent controller name.\n  reference:\n    name: statefulsets.apps\n    version: v1\n  # Scheduler name.\n  schedulerName: default-scheduler   \n  # Start NebulaGraph Console service for connecting to the Graph service.\n  console:\n    image: vesoft/nebula-console\n    version: nightly\n    username: \"demo\"\n    password: \"test\"                 \n  # Graph service configuration. \n  graphd:\n  # Used to check if the Graph service is running normally.\n  #  readinessProbe:\n  #    failureThreshold: 3\n  #    httpGet:\n  #      path: /status\n  #      port: 19669\n  #      scheme: HTTP\n  #    initialDelaySeconds: 40\n  #    periodSeconds: 10\n  #    successThreshold: 1\n  #    timeoutSeconds: 10\n    # Container image for the Graph service.\n    image: vesoft/nebula-graphd\n    logVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      # Storage class name for storing Graph service logs.\n      storageClassName: local-sc\n    # Number of replicas for the Graph service Pod.\n    replicas: 1\n    # Resource configuration for the Graph service.\n    resources:\n      limits:\n        cpu: \"1\"\n        memory: 1Gi\n      requests:\n        cpu: 500m\n        memory: 500Mi\n    # Version of the Graph service.\n    version: v3.8.0\n    # Custom flags configuration for the Graph service.\n    config: {}\n  # Meta service configuration.\n  metad:\n  #  readinessProbe:\n  #    failureThreshold: 3\n  #    httpGet:\n  #      path: /status\n  #      port: 19559\n  #      scheme: HTTP\n  #    initialDelaySeconds: 5\n  #    periodSeconds: 5\n  #    successThreshold: 1\n  #    timeoutSeconds: 5\n    # Container image for the Meta service.\n    image: vesoft/nebula-metad\n    logVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: local-sc\n    dataVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: local-sc\n    replicas: 1\n    resources:\n      limits:\n        cpu: \"1\"\n        memory: 1Gi\n      requests:\n        cpu: 500m\n        memory: 500Mi\n    version: v3.8.0\n    # Custom flags configuration for the Meta service.\n    config: {}          \n  # Storage service configuration.\n  storaged:\n  #  readinessProbe:\n  #    failureThreshold: 3\n  #    httpGet:\n  #      path: /status\n  #      port: 19779\n  #      scheme: HTTP\n  #    initialDelaySeconds: 40\n  #    periodSeconds: 10\n  #    successThreshold: 1\n  #    timeoutSeconds: 5\n    # Container image for the Storage service.\n    image: vesoft/nebula-graphd\n    logVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: local-sc\n    dataVolumeClaims:\n    - resources:\n        requests:\n          storage: 2Gi\n      storageClassName: local-sc\n    replicas: 1\n    resources:\n      limits:\n        cpu: \"1\"\n        memory: 1Gi\n      requests:\n        cpu: 500m\n        memory: 500Mi\n    version: v3.8.0\n    # Custom flags configuration for the Storage service.\n    config: {} \n</code></pre> Expand to view all configurable parameters and descriptions Parameter Default Value Description <code>metadata.name</code> - The name of the created NebulaGraph cluster. <code>spec.console</code> - Launches a Console container for connecting to the Graph service. For configuration details, see nebula-console. <code>spec.topologySpreadConstraints</code> - Controls the scheduling strategy for Pods. For more details, see Topology Spread Constraints. When the value of <code>topologyKey</code> is <code>kubernetes.io/zone</code>, the value of <code>whenUnsatisfiable</code> must be set to <code>DoNotSchedule</code>, and the value of <code>spec.schedulerName</code> should be <code>nebula-scheduler</code>. <code>spec.graphd.replicas</code> <code>1</code> The number of replicas for the Graphd service. <code>spec.graphd.image</code> <code>vesoft/nebula-graphd</code> The container image for the Graphd service. <code>spec.graphd.version</code> <code>v3.8.0</code> The version of the Graphd service. <code>spec.graphd.service</code> Configuration for accessing the Graphd service via a Service. <code>spec.graphd.logVolumeClaim.storageClassName</code> - The storage class name for the log volume claim of the Graphd service. When using sample configuration, replace it with the name of the pre-created storage class. See Storage Classes for creating a storage class. <code>spec.metad.replicas</code> <code>1</code> The number of replicas for the Metad service. <code>spec.metad.image</code> <code>vesoft/nebula-metad</code> The container image for the Metad service. <code>spec.metad.version</code> <code>v3.8.0</code> The version of the Metad service. <code>spec.metad.dataVolumeClaim.storageClassName</code> - Storage configuration for the data disk of the Metad service. When using sample configuration, replace it with the name of the pre-created storage class. See Storage Classes for creating a storage class. <code>spec.metad.logVolumeClaim.storageClassName</code> - Storage configuration for the log disk of the Metad service. When using sample configuration, replace it with the name of the pre-created storage class. See Storage Classes for creating a storage class. <code>spec.storaged.replicas</code> <code>3</code> The number of replicas for the Storaged service. <code>spec.storaged.image</code> <code>vesoft/nebula-storaged</code> The container image for the Storaged service. <code>spec.storaged.version</code> <code>v3.8.0</code> The version of the Storaged service. <code>spec.storaged.dataVolumeClaims.resources.requests.storage</code> - The storage size for the data disk of the Storaged service. You can specify multiple data disks. When specifying multiple data disks, the paths are like <code>/usr/local/nebula/data1</code>, <code>/usr/local/nebula/data2</code>, and so on. <code>spec.storaged.dataVolumeClaims.storageClassName</code> - Storage configuration for the data disks of the Storaged service. When using sample configuration, replace it with the name of the pre-created storage class. See Storage Classes for creating a storage class. <code>spec.storaged.logVolumeClaim.storageClassName</code> - Storage configuration for the log disk of the Storaged service. When using sample configuration, replace it with the name of the pre-created storage class. See Storage Classes for creating a storage class. <code>spec.&lt;metad|storaged|graphd&gt;.securityContext</code> <code>{}</code> Defines the permission and access control for the cluster containers to control access and execution of container operations. For details, see SecurityContext. <code>spec.agent</code> <code>{}</code> Configuration for the Agent service used for backup and recovery, and log cleaning functions. If you don't customize this configuration, the default configuration is used. <code>spec.reference.name</code> <code>{}</code> The name of the controller it depends on. <code>spec.schedulerName</code> <code>default-scheduler</code> The name of the scheduler. <code>spec.imagePullPolicy</code> <code>Always</code> The image pull policy for NebulaGraph images. For more details on pull policies, please see Image pull policy. <code>spec.logRotate</code> <code>{}</code> Log rotation configuration. For details, see Managing Cluster Logs. <code>spec.enablePVReclaim</code> <code>false</code> Defines whether to automatically delete PVCs after deleting the cluster to release data. For details, see Reclaim PV. <code>spec.metad.licenseManagerURL</code> - Configures the URL pointing to the License Manager (LM), consisting of the access address and port (default port <code>9119</code>). For example, <code>192.168.8.xxx:9119</code>. For creating the NebulaGraph Enterprise Edition only. <code>spec.storaged.enableAutoBalance</code> <code>false</code> Whether to enable automatic balancing. For details, see Balancing Storage Data After Scaling Out. <code>spec.enableBR</code> <code>false</code> Defines whether to enable the BR tool. For details, see Backup and Restore. <code>spec.imagePullSecrets</code> <code>[]</code> Defines the Secret required to pull images from a private repository. </li> <li> <p>Create the NebulaGraph cluster.</p> <pre><code>kubectl create -f nebulacluster.yaml -n nebula\n</code></pre> <p>Output:</p> <pre><code>nebulacluster.apps.nebula-graph.io/nebula created\n</code></pre> <p>If you don't specify the namespace using <code>-n</code>, it will default to the <code>default</code> namespace.</p> </li> <li> <p>Check the status of the NebulaGraph cluster.</p> <pre><code>kubectl get nebulaclusters nebula -n nebula\n</code></pre> <p>Output:</p> <pre><code>NAME      READY   GRAPHD-DESIRED   GRAPHD-READY   METAD-DESIRED   METAD-READY   STORAGED-DESIRED   STORAGED-READY   AGE\nnebula    True    1                1              1               1             1                  1                86s\n</code></pre> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.1.cluster-install/#use_helm","title":"Use <code>helm</code>","text":"<ol> <li> <p>Add the NebulaGraph Operator Helm repository (if it's already added, run the next step directly).</p> <pre><code>helm repo add nebula-operator https://vesoft-inc.github.io/nebula-operator/charts\n</code></pre> </li> <li> <p>Update the Helm repository to fetch the latest resources.</p> <pre><code>helm repo update nebula-operator\n</code></pre> </li> <li> <p>Set environment variables for the configuration parameters required for installing the cluster.</p> <pre><code>export NEBULA_CLUSTER_NAME=nebula         # Name of the NebulaGraph cluster.\nexport NEBULA_CLUSTER_NAMESPACE=nebula    # Namespace for the NebulaGraph cluster.\nexport STORAGE_CLASS_NAME=local-sc       # StorageClass for the NebulaGraph cluster.\n</code></pre> </li> <li> <p>Create a namespace for the NebulaGraph cluster if it is not created.</p> <pre><code>kubectl create namespace \"${NEBULA_CLUSTER_NAMESPACE}\"\n</code></pre> </li> <li> <p>Check the customizable configuration parameters for the <code>nebula-cluster</code> Helm chart of the <code>nebula-operator</code> when creating the cluster.</p> <ul> <li>Visit nebula-cluster/values.yaml to see all the configuration parameters for the NebulaGraph cluster. </li> </ul> <ul> <li> <p>Run the following command to view all the configurable parameters.</p> <pre><code>helm show values nebula-operator/nebula-cluster\n</code></pre> Example to view all configurable parameters <pre><code>nebula:\n  version: v3.8.0\n  imagePullPolicy: Always\n  storageClassName: \"\"\n  enablePVReclaim: false\n  enableBR: false\n  enableForceUpdate: false\n  schedulerName: default-scheduler \n  topologySpreadConstraints:\n  - topologyKey: \"kubernetes.io/hostname\"\n    whenUnsatisfiable: \"ScheduleAnyway\"\n  logRotate: {}\n  reference:\n    name: statefulsets.apps\n    version: v1\n  graphd:\n    image: vesoft/nebula-graphd\n    replicas: 2\n    serviceType: NodePort\n    env: []\n    config: {}\n    resources:\n      requests:\n        cpu: \"500m\"\n        memory: \"500Mi\"\n      limits:\n        cpu: \"1\"\n        memory: \"500Mi\"\n    logVolume:\n      enable: true\n      storage: \"500Mi\"\n    podLabels: {}\n    podAnnotations: {}\n    securityContext: {}\n    nodeSelector: {}\n    tolerations: []\n    affinity: {}\n    readinessProbe: {}\n    livenessProbe: {}\n    initContainers: []\n    sidecarContainers: []\n    volumes: []\n    volumeMounts: []\n\n  metad:\n    image: vesoft/nebula-metad\n    replicas: 3\n    env: []\n    config: {}\n    resources:\n      requests:\n        cpu: \"500m\"\n        memory: \"500Mi\"\n      limits:\n        cpu: \"1\"\n        memory: \"1Gi\"\n    logVolume:\n      enable: true\n      storage: \"500Mi\"\n    dataVolume:\n      storage: \"2Gi\"\n    licenseManagerURL: \"\"\n    license: {}\n    podLabels: {}\n    podAnnotations: {}\n    securityContext: {}\n    nodeSelector: {}\n    tolerations: []\n    affinity: {}\n    readinessProbe: {}\n    livenessProbe: {}\n    initContainers: []\n    sidecarContainers: []\n    volumes: []\n    volumeMounts: []\n\n  storaged:\n    image: vesoft/nebula-storaged\n    replicas: 3\n    env: []\n    config: {}\n    resources:\n      requests:\n        cpu: \"500m\"\n        memory: \"500Mi\"\n      limits:\n        cpu: \"1\"\n        memory: \"1Gi\"\n    logVolume:\n      enable: true\n      storage: \"500Mi\"\n    dataVolumes:\n    - storage: \"10Gi\"\n    enableAutoBalance: false\n    podLabels: {}\n    podAnnotations: {}\n    securityContext: {}\n    nodeSelector: {}\n    tolerations: []\n    affinity: {}\n    readinessProbe: {}\n    livenessProbe: {}\n    initContainers: []\n    sidecarContainers: []\n    volumes: []\n    volumeMounts: []\n\n  exporter:\n    image: vesoft/nebula-stats-exporter\n    version: v3.3.0\n    replicas: 1\n    env: []\n    resources:\n      requests:\n        cpu: \"100m\"\n        memory: \"128Mi\"\n      limits:\n        cpu: \"200m\"\n        memory: \"256Mi\"\n    podLabels: {}\n    podAnnotations: {}\n    securityContext: {}\n    nodeSelector: {}\n    tolerations: []\n    affinity: {}\n    readinessProbe: {}\n    livenessProbe: {}\n    initContainers: []\n    sidecarContainers: []\n    volumes: []\n    volumeMounts: []\n    maxRequests: 20\n\n  agent:\n    image: vesoft/nebula-agent\n    version: latest\n    resources:\n      requests:\n        cpu: \"100m\"\n        memory: \"128Mi\"\n      limits:\n        cpu: \"200m\"\n        memory: \"256Mi\"\n\n  console:\n    username: root\n    password: nebula\n    image: vesoft/nebula-console\n    version: latest\n    nodeSelector: {}\n\n  alpineImage: \"\"\n\nimagePullSecrets: []\nnameOverride: \"\"\nfullnameOverride: \"\" \n</code></pre> Expand to view parameter descriptions  Parameter Default Value Description <code>nebula.version</code> v3.8.0 Version of the cluster. <code>nebula.imagePullPolicy</code> <code>Always</code> Container image pull policy. <code>Always</code> means always attempting to pull the latest image from the remote. <code>nebula.storageClassName</code> <code>\"\"</code> Name of the Kubernetes storage class for dynamic provisioning of persistent volumes. <code>nebula.enablePVReclaim</code> <code>false</code> Enable persistent volume reclaim. See Reclaim PV for details. <code>nebula.enableBR</code> <code>false</code> Enable the backup and restore feature. See Backup and Restore with NebulaGraph Operator for details. <code>nebula.enableForceUpdate</code> <code>false</code> Force update the Storage service without transferring the leader partition replicas. See Optimize leader transfer in rolling updates for details. <code>nebula.schedulerName</code> <code>default-scheduler</code> Name of the Kubernetes scheduler. Must be configured as <code>nebula-scheduler</code> when using the Zone feature. <code>nebula.topologySpreadConstraints</code> <code>[]</code> Control the distribution of pods in the cluster. <code>nebula.logRotate</code> <code>{}</code> Log rotation configuration. See Manage cluster logs for details. <code>nebula.reference</code> <code>{\"name\": \"statefulsets.apps\", \"version\": \"v1\"}</code> The workload referenced for a NebulaGraph cluster. <code>nebula.graphd.image</code> <code>vesoft/nebula-graphd</code> Container image for the Graph service. <code>nebula.graphd.replicas</code> <code>2</code> Number of replicas for the Graph service. <code>nebula.graphd.serviceType</code> <code>NodePort</code> Service type for the Graph service, defining how the Graph service is accessed. See Connect to the Cluster for details. <code>nebula.graphd.env</code> <code>[]</code> Container environment variables for the Graph service. <code>nebula.graphd.config</code> <code>{}</code> Configuration for the Graph service. See Customize the configuration of the NebulaGraph cluster for details. <code>nebula.graphd.resources</code> <code>{\"resources\":{\"requests\":{\"cpu\":\"500m\",\"memory\":\"500Mi\"},\"limits\":{\"cpu\":\"1\",\"memory\":\"500Mi\"}}}</code> Resource limits and requests for the Graph service. <code>nebula.graphd.logVolume</code> <code>{\"logVolume\": {\"enable\": true,\"storage\": \"500Mi\"}}</code> Log storage configuration for the Graph service. When <code>enable</code> is <code>false</code>, log volume is not used. <code>nebula.metad.image</code> <code>vesoft/nebula-metad</code> Container image for the Meta service. <code>nebula.metad.replicas</code> <code>3</code> Number of replicas for the Meta service. <code>nebula.metad.env</code> <code>[]</code> Container environment variables for the Meta service. <code>nebula.metad.config</code> <code>{}</code> Configuration for the Meta service. See Customize the configuration of the NebulaGraph cluster for details. <code>nebula.metad.resources</code> <code>{\"resources\":{\"requests\":{\"cpu\":\"500m\",\"memory\":\"500Mi\"},\"limits\":{\"cpu\":\"1\",\"memory\":\"1Gi\"}}}</code> Resource limits and requests for the Meta service. <code>nebula.metad.logVolume</code> <code>{\"logVolume\": {\"enable\": true,\"storage\": \"500Mi\"}}</code> Log storage configuration for the Meta service. When <code>enable</code> is <code>false</code>, log volume is not used. <code>nebula.metad.dataVolume</code> <code>{\"dataVolume\": {\"storage\": \"2Gi\"}}</code> Data storage configuration for the Meta service. <code>nebula.metad.licenseManagerURL</code> <code>\"\"</code> URL for the license manager (LM) to obtain license information. For creating the NebulaGraph Enterprise Edition only. <code>nebula.storaged.image</code> <code>vesoft/nebula-storaged</code> Container image for the Storage service. <code>nebula.storaged.replicas</code> <code>3</code> Number of replicas for the Storage service. <code>nebula.storaged.env</code> <code>[]</code> Container environment variables for the Storage service. <code>nebula.storaged.config</code> <code>{}</code> Configuration for the Storage service. See Customize the configuration of the NebulaGraph cluster for details. <code>nebula.storaged.resources</code> <code>{\"resources\":{\"requests\":{\"cpu\":\"500m\",\"memory\":\"500Mi\"},\"limits\":{\"cpu\":\"1\",\"memory\":\"1Gi\"}}}</code> Resource limits and requests for the Storage service. <code>nebula.storaged.logVolume</code> <code>{\"logVolume\": {\"enable\": true,\"storage\": \"500Mi\"}}</code> Log storage configuration for the Storage service. When <code>enable</code> is <code>false</code>, log volume is not used. <code>nebula.storaged.dataVolumes</code> <code>{\"dataVolumes\": [{\"storage\": \"10Gi\"}]}</code> Data storage configuration for the Storage service. Supports specifying multiple data volumes. <code>nebula.storaged.enableAutoBalance</code> <code>false</code> Enable automatic balancing. See Balance storage data after scaling out for details. <code>nebula.exporter.image</code> <code>vesoft/nebula-stats-exporter</code> Container image for the Exporter service. <code>nebula.exporter.version</code> <code>v3.3.0</code> Version of the Exporter service. <code>nebula.exporter.replicas</code> <code>1</code> Number of replicas for the Exporter service. <code>nebula.exporter.env</code> <code>[]</code> Environment variables for the Exporter service. <code>nebula.exporter.resources</code> <code>{\"resources\":{\"requests\":{\"cpu\":\"100m\",\"memory\":\"128Mi\"},\"limits\":{\"cpu\":\"200m\",\"memory\":\"256Mi\"}}}</code> Resource limits and requests for the Exporter service. <code>nebula.agent.image</code> <code>vesoft/nebula-agent</code> Container image for the agent service. <code>nebula.agent.version</code> <code>latest</code> Version of the agent service. <code>nebula.agent.resources</code> <code>{\"resources\":{\"requests\":{\"cpu\":\"100m\",\"memory\":\"128Mi\"},\"limits\":{\"cpu\":\"200m\",\"memory\":\"256Mi\"}}}</code> Resource limits and requests for the agent service. <code>nebula.console.username</code> <code>root</code> Username for accessing the NebulaGraph Console client. See Connect to the cluster for details. <code>nebula.console.password</code> <code>nebula</code> Password for accessing the NebulaGraph Console client. <code>nebula.console.image</code> <code>vesoft/nebula-console</code> Container image for the NebulaGraph Console client. <code>nebula.console.version</code> <code>latest</code> Version of the NebulaGraph Console client. <code>nebula.alpineImage</code> <code>\"\"</code> Alpine Linux container image used to obtain zone information for nodes. <code>imagePullSecrets</code> <code>[]</code> Names of secrets to pull private images. <code>nameOverride</code> <code>\"\"</code> Cluster name. <code>fullnameOverride</code> <code>\"\"</code> Name of the released chart instance. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.podLabels</code> <code>{}</code> Additional labels to be added to the pod. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.podAnnotations</code> <code>{}</code> Additional annotations to be added to the pod. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.securityContext</code> <code>{}</code> Security context for setting pod-level security attributes, including user ID, group ID, Linux Capabilities, etc. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.nodeSelector</code> <code>{}</code> Label selectors for determining which nodes to run the pod on. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.tolerations</code> <code>[]</code> Tolerations allow a pod to be scheduled to nodes with specific taints. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.affinity</code> <code>{}</code> Affinity rules for the pod, including node affinity, pod affinity, and pod anti-affinity. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.readinessProbe</code> <code>{}</code> Probe to check if a container is ready to accept service requests. When the probe returns success, traffic can be routed to the container. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.livenessProbe</code> <code>{}</code> Probe to check if a container is still running. If the probe fails, Kubernetes will kill and restart the container. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.initContainers</code> <code>[]</code> Special containers that run before the main application container starts, typically used for setting up the environment or initializing data. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.sidecarContainers</code> <code>[]</code> Containers that run alongside the main application container, typically used for auxiliary tasks such as log processing, monitoring, etc. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.volumes</code> <code>[]</code> Storage volumes to be attached to the service pod. <code>nebula.&lt;graphd|metad|storaged|exporter&gt;.volumeMounts</code> <code>[]</code> Specifies where to mount the storage volume inside the container. </li> </ul> </li> <li> <p>Create the NebulaGraph cluster.</p> <p>You can use the <code>--set</code> flag to customize the default values of the NebulaGraph cluster configuration. For example, <code>--set nebula.storaged.replicas=3</code> sets the number of replicas for the Storage service to 3.</p> <pre><code>helm install \"${NEBULA_CLUSTER_NAME}\" nebula-operator/nebula-cluster \\ \n    # Specify the version of the cluster chart. If not specified, it will install the latest version by default.\n    # You can check all chart versions by running the command: helm search repo -l nebula-operator/nebula-cluster\n    --version=1.8.0 \\\n    # Specify the namespace for the NebulaGraph cluster.\n    --namespace=\"${NEBULA_CLUSTER_NAMESPACE}\" \\\n    # Customize the cluster name.\n    --set nameOverride=\"${NEBULA_CLUSTER_NAME}\" \\\n    --set nebula.storageClassName=\"${STORAGE_CLASS_NAME}\" \\\n    # Specify the version for the NebulaGraph cluster.\n    --set nebula.version=v3.8.0\n</code></pre> </li> <li> <p>Check the status of NebulaGraph cluster pods.</p> <pre><code>kubectl -n \"${NEBULA_CLUSTER_NAMESPACE}\" get pod -l \"app.kubernetes.io/cluster=${NEBULA_CLUSTER_NAME}\"\n</code></pre> <p>Output:</p> <pre><code>NAME                               READY   STATUS    RESTARTS   AGE\nnebula-exporter-854c76989c-mp725   1/1     Running   0          14h\nnebula-graphd-0                    1/1     Running   0          14h\nnebula-graphd-1                    1/1     Running   0          14h\nnebula-metad-0                     1/1     Running   0          14h\nnebula-metad-1                     1/1     Running   0          14h\nnebula-metad-2                     1/1     Running   0          14h\nnebula-storaged-0                  1/1     Running   0          14h\nnebula-storaged-1                  1/1     Running   0          14h\nnebula-storaged-2                  1/1     Running   0          14h\n</code></pre> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.2.cluster-upgrade/","title":"Upgrade NebulaGraph clusters created with NebulaGraph Operator","text":"<p>This topic introduces how to upgrade a NebulaGraph cluster created with NebulaGraph Operator.</p> <p>Legacy version compatibility</p> <p>The 1.x version NebulaGraph Operator is not compatible with NebulaGraph of version below v3.x.</p>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.2.cluster-upgrade/#limits","title":"Limits","text":"<ul> <li>Only for upgrading the NebulaGraph clusters created with NebulaGraph Operator.</li> </ul> <ul> <li>Only support upgrading the NebulaGraph version from 3.5.0 to 3.6.0.</li> </ul> <ul> <li>For upgrading NebulaGraph Enterprise Edition clusters, contact us.</li> </ul>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.2.cluster-upgrade/#prerequisites","title":"Prerequisites","text":"<p>You have created a NebulaGraph cluster. For details, see Create a NebulaGraph cluster.</p>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.2.cluster-upgrade/#upgrade_a_nebulagraph_cluster_with_kubectl","title":"Upgrade a NebulaGraph cluster with <code>kubectl</code>","text":"<p>The following steps upgrade a NebulaGraph cluster from version <code>3.5.0</code> to <code>v3.8.0</code>.</p> <ol> <li> <p>Check the image version of the services in the cluster.</p> <pre><code>kubectl get pods -l app.kubernetes.io/cluster=nebula  -o jsonpath=\"{.items[*].spec.containers[*].image}\" |tr -s '[[:space:]]' '\\n' |sort |uniq -c\n</code></pre> <p>Output:</p> <pre><code>      1 vesoft/nebula-graphd:3.5.0\n      1 vesoft/nebula-metad:3.5.0\n      3 vesoft/nebula-storaged:3.5.0  \n</code></pre> </li> <li> <p>Edit the <code>nebula</code> cluster configuration to change the <code>version</code> value of the cluster services from 3.5.0 to v3.8.0.</p> <ol> <li> <p>Open the YAML file for the <code>nebula</code> cluster.</p> <pre><code>kubectl edit nebulacluster nebula -n &lt;namespace&gt;\n</code></pre> </li> <li> <p>Change the value of <code>version</code>.</p> <p>After making these changes, the YAML file should look like this:</p> <pre><code>apiVersion: apps.nebula-graph.io/v1alpha1\nkind: NebulaCluster\nmetadata:\n  name: nebula\nspec:\n  graphd:\n    version: v3.8.0 // Change the value from 3.5.0 to v3.8.0.\n    ...\n  metad:\n    version: v3.8.0 // Change the value from 3.5.0 to v3.8.0.\n    ...\n  storaged:\n    version: v3.8.0 // Change the value from 3.5.0 to v3.8.0.\n    ...\n</code></pre> </li> </ol> </li> <li> <p>Apply the configuration.</p> <p>After saving the YAML file and exiting, Kubernetes automatically updates the cluster's configuration and starts the cluster upgrade.</p> </li> <li> <p>After waiting for about 2 minutes, run the following command to see if the image versions of the services in the cluster have been changed to v3.8.0.</p> <pre><code>kubectl get pods -l app.kubernetes.io/cluster=nebula  -o jsonpath=\"{.items[*].spec.containers[*].image}\" |tr -s '[[:space:]]' '\\n' |sort |uniq -c\n</code></pre> <p>Output:</p> <pre><code>      1 vesoft/nebula-graphd:v3.8.0\n      1 vesoft/nebula-metad:v3.8.0\n      3 vesoft/nebula-storaged:v3.8.0 \n</code></pre> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.2.cluster-upgrade/#upgrade_a_nebulagraph_cluster_with_helm","title":"Upgrade a NebulaGraph cluster with <code>helm</code>","text":"<ol> <li> <p>Update the information of available charts locally from chart repositories.</p> <pre><code>helm repo update\n</code></pre> </li> <li> <p>Set environment variables to your desired values.</p> <pre><code>export NEBULA_CLUSTER_NAME=nebula         # The desired NebulaGraph cluster name.\nexport NEBULA_CLUSTER_NAMESPACE=nebula    # The desired namespace where your NebulaGraph cluster locates.\n</code></pre> </li> <li> <p>Upgrade a NebulaGraph cluster.</p> <p>For example, upgrade a cluster to v3.8.0.</p> <pre><code>helm upgrade \"${NEBULA_CLUSTER_NAME}\" nebula-operator/nebula-cluster \\\n    --namespace=\"${NEBULA_CLUSTER_NAMESPACE}\" \\\n    --set nameOverride=${NEBULA_CLUSTER_NAME} \\\n    --set nebula.version=v3.8.0\n</code></pre> <p>The value of <code>--set nebula.version</code> specifies the version of the cluster you want to upgrade to.</p> </li> <li> <p>Run the following command to check the status and version of the upgraded cluster.</p> <p>Check cluster status:</p> <pre><code>$ kubectl -n \"${NEBULA_CLUSTER_NAMESPACE}\" get pod -l \"app.kubernetes.io/cluster=${NEBULA_CLUSTER_NAME}\"\nNAME                READY   STATUS    RESTARTS   AGE\nnebula-graphd-0     1/1     Running   0          2m\nnebula-graphd-1     1/1     Running   0          2m\nnebula-metad-0      1/1     Running   0          2m\nnebula-metad-1      1/1     Running   0          2m\nnebula-metad-2      1/1     Running   0          2m\nnebula-storaged-0   1/1     Running   0          2m\nnebula-storaged-1   1/1     Running   0          2m\nnebula-storaged-2   1/1     Running   0          2m\n</code></pre> <p>Check cluster version:</p> <pre><code>$ kubectl get pods -l app.kubernetes.io/cluster=nebula  -o jsonpath=\"{.items[*].spec.containers[*].image}\" |tr -s '[[:space:]]' '\\n' |sort |uniq -c\n      1 vesoft/nebula-graphd:v3.8.0\n      1 vesoft/nebula-metad:v3.8.0\n      3 vesoft/nebula-storaged:v3.8.0\n</code></pre> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.2.cluster-upgrade/#accelerate_the_upgrade_process","title":"Accelerate the upgrade process","text":"<p>The upgrade process of a cluster is a rolling update process and can be time-consuming due to the state transition of the leader partition replicas in the Storage service. You can configure the <code>enableForceUpdate</code> field in the cluster instance's YAML file to skip the leader partition replica transfer operation, thereby accelerating the upgrade process. For more information, see Specify a rolling update strategy.</p>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.2.cluster-upgrade/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues during the upgrade process, you can check the logs of the cluster service pods.</p> <pre><code>kubectl logs &lt;pod-name&gt; -n &lt;namespace&gt;\n</code></pre> <p>Additionally, you can inspect the cluster's status and events.</p> <pre><code>kubectl describe nebulaclusters &lt;cluster-name&gt; -n &lt;namespace&gt;\n</code></pre>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.3.cluster-uninstall/","title":"Delete a NebulaGraph cluster","text":"<p>This topic explains how to delete a NebulaGraph cluster created using NebulaGraph Operator.</p>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.3.cluster-uninstall/#usage_limitations","title":"Usage limitations","text":"<ul> <li>Deletion is only supported for NebulaGraph clusters created with the NebulaGraph Operator.</li> <li>You cannot delete a NebulaGraph cluster that has deletion protection enabled. For more information, see Configure deletion protection.</li> </ul>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.3.cluster-uninstall/#delete_a_nebulagraph_cluster_using_kubectl","title":"Delete a NebulaGraph cluster using <code>kubectl</code>","text":"<ol> <li> <p>View all created clusters.</p> <pre><code>kubectl get nc --all-namespaces\n</code></pre> <p>Example output:</p> <pre><code>NAMESPACE   NAME      READY   GRAPHD-DESIRED   GRAPHD-READY   METAD-DESIRED   METAD-READY   STORAGED-DESIRED   STORAGED-READY   AGE\ndefault     nebula    True    2                2              3               3             3                  3                38h\nnebula      nebula2   True    1                1              1               1             1                  1                2m7s\n</code></pre> </li> <li> <p>Delete a cluster. For example, run the following command to delete a cluster named <code>nebula2</code>:</p> <pre><code>kubectl delete nc nebula2 -n nebula\n</code></pre> <p>Example output:</p> <pre><code>nebulacluster.nebula-graph.io \"nebula2\" deleted\n</code></pre> </li> <li> <p>Confirm the deletion.</p> <pre><code>kubectl get nc nebula2 -n nebula\n</code></pre> <p>Example output:</p> <pre><code>No resources found in nebula namespace.\n</code></pre> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.1.installation/4.1.3.cluster-uninstall/#delete_a_nebulagraph_cluster_using_helm","title":"Delete a NebulaGraph cluster using <code>helm</code>","text":"<ol> <li> <p>View all Helm releases.</p> <pre><code>helm list --all-namespaces\n</code></pre> <p>Example output:</p> <pre><code>NAME              NAMESPACE               REVISION    UPDATED                                 STATUS      CHART                   APP VERSION\nnebula            default                 1           2023-11-06 20:16:07.913136377 +0800 CST deployed    nebula-cluster-1.7.1    1.7.1\nnebula-operator   nebula-operator-system  3           2023-11-06 12:06:24.742397418 +0800 CST deployed    nebula-operator-1.7.1   1.7.1\n</code></pre> </li> <li> <p>View detailed information about a Helm release. For example, to view the cluster information for a Helm release named <code>nebula</code>:</p> <pre><code>helm get values nebula -n default\n</code></pre> <p>Example output:</p> <pre><code>USER-SUPPLIED VALUES:\nimagePullSecrets:\n- name: secret_for_pull_image\nnameOverride: nebula # The cluster name\nnebula:\n  graphd:\n    image: reg.vesoft-inc.com/xx\n  metad:\n    image: reg.vesoft-inc.com/xx\n    licenseManagerURL: xxx:9119\n  storageClassName: local-sc\n  storaged:\n    image: reg.vesoft-inc.com/xx\n  version: v1.8.0 # The cluster version\n</code></pre> </li> <li> <p>Uninstall a Helm release. For example, to uninstall a Helm release named <code>nebula</code>:</p> <pre><code>helm uninstall nebula -n default\n</code></pre> <p>Example output:</p> <pre><code>release \"nebula\" uninstalled\n</code></pre> <p>Once the Helm release is uninstalled, NebulaGraph Operator will automatically remove all K8s resources associated with that release.</p> </li> <li> <p>Verify that the cluster resources are removed.</p> <pre><code>kubectl get nc nebula -n default\n</code></pre> <p>Example output:</p> <pre><code>No resources found in default namespace.\n</code></pre> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.1.use-local-pv/","title":"Use Local Persistent Volumes in a NebulaGraph cluster","text":"<p>Local Persistent Volumes, abbreviated as Local PVs in K8s store container data directly using the node's local disk directory. Compared with network storage, Local Persistent Volumes provide higher IOPS and lower read and write latency, which is suitable for data-intensive applications. This topic introduces how to use Local PVs in Google Kubernetes Engine (GKE) and Amazon Elastic Kubernetes Service (EKS) clusters, and how to enable automatic failover for Local PVs in the cloud.</p> <p>While using Local Persistent Volumes can enhance performance, it's essential to note that, unlike network storage, local storage does not support automatic backup. In the event of a node failure, all data in local storage may be lost. Therefore, the utilization of Local Persistent Volumes involves a trade-off between service availability, data persistence, and flexibility.</p>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.1.use-local-pv/#principles","title":"Principles","text":"<p>NebulaGraph Operator implements a Storage Volume Provisioner interface to automatically create and delete PV objects. Utilizing the provisioner, you can dynamically generate Local PVs as required. Based on the PVC and StorageClass specified in the cluster configuration file, NebulaGraph Operator automatically generates PVCs and associates them with their respective Local PVs.</p> <p>When a Local PV is initiated by the provisioner interface, the provisioner controller generates a <code>local</code> type PV and configures the <code>nodeAffinity</code> field. This configuration ensures that Pods using the <code>local</code> type PV are scheduled onto specific nodes. Conversely, when a Local PV is deleted, the provisioner controller eliminates the <code>local</code> type PV object and purges the node's storage resources.</p>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.1.use-local-pv/#prerequisites","title":"Prerequisites","text":"<p>NebulaGraph Operator is installed. For details, see Install NebulaGraph Operator.</p>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.1.use-local-pv/#steps","title":"Steps","text":"<p>The resources in the following examples are all created in the <code>default</code> namespace.</p> Use Local PV on GKEUse Local PV on EKS <ol> <li> <p>Create a node pool with local SSDs if not existing</p> <pre><code>gcloud container node-pools create \"pool-1\" --cluster \"gke-1\" --region us-central1 --node-version \"1.27.10-gke.1055000\" --machine-type \"n2-standard-2\" --local-nvme-ssd-block count=2 --max-surge-upgrade 1 --max-unavailable-upgrade 0 --num-nodes 1 --enable-autoscaling --min-nodes 1 --max-nodes 2\n</code></pre> <p>For information about the parameters to create a node pool with local SSDs, see Create a node pool with Local SSD.</p> </li> <li> <p>Format and mount the local SSDs using a DaemonSet.</p> <ol> <li> <p>Download the gke-daemonset-raid-disks.yaml file.</p> </li> <li> <p>Deploy the RAID disks DaemonSet. The DaemonSet sets a RAID <code>0</code> array on all Local SSD disks and formats the device to an <code>ext4</code> filesystem.   <pre><code>kubectl apply -f gke-daemonset-raid-disks.yaml\n</code></pre></p> </li> </ol> </li> <li> <p>Deploy the Local PV provisioner.</p> <ol> <li>Download the local-pv-provisioner.yaml file.</li> <li>Run the provisioner.   <pre><code>kubectl apply -f local-pv-provisioner.yaml\n</code></pre></li> </ol> </li> <li> <p>In the NebulaGraph cluster configuration file, specify <code>spec.storaged.dataVolumeClaims</code> or <code>spec.metad.dataVolumeClaim</code>, and the StorageClass needs to be configured as <code>local-nvme</code>. For more information about cluster configurations, see Create a NebulaGraph cluster. </p> Partial configuration of the NebulaGraph cluster<pre><code>...\nmetad: \n  dataVolumeClaim:\n    resources:\n      requests:\n        storage: 2Gi\n    storageClassName: local-nvme\nstoraged:\n  dataVolumeClaims:\n  - resources:\n      requests:\n        storage: 2Gi\n    storageClassName: local-nvme  \n...\n</code></pre> <p>After the NebulaGraph is deployed, the Local PVs are automatically created.</p> </li> <li> <p>View the PV list.</p> <pre><code>kubectl get pv\n</code></pre> <p>Return:</p> <pre><code>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                                     STORAGECLASS   REASON   AGE\npvc-01be9b75-9c50-4532-8695-08e11b489718   5Gi        RWO            Delete           Bound    default/storaged-data-nebula-storaged-0   local-nvme              3m35s\npvc-09de8eb1-1225-4025-b91b-fbc0bcce670f   5Gi        RWO            Delete           Bound    default/storaged-data-nebula-storaged-1   local-nvme              3m35s\npvc-4b2a9ffb-9000-4998-a7bb-edb825c872cb   5Gi        RWO            Delete           Bound    default/storaged-data-nebula-storaged-2   local-nvme              3m35s\n...\n</code></pre> </li> <li> <p>View the detailed information of the PV.</p> <pre><code>kubectl get pv pvc-01be9b75-9c50-4532-8695-08e11b489718 -o yaml\n</code></pre> <p>Return:</p> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  annotations:\n    local.pv.provisioner/selected-node: gke-snap-test-snap-test-591403a8-xdfc\n    nebula-graph.io/pod-name: nebula-storaged-0\n    pv.kubernetes.io/provisioned-by: nebula-cloud.io/local-pv\n  creationTimestamp: \"2024-03-05T06:12:32Z\"\n  finalizers:\n  - kubernetes.io/pv-protection\n  labels:\n    app.kubernetes.io/cluster: nebula\n    app.kubernetes.io/component: storaged\n    app.kubernetes.io/managed-by: nebula-operator\n    app.kubernetes.io/name: nebula-graph\n  name: pvc-01be9b75-9c50-4532-8695-08e11b489718\n  resourceVersion: \"9999469\"\n  uid: ee28a4da-6026-49ac-819b-2075154b4724\nspec:\n  accessModes:\n  - ReadWriteOnce\n  capacity:\n    storage: 5Gi\n  claimRef:\n    apiVersion: v1\n    kind: PersistentVolumeClaim\n    name: storaged-data-nebula-storaged-0\n    namespace: default\n    resourceVersion: \"9996541\"\n    uid: 01be9b75-9c50-4532-8695-08e11b489718\n  local:\n    fsType: ext4\n    path: /mnt/disks/raid0\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: kubernetes.io/hostname\n          operator: In\n          values:\n          - gke-snap-test-snap-test-591403a8-xdfc\n  persistentVolumeReclaimPolicy: Delete\n  storageClassName: local-nvme\n  volumeMode: Filesystem\nstatus:\n  phase: Bound    \n</code></pre> </li> </ol> <ol> <li> <p>Create a node pool with Instance Store if not existing.</p> <pre><code>eksctl create nodegroup  --instance-types m5ad.2xlarge  --nodes 3  --cluster eks-1\n</code></pre> <p>For more information about parameters to cluster node pools, see Creating a managed node group.</p> </li> <li> <p>Format and mount the local SSDs using a DaemonSet.</p> <ol> <li> <p>Download the eks-daemonset-raid-disks.yaml file.</p> </li> <li> <p>Based on the node type created in step 1, modify the value of the <code>nodeSelector.node.kubernetes.io/instance-type</code> field in the <code>eks-daemonset-raid-disks.yaml</code> file as needed.   <pre><code>    spec:\n      nodeSelector:\n        node.kubernetes.io/instance-type: \"m5ad.2xlarge\"\n</code></pre></p> </li> <li> <p>Install nvme-cli.</p> <ul> <li>For Ubuntu and Debian systems   <pre><code>sudo apt-get update\nsudo apt-get install -y nvme-cli\n</code></pre></li> <li>For CentOS and RHEL systems   <pre><code>sudo yum install -y nvme-cli\n</code></pre></li> </ul> </li> <li> <p>Deploy the RAID disk DaemonSet. The DaemonSet sets up a RAID <code>0</code> array on all local SSD disks and formats the devices as an <code>ext4</code> file system.   <pre><code>kubectl apply -f gke-daemonset-raid-disks.yaml\n</code></pre></p> </li> </ol> </li> <li> <p>Deploy the Local PV provisioner.</p> <ol> <li>Download the local-pv-provisioner.yaml file.</li> <li>Run the provisioner.   <pre><code>kubectl apply -f local-pv-provisioner.yaml\n</code></pre></li> </ol> </li> <li> <p>In the NebulaGraph cluster configuration file, specify <code>spec.storaged.dataVolumeClaims</code> or <code>spec.metad.dataVolumeClaim</code>, and the StorageClass needs to be configured as <code>local-nvme</code>. For more information about cluster configurations, see Create a NebulaGraph cluster. </p> Partial configuration of the NebulaGraph cluster<pre><code>metad:\n  dataVolumeClaim:\n    resources:\n      requests:\n        storage: 2Gi\n    storageClassName: local-nvme\nstoraged:\n  dataVolumeClaims:\n  - resources:\n      requests:\n        storage: 2Gi\n    storageClassName: local-nvme  \n</code></pre> </li> <li> <p>View the PV list.</p> <pre><code>kubectl get pv\n</code></pre> <p>Return:</p> <pre><code>NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                                     STORAGECLASS   REASON   AGE\npvc-290c15cc-a302-4463-a591-84b7217a6cd2   5Gi        RWO            Delete           Bound    default/storaged-data-nebula-storaged-0   local-nvme              3m40s\npvc-fbb3167f-f556-4a16-ae0e-171aed0ac954   5Gi        RWO            Delete           Bound    default/storaged-data-nebula-storaged-1   local-nvme              3m40s\npvc-6c7cfe80-0134-4573-b93e-9b259c6fcd63   5Gi        RWO            Delete           Bound    default/storaged-data-nebula-storaged-2   local-nvme              3m40s\n...\n</code></pre> </li> <li> <p>View the detailed information of the PV.</p> <pre><code>kubectl get pv pvc-290c15cc-a302-4463-a591-84b7217a6cd2 -o yaml\n</code></pre> <p>Return:</p> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  annotations:\n    local.pv.provisioner/selected-node: ip-192-168-77-60.ec2.internal\n    nebula-graph.io/pod-name: nebula-storaged-0\n    pv.kubernetes.io/provisioned-by: nebula-cloud.io/local-pv\n  creationTimestamp: \"2024-03-04T07:51:32Z\"\n  finalizers:\n  - kubernetes.io/pv-protection\n  labels:\n    app.kubernetes.io/cluster: nebula\n    app.kubernetes.io/component: storaged\n    app.kubernetes.io/managed-by: nebula-operator\n    app.kubernetes.io/name: nebula-graph\n  name: pvc-290c15cc-a302-4463-a591-84b7217a6cd2\n  resourceVersion: \"7932689\"\n  uid: 66c0a2d3-2914-43ad-93b5-6d84fb62acef\nspec:\n  accessModes:\n  - ReadWriteOnce\n  capacity:\n    storage: 5Gi\n  claimRef:\n    apiVersion: v1\n    kind: PersistentVolumeClaim\n    name: storaged-data-nebula-storaged-0\n    namespace: default\n    resourceVersion: \"7932688\"\n    uid: 8ecb5d96-004b-4672-bac4-1355ae15eae4\n  local:\n    fsType: ext4\n    path: /mnt/disks/raid0\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: kubernetes.io/hostname\n          operator: In\n          values:\n          - ip-192-168-77-60.ec2.internal\n  persistentVolumeReclaimPolicy: Delete\n  storageClassName: local-nvme\n  volumeMode: Filesystem\nstatus:\n  phase: Bound    \n</code></pre> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.1.use-local-pv/#failover_for_local_persistent_volumes_in_the_cloud","title":"Failover for Local Persistent Volumes in the cloud","text":"<p>When using network storage (e.g., AWS EBS, Google Cloud Persistent Disk, Azure Disk Storage, Ceph, NFS, etc.) as a PV, the storage resource is independent of any particular node. Therefore, the storage resource can be mounted and used by Pods regardless of the node to which the Pods are scheduled. However, when using a local storage disk as a PV, the storage resource can only be used by Pods on a specific node due to nodeAffinity.</p> <p>The Storage service of NebulaGraph supports data redundancy, which allows you to set multiple odd-numbered partition replicas. When a node fails, the associated partition is automatically transferred to a healthy node. However, Storage Pods using Local Persistent Volumes cannot run on other nodes due to the node affinity setting and must wait for the node to recover. To run on another node, the Pods must be unbound from the associated Local Persistent Volume.</p> <p>NebulaGraph Operator supports automatic failover in the event of a node failure while using Local Persistent Volumes in the cloud for elastic scaling. This is achieved by setting <code>spec.enableAutoFailover</code> to <code>true</code> in the cluster configuration file, which automatically unbinds the Pods from the Local Persistent Volume, allowing the Pods to run on another node.</p> <p>Example configuration:</p> <pre><code>...\nspec:\n  # Enable automatic failover for Local PV.\n  enableAutoFailover: true\n  # The time to wait for the Storage service to be in the `OFFLINE` status\n  # before automatic failover. \n  # The default value is 5 minutes.\n  # If the Storage service recovers to the `ONLINE` status during this period,\n  # failover will not be triggered.\n  failoverPeriod: \"2m\"\n  ...\n</code></pre>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.2.pv-expansion/","title":"Dynamically expand persistent volumes","text":"<p>In a Kubernetes environment, NebulaGraph's data is stored on Persistent Volumes (PVs). Dynamic volume expansion refers to increasing the capacity of a volume without stopping the service, enabling NebulaGraph to accommodate growing data. This topic explains how to dynamically expand the PV for NebulaGraph services in a Kubernetes environment.</p> <p>Note</p> <ul> <li>After the cluster is created, you cannot dynamically increase the number of PVs while the cluster is running.</li> <li>The method described in this topic is only for online volume expansion and does not support volume reduction.</li> </ul>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.2.pv-expansion/#background","title":"Background","text":"<p>In Kubernetes, a StorageClass is a resource that defines a particular storage type. It describes a class of storage, including its provisioner, parameters, and other details. When creating a PersistentVolumeClaim (PVC) and specifying a StorageClass, Kubernetes automatically creates a corresponding PV. The principle of dynamic volume expansion is to edit the PVC and increase the volume's capacity. Kubernetes will then automatically expand the capacity of the PV associated with this PVC based on the specified <code>storageClassName</code> in the PVC. During this process, new PVs are not created; the size of the existing PV is changed. Only dynamic storage volumes, typically those associated with a <code>storageClassName</code>, support dynamic volume expansion. Additionally, the <code>allowVolumeExpansion</code> field in the StorageClass must be set to <code>true</code>. For more details, see the Kubernetes documentation on expanding Persistent Volume Claims.</p> <p>In NebulaGraph Operator, you cannot directly edit PVC because Operator automatically creates PVC based on the configuration in the <code>spec.&lt;metad|storaged&gt;.dataVolumeClaim</code> of the Nebula Graph cluster. Therefore, you need to modify the cluster's configuration to update the PVC and trigger dynamic online volume expansion for the PV.</p>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.2.pv-expansion/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes version is equal to or greater than 1.18.</li> <li>A StorageClass has been created in the Kubernetes environment. For details, see Expanding Persistent Volumes Claims.<ul> <li>Ensure the <code>allowVolumeExpansion</code> field in the StorageClass is set to <code>true</code>.</li> <li>Make sure that the <code>provisioner</code> configured in the StorageClass supports dynamic expansion.</li> </ul> </li> <li>A NebulaGraph cluster is created in Kubernetes. For specific steps, see Create a NebulaGraph cluster.</li> <li>NebulaGraph cluster Pods are in running status.</li> </ul>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.2.pv-expansion/#online_volume_expansion_example","title":"Online volume expansion example","text":"<p>In the following example, we assume that the StorageClass is named <code>ebs-sc</code> and the NebulaGraph cluster is named <code>nebula</code>. We will demonstrate how to dynamically expand the PV for the Storage service.</p> <ol> <li> <p>Check the status of the Storage service Pod:</p> <pre><code>kubectl get pod\n</code></pre> <p>Example output:</p> <pre><code>nebula-storaged-0                                                1/1     Running   0                43h\n</code></pre> </li> <li> <p>Check the PVC and PV information for the Storage service:</p> <pre><code># View PVC \nkubectl get pvc\n</code></pre> <p>Example output:</p> <pre><code>storaged-data-nebula-storaged-0   Bound    pvc-36ca3871-9265-460f-b812-7e73a718xxxx   5Gi        RWO            ebs-sc     43h\n</code></pre> <pre><code># View PV and confirm that the capacity of the PV is 5Gi\nkubectl get pv\n</code></pre> <p>Example output:</p> <pre><code>pvc-36ca3871-9265-460f-b812-xxx   5Gi        RWO            Delete           Bound       default/storaged-data-nebula-storaged-0   ebs-sc              43h\n</code></pre> </li> <li> <p>Assuming all the above-mentioned prerequisites are met, use the following command to request an expansion of the PV for the Storage service to 10Gi:</p> <pre><code>kubectl patch nc nebula --type='merge' --patch '{\"spec\": {\"storaged\": {\"dataVolumeClaims\":[{\"resources\": {\"requests\": {\"storage\": \"10Gi\"}}, \"storageClassName\": \"ebs-sc\"}]}}}'\n</code></pre> <p>Example output:</p> <pre><code>nebulacluster.apps.nebula-graph.io/nebula patched\n</code></pre> </li> <li> <p>After waiting for about a minute, check the expanded PVC and PV information:</p> <pre><code>kubectl get pvc\n</code></pre> <p>Example output:</p> <pre><code>storaged-data-nebula-storaged-0   Bound    pvc-36ca3871-9265-460f-b812-7e73a718xxxx   10Gi        RWO            ebs-sc     43h\n</code></pre> <pre><code>kubectl get pv\n</code></pre> <p>Example output:</p> <pre><code>pvc-36ca3871-9265-460f-b812-xxx   10Gi        RWO            Delete           Bound       default/storaged-data-nebula-storaged-0   ebs-sc              43h\n</code></pre> <p>As you can see, both the PVC and PV capacity have been expanded to 10Gi.</p> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.3.configure-pv-reclaim/","title":"Reclaim PVs","text":"<p>NebulaGraph Operator uses PVs (Persistent Volumes) and PVCs (Persistent Volume Claims) to store persistent data. If you accidentally deletes a NebulaGraph cluster, by default, PV and PVC objects and the relevant data will be retained to ensure data security.</p> <p>You can also define the automatic deletion of PVCs to release data by setting the parameter <code>spec.enablePVReclaim</code> to <code>true</code> in the configuration file of the cluster instance. As for whether PV will be deleted automatically after PVC is deleted, you need to customize the PV reclaim policy. See reclaimPolicy in StorageClass and PV Reclaiming for details.</p>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.3.configure-pv-reclaim/#prerequisites","title":"Prerequisites","text":"<p>A NebulaGraph cluster is created in Kubernetes. For specific steps, see Create a NebulaGraph cluster.</p>"},{"location":"k8s-operator/4.cluster-administration/4.4.storage-management/4.4.3.configure-pv-reclaim/#steps","title":"Steps","text":"<p>The following example uses a cluster named <code>nebula</code> and the cluster's configuration file named <code>nebula_cluster.yaml</code> to show how to set <code>enablePVReclaim</code>:</p> <ol> <li> <p>Run the following command to edit the <code>nebula</code> cluster's configuration file.</p> <pre><code>kubectl edit nebulaclusters.apps.nebula-graph.io nebula\n</code></pre> </li> <li> <p>Add <code>enablePVReclaim</code> and set its value to <code>true</code> under <code>spec</code>.</p> <pre><code>apiVersion: apps.nebula-graph.io/v1alpha1\nkind: NebulaCluster\nmetadata:\n  name: nebula\nspec:\n  enablePVReclaim: true  //Set its value to true.\n  graphd:\n    image: vesoft/nebula-graphd\n    logVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: fast-disks\n    replicas: 1\n    resources:\n      limits:\n        cpu: \"1\"\n        memory: 1Gi\n      requests:\n        cpu: 500m\n        memory: 500Mi\n    version: v3.8.0\n  imagePullPolicy: IfNotPresent\n  metad:\n    dataVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: fast-disks\n    image: vesoft/nebula-metad\n    logVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: fast-disks\n    replicas: 1\n    resources:\n      limits:\n        cpu: \"1\"\n        memory: 1Gi\n      requests:\n        cpu: 500m\n        memory: 500Mi\n    version: v3.8.0\n  nodeSelector:\n    nebula: cloud\n  reference:\n    name: statefulsets.apps\n    version: v1\n  schedulerName: default-scheduler\n  storaged:\n    dataVolumeClaims:\n    - resources:\n        requests:\n          storage: 2Gi\n      storageClassName: fast-disks\n    - resources:\n        requests:\n          storage: 2Gi\n      storageClassName: fast-disks\n    image: vesoft/nebula-storaged\n    logVolumeClaim:\n      resources:\n        requests:\n          storage: 2Gi\n      storageClassName: fast-disks\n    replicas: 3\n    resources:\n      limits:\n        cpu: \"1\"\n        memory: 1Gi\n      requests:\n        cpu: 500m\n        memory: 500Mi\n    version: v3.8.0\n...    \n</code></pre> </li> <li> <p>Run <code>kubectl apply -f nebula_cluster.yaml</code> to push your configuration changes to the cluster.</p> </li> </ol> <p>After setting <code>enablePVReclaim</code> to <code>true</code>, the PVCs of the cluster will be deleted automatically after the cluster is deleted. If you want to delete the PVs, you need to set the reclaim policy of the PVs to <code>Delete</code>. </p>"},{"location":"k8s-operator/4.cluster-administration/4.7.security/4.7.2.enable-admission-control/","title":"Enable admission control","text":"<p>Kubernetes Admission Control is a security mechanism running as a webhook at runtime. It intercepts and modifies requests to ensure the cluster's security. Admission webhooks involve two main operations: validation and mutation. NebulaGraph Operator supports only validation operations and provides some default admission control rules. This topic describes NebulaGraph Operator's default admission control rules and how to enable admission control.</p>"},{"location":"k8s-operator/4.cluster-administration/4.7.security/4.7.2.enable-admission-control/#prerequisites","title":"Prerequisites","text":"<p>A NebulaGraph cluster is created with NebulaGrpah Operator. For detailed steps, see Create a NebulaGraph cluster.</p>"},{"location":"k8s-operator/4.cluster-administration/4.7.security/4.7.2.enable-admission-control/#admission_control_rules","title":"Admission control rules","text":"<p>Kubernetes admission control allows you to insert custom logic or policies before Kubernetes API Server processes requests. This mechanism can be used to implement various security policies, such as restricting a Pod's resource consumption or limiting its access permissions. NebulaGraph Operator supports validation operations, which means it validates and intercepts requests without making changes. </p> <p>After admission control is enabled, NebulaGraph Operator implements the following admission validation control rules by default. You cannot disable these rules:</p> <ul> <li>Forbid adding additional PVs to Storage service via <code>dataVolumeClaims</code>.</li> </ul> <ul> <li>Forbid shrinking the capacity of all service's PVCs, but allow expansion.</li> </ul> <ul> <li>Forbid any secondary operation during Storage service scale-in/scale-out.</li> </ul> <p>After admission control is enabled, NebulaGraph Operator allows you to add annotations to implement the following admission validation control rules:</p> <ul> <li> <p>Clusters with the <code>ha-mode</code> annotation must have the minimum number of replicas as required by high availability mode:</p> <ul> <li>For Graph service: At least 2 replicas are required.</li> <li>For Meta service: At least 3 replicas are required.</li> <li>For Storage service: At least 3 replicas are required.</li> </ul> <p>Note</p> <p>High availability mode refers to the high availability of NebulaGraph cluster services. Storage and Meta services are stateful, and the number of replicas should be an odd number due to Raft protocol requirements for data consistency. In high availability mode, at least 3 Storage services and 3 Meta services are required. Graph services are stateless, so their number of replicas can be even but should be at least 2.</p> </li> </ul> <ul> <li>Clusters with the <code>delete-protection</code> annotation cannot be deleted. For more information, see Configure deletion protection.        </li> </ul>"},{"location":"k8s-operator/4.cluster-administration/4.7.security/4.7.2.enable-admission-control/#tls_certificates_for_admission_webhooks","title":"TLS certificates for admission webhooks","text":"<p>To ensure secure communication and data integrity between the K8s API server and the admission webhook, this communication is done over HTTPS by default. This means that TLS certificates are required for the admission webhook. cert-manager is a Kubernetes certificate management controller that automates the issuance and renewal of certificates. NebulaGraph Operator uses cert-manager to manage certificates.</p> <p>Once cert-manager is installed and admission control is enabled, NebulaGraph Operator will automatically create an Issuer for issuing the necessary certificate for the admission webhook, and a Certificate for storing the issued certificate. The issued certificate is stored in the <code>nebula-operator-webhook-secret</code> Secret.</p>"},{"location":"k8s-operator/4.cluster-administration/4.7.security/4.7.2.enable-admission-control/#steps_of_enabling_admission_control","title":"Steps of enabling admission control","text":"<ol> <li> <p>Install cert-manager.</p> <pre><code>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.1/cert-manager.yaml\n</code></pre> <p>It is suggested to deploy the latest version of cert-manager. For details, see the official cert-manager documentation.</p> </li> <li> <p>Modify the NebulaGraph Operator configuration file to enable admission control. Admission control is disabled by default and needs to be enabled manually.</p> <pre><code># Check the current configuration\nhelm show values nebula-operator/nebula-operator\n</code></pre> <pre><code># Modify the configuration by setting `enableAdmissionWebhook` to `true`.\nhelm upgrade nebula-operator nebula-operator/nebula-operator --set enableAdmissionWebhook=true\n</code></pre> <p>Note</p> <p><code>nebula-operator</code> is the name of the chart repository, and <code>nebula-operator/nebula-operator</code> is the chart name. If the chart's namespace is not specified, it defaults to <code>default</code>.</p> </li> <li> <p>View the certificate Secret for the admission webhook.</p> <pre><code>kubectl get secret nebula-operator-webhook-secret -o yaml\n</code></pre> <p>If the output includes certificate contents, it means that the admission webhook's certificate has been successfully created.</p> </li> <li> <p>Verify the control rules.</p> <ul> <li> <p>Verify preventing additional PVs from being added to Storage service.</p> <pre><code>$ kubectl patch nc nebula --type='merge' --patch '{\"spec\": {\"storaged\": {\"dataVolumeClaims\":[{\"resources\": {\"requests\": {\"storage\": \"2Gi\"}}, \"storageClassName\": \"local-path\"},{\"resources\": {\"requests\": {\"storage\": \"3Gi\"}}, \"storageClassName\": \"fask-disks\"}]}}}'\nError from server: admission webhook \"nebulaclustervalidating.nebula-graph.io\" deniedthe request: spec.storaged.dataVolumeClaims: Forbidden: storaged dataVolumeClaims is immutable\n</code></pre> </li> </ul> <ul> <li> <p>Verify disallowing shrinking Storage service's PVC capacity.</p> <pre><code>$ kubectl patch nc nebula --type='merge' --patch '{\"spec\": {\"storaged\": {\"dataVolumeClaims\":[{\"resources\": {\"requests\": {\"storage\": \"1Gi\"}}, \"storageClassName\": \"fast-disks\"}]}}}'\nError from server: admission webhook \"nebulaclustervalidating.nebula-graph.io\" denied the request: spec.storaged.dataVolumeClaims: Invalid value: resource.Quantity{i:resource.int64Amount{value:1073741824, scale:0}, d:resource.infDecAmount{Dec:(*inf.Dec)(nil)}, s:\"1Gi\", Format:\"BinarySI\"}: data volume size can only be increased\n</code></pre> </li> </ul> <ul> <li> <p>Verify disallowing any secondary operation during Storage service scale-in.</p> <pre><code>$ kubectl patch nc nebula --type='merge' --patch '{\"spec\": {\"storaged\": {\"replicas\": 5}}}'\nnebulacluster.apps.nebula-graph.io/nebula patched\n$ kubectl patch nc nebula --type='merge' --patch '{\"spec\": {\"storaged\": {\"replicas\": 3}}}'\nError from server: admission webhook \"nebulaclustervalidating.nebula-graph.io\" denied the request: [spec.storaged: Forbidden: field is immutable while in ScaleOut phase, spec.storaged.replicas: Invalid value: 3: field is immutable while not in Running phase]\n</code></pre> </li> </ul> <ul> <li> <p>Verify the minimum number of replicas in high availability mode.</p> <pre><code># Annotate the cluster to enable high availability mode.\n$ kubectl annotate nc nebula nebula-graph.io/ha-mode=true\n# Verify the minimum number of the Graph service's replicas.\n$ kubectl patch nc nebula --type='merge' --patch '{\"spec\": {\"graphd\": {\"replicas\":1}}}'\nError from server: admission webhook \"nebulaclustervalidating.nebula-graph.io\" denied the request: spec.graphd.replicas: Invalid value: 1: should be at least 2 in HA mode\n</code></pre> </li> </ul> <ul> <li>Verify deletion protection. For more information, see Configure deletion protection.</li> </ul> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.7.security/4.7.3.config-deletion-protection/","title":"Configure deletion protection","text":"<p>NebulaGraph Operator supports deletion protection to prevent NebulaGraph clusters from being deleted by accident. This topic describes how to configure deletion protection for a NebulaGraph cluster.</p>"},{"location":"k8s-operator/4.cluster-administration/4.7.security/4.7.3.config-deletion-protection/#prerequisites","title":"Prerequisites","text":"<ul> <li>A NebulaGraph cluster is created with NebulaGrpah Operator. For more information, see Create a NebulaGraph cluster.</li> <li>Admission control is enabled on the NebulaGraph cluster. For more information, see Enable admission control.</li> </ul>"},{"location":"k8s-operator/4.cluster-administration/4.7.security/4.7.3.config-deletion-protection/#add_an_annotation_to_enable_deletion_protection","title":"Add an annotation to enable deletion protection","text":"<p>Add the <code>delete-protection</code> annotation to the cluster.</p> <p><pre><code>kubectl annotate nc nebula -n nebula-test nebula-graph.io/delete-protection=true\n</code></pre> The preceding command enables deletion protection for the <code>nebula</code> cluster in the <code>nebula-test</code> namespace.</p>"},{"location":"k8s-operator/4.cluster-administration/4.7.security/4.7.3.config-deletion-protection/#verify_deletion_protection","title":"Verify deletion protection","text":"<p>To verify that deletion protection is enabled, run the following command:</p> <pre><code>kubectl delete nc nebula -n nebula-test\n</code></pre> <p>The preceding command attempts to delete the <code>nebula</code> cluster in the <code>nebula-test</code> namespace.</p> <p>Return:</p> <pre><code>Error from server: admission webhook \"nebulaclustervalidating.nebula-graph.io\" denied the request: metadata.annotations[nebula-graph.io/delete-protection]: Forbidden: protected cluster cannot be deleted\n</code></pre>"},{"location":"k8s-operator/4.cluster-administration/4.7.security/4.7.3.config-deletion-protection/#remove_the_annotation_to_disable_deletion_protection","title":"Remove the annotation to disable deletion protection","text":"<p>Remove the <code>delete-protection</code> annotation from the cluster as follows:</p> <pre><code>kubectl annotate nc nebula -n nebula-test nebula-graph.io/delete-protection-\n</code></pre> <p>The preceding command disables deletion protection for the <code>nebula</code> cluster in the <code>nebula-test</code> namespace.</p>"},{"location":"k8s-operator/4.cluster-administration/4.8.ha-and-balancing/4.8.1.self-healing/","title":"Self-healing","text":"<p>NebulaGraph Operator calls the interface provided by NebulaGraph clusters to dynamically sense cluster service status. Once an exception is detected (for example, a component in a NebulaGraph cluster stops running), NebulaGraph Operator automatically performs fault tolerance. This topic shows how Nebular Operator performs self-healing by simulating cluster failure of deleting one Storage service Pod in a NebulaGraph cluster.</p>"},{"location":"k8s-operator/4.cluster-administration/4.8.ha-and-balancing/4.8.1.self-healing/#prerequisites","title":"Prerequisites","text":"<p>Install NebulaGraph Operator</p>"},{"location":"k8s-operator/4.cluster-administration/4.8.ha-and-balancing/4.8.1.self-healing/#steps","title":"Steps","text":"<ol> <li> <p>Create a NebulaGraph cluster. For more information, see Create a NebulaGraph clusters.</p> </li> <li> <p>Delete the Pod named <code>&lt;cluster_name&gt;-storaged-2</code> after all pods are in the <code>Running</code> status.</p> <p><pre><code>kubectl delete pod &lt;cluster-name&gt;-storaged-2 --now\n</code></pre> <code>&lt;cluster_name&gt;</code> is the name of your NebulaGraph cluster.</p> </li> <li> <p>NebulaGraph Operator automates the creation of the Pod named <code>&lt;cluster-name&gt;-storaged-2</code> to perform self-healing.</p> <p>Run the <code>kubectl get pods</code> command to check the status of the Pod <code>&lt;cluster-name&gt;-storaged-2</code>.</p> <pre><code>...\nnebula-cluster-storaged-1        1/1     Running             0          5d23h\nnebula-cluster-storaged-2        0/1     ContainerCreating   0          1s\n...\n</code></pre> <p><pre><code>...\nnebula-cluster-storaged-1        1/1     Running     0          5d23h\nnebula-cluster-storaged-2        1/1     Running     0          4m2s\n...\n</code></pre> When the status of <code>&lt;cluster-name&gt;-storaged-2</code> is changed from <code>ContainerCreating</code> to <code>Running</code>, the self-healing is performed successfully.</p> </li> </ol>"},{"location":"k8s-operator/4.cluster-administration/4.9.advanced/4.9.1.rolling-update-strategy/","title":"Optimize leader transfer in rolling updates","text":"<p>NebulaGraph clusters use a distributed architecture to divide data into multiple logical partitions, which are typically evenly distributed across different nodes. In distributed systems, there are usually multiple replicas of the same data. To ensure the consistency of data across multiple replicas, NebulaGraph clusters use the Raft protocol to synchronize multiple partition replicas. In the Raft protocol, each partition elects a leader replica, which is responsible for handling write requests, while follower replicas handle read requests.</p> <p>When a NebulaGraph cluster created by NebulaGraph Operator performs a rolling update, a storage node temporarily stops providing services for the update. For an overview of rolling updates, see Performing a Rolling Update. If the node hosting the leader replica stops providing services, it will result in the unavailability of read and write operations for that partition. To avoid this situation, by default, NebulaGraph Operator transfers the leader replicas to other unaffected nodes during the rolling update process of a NebulaGraph cluster. This way, when a storage node is being updated, the leader replicas on other nodes can continue processing client requests, ensuring the read and write availability of the cluster.</p> <p>The process of migrating all leader replicas from one storage node to the other nodes may take a long time. To better control the rolling update duration, Operator provides a field called <code>enableForceUpdate</code>. When it is confirmed that there is no external access traffic, you can set this field to <code>true</code>. This way, the leader replicas will not be transferred to other nodes, thereby speeding up the rolling update process.</p>"},{"location":"k8s-operator/4.cluster-administration/4.9.advanced/4.9.1.rolling-update-strategy/#rolling_update_trigger_conditions","title":"Rolling update trigger conditions","text":"<p>Operator triggers a rolling update of the NebulaGraph cluster under the following circumstances:</p> <ul> <li>The version of the NebulaGraph cluster changes.</li> <li>The configuration of the NebulaGraph cluster changes.</li> <li>NebulaGraph cluster services are restarted.</li> </ul>"},{"location":"k8s-operator/4.cluster-administration/4.9.advanced/4.9.1.rolling-update-strategy/#specify_a_rolling_update_strategy","title":"Specify a rolling update strategy","text":"<p>In the YAML file for creating a cluster instance, add the <code>spec.storaged.enableForceUpdate</code> field and set it to <code>true</code> or <code>false</code> to control the rolling update speed.</p> <p>When <code>enableForceUpdate</code> is set to <code>true</code>, it means that the leader partition replicas are not transferred, thus speeding up the rolling update process. Conversely, when set to <code>false</code>, it means that the leader replicas are transferred to other nodes to ensure the read and write availability of the cluster. The default value is <code>false</code>.</p> <p>Warning</p> <p>When setting <code>enableForceUpdate</code> to <code>true</code>, make sure there is no traffic entering the cluster for read and write operations. This is because this setting will force the cluster pods to be rebuilt, and during this process, data loss or client request failures may occur.</p> <p>Configuration example:</p> <pre><code>...\nspec:\n...\n  storaged:\n    # When set to true,\n    # it means that the leader partition replicas are not transferred,\n    # but the cluster pods are rebuilt directly.\n    enableForceUpdate: true \n    ...\n</code></pre>"},{"location":"k8s-operator/4.cluster-administration/4.9.advanced/4.9.2.restart-cluster/","title":"Restart service Pods in a NebulaGraph cluster on K8s","text":"<p>Note</p> <p>Restarting NebulaGraph cluster service Pods is a feature in the Alpha version.</p> <p>During routine maintenance, it might be necessary to restart a specific service Pod in the NebulaGraph cluster, for instance, when the Pod's status is abnormal or to enforce a restart. Restarting a Pod essentially means restarting the service process. To ensure high availability, NebulaGraph Operator supports gracefully restarting all Pods of the Graph, Meta, or Storage service respectively and gracefully restarting an individual Pod of the Storage service.</p>"},{"location":"k8s-operator/4.cluster-administration/4.9.advanced/4.9.2.restart-cluster/#prerequisites","title":"Prerequisites","text":"<p>A NebulaGraph cluster is created in a K8s environment. For details, see Create a NebulaGraph cluster.</p>"},{"location":"k8s-operator/4.cluster-administration/4.9.advanced/4.9.2.restart-cluster/#restart_all_pods_of_a_certain_service_type","title":"Restart all Pods of a certain service type","text":"<p>To gracefully roll restart all Pods of a certain service type in the cluster, you can add an annotation (<code>nebula-graph.io/restart-timestamp</code>) with the current time to the configuration of the StatefulSet controller of the corresponding service.</p> <p>When NebulaGraph Operator detects that the StatefulSet controller of the corresponding service has the annotation <code>nebula-graph.io/restart-timestamp</code> and its value is changed, it triggers the graceful rolling restart operation for all Pods of that service type in the cluster.</p> <p>In the following example, the annotation is added for all Graph services so that all Pods of these Graph services are restarted one by one.</p> <p>Assume that the cluster name is <code>nebula</code> and the cluster resources are in the <code>default</code> namespace. Run the following command:</p> <ol> <li> <p>Check the name of the StatefulSet controller.</p> <pre><code>kubectl get statefulset \n</code></pre> <p>Sample output:</p> <pre><code>NAME              READY   AGE\nnebula-graphd     2/2     33s\nnebula-metad      3/3     69s\nnebula-storaged   3/3     69s\n</code></pre> </li> <li> <p>Get the current timestamp.</p> <pre><code>date -u +%s\n</code></pre> <p>Example output:</p> <pre><code>1700547115\n</code></pre> </li> <li> <p>Overwrite the timestamp annotation of the StatefulSet controller to trigger the graceful rolling restart operation.</p> <pre><code>kubectl annotate statefulset nebula-graphd nebula-graph.io/restart-timestamp=\"1700547115\" --overwrite\n</code></pre> <p>Example output:</p> <pre><code>statefulset.apps/nebula-graphd annotate\n</code></pre> </li> <li> <p>Observe the restart process.</p> <pre><code>kubectl get pods -l app.kubernetes.io/cluster=nebula,app.kubernetes.io/component=graphd -w\n</code></pre> <p>Example output:</p> <pre><code>NAME              READY   STATUS    RESTARTS   AGE\nnebula-graphd-0   1/1     Running   0          9m37s\nnebula-graphd-1   0/1     Running   0          17s\nnebula-graphd-1   1/1     Running   0          20s\nnebula-graphd-0   1/1     Terminating   0          9m40s\nnebula-graphd-0   0/1     Terminating   0          9m41s\nnebula-graphd-0   0/1     Terminating   0          9m42s\nnebula-graphd-0   0/1     Terminating   0          9m42s\nnebula-graphd-0   0/1     Terminating   0          9m42s\nnebula-graphd-0   0/1     Pending       0          0s\nnebula-graphd-0   0/1     Pending       0          0s\nnebula-graphd-0   0/1     ContainerCreating   0          0s\nnebula-graphd-0   0/1     Running             0          2s\n</code></pre> <p>This above output shows the status of Graph service Pods during the restart process.</p> </li> <li> <p>Verify that the StatefulSet controller annotation is updated.</p> <pre><code>kubectl get statefulset nebula-graphd -o yaml | grep \"nebula-graph.io/restart-timestamp\"\n</code></pre> <p>Example output:</p> <pre><code>nebula-graph.io/last-applied-configuration: '{\"persistentVolumeClaimRetentionPolicy\":{\"whenDeleted\":\"Retain\",\"whenScaled\":\"Retain\"},\"podManagementPolicy\":\"Parallel\",\"replicas\":2,\"revisionHistoryLimit\":10,\"selector\":{\"matchLabels\":{\"app.kubernetes.io/cluster\":\"nebula\",\"app.kubernetes.io/component\":\"graphd\",\"app.kubernetes.io/managed-by\":\"nebula-operator\",\"app.kubernetes.io/name\":\"nebula-graph\"}},\"serviceName\":\"nebula-graphd-headless\",\"template\":{\"metadata\":{\"annotations\":{\"nebula-graph.io/cm-hash\":\"7c55c0e5ac74e85f\",\"nebula-graph.io/restart-timestamp\":\"1700547815\"},\"creationTimestamp\":null,\"labels\":{\"app.kubernetes.io/cluster\":\"nebula\",\"app.kubernetes.io/component\":\"graphd\",\"app.kubernetes.io/managed-by\":\"nebula-operator\",\"app.kubernetes.io/name\":\"nebula-graph\"}},\"spec\":{\"containers\":[{\"command\":[\"/bin/sh\",\"-ecx\",\"exec\nnebula-graph.io/restart-timestamp: \"1700547115\"\n    nebula-graph.io/restart-timestamp: \"1700547815\" \n</code></pre> </li> </ol> <p>The above output indicates that the annotation of the StatefulSet controller has been updated, and all graph service Pods has been restarted.</p>"},{"location":"k8s-operator/4.cluster-administration/4.9.advanced/4.9.2.restart-cluster/#restart_a_single_storage_service_pod","title":"Restart a single Storage service Pod","text":"<p>To gracefully roll restart a single Storage service Pod, you can add an annotation (<code>nebula-graph.io/restart-ordinal</code>) with the value set to the ordinal number of the Storage service Pod you want to restart. This triggers a graceful restart or state transition for that specific Storage service Pod. The added annotation will be automatically removed after the Storage service Pod is restarted.</p> <p>In the following example, the annotation is added for the Pod with ordinal number <code>1</code>, indicating a graceful restart for the <code>nebula-storaged-1</code> Storage service Pod.</p> <p>Assume that the cluster name is <code>nebula</code>, and the cluster resources are in the <code>default</code> namespace. Run the following commands:</p> <ol> <li> <p>Check the name of the StatefulSet controller.</p> <pre><code>kubectl get statefulset \n</code></pre> <p>Example output:</p> <pre><code>NAME              READY   AGE\nnebula-graphd     2/2     33s\nnebula-metad      3/3     69s\nnebula-storaged   3/3     69s\n</code></pre> </li> <li> <p>Get the ordinal number of the Storage service Pod.</p> <pre><code>kubectl get pods -l app.kubernetes.io/cluster=nebula,app.kubernetes.io/component=storaged\n</code></pre> <p>Example output:</p> <pre><code>NAME                READY   STATUS    RESTARTS   AGE\nnebula-storaged-0   1/1     Running   0          13h\nnebula-storaged-1   1/1     Running   0          13h\nnebula-storaged-2   1/1     Running   0          13h\nnebula-storaged-3   1/1     Running   0          13h\nnebula-storaged-4   1/1     Running   0          13h\nnebula-storaged-5   1/1     Running   0          13h\nnebula-storaged-6   1/1     Running   0          13h\nnebula-storaged-7   1/1     Running   0          13h\nnebula-storaged-8   1/1     Running   0          13h\n</code></pre> </li> <li> <p>Add the annotation for the <code>nebula-storaged-1</code> Pod to trigger a graceful restart for that specific Pod.</p> <pre><code>kubectl annotate statefulset nebula-storaged nebula-graph.io/restart-ordinal=\"1\" \n</code></pre> <p>Example output:</p> <pre><code>statefulset.apps/nebula-storaged annotate\n</code></pre> </li> <li> <p>Observe the restart process.</p> <pre><code>kubectl get pods -l app.kubernetes.io/cluster=nebula,app.kubernetes.io/component=storaged -w\n</code></pre> <p>Example output:</p> <pre><code>NAME                READY   STATUS    RESTARTS   AGE\nnebula-storaged-0   1/1     Running   0          13h\nnebula-storaged-1   1/1     Running   0          13h\nnebula-storaged-2   1/1     Running   0          13h\nnebula-storaged-3   1/1     Running   0          13h\nnebula-storaged-4   1/1     Running   0          13h\nnebula-storaged-5   1/1     Running   0          12h\nnebula-storaged-6   1/1     Running   0          12h\nnebula-storaged-7   1/1     Running   0          12h\nnebula-storaged-8   1/1     Running   0          12h\n\n\nnebula-storaged-1   1/1     Running   0          13h\nnebula-storaged-1   1/1     Terminating   0          13h\nnebula-storaged-1   0/1     Terminating   0          13h\nnebula-storaged-1   0/1     Terminating   0          13h\nnebula-storaged-1   0/1     Terminating   0          13h\nnebula-storaged-1   0/1     Terminating   0          13h\nnebula-storaged-1   0/1     Pending       0          0s\nnebula-storaged-1   0/1     Pending       0          0s\nnebula-storaged-1   0/1     ContainerCreating   0          0s\nnebula-storaged-1   0/1     Running             0          1s\nnebula-storaged-1   1/1     Running             0          10s  \n</code></pre> <p>The above output indicates that the <code>nebula-storaged-1</code> Storage service Pod is successfully restarted.</p> <p>After restarting a single Storage service Pod, the distribution of storage leader replicas may become unbalanced. You can execute the <code>BALANCE LEADER</code> command to rebalance the distribution of leader replicas. For information about how to view the leader distribution, see <code>SHOW HOSTS</code>.</p> </li> </ol>"},{"location":"nebula-cloud/2.how-to-create-subsciption/","title":"Create a subscription","text":"<p>Before using NebulaGraph Cloud, you need to create a subscription on Azure. This topic describes how to create a subscription on Azure Marketplace.</p>"},{"location":"nebula-cloud/2.how-to-create-subsciption/#subscription_workflow","title":"Subscription workflow","text":"<ol> <li> <p>Enter the Azure Marketplace, and search for NebulaGraph Cloud in the search bar in Marketplace, or directly click NebulaGraph Cloud to enter the subscription page. [TODO]</p> </li> <li> <p>Select a plan according to your own needs and click Set up + subscribe.</p> <ol> <li> <p>On the Basics page of Subscribe NebulaGraph Cloud, fill in the following plan details:</p> <ul> <li> <p>Project details</p> Field Description Subscription Select a subscription. Resource group Select an existing resource group or create a new one. </li> </ul> <ul> <li> <p>SaaS details</p> Field Description Name Create a name for this SaaS subscription to easily identify it later. Recurring billing <code>On</code> or <code>Off</code>. </li> </ul> </li> <li> <p>At the bottom of the Basics page, click Next: Tags.</p> </li> <li>(Optional) On the Tags page, enter Name: Value.</li> <li>At the bottom of Review + subscribe page, click Subscribe and wait for about 2 minutes.</li> </ol> </li> <li> <p>After the subscription is completed, you need to click <code>Open the SaaS account on the publisher's website</code> to create and configure your Solution. For details, see How to configure a Solution.</p> </li> </ol>"},{"location":"nebula-cloud/3.how-to-set-solution/","title":"Configure a Solution","text":"<p>Solution refers to the NebulaGraph database running on NebulaGraph Cloud. After subscribing NebulaGraph Cloud on Azure, you need to configure your Solutions on the Cloud platform to complete the purchase. This topic describes how to configure a Solution.</p>"},{"location":"nebula-cloud/3.how-to-set-solution/#configuration_workflow","title":"Configuration workflow","text":"<ol> <li>To complete your purchase after subscribing NebulaGraph Cloud on Azure, click Configure account now on the page and the system will jump to the NebulaGraph Cloud login page.</li> <li> <p>Log in to the Azure account that has subscribed the Solution service in NebulaGraph Cloud.</p> <ol> <li> <p>Select a region in the Provider section.</p> <p></p> <p>Caution</p> <p>The region of the database you select should be in the same area as that of your business to avoid performance and speed problems.</p> </li> <li> <p>Configure the type and the number of the query engine and the type, the number, and the disk size of the storage engine in the Instance section.</p> <p>Caution</p> <p>It is recommended to configure at least 2 query engines and 3 storage engines to ensure high service availability.</p> </li> <li> <p>Enter the specified Azure account mailbox as the Root user in the NebulaGraph section.</p> <p></p> </li> <li> <p>Click Next at the bottom of this page.</p> </li> <li>After confirmation, click Create at the bottom of this page.</li> </ol> </li> <li> <p>For now, you have completed the configuration of the Solution. If the status of the Solution is running on the Cloud homepage, the Solution has been created successfully.</p> </li> </ol>"},{"location":"nebula-cloud/3.how-to-set-solution/#solution_status","title":"Solution status","text":"<p>You may see the following status and corresponding description on the Solution page.</p> Status Description creating The resources required by a Solution are ready and the Solution will be created automatically. At this time, the Solution is in the creating state, which may last from several minutes to over ten minutes. starting After you have restarted a Solution, it will be in the starting state for a while. stopping After you have clicked Stop Solution, the Solution will be in the stopping state for a while. deleting After you have clicked Delete Solution, the Solution will be in the deleting state for a while. running After you create a Solution, it will be in the running state for a long time. stopped After you stop a Solution, it will be in the stopped state for a long time. deleted After you delete a Solution, it will be in the deleted state for a long time. create_failed If you failed to create a Solution, the Solution will be in the create_failed state for a long time. stop_failed If you failed to stop a Solution, the Solution will be in the stop_failed state for a long time. start_failed If you failed to start a Solution, the Solution will be in the start_failed state for a long time. <p>Caution</p> <p>If a Solution stays in an intermediate state for a long time and the page remains unchanged after refreshing, it means that there is an exception and you need to submit an order to solve the problem.</p> <p>Caution</p> <p>If a Solution is in the state of create_failed, stop_failed, or start_failed, you can execute CREATE, STOP, or START again.</p>"},{"location":"nebula-cloud/4.user-role-description/","title":"Cloud Solution roles","text":"<p>After creating a Solution, you need to confirm the role privileges in the Cloud platform. This topic introduces the role privileges in the Cloud Solution.</p>"},{"location":"nebula-cloud/4.user-role-description/#built-in_roles","title":"Built-in roles","text":"<p>NebulaGraph Cloud has multiple built-in roles:</p> <ul> <li>OWNER  <ul> <li>Correspond to the resource manager who can subscribe services and manage resource privileges.</li> <li>Configure Solution, create and confirm services, and activate subscription.</li> <li>Start and stop services of the Solution.</li> <li>Authorizing the ROOT user in the database manually.</li> <li>Access the database on the Cloud through a private endpoint.</li> <li>View history logs.</li> <li>Connect to NebulaGraph Dashboard to monitor specified Solution nodes and services.</li> </ul> </li> </ul> <ul> <li>ROOT<ul> <li>Correspond to the God of the NebulaGraph database, which is set by the OWNER. For privileges of the God role, see Built-in role privileges.</li> <li>Manage users with the USER role in different spaces in the Cloud platform. When authorizing the USER role, you need to specify the role privileges of the NebulaGraph database, including ADMIN, DBA, GUEST, and USER. For details, see Built-in role privileges.</li> <li>Access the database on the Cloud through a private endpoint.</li> <li>Connect to visualized tools, including NebulaGraph Dashboard, NebulaGraph Studio, and NebulaGraph Explorer.</li> </ul> </li> </ul> <ul> <li>USER<ul> <li>The database users are the Azure subscribers invited by the ROOT user in the Cloud platform.</li> <li>Correspond to the ADMIN, DBA, GUEST, or USER in the NebulaGraph database.</li> <li>Access the database on the Cloud through a private endpoint.</li> <li>Connect to visualized tools, including NebulaGraph Studio and NebulaGraph Explorer.</li> </ul> </li> </ul>"},{"location":"nebula-cloud/4.user-role-description/#solutions_privileges","title":"Solutions privileges","text":"<p>On the Solution page, users with different roles will see different sidebars. The following describes the privileges of each role. Among them, Y means that this role can view this page, and N means that it cannot.</p> Page OWNER ROOT USER Solution Info Y Y Y Applications Y Y Y Connectivity Y N N Root Management Y N N User Management N Y N Audit Log Y N N Settings Y N N Subscribe Settings Y N N Billing Y N N"},{"location":"nebula-cloud/7.terms-and-conditions/","title":"Terms of Service","text":"<p>These terms and conditions (\"Agreement\") sets forth the general terms and conditions of your use of the https://cloud.nebula-cloud.io website (\"Website\" or \"Service\") and any of its related products and services (collectively, \"Services\"). This Agreement is legally binding between you (\"User\", \"you\" or \"your\") and vesoft inc. (\"vesoft inc.\", \"we\", \"us\" or \"our\"). By accessing and using the Website and Services, you acknowledge that you have read, understood, and agree to be bound by the terms of this Agreement. If you are entering into this Agreement on behalf of a business or other legal entity, you represent that you have the authority to bind such entity to this Agreement, in which case the terms \"User\", \"you\" or \"your\" shall refer to such entity. If you do not have such authority, or if you do not agree with the terms of this Agreement, you must not accept this Agreement and may not access and use the Website and Services. You acknowledge that this Agreement is a contract between you and vesoft inc., even though it is electronic and is not physically signed by you, and it governs your use of the Website and Services.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#accounts","title":"Accounts","text":"<p>You give NebulaGraph Cloud permission to use your Azure account as your NebulaGraph Cloud account and get your account information so that NebulaGraph Cloud can contact you regarding this product and related products. You understand that the rights to use NebulaGraph Cloud come from vesoft instead of Microsoft, vesoft is the provider of this product. Use of NebulaGraph Cloud is governed by provider's terms of service, service-level agreement, and privacy policy.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#billing_and_payments","title":"Billing and payments","text":"<p>Microsoft collects payments from you for your commercial marketplace purchases. You may pay the fees for the NebulaGraph Cloud services according to your chosen solutions. You shall pay all fees or charges to your account in accordance with the fees, charges, and billing terms in effect at the time a fee or charge is due and payable. </p>"},{"location":"nebula-cloud/7.terms-and-conditions/#accuracy_of_information","title":"Accuracy of information","text":"<p>Occasionally there may be information on the Website that contains typographical errors, inaccuracies or omissions that may relate to pricing, availability, promotions and offers. We reserve the right to correct any errors, inaccuracies or omissions, and to change or update information or cancel orders if any information on the Website or Services is inaccurate at any time without prior notice (including after you have submitted your order). We undertake no obligation to update, amend or clarify information on the Website including, without limitation, pricing information, except as required by law. No specified update or refresh date applied on the Website should be taken to indicate that all information on the Website or Services has been modified or updated.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#data_and_content_protection","title":"Data and content protection","text":"<p>vesoft understands and recognizes that all the data processed, stored, uploaded, downloaded, distributed, or processed through services provided by NebulaGraph Cloud is your data or content, and you fully own your data and content. Except for the implementation of your service requirements, no unauthorized use or disclosure of your data or content will be made except in the following circumstances:</p> <p>a.vesoft may disclose the data or content in any legal proceeding or to a governmental body as required by Law; </p> <p>b.an agreement made between you and vesoft.</p> <p>You can delete or edit your data or content yourself. If you have deleted the service or data, vesoft will delete your data and will no longer retain such data in accordance with your instructions. You should operate carefully with regard to operations such as deletion or modification.</p> <p>You understand and agree: when your subscription is in the Suspended state, Microsoft gives the customer a 30-day grace period before automatically canceling the subscription. After the 30-day grace period is over, the webhook will receive an Unsubscribe action. After vesoft receives a cancellation webhook call, vesoft will only continue to store your data and content (if any) within 7 days. After 7 days, vesoft will delete all your data and content, including all cached or backup copies, and will no longer retain any of them.</p> <p>Once the data or content is deleted, it cannot be restored; you shall take responsibilities caused by the data being deleted. You understand and agree that vesoft has no obligation to continue to retain, export or return your data or content.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#links_to_other_resources","title":"Links to other resources","text":"<p>Although the Website and Services may link to other resources (such as websites), we are not, directly or indirectly, implying any approval, association, sponsorship, endorsement, or affiliation with any linked resource, unless specifically stated herein. You acknowledge that vesoft inc. is providing these links to you only as a convenience. We are not responsible for examining or evaluating, and we do not warrant the offerings of, any businesses or individuals or the content of their resources. We do not assume any responsibility or liability for the actions, products, services, and content of any other third parties. You should carefully review the legal statements and other conditions of use of any resource which you access through a link on the Website and Services. Your linking to any other off-site resources is at your own risk.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#prohibited_uses","title":"Prohibited uses","text":"<p>In addition to other terms as set forth in the Agreement, you are prohibited from using the Website and Services or Content: (a) for any unlawful purpose; (b) to solicit others to perform or participate in any unlawful acts; (c) to violate any international, federal, provincial or state regulations, rules, laws, or local ordinances; (d) to infringe upon or violate our intellectual property rights or the intellectual property rights of others; (e) to harass, abuse, insult, harm, defame, slander, disparage, intimidate, or discriminate based on gender, sexual orientation, religion, ethnicity, race, age, national origin, or disability; (f) to submit false or misleading information; (g) to upload or transmit viruses or any other type of malicious code that will or may be used in any way that will affect the functionality or operation of the Website and Services, third party products and services, or the Internet; (h) to spam, phish, pharm, pretext, spider, crawl, or scrape; (i) for any obscene or immoral purpose; or (j) to interfere with or circumvent the security features of the Website and Services, third party products and services, or the Internet. We reserve the right to terminate your use of the Website and Services for violating any of the prohibited uses.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#intellectual_property_rights","title":"Intellectual property rights","text":"<p>\"Intellectual Property Rights\" means all present and future rights conferred by law or statute in or in relation to any copyright and related rights, trademarks, designs, patents, inventions, goodwill and the right to sue for passing off, rights to inventions, rights to use, and all other intellectual property rights, in each case whether registered or unregistered and including all applications and rights to apply for and be granted, rights to claim priority from, such rights and all similar or equivalent rights or forms of protection and any other results of intellectual activity which subsist or will subsist now or in the future in any part of the world. This Agreement does not transfer to you any intellectual property owned by vesoft inc. or third parties, and all rights, titles, and interests in and to such property will remain (as between the parties) solely with vesoft inc. All trademarks, service marks, graphics and logos used in connection with the Website and Services, are trademarks or registered trademarks of vesoft inc. or its licensors. Other trademarks, service marks, graphics and logos used in connection with the Website and Services may be the trademarks of other third parties. Your use of the Website and Services grants you no right or license to reproduce or otherwise use any of vesoft inc. or third party trademarks.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#disclaimer_of_warranty","title":"Disclaimer of warranty","text":"<p>You agree that such Service is provided on an \"as is\" and \"as available\" basis and that your use of the Website and Services is solely at your own risk. We expressly disclaim all warranties of any kind, whether express or implied, including but not limited to the implied warranties of merchantability, fitness for a particular purpose and non-infringement. We make no warranty that the Services will meet your requirements, or that the Service will be uninterrupted, timely, secure, or error-free; nor do we make any warranty as to the results that may be obtained from the use of the Service or as to the accuracy or reliability of any information obtained through the Service or that defects in the Service will be corrected. You understand and agree that any material and/or data downloaded or otherwise obtained through the use of Service is done at your own discretion and risk and that you will be solely responsible for any damage or loss of data that results from the download of such material and/or data. We make no warranty regarding any goods or services purchased or obtained through the Service or any transactions entered into through the Service. No advice or information, whether oral or written, obtained by you from us or through the Service shall create any warranty not expressly made herein.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#limitation_of_liability","title":"Limitation of liability","text":"<p>To the fullest extent permitted by applicable law, in no event will vesoft inc., its affiliates, directors, officers, employees, agents, suppliers or licensors be liable to any person for any indirect, incidental, special, punitive, cover or consequential damages (including, without limitation, damages for lost profits, revenue, sales, goodwill, use of content, impact on business, business interruption, loss of anticipated savings, loss of business opportunity) however caused, under any theory of liability, including, without limitation, contract, tort, warranty, breach of statutory duty, negligence or otherwise, even if the liable party has been advised as to the possibility of such damages or could have foreseen such damages.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#indemnification","title":"Indemnification","text":"<p>You agree to indemnify and hold vesoft inc. and its affiliates, directors, officers, employees, agents, suppliers and licensors harmless from and against any liabilities, losses, damages or costs, including reasonable attorneys' fees, incurred in connection with or arising from any third party allegations, claims, actions, disputes, or demands asserted against any of them as a result of or relating to your Content, your use of the Website and Services or any willful misconduct on your part.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#severability","title":"Severability","text":"<p>All rights and restrictions contained in this Agreement may be exercised and shall be applicable and binding only to the extent that they do not violate any applicable laws and are intended to be limited to the extent necessary so that they will not render this Agreement illegal, invalid or unenforceable. If any provision or portion of any provision of this Agreement shall be held to be illegal, invalid or unenforceable by a court of competent jurisdiction, it is the intention of the parties that the remaining provisions or portions thereof shall constitute their agreement with respect to the subject matter hereof, and all such remaining provisions or portions thereof shall remain in full force and effect.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#dispute_resolution","title":"Dispute resolution","text":"<p>The formation, interpretation, and performance of this Agreement and any disputes arising out of it shall be governed by the substantive and procedural laws of China without regard to its rules on conflicts or choice of law and, to the extent applicable, the laws of China. You further consent to the territorial jurisdiction of and exclusive venue in Internet Court of Hangzhou as the legal forum for any such dispute. You hereby waive any right to a jury trial in any proceeding arising out of or related to this Agreement. The United Nations Convention on Contracts for the International Sale of Goods does not apply to this Agreement.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#assignment","title":"Assignment","text":"<p>You may not assign, resell, sub-license or otherwise transfer or delegate any of your rights or obligations hereunder, in whole or in part, without our prior written consent, which consent shall be at our own sole discretion and without obligation; any such assignment or transfer shall be null and void. We are free to assign any of its rights or obligations hereunder, in whole or in part, to any third party as part of the sale of all or substantially all of its assets or stock or as part of a merger.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#changes_and_amendments","title":"Changes and amendments","text":"<p>We reserve the right to modify this Agreement or its terms relating to the Website and Services at any time, effective upon posting of an updated version of this Agreement on the Website. When we do, we will revise the updated date at the bottom of this page. Continued use of the Website and Services after any such changes shall constitute your consent to such changes.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#acceptance_of_these_terms","title":"Acceptance of these terms","text":"<p>You acknowledge that you have read this Agreement and agree to all its terms and conditions. By accessing and using the Website and Services you agree to be bound by this Agreement. If you do not agree to abide by the terms of this Agreement, you are not authorized to access or use the Website and Services.</p>"},{"location":"nebula-cloud/7.terms-and-conditions/#contacting_us","title":"Contacting us","text":"<p>If you would like to contact us to understand more about this Agreement or wish to contact us concerning any matter relating to it, you may send an email to legal@vesoft.com</p> <p>This document was last updated on December 14, 2021</p>"},{"location":"nebula-cloud/8.privacy-policy/","title":"Privacy Policy","text":"<p>This privacy policy (\"Policy\") describes how the personally identifiable information (\"Personal Information\") you may provide on the https://www.nebula-cloud.io[TODO] website (\"Website\" or \"Service\") and any of its related products and services (collectively, \"Services\") is collected, protected and used. It also describes the choices available to you regarding our use of your Personal Information and how you can access and update this information. This Policy is a legally binding agreement between you (\"User\", \"you\" or \"your\") and vesoft Inc. (\"vesoft Inc.\", \"we\", \"us\" or \"our\"). By accessing and using the Website and Services, you acknowledge that you have read, understood, and agree to be bound by the terms of this Agreement. This Policy does not apply to the practices of companies that we do not own or control, or to individuals that we do not employ or manage.</p>"},{"location":"nebula-cloud/8.privacy-policy/#automatic_collection_of_information","title":"Automatic collection of information","text":"<p>When you open the Website, our servers automatically record information that your browser sends. This data may include information such as your device's IP address, browser type and version, operating system type and version, language preferences or the webpage you were visiting before you came to the Website and Services, pages of the Website and Services that you visit, the time spent on those pages, information you search for on the Website, access times and dates, and other statistics.</p> <p>Information collected automatically is used only to identify potential cases of abuse and establish statistical information regarding the usage and traffic of the Website and Services. This statistical information is not otherwise aggregated in such a way that would identify any particular user of the system.</p>"},{"location":"nebula-cloud/8.privacy-policy/#collection_of_personal_information","title":"Collection of personal information","text":"<p>You can access and use the Website and Services without telling us who you are or revealing any information by which someone could identify you as a specific, identifiable individual. If, however, you wish to use some of the features on the Website, you may be asked to provide certain Personal Information (for example, your name and e-mail address). We receive and store any information you knowingly provide to us when you create an account or fill any online forms on the Website. When required, this information may include the following:</p> <ul> <li>Personal details such as name.</li> <li>Contact information such as email address.</li> <li>Account details such as user name and password.</li> <li>Any other materials you willingly submit to us such as articles, images, feedback, etc.</li> </ul> <p>You can choose not to provide us with your Personal Information, but then you may not be able to take advantage of some of the features on the Website. Users who are uncertain about what information is mandatory are welcome to contact us.</p>"},{"location":"nebula-cloud/8.privacy-policy/#use_and_processing_of_collected_information","title":"Use and processing of collected information","text":"<p>In order to make the Website and Services available to you, or to meet a legal obligation, we need to collect and use certain Personal Information. If you do not provide the information that we request, we may not be able to provide you with the requested products or services. Some of the information we collect is directly from you via the Website and Services. However, we may also collect Personal Information about you from other sources. Any of the information we collect from you may be used for the following purposes:</p> <ul> <li>Create and manage user accounts</li> <li>Deliver products or services</li> <li>Improve products and services</li> <li>Send marketing and promotional communications</li> <li>Respond to inquiries and offer support</li> <li>Request user feedback</li> <li>Improve user experience</li> <li>Deliver targeted advertising</li> <li>Enforce terms and conditions and policies</li> <li>Protect from abuse and malicious users</li> <li>Respond to legal requests and prevent harm</li> <li>Run and operate the Website and Services</li> </ul> <p>Processing your Personal Information depends on how you interact with the Website and Services, where you are located in the world and if one of the following applies: (i) you have given your consent for one or more specific purposes; (ii) provision of information is necessary for the performance of an agreement with you and/or for any pre-contractual obligations thereof; (iii) processing is necessary for compliance with a legal obligation to which you are subject; (iv) processing is related to a task that is carried out in the public interest or in the exercise of official authority vested in us; (v) processing is necessary for the purposes of the legitimate interests pursued by us or by a third party.</p> <p>Note that under some legislation we may be allowed to process information until you object to such processing (by opting out), without having to rely on consent or any other of the following legal bases below. In any case, we will be happy to clarify the specific legal basis that applies to the processing, and in particular whether the provision of Personal Information is a statutory or contractual requirement, or a requirement necessary to enter into a contract.</p>"},{"location":"nebula-cloud/8.privacy-policy/#managing_information","title":"Managing information","text":"<p>You are able to delete certain Personal Information we have about you. The Personal Information you can delete may change as the Website and Services change. If you would like to delete your Personal Information or permanently delete your account, you can do so by contacting us.</p>"},{"location":"nebula-cloud/8.privacy-policy/#disclosure_of_information","title":"Disclosure of information","text":"<p>Depending on the requested Services or as necessary to complete any transaction or provide any service you have requested, we may share your information with your consent with our trusted third parties that work with us, any other affiliates and subsidiaries we rely upon to assist in the operation of the Website and Services available to you. We do not share Personal Information with unaffiliated third parties. These service providers are not authorized to use or disclose your information except as necessary to perform services on our behalf or comply with legal requirements. We may share your Personal Information for these purposes only with third parties whose privacy policies are consistent with ours or who agree to abide by our policies with respect to Personal Information. These third parties are given Personal Information they need only in order to perform their designated functions, and we do not authorize them to use or disclose Personal Information for their own marketing or other purposes.</p> <p>We will disclose any Personal Information we collect, use or receive if required or permitted by law, such as to comply with a subpoena, or similar legal process, and when we believe in good faith that disclosure is necessary to protect our rights, protect your safety or the safety of others, investigate fraud, or respond to a government request.</p> <p>In the event we go through a business transition, such as a merger or acquisition by another company, or sale of all or a portion of its assets, your user account, and Personal Information will likely be among the assets transferred.</p>"},{"location":"nebula-cloud/8.privacy-policy/#retention_of_information","title":"Retention of information","text":"<p>We will retain and use your Personal Information for the period necessary to comply with our legal obligations, resolve disputes, and enforce our agreements unless a longer retention period is required or permitted by law. We may use any aggregated data derived from or incorporating your Personal Information after you update or delete it, but not in a manner that would identify you personally. Once the retention period expires, Personal Information shall be deleted. Therefore, the right to access, the right to erasure, the right to rectification and the right to data portability cannot be enforced after the expiration of the retention period.</p>"},{"location":"nebula-cloud/8.privacy-policy/#transfer_of_information","title":"Transfer of information","text":"<p>Depending on your location, data transfers may involve transferring and storing your information in a country other than your own. You are entitled to learn about the legal basis of information transfers to a country outside the European Union or to any international organization governed by public international law or set up by two or more countries, such as the UN, and about the security measures taken by us to safeguard your information. If any such transfer takes place, you can find out more by checking the relevant sections of this Policy or inquire with us using the information provided in the contact section.</p>"},{"location":"nebula-cloud/8.privacy-policy/#the_rights_of_users","title":"The rights of users","text":"<p>You may exercise certain rights regarding your information processed by us. In particular, you have the right to do the following: (i) you have the right to withdraw consent where you have previously given your consent to the processing of your information; (ii) you have the right to object to the processing of your information if the processing is carried out on a legal basis other than consent; (iii) you have the right to learn if information is being processed by us, obtain disclosure regarding certain aspects of the processing and obtain a copy of the information undergoing processing; (iv) you have the right to verify the accuracy of your information and ask for it to be updated or corrected; (v) you have the right, under certain circumstances, to restrict the processing of your information, in which case, we will not process your information for any purpose other than storing it; (vi) you have the right, under certain circumstances, to obtain the erasure of your Personal Information from us; (vii) you have the right to receive your information in a structured, commonly used and machine readable format and, if technically feasible, to have it transmitted to another controller without any hindrance. This provision is applicable provided that your information is processed by automated means and that the processing is based on your consent, on a contract which you are part of or on pre-contractual obligations thereof.</p>"},{"location":"nebula-cloud/8.privacy-policy/#the_right_to_object_to_processing","title":"The right to object to processing","text":"<p>Where Personal Information is processed for the public interest, in the exercise of an official authority vested in us or for the purposes of the legitimate interests pursued by us, you may object to such processing by providing a ground related to your particular situation to justify the objection.</p>"},{"location":"nebula-cloud/8.privacy-policy/#how_to_exercise_these_rights","title":"How to exercise these rights","text":"<p>Any requests to exercise your rights can be directed to vesoft Inc. through the contact details provided in this document. Please note that we may ask you to verify your identity before responding to such requests. Your request must provide sufficient information that allows us to verify that you are the person you are claiming to be or that you are the authorized representative of such person. You must include sufficient details to allow us to properly understand the request and respond to it. We cannot respond to your request or provide you with Personal Information unless we first verify your identity or authority to make such a request and confirm that the Personal Information relates to you.</p>"},{"location":"nebula-cloud/8.privacy-policy/#privacy_of_children","title":"Privacy of children","text":"<p>We do not knowingly collect any Personal Information from children under the age of 18. If you are under the age of 18, please do not submit any Personal Information through the Website and Services. We encourage parents and legal guardians to monitor their children's Internet usage and to help enforce this Policy by instructing their children never to provide Personal Information through the Website and Services without their permission. If you have reason to believe that a child under the age of 18 has provided Personal Information to us through the Website and Services, please contact us. You must also be at least 16 years of age to consent to the processing of your Personal Information in your country (in some countries we may allow your parent or guardian to do so on your behalf).</p>"},{"location":"nebula-cloud/8.privacy-policy/#cookies","title":"Cookies","text":"<p>The Website and Services use \"cookies\" to help personalize your online experience. A cookie is a text file that is placed on your hard disk by a web page server. Cookies cannot be used to run programs or deliver viruses to your computer. Cookies are uniquely assigned to you, and can only be read by a web server in the domain that issued the cookie to you. We may use cookies to collect, store, and track information for statistical purposes to operate the Website and Services. You have the ability to accept or decline cookies. Most web browsers automatically accept cookies, but you can usually modify your browser setting to decline cookies if you prefer. To learn more about cookies and how to manage them, visit internetcookies.org</p>"},{"location":"nebula-cloud/8.privacy-policy/#email_marketing","title":"Email marketing","text":"<p>We offer electronic newsletters to which you may voluntarily subscribe at any time. We are committed to keeping your e-mail address confidential and will not disclose your email address to any third parties except as allowed in the information use and processing section. We will maintain the information sent via e-mail in accordance with applicable laws and regulations.</p>"},{"location":"nebula-cloud/8.privacy-policy/#links_to_other_resources","title":"Links to other resources","text":"<p>The Website and Services contain links to other resources that are not owned or controlled by us. Such links do not constitute an endorsement by vesoft Inc. of those External Web Sites. Please be aware that we are not responsible for the privacy practices of such other resources or third parties. We encourage you to be aware when you leave the Website and Services and to read the privacy statements of each and every resource that may collect Personal Information. You should carefully review the legal statements and other conditions of use of any resource which you access through a link on the Website and Services.</p>"},{"location":"nebula-cloud/8.privacy-policy/#information_security","title":"Information security","text":"<p>We secure information you provide on computer servers in a controlled, secure environment, protected from unauthorized access, use, or disclosure. We maintain reasonable administrative, technical, and physical safeguards in an effort to protect against unauthorized access, use, modification, and disclosure of Personal Information in its control and custody. However, no data transmission over the Internet or wireless network can be guaranteed. Therefore, while we strive to protect your Personal Information, you acknowledge that (i) there are security and privacy limitations of the Internet which are beyond our control; (ii) the security, integrity, and privacy of any and all information and data exchanged between you and the Website and Services cannot be guaranteed; and (iii) any such information and data may be viewed or tampered with in transit by a third party, despite best efforts.</p>"},{"location":"nebula-cloud/8.privacy-policy/#data_breach","title":"Data breach","text":"<p>In the event we become aware that the security of the Website and Services has been compromised or users Personal Information has been disclosed to unrelated third parties as a result of external activity, including, but not limited to, security attacks or fraud, we reserve the right to take reasonably appropriate measures, including, but not limited to, investigation and reporting, as well as notification to and cooperation with law enforcement authorities. In the event of a data breach, we will make reasonable efforts to notify affected individuals if we believe that there is a reasonable risk of harm to the user as a result of the breach or if notice is otherwise required by law. When we do, we will post a notice on the Website, send you an email.</p>"},{"location":"nebula-cloud/8.privacy-policy/#changes_and_amendments","title":"Changes and amendments","text":"<p>We reserve the right to modify this Policy or its terms relating to the Website and Services from time to time in our discretion and will notify you of any material changes to the way in which we treat Personal Information. When we do, we will revise the updated date at the bottom of this page. We may also provide notice to you in other ways in our discretion, such as through contact information you have provided. Any updated version of this Policy will be effective immediately upon the posting of the revised Policy unless otherwise specified. Your continued use of the Website and Services after the effective date of the revised Policy (or such other act specified at that time) will constitute your consent to those changes. However, we will not, without your consent, use your Personal Information in a manner materially different than what was stated at the time your Personal Information was collected.</p>"},{"location":"nebula-cloud/8.privacy-policy/#dispute_resolution","title":"Dispute resolution","text":"<p>The formation, interpretation, and performance of this Agreement and any disputes arising out of it shall be governed by the substantive and procedural laws of China without regard to its rules on conflicts or choice of law and, to the extent applicable, the laws of China. You further consent to the personal jurisdiction of and exclusive venue in Yuhang District Court located in Hangzhou as the legal forum for any such dispute. You hereby waive any right to a jury trial in any proceeding arising out of or related to this Agreement. The United Nations Convention on Contracts for the International Sale of Goods does not apply to this Agreement.</p>"},{"location":"nebula-cloud/8.privacy-policy/#acceptance_of_this_policy","title":"Acceptance of this policy","text":"<p>You acknowledge that you have read this Policy and agree to all its terms and conditions. By accessing and using the Website and Services you agree to be bound by this Policy. If you do not agree to abide by the terms of this Policy, you are not authorized to access or use the Website and Services.</p>"},{"location":"nebula-cloud/8.privacy-policy/#contacting_us","title":"Contacting us","text":"<p>If you would like to contact us to understand more about this Policy or wish to contact us concerning any matter relating to individual rights and your Personal Information, you may send an email to legal@vesoft.com</p> <p>This document was last updated on December 28, 2021</p>"},{"location":"nebula-cloud/5.solution/5.0.introduce-solution/","title":"Solution","text":"<p>On the Solution page, the sidebars are different based on roles and privileges. For more information, see Roles and privileges in Cloud.</p>"},{"location":"nebula-cloud/5.solution/5.0.introduce-solution/#solution_info","title":"Solution Info","text":"<p>On the homepage of Cloud, click on the Solution's name to enter the Solution Info page. The Solution Info page consists of the following parts: Basic Info, Instance Info, Price Info, Getting Started. You can view the information on this page in detail.</p> <p></p>"},{"location":"nebula-cloud/5.solution/5.0.introduce-solution/#applications","title":"Applications","text":"<p>In the sidebar, click Applications to enter the page of ecosystem tools(Dashboard/Studio/Explorer). Different roles see different ecosystem tools. For more information, see Accessory applications.</p> <p></p>"},{"location":"nebula-cloud/5.solution/5.0.introduce-solution/#connectivity","title":"Connectivity","text":"<p>In the sidebar, click Connectivity to enter Private Link page. On this page, you can create a Private Link endpoint that enables you to access NebulaGraph databases through a private IP address in a virtual network. For more information, see Private Link.</p> <p></p>"},{"location":"nebula-cloud/5.solution/5.0.introduce-solution/#root_management","title":"Root Management","text":"<p>In the sidebar, click Root Management to enter the root account management page. For more information, see Role and User Management.</p> <p></p>"},{"location":"nebula-cloud/5.solution/5.0.introduce-solution/#user_management","title":"User Management","text":"<p>In the sidebar, click User Management to enter the user account management page. For more information, see Role and User Management.</p> <p></p>"},{"location":"nebula-cloud/5.solution/5.0.introduce-solution/#audit_log","title":"Audit Log","text":"<p>In the sidebar, click Audit Log to enter the operation history page. You can select the time period according to the operation information such as <code>Create Solution</code>, <code>Start Solution</code>, <code>Stop Solution</code>, and filter results by operator and operation record.</p> <p></p>"},{"location":"nebula-cloud/5.solution/5.0.introduce-solution/#settings","title":"Settings","text":"<p>In the sidebar, click Settings to enter the settings page, and you can <code>Stop Solution</code> or <code>Transfer Solution</code> in this page.</p> <p></p>"},{"location":"nebula-cloud/5.solution/5.1.supporting-application/","title":"Accessory applications(Dashboard/Studio/Explorer)","text":"<p>NebulaGraph Cloud integrates with NebulaGraph Studio, NebulaGraph Dashboard, and NebulaGraph Explorer.</p> <p>On the Applications page, ecosystem tools are different based on roles and privileges. The correspondence between different roles and privileges is as follows. The first column means the tools that the role can use, Y means the role has the corresponding privileges, and N means the role has no privileges.</p> Tools OWNER ROOT USER Dashboard Y Y N Studio N Y Y Explorer N Y Y"},{"location":"nebula-cloud/5.solution/5.1.supporting-application/#dashboard","title":"Dashboard","text":"<p>NebulaGraph Dashboard (Dashboard for short) is a visualization tool that monitors and manages the status of machines and services in NebulaGraph clusters.</p>"},{"location":"nebula-cloud/5.solution/5.1.supporting-application/#studio","title":"Studio","text":"<p>NebulaGraph Studio (Studio in short) is a browser-based visualization tool to manage NebulaGraph. It provides you with a graphical user interface to manipulate graph schemas, import data, explore graph data, and run nGQL statements to retrieve data. With Studio, you can quickly become a graph exploration expert from scratch. For more information, see What is NebulaGraph Studio.</p>"},{"location":"nebula-cloud/5.solution/5.1.supporting-application/#explorer","title":"Explorer","text":"<p>NebulaGraph Explorer (Explorer in short) is a browser-based visualization tool. It is used with the NebulaGraph core to visualize interaction with graph data. Even without any experience in a graph database, you can quickly become a graph exploration expert.</p>"},{"location":"nebula-cloud/5.solution/5.2.connection-configuration-and-use/","title":"Private Link","text":"<p>You can create a Private Link endpoint in Connectivity to allow users to access NebulaGraph databases through a private IP in a virtual network, without exposing your traffic to the public internet. For more information about Private Link, see What is Azure Private Link?.</p>"},{"location":"nebula-cloud/5.solution/5.2.connection-configuration-and-use/#configure_private_link","title":"Configure Private Link","text":"<ol> <li> <p>Enter your subscription ID, click Create. The creation time takes about 2 minutes.</p> <p></p> <p>Note</p> <p>The subscription ID on the Subscription page of Azure Portal. You can click on the [Subscriptions] (https://portal.azure.com/?l=en.en-us#blade/Microsoft_Azure_Billing/SubscriptionsBlade) page for quick access.</p> </li> <li> <p>After the creation, you can use Alias to connect to Azure resources and create a private endpoint in Azure.</p> <ol> <li>Navigate to the Azure portal. Search for Private Link and click Private endpoint.</li> <li> <p>Click + add.</p> <p></p> </li> <li> <p>In the Basics section, fill in the following plan details:</p> <ul> <li> <p>Project details</p> Field Description Subscription Select the subscription. Resource group Select an existing resource group or create a new resource group. </li> </ul> <ul> <li> <p>Instance details</p> Field Description Name Set the name of the private endpoint. Region Select the region. </li> </ul> <p></p> <p>Caution</p> <p>The region of the database you select should be in the same area as that of your business to avoid performance and speed problems.</p> </li> <li> <p>At the bottom of the Basics page, click Next: Resource.</p> </li> <li> <p>In the Resource section, fill in the following plan details:</p> Field Description Connection method Click Connect to an Azure resource by resource ID or alias. Resource ID or alias Set the alias. Request message Set the message, this message will be sent to the resource owner. <p>Note</p> <p>The alias is on the Connectivity page of NebulaGraph Cloud, click  to copy it.</p> <p></p> </li> <li> <p>At the bottom of the Resource page, click Next: Configuration.</p> </li> <li> <p>In the Configuration section, select the following plan details:</p> <ul> <li> <p>Networking</p> Field Description Virtual network Set virtual networks. Subnet Set the subnet in the selected virtual network. </li> </ul> <p>Note</p> <p>Private DNS integration is currently not supported.</p> <p></p> </li> <li> <p>At the bottom of the Configuration page, click Next: Tags.</p> </li> <li> <p>(optional)In the Tags section, enter Name:Values.</p> <p></p> </li> <li> <p>At the bottom of the Tags page, click Next: Review + create.</p> </li> <li>At the bottom of the Review + create page, click Create.</li> </ol> </li> <li> <p>After creating the private endpoint, copy the Private IP address in Network interface to the Connectivity page in Cloud. Click the Create.</p> <p>Note</p> <p>Private Link Endpoint IP information is stored in the Cloud, and you can click  to modify.</p> </li> </ol>"},{"location":"nebula-cloud/5.solution/5.2.connection-configuration-and-use/#connect_to_nebulagraph_with_private_link","title":"Connect to NebulaGraph with Private Link","text":"<p>You can use Private link endpoint IP to connect to NebulaGraph. For more information, see Connect to NebulaGraph.</p>"},{"location":"nebula-cloud/5.solution/5.3.role-and-authority-management/","title":"Roles and authority management","text":"<p>NebulaGraph Cloud roles are different from roles in NebulaGraph. For more information, see Roles in Cloud Solution.</p> Roles in Cloud Roles in NebulaGraph OWNER - ROOT ROOT USER ADMIN/DBA/GUEST/USER"},{"location":"nebula-cloud/5.solution/5.3.role-and-authority-management/#root_management","title":"Root Management","text":"<p>Only users with OWNER authority can manage ROOT users.</p> <p>On the Root Management page, OWNER can reset ROOT users.</p> <ol> <li> <p>Click Reset, enter the email address of the ROOT user to be updated, and click Send Email to send the email. </p> </li> <li> <p>After the ROOT user receives the confirmation email, click Confirm.</p> </li> </ol>"},{"location":"nebula-cloud/5.solution/5.3.role-and-authority-management/#user_management","title":"User Management","text":"<p>Only users with ROOT authority can manage USER users.</p> <p>On the User Management page, the ROOT user can grant roles in graph spaces to other users. Available roles are ADMIN, DBA, GUEST, and USER.</p> <ol> <li>Select the graph space, click Add User, enter the specified user email and select the management authority of the user. </li> <li>Click Send Email to send the email. </li> <li>After the USER user receives the confirmation email, click Confirm.</li> </ol>"},{"location":"nebula-dashboard/1.what-is-dashboard/","title":"What is NebulaGraph Dashboard Community Edition","text":"<p>NebulaGraph Dashboard Community Edition (Dashboard for short) is a visualization tool that monitors the status of machines and services in NebulaGraph clusters.</p> <p>Enterpriseonly</p> <p>Dashboard Enterprise Edition adds features such as visual cluster creation, batch import of clusters, fast scaling, etc. For more information, see Pricing.</p>"},{"location":"nebula-dashboard/1.what-is-dashboard/#features","title":"Features","text":"<p>Dashboard monitors:</p> <ul> <li>The status of all the machines in clusters, including CPU, memory, load, disk, and network.</li> </ul> <ul> <li>The information of all the services in clusters, including the IP addresses, versions, and monitoring metrics (such as the number of queries, the latency of queries, the latency of heartbeats, and so on).</li> </ul> <ul> <li>The information of clusters, including the information of services, partitions, configurations, and long-term tasks.</li> </ul> <ul> <li>Set how often the metrics page refreshes.</li> </ul>"},{"location":"nebula-dashboard/1.what-is-dashboard/#scenarios","title":"Scenarios","text":"<p>You can use Dashboard in one of the following scenarios:</p> <ul> <li>You want to monitor key metrics conveniently and quickly, and present multiple key information of the business to ensure the business operates normally.</li> </ul> <ul> <li>You want to monitor clusters from multiple dimensions (such as the time, aggregate rules, and metrics).</li> </ul> <ul> <li>After a failure occurs, you need to review it and confirm its occurrence time and unexpected phenomena.</li> </ul>"},{"location":"nebula-dashboard/1.what-is-dashboard/#precautions","title":"Precautions","text":"<p>The monitoring data will be retained for 14 days by default, that is, only the monitoring data within the last 14 days can be queried.</p> <p>Note</p> <p>The monitoring service is supported by Prometheus. The update frequency and retention intervals can be modified. For details, see Prometheus.</p>"},{"location":"nebula-dashboard/1.what-is-dashboard/#version_compatibility","title":"Version compatibility","text":"<p>The version correspondence between NebulaGraph and Dashboard Community Edition is as follows.</p> NebulaGraph version Dashboard version 3.6.0, 3.8.0 3.4.0 3.5.x 3.4.0 3.4.0 ~ 3.4.1 3.4.0\u30013.2.0 3.3.0 3.2.0 2.5.0 ~ 3.2.0 3.1.0 2.5.x ~ 3.1.0 1.1.1 2.0.1~2.5.1 1.0.2 2.0.1~2.5.1 1.0.1"},{"location":"nebula-dashboard/1.what-is-dashboard/#release_note","title":"Release note","text":"<p>Release</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/","title":"Deploy Dashboard Community Edition","text":"<p>This topic will describe how to deploy NebulaGraph Dashboard in detail.</p> <p>To download and compile the latest source code of Dashboard, follow the instructions on the nebula dashboard GitHub page.</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/#prerequisites","title":"Prerequisites","text":"<p>Before you deploy Dashboard, you must confirm that:</p> <ul> <li>The NebulaGraph services are deployed and started. For more information, see NebulaGraph Database Manual.</li> </ul> <ul> <li> <p>Before the installation starts, the following ports are not occupied.</p> <ul> <li>9200</li> </ul> <ul> <li>9100</li> </ul> <ul> <li>9090</li> </ul> <ul> <li>8090</li> </ul> <ul> <li>7003</li> </ul> </li> </ul> <ul> <li>The node-exporter is installed on the machines to be monitored. For details on installation, see Prometheus document.</li> </ul>"},{"location":"nebula-dashboard/2.deploy-dashboard/#steps","title":"Steps","text":"<ol> <li> <p>Download the tar packagenebula-dashboard-3.4.0.x86_64.tar.gz  as needed.</p> </li> <li> <p>Run <code>tar -xvf nebula-dashboard-3.4.0.x86_64.tar.gz</code> to decompress the installation package.</p> </li> <li> <p>Modify the <code>config.yaml</code> file in <code>nebula-dashboard</code>.</p> <p>The configuration file contains the configurations of four dependent services and configurations of clusters. The descriptions of the dependent services are as follows.</p> Service Default port Description nebula-http-gateway 8090 Provides HTTP ports for cluster services to execute nGQL statements to interact with the NebulaGraph database. nebula-stats-exporter 9200 Collects the performance metrics in the cluster, including the IP addresses, versions, and monitoring metrics (such as the number of queries, the latency of queries, the latency of heartbeats, and so on). node-exporter 9100 Collects the source information of nodes in the cluster, including the CPU, memory, load, disk, and network. prometheus 9090 The time series database that stores monitoring data. <p>The descriptions of the configuration file are as follows.</p> <pre><code>port: 7003   # Web service port.\ngateway:\n  ip: hostIP   # The IP of the machine where the Dashboard is deployed.\n  port: 8090\n  https: false  # Whether to enable HTTPS.\n  runmode: dev  # Program running mode, including dev, test, and prod. It is used to distinguish between different running environments generally.\nstats-exporter:\n  ip: hostIP   # The IP of the machine where the Dashboard is deployed.\n  nebulaPort: 9200\n  https: false  # Whether to enable HTTPS.\nnode-exporter:\n  - ip: nebulaHostIP_1 # The IP of the machine where the NebulaGraph is deployed.\n    port: 9100\n    https: false # Whether to enable HTTPS.\n# - ip: nebulaHostIP_2\n#   port: 9100\n#   https: false\nprometheus:\n  ip: hostIP    # The IP of the machine where the Dashboard is deployed.\n  prometheusPort: 9090\n  https: false  # Whether to enable HTTPS.\n  scrape_interval: 5s  # The interval for collecting the monitoring data, which is 1 minute by default.\n  evaluation_interval: 5s  # The interval for running alert rules, which is 1 minute by default.\n# Cluster node info\nnebula-cluster:\n  name: 'default' # Cluster name\n  metad:\n    - name: metad0\n      endpointIP: nebulaMetadIP  # The IP of the machine where the Meta service is deployed.\n      port: 9559\n      endpointPort: 19559\n  # - name: metad1\n  #   endpointIP: nebulaMetadIP\n  #   port: 9559\n  #   endpointPort: 19559  \n  graphd:\n    - name: graphd0\n      endpointIP: nebulaGraphdIP  # The IP of the machine where the Graph service is deployed.\n      port: 9669\n      endpointPort: 19669\n  # - name: graphd1\n  #   endpointIP: nebulaGraphdIP\n  #   port: 9669\n  #   endpointPort: 19669  \n  storaged:\n    - name: storaged0\n      endpointIP: nebulaStoragedIP  # The IP of the machine where the Storage service is deployed.\n      port: 9779\n      endpointPort: 19779\n  # - name: storaged1\n  #   endpointIP: nebulaStoragedIP\n  #   port: 9779\n  #   endpointPort: 19779  \n</code></pre> </li> <li> <p>Run <code>./dashboard.service start all</code> to start the services.</p> </li> </ol>"},{"location":"nebula-dashboard/2.deploy-dashboard/#deploy_dashboard_with_docker_compose","title":"Deploy Dashboard with Docker Compose","text":"<p>If you are deploying Dashboard using docker, you should also modify the configuration file <code>config.yaml</code>, and then run <code>docker-compose up -d</code> to start the container.</p> <p>Note</p> <p>If you change the port number in <code>config.yaml</code>, the port number in <code>docker-compose.yaml</code> needs to be consistent as well.</p> <p>Run <code>docker-compose stop</code> to stop the container.</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/#manage_services_in_dashboard","title":"Manage services in Dashboard","text":"<p>You can use the <code>dashboard.service</code> script to start, restart, stop, and check the Dashboard services.</p> <pre><code>sudo &lt;dashboard_path&gt;/dashboard.service\n[-v] [-h]\n&lt;start|restart|stop|status&gt;  &lt;prometheus|webserver|exporter|gateway|all&gt;\n</code></pre> Parameter Description <code>dashboard_path</code> Dashboard installation path. <code>-v</code> Display detailed debugging information. <code>-h</code> Display help information. <code>start</code> Start the target services. <code>restart</code> Restart the target services. <code>stop</code> Stop the target services. <code>status</code> Check the status of the target services. <code>prometheus</code> Set the prometheus service as the target service. <code>webserver</code> Set the webserver Service as the target service. <code>exporter</code> Set the exporter Service as the target service. <code>gateway</code> Set the gateway Service as the target service. <code>all</code> Set all the Dashboard services as the target services. <p>Note</p> <p>To view the Dashboard version, run the command <code>./dashboard.service -version</code>.</p>"},{"location":"nebula-dashboard/2.deploy-dashboard/#next_to_do","title":"Next to do","text":"<p>Connect to Dashboard</p>"},{"location":"nebula-dashboard/3.connect-dashboard/","title":"Connect Dashboard","text":"<p>After Dashboard is deployed, you can log in and use Dashboard on the browser.</p>"},{"location":"nebula-dashboard/3.connect-dashboard/#prerequisites","title":"Prerequisites","text":"<ul> <li>The Dashboard services are started. For more information, see Deploy Dashboard.</li> </ul> <ul> <li>We recommend you to use the Chrome browser of the version above 89. Otherwise, there may be compatibility issues.</li> </ul>"},{"location":"nebula-dashboard/3.connect-dashboard/#procedures","title":"Procedures","text":"<ol> <li> <p>Confirm the IP address of the machine where the Dashboard service is installed. Enter <code>&lt;IP&gt;:7003</code> in the browser to open the login page.</p> </li> <li> <p>Enter the username and the passwords of the NebulaGraph database.</p> <ul> <li>If authentication is enabled, you can log in with the created accounts.</li> </ul> <ul> <li>If authentication is not enabled, you can only log in using <code>root</code> as the username and random characters as the password.</li> </ul> <p>To enable authentication, see Authentication.</p> </li> <li> <p>Select the NebulaGraph version to be used.</p> </li> <li> <p>Click Login.</p> </li> </ol>"},{"location":"nebula-dashboard/4.use-dashboard/","title":"Dashboard","text":"<p>NebulaGraph Dashboard consists of three parts: Machine, Service, and Management. This topic will describe them in detail.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#overview","title":"Overview","text":""},{"location":"nebula-dashboard/4.use-dashboard/#machine","title":"Machine","text":"<p>Click Machine-&gt;Overview to enter the machine overview page.</p> <p>On this page, you can view the variation of CPU, Memory, Load, Disk, and Network In/Out quickly.</p> <ul> <li>By default, you can view the monitoring data for a maximum of 14 days. You can also select a time range or quickly select the latest 1 hour, 6 hours, 12 hours, 1 day, 3 days, 7 days, or 14 days.</li> <li>By default, you can view the monitoring data of all the instances in clusters. You can select the instances you want to view in the instance box.</li> <li>By default, the monitoring information page will not be updated automatically. You can set the update frequency of the monitoring information page globally or click the  button to update the page manually.</li> <li>To set a base line, click the  button.</li> <li> <p>To view the detailed monitoring information, click the  button. In this example, select <code>Load</code> for details. The figure is as follows.</p> <p></p> <ul> <li>You can set the monitoring time range, instance, update frequency and base line.</li> <li>You can search for or select the target metric. For details about monitoring metrics, see Metrics.</li> <li>You can temporarily hide nodes that you do not need to view.</li> <li>You can click the  button to view the detailed monitoring information.</li> </ul> </li> </ul>"},{"location":"nebula-dashboard/4.use-dashboard/#service","title":"Service","text":"<p>Click Service-&gt;Overview to enter the service overview page.</p> <p>On this page, you can view the information of Graph, Meta, and Storage services quickly. In the upper right corner, the number of normal services and abnormal services will be displayed.</p> <p>Note</p> <p>In the  Service page, only two monitoring metrics can be set for each service, which can be adjusted by clicking the Set up button.</p> <ul> <li>By default, you can view the monitoring data for a maximum of 14 days. You can also select a time range or quickly select the latest 1 hour, 6 hours, 12 hours, 1 day, 3 days, 7 days, or 14 days.</li> <li>By default, you can view the monitoring data of all the instances in clusters. You can select the instances you want to view in the instance box.</li> <li>By default, the monitoring information page will not be updated automatically. You can set the update frequency of the monitoring information page globally or click the  button to update the page manually.</li> <li>You can view the status of all the services in a cluster.</li> <li> <p>To view the detailed monitoring information, click the  button. In this example, select <code>Graph</code> for details. The figure is as follows.</p> <p></p> <ul> <li>You can set the monitoring time range, instance, update frequency, period, aggregation and base line.</li> <li>You can search for or select the target metric. For details of monitoring metrics, see Monitor parameter.</li> <li>You can temporarily hide nodes that you do not need to view.</li> <li>You can click the  button to view the detailed monitoring information.</li> <li>The Graph service supports a set of space-level metrics. For more information, see the following section Graph space.</li> </ul> </li> </ul>"},{"location":"nebula-dashboard/4.use-dashboard/#graph_space","title":"Graph space","text":"<p>Note</p> <p>Before using graph space metrics, you need to set <code>enable_space_level_metrics</code> to <code>true</code> in the Graph service. For details, see [Graph Service configuration](../5.configurations-and-logs/1.configurations/3.graph-config.md.</p> <p>Space-level metric incompatibility</p> <p>If a graph space name contains special characters, the corresponding metric data of that graph space may not be displayed. </p> <p>The service monitoring page can also monitor graph space level metrics. Only when the behavior of a graph space metric is triggered, you can specify the graph space to view information about the corresponding graph space metric.</p> <p>Space graph metrics record the information of different graph spaces separately. Currently, only the Graph service supports a set of space-level metrics.</p> <p>For information about the space graph metrics, see Graph space.</p> <p></p>"},{"location":"nebula-dashboard/4.use-dashboard/#management","title":"Management","text":""},{"location":"nebula-dashboard/4.use-dashboard/#overview_info","title":"Overview info","text":"<p>On the Overview Info page, you can see the information of the NebulaGraph cluster, including Storage leader distribution, Storage service details, versions and hosts information of each NebulaGraph service, and partition distribution and details.</p> <p></p>"},{"location":"nebula-dashboard/4.use-dashboard/#storage_leader_distribution","title":"Storage Leader Distribution","text":"<p>In this section, the number of Leaders and the Leader distribution will be shown.</p> <ul> <li>Click the Balance Leader button in the upper right corner to distribute Leaders evenly and quickly in the NebulaGraph cluster. For details about the Leader, see Storage Service.</li> </ul> <ul> <li>Click Detail in the upper right corner to view the details of the Leader distribution.</li> </ul>"},{"location":"nebula-dashboard/4.use-dashboard/#version","title":"Version","text":"<p>In this section, the version and host information of each NebulaGraph service will be shown. Click Detail in the upper right corner to view the details of the version and host information.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#service_information","title":"Service information","text":"<p>In this section, the information on Storage services will be shown. The parameter description is as follows:</p> Parameter Description <code>Host</code> The IP address of the host. <code>Port</code> The port of the host. <code>Status</code> The host status. <code>Git Info Sha</code> The commit ID of the current version. <code>Leader Count</code> The number of Leaders. <code>Partition Distribution</code> The distribution of partitions. <code>Leader Distribution</code> The distribution of Leaders. <p>Click Detail in the upper right corner to view the details of the Storage service information.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#partition_distribution","title":"Partition Distribution","text":"<p>Select the specified graph space in the upper left corner, you can view the distribution of partitions in the specified graph space. You can see the IP addresses and ports of all Storage services in the cluster, and the number of partitions in each Storage service.</p> <p>Click Detail in the upper right corner to view more details.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#partition_information","title":"Partition information","text":"<p>In this section, the information on partitions will be shown. Before viewing the partition information, you need to select a graph space in the upper left corner. The parameter description is as follows:</p> Parameter Description <code>Partition ID</code> The ID of the partition. <code>Leader</code> The IP address and port of the leader. <code>Peers</code> The IP addresses and ports of all the replicas. <code>Losts</code> The IP addresses and ports of faulty replicas. <p>Click Detail in the upper right corner to view details. You can also enter the partition ID into the input box in the upper right corner of the details page to filter the shown data. </p>"},{"location":"nebula-dashboard/4.use-dashboard/#config","title":"Config","text":"<p>It shows the configuration of the NebulaGraph service. NebulaGraph Dashboard Community Edition does not support online modification of configurations for now.</p>"},{"location":"nebula-dashboard/4.use-dashboard/#others","title":"Others","text":"<p>In the lower left corner of the page, you can:</p> <ul> <li>Sign out</li> </ul> <ul> <li>Switch between Chinese and English</li> </ul> <ul> <li>View the current Dashboard release</li> </ul> <ul> <li>View the user manual and forum</li> </ul> <ul> <li>Fold the sidebar</li> </ul>"},{"location":"nebula-dashboard/6.monitor-parameter/","title":"Metrics","text":"<p>This topic will describe the monitoring metrics in NebulaGraph Dashboard.</p>"},{"location":"nebula-dashboard/6.monitor-parameter/#machine","title":"Machine","text":"<p>Note</p> <ul> <li>All the machine metrics listed below are for the Linux operating system.</li> <li>The default unit in Disk and Network is byte. The unit will change with the data magnitude as the page displays. For example, when the flow is less than 1 KB/s, the unit will be Bytes/s.</li> <li>For versions of Dashboard Community Edition greater than v1.0.2, the memory occupied by Buff and Cache will not be counted in the memory usage.</li> </ul>"},{"location":"nebula-dashboard/6.monitor-parameter/#cpu","title":"CPU","text":"Parameter Description <code>cpu_utilization</code> The percentage of used CPU. <code>cpu_idle</code> The percentage of idled CPU. <code>cpu_wait</code> The percentage of CPU waiting for IO operations. <code>cpu_user</code> The percentage of CPU used by users. <code>cpu_system</code> The percentage of CPU used by the system."},{"location":"nebula-dashboard/6.monitor-parameter/#memory","title":"Memory","text":"Parameter Description <code>memory_utilization</code> The percentage of used memory. <code>memory_used</code> The memory space used (not including caches). <code>memory_free</code> The memory space available."},{"location":"nebula-dashboard/6.monitor-parameter/#load","title":"Load","text":"Parameter Description <code>load_1m</code> The average load of the system in the last 1 minute. <code>load_5m</code> The average load of the system in the last 5 minutes. <code>load_15m</code> The average load of the system in the last 15 minutes."},{"location":"nebula-dashboard/6.monitor-parameter/#disk","title":"Disk","text":"Parameter Description <code>disk_used_percentage</code> The disk utilization percentage. <code>disk_used</code> The disk space used. <code>disk_free</code> The disk space available. <code>disk_readbytes</code> The number of bytes that the system reads in the disk per second. <code>disk_writebytes</code> The number of bytes that the system writes in the disk per second. <code>disk_readiops</code> The number of read queries that the disk receives per second. <code>disk_writeiops</code> The number of write queries that the disk receives per second. <code>inode_utilization</code> The percentage of used inode."},{"location":"nebula-dashboard/6.monitor-parameter/#network","title":"Network","text":"Parameter Description <code>network_in_rate</code> The number of bytes that the network card receives per second. <code>network_out_rate</code> The number of bytes that the network card sends out per second. <code>network_in_errs</code> The number of wrong bytes that the network card receives per second. <code>network_out_errs</code> The number of wrong bytes that the network card sends out per second. <code>network_in_packets</code> The number of data packages that the network card receives per second. <code>network_out_packets</code> The number of data packages that the network card sends out per second."},{"location":"nebula-dashboard/6.monitor-parameter/#service","title":"Service","text":""},{"location":"nebula-dashboard/6.monitor-parameter/#period","title":"Period","text":"<p>The period is the time range of counting metrics. It currently supports 5 seconds, 60 seconds, 600 seconds, and 3600 seconds, which respectively represent the last 5 seconds, the last 1 minute, the last 10 minutes, and the last 1 hour.</p>"},{"location":"nebula-dashboard/6.monitor-parameter/#metric_methods","title":"Metric methods","text":"Parameter Description <code>rate</code> The average rate of operations per second in a period. <code>sum</code> The sum of operations in the period. <code>avg</code> The average latency in the cycle. <code>P75</code> The 75th percentile latency. <code>P95</code> The 95th percentile latency. <code>P99</code> The 99th percentile latency. <code>P999</code> The 99.9th percentile latency. <p>Note</p> <p>Dashboard collects the following metrics from the NebulaGraph core, but only shows the metrics that are important to it. </p>"},{"location":"nebula-dashboard/6.monitor-parameter/#graph","title":"Graph","text":"Parameter Description <code>num_active_queries</code> The number of changes in the number of active queries. Formula: The number of started queries minus the number of finished queries within a specified time. <code>num_active_sessions</code> The number of changes in the number of active sessions. Formula: The number of logged in sessions minus the number of logged out sessions within a specified time.For example, when querying <code>num_active_sessions.sum.5</code>, if there were 10 sessions logged in and 30 sessions logged out in the last 5 seconds, the value of this metric is <code>-20</code> (10-30). <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions_out_of_max_allowed</code> The number of sessions that failed to authenticate logins because the value of the parameter <code>FLAG_OUT_OF_MAX_ALLOWED_CONNECTIONS</code> was exceeded. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_killed_queries</code> The number of killed queries. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries</code> The number of queries. <code>num_query_errors_leader_changes</code> The number of the raft leader changes due to query errors. <code>num_query_errors</code> The number of query errors. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>num_sentences</code> The number of statements received by the Graphd service. <code>num_slow_queries</code> The number of slow queries. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>slow_query_latency_us</code> The latency of slow queries. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>resp_part_completeness</code> The completeness of the partial success. You need to set <code>accept_partial_success</code> to <code>true</code> in the graph configuration first."},{"location":"nebula-dashboard/6.monitor-parameter/#meta","title":"Meta","text":"Parameter Description <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>heartbeat_latency_us</code> The latency of heartbeats. <code>num_heartbeats</code> The number of heartbeats. <code>num_raft_votes</code> The number of votes in Raft. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>num_agent_heartbeats</code> The number of heartbeats for the AgentHBProcessor. <code>agent_heartbeat_latency_us</code> The latency of the AgentHBProcessor. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_send_snapshot</code> The number of times that Raft sends snapshots to other nodes. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>num_start_elect</code> The number of times that Raft starts an election."},{"location":"nebula-dashboard/6.monitor-parameter/#storage","title":"Storage","text":"Parameter Description <code>add_edges_latency_us</code> The latency of adding edges. <code>add_vertices_latency_us</code> The latency of adding vertices. <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>delete_edges_latency_us</code> The latency of deleting edges. <code>delete_vertices_latency_us</code> The latency of deleting vertices. <code>get_neighbors_latency_us</code> The latency of querying neighbor vertices. <code>get_dst_by_src_latency_us</code> The latency of querying the destination vertex by the source vertex. <code>num_get_prop</code> The number of executions for the GetPropProcessor. <code>num_get_neighbors_errors</code> The number of execution errors for the GetNeighborsProcessor. <code>num_get_dst_by_src_errors</code> The number of execution errors for the GetDstBySrcProcessor. <code>get_prop_latency_us</code> The latency of executions for the GetPropProcessor. <code>num_edges_deleted</code> The number of deleted edges. <code>num_edges_inserted</code> The number of inserted edges. <code>num_raft_votes</code> The number of votes in Raft. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Storage service sent to the Meta service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Storaged service sent to the Metad service. <code>num_tags_deleted</code> The number of deleted tags. <code>num_vertices_deleted</code> The number of deleted vertices. <code>num_vertices_inserted</code> The number of inserted vertices. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>lookup_latency_us</code> The latency of executions for the LookupProcessor. <code>num_lookup_errors</code> The number of execution errors for the LookupProcessor. <code>num_scan_vertex</code> The number of executions for the ScanVertexProcessor. <code>num_scan_vertex_errors</code> The number of execution errors for the ScanVertexProcessor. <code>update_edge_latency_us</code> The latency of executions for the UpdateEdgeProcessor. <code>num_update_vertex</code> The number of executions for the UpdateVertexProcessor. <code>num_update_vertex_errors</code> The number of execution errors for the UpdateVertexProcessor. <code>kv_get_latency_us</code> The latency of executions for the Getprocessor. <code>kv_put_latency_us</code> The latency of executions for the PutProcessor. <code>kv_remove_latency_us</code> The latency of executions for the RemoveProcessor. <code>num_kv_get_errors</code> The number of execution errors for the GetProcessor. <code>num_kv_get</code> The number of executions for the GetProcessor. <code>num_kv_put_errors</code> The number of execution errors for the PutProcessor. <code>num_kv_put</code> The number of executions for the PutProcessor. <code>num_kv_remove_errors</code> The number of execution errors for the RemoveProcessor. <code>num_kv_remove</code> The number of executions for the RemoveProcessor. <code>forward_tranx_latency_us</code> The latency of transmission. <code>scan_edge_latency_us</code> The latency of executions for the ScanEdgeProcessor. <code>num_scan_edge_errors</code> The number of execution errors for the ScanEdgeProcessor. <code>num_scan_edge</code> The number of executions for the ScanEdgeProcessor. <code>scan_vertex_latency_us</code> The latency of executions for the ScanVertexProcessor. <code>num_add_edges</code> The number of times that edges are added. <code>num_add_edges_errors</code> The number of errors when adding edges. <code>num_add_vertices</code> The number of times that vertices are added. <code>num_start_elect</code> The number of times that Raft starts an election. <code>num_add_vertices_errors</code> The number of errors when adding vertices. <code>num_delete_vertices_errors</code> The number of errors when deleting vertices. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_delete_tags</code> The number of times that tags are deleted. <code>num_delete_tags_errors</code> The number of errors when deleting tags. <code>num_delete_edges</code> The number of edge deletions. <code>num_delete_edges_errors</code> The number of errors when deleting edges <code>num_send_snapshot</code> The number of times that snapshots are sent. <code>update_vertex_latency_us</code> The latency of executions for the UpdateVertexProcessor. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_update_edge</code> The number of executions for the UpdateEdgeProcessor. <code>delete_tags_latency_us</code> The latency of deleting tags. <code>num_update_edge_errors</code> The number of execution errors for the UpdateEdgeProcessor. <code>num_get_neighbors</code> The number of executions for the GetNeighborsProcessor. <code>num_get_dst_by_src</code> The number of executions for the GetDstBySrcProcessor. <code>num_get_prop_errors</code> The number of execution errors for the GetPropProcessor. <code>num_delete_vertices</code> The number of times that vertices are deleted. <code>num_lookup</code> The number of executions for the LookupProcessor. <code>num_sync_data</code> The number of times the Storage service synchronizes data from the Drainer. <code>num_sync_data_errors</code> The number of errors that occur when the Storage service synchronizes data from the Drainer. <code>sync_data_latency_us</code> The latency of the Storage service synchronizing data from the Drainer."},{"location":"nebula-dashboard/6.monitor-parameter/#graph_space","title":"Graph space","text":"<p>Note</p> <p>Space-level metrics are created dynamically, so that only when the behavior is triggered in the graph space, the corresponding metric is created and can be queried by the user.</p> Parameter Description <code>num_active_queries</code> The number of queries currently being executed. <code>num_queries</code> The number of queries. <code>num_sentences</code> The number of statements received by the Graphd service. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>num_slow_queries</code> The number of slow queries. <code>num_query_errors</code> The number of query errors. <code>num_query_errors_leader_changes</code> The number of raft leader changes due to query errors. <code>num_killed_queries</code> The number of killed queries. <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>slow_query_latency_us</code> The latency of slow queries."},{"location":"nebula-studio/system-settings/","title":"Global settings","text":"<p>This topic introduces the global settings of NebulaGraph Studio, including language switching and beta functions.</p> <ul> <li>Language: Switch between Chinese and English.</li> </ul> <ul> <li> <p>Beta functions: Switch on/off beta features, which include view schema, text to query and AI import.</p> <p>The text to query and AI import features need to be configured with AI-related configurations. See below for detailed configurations.</p> </li> </ul>"},{"location":"nebula-studio/system-settings/#text_to_query_and_ai_import","title":"Text to query and AI import","text":"<p>The text to query and AI import are artificial intelligence features developed based on the large language model (LLM) and require the following parameters to be configured.</p> Parameter Description API type The API type for AI. Valid values are <code>OpenAI</code> and <code>Aliyun</code>. URL The API URL. Fill in the correct URL format according to the corresponding API type. For example, <code>https://{your-resource-name}.openai.azure.com/openai/deployments/{deployment-id}/chat/completions?api-version={api-version}</code>\u3002 Key The key used to validate the API. The key is required when using an online large language model, and is optional depending on the actual settings when using an offline large language model. Model The version of the large language model. The model is required when using an online large language model, and is optional depending on the actual settings when using an offline large language model. Max text length The maximum length for receiving or generating a single piece of text. Unit: byte."},{"location":"nebula-studio/about-studio/st-ug-limitations/","title":"Limitations","text":"<p>This topic introduces the limitations of Studio.</p>"},{"location":"nebula-studio/about-studio/st-ug-limitations/#architecture","title":"Architecture","text":"<p>For now, Studio v3.x supports x86_64 architecture only.</p>"},{"location":"nebula-studio/about-studio/st-ug-limitations/#upload_data","title":"Upload data","text":"<p>Only CSV files without headers can be uploaded, but no limitations are applied to the size and store period for a single file. The maximum data volume depends on the storage capacity of your machine.</p>"},{"location":"nebula-studio/about-studio/st-ug-limitations/#data_backup","title":"Data backup","text":"<p>For now, only supports exporting query results in CSV format on Console, and other data backup methods are not supported.</p>"},{"location":"nebula-studio/about-studio/st-ug-limitations/#ngql_statements","title":"nGQL statements","text":"<p>On the Console page of Docker-based and RPM-based Studio v3.x, all the nGQL syntaxes except these are supported:</p> <ul> <li><code>USE &lt;space_name&gt;</code>: You cannot run such a statement on the Console page to choose a graph space. As an alternative, you can click a graph space name in the drop-down list of Current Graph Space.</li> <li>You cannot use line breaks (\\). As an alternative, you can use the Enter key to split a line.</li> </ul>"},{"location":"nebula-studio/about-studio/st-ug-limitations/#browser","title":"Browser","text":"<p>We recommend that you use the latest version of Chrome to get access to Studio. Otherwise, some features may not work properly.</p>"},{"location":"nebula-studio/about-studio/st-ug-what-is-graph-studio/","title":"What is NebulaGraph Studio","text":"<p>NebulaGraph Studio (Studio in short) is a browser-based visualization tool to manage NebulaGraph. It provides you with a graphical user interface to manipulate graph schemas, import data, and run nGQL statements to retrieve data. With Studio, you can quickly become a graph exploration expert from scratch. You can view the latest source code in the NebulaGraph GitHub repository, see nebula-studio for details.</p> <p>Note</p> <p>You can also try some functions online in Studio.</p>"},{"location":"nebula-studio/about-studio/st-ug-what-is-graph-studio/#deployment","title":"Deployment","text":"<p>In addition to deploying Studio with RPM-based, DEB-based, or Tar-based packages, or with Docker, you can also deploy Studio with Helm in the Kubernetes cluster. For more information, see Deploy Studio.</p> <p>The functions of the above four deployment methods are the same and may be restricted when using Studio. For more information, see Limitations.</p>"},{"location":"nebula-studio/about-studio/st-ug-what-is-graph-studio/#features","title":"Features","text":"<p>Studio can easily manage NebulaGraph data, with the following functions:</p> <ul> <li>On the Schema page, you can use the graphical user interface to create the space, Tag, Edge Type, Index, and view the statistics on the graph. It helps you quickly get started with NebulaGraph.</li> </ul> <ul> <li>On the Import page, you can operate batch import of vertex and edge data with clicks, and view a real-time import log.</li> </ul> <ul> <li>On the Console page, you can run nGQL statements and read the results in a human-friendly way.</li> </ul>"},{"location":"nebula-studio/about-studio/st-ug-what-is-graph-studio/#scenarios","title":"Scenarios","text":"<p>You can use Studio in one of these scenarios:</p> <ul> <li>You have a dataset, and you want to explore and analyze data in a visualized way. You can use Docker Compose to deploy NebulaGraph and then use Studio to explore or analyze data in a visualized way. </li> </ul> <ul> <li>You are a beginner of nGQL (NebulaGraph Query Language) and you prefer to use a GUI rather than a command-line interface (CLI) to learn the language.  </li> </ul>"},{"location":"nebula-studio/about-studio/st-ug-what-is-graph-studio/#authentication","title":"Authentication","text":"<p>Authentication is not enabled in NebulaGraph by default. Users can log into Studio with the <code>root</code> account and any password.</p> <p>When NebulaGraph enables authentication, users can only sign into Studio with the specified account. For more information, see Authentication.</p>"},{"location":"nebula-studio/about-studio/st-ug-what-is-graph-studio/#version_compatibility","title":"Version compatibility","text":"<p>Note</p> <p>The Studio version is released independently of the NebulaGraph core. The correspondence between the versions of Studio and the NebulaGraph core, as shown in the table below.</p> NebulaGraph version Studio version 3.8.0 3.10.0\u30013.9.x 3.6.0 3.8.0, 3.7.0 3.5.0 3.7.0 3.4.0 ~ 3.4.1 3.7.0\u30013.6.0\u30013.5.1\u30013.5.0 3.3.0 3.5.1\u30013.5.0 3.0.0 \uff5e 3.2.0 3.4.1\u30013.4.0 3.1.0 3.3.2 3.0.0 3.2.x 2.6.x 3.1.x 2.6.x 3.1.x 2.0 &amp; 2.0.1 2.x 1.x 1.x"},{"location":"nebula-studio/about-studio/st-ug-what-is-graph-studio/#check_updates","title":"Check updates","text":"<p>Studio is in development. Users can view the latest releases features through Changelog.</p> <p>To view the Changelog, on the upper-right corner of the page, click the version and then New version.</p> <p></p>"},{"location":"nebula-studio/deploy-connect/st-ug-connect/","title":"Connect to NebulaGraph","text":"<p>After successfully launching Studio, you need to configure to connect to NebulaGraph. This topic describes how Studio connects to the NebulaGraph database.</p>"},{"location":"nebula-studio/deploy-connect/st-ug-connect/#prerequisites","title":"Prerequisites","text":"<p>Before connecting to the NebulaGraph database, you need to confirm the following information:</p> <ul> <li>The NebulaGraph services and Studio are started. For more information, see Deploy Studio.</li> </ul> <ul> <li>You have the local IP address and the port used by the Graph service of NebulaGraph. The default port is <code>9669</code>.  </li> </ul> <ul> <li>You have a NebulaGraph account and its password.</li> </ul>"},{"location":"nebula-studio/deploy-connect/st-ug-connect/#procedure","title":"Procedure","text":"<p>To connect Studio to NebulaGraph, follow these steps:</p> <ol> <li> <p>Type <code>http://&lt;ip_address&gt;:7001</code> in the address bar of your browser.</p> <p>The following login page shows that Studio starts successfully.</p> <p></p> </li> <li> <p>On the Config Server page of Studio, configure these fields:</p> <ul> <li> <p>Graphd IP address: Enter the IP address of the Graph service of NebulaGraph. For example, <code>192.168.10.100</code>.</p> <p>Note</p> <ul> <li>When NebulaGraph and Studio are deployed on the same machine, you must enter the IP address of the machine, instead of <code>127.0.0.1</code> or <code>localhost</code>.</li> <li>When connecting to a NebulaGraph database on a new browser tab, a new session will overwrite the sessions of the old tab. If you need to log in to multiple NebulaGraph databases simultaneously, you can use a different browser or non-trace mode.</li> </ul> </li> </ul> <ul> <li>Port: The port of the Graph service. The default port is <code>9669</code>.</li> </ul> <ul> <li> <p>Username and Password: Fill in the log in account according to the authentication settings of NebulaGraph.</p> <ul> <li>If authentication is not enabled, you can use <code>root</code> and any password as the username and its password.</li> </ul> <ul> <li>If authentication is enabled and no account information has been created, you can only log in as GOD role and use <code>root</code> and <code>nebula</code> as the username and its password.</li> </ul> <ul> <li>If authentication is enabled and different users are created and assigned roles, users in different roles log in with their accounts and passwords.</li> </ul> </li> </ul> </li> <li> <p>After the configuration, click the Connect button.</p> <p>Note</p> <p>One session continues for up to 30 minutes. If you do not operate Studio within 30 minutes, the active session will time out and you must connect to NebulaGraph again.</p> </li> </ol> <p>A welcome page is displayed on the first login, showing the relevant functions according to the usage process, and the test datasets can be automatically downloaded and imported.</p> <p>To visit the welcome page, click .</p>"},{"location":"nebula-studio/deploy-connect/st-ug-connect/#next_to_do","title":"Next to do","text":"<p>When Studio is successfully connected to NebulaGraph, you can do these operations:</p> <ul> <li>Create a schema on the Console page or on the Schema page.</li> <li>Batch import data on the Import page.</li> <li>Execute nGQL statements on the Console page.</li> <li>Design the schema visually on the Schema drafting page.</li> </ul> <p>Note</p> <p>The permissions of an account determine the operations that can be performed. For details, see Roles and privileges.</p>"},{"location":"nebula-studio/deploy-connect/st-ug-connect/#log_out","title":"Log out","text":"<p>If you want to reconnect to NebulaGraph, you can log out and reconfigure the database.</p> <p>Click the user profile picture in the upper right corner, and choose Log out.</p>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/","title":"Deploy Studio","text":"<p>This topic describes how to deploy Studio locally by RPM, DEB, tar package and Docker.</p>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#rpm-based_studio","title":"RPM-based Studio","text":""},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#prerequisites","title":"Prerequisites","text":"<p>Before you deploy RPM-based Studio, you must confirm that:</p> <ul> <li>The NebulaGraph services are deployed and started. For more information, see NebulaGraph Database Manual.</li> </ul> <ul> <li>The Linux distribution is CentOS, install <code>lsof</code>.</li> </ul> <ul> <li> <p>Before the installation starts, the following ports are not occupied.</p> Port Description 7001 Web service provided by Studio. </li> </ul>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#install","title":"Install","text":"<ol> <li> <p>Select and download the RPM package according to your needs. It is recommended to select the latest version. Common links are as follows:</p> Installation package Checksum NebulaGraph version nebula-graph-studio-3.10.0.x86_64.rpm nebula-graph-studio-3.10.0.x86_64.rpm.sha256 3.8.0 </li> <li> <p>Use <code>sudo rpm -i &lt;rpm_name&gt;</code> to install RPM package.</p> <p>For example, install Studio 3.10.0, use the following command. The default installation path is <code>/usr/local/nebula-graph-studio</code>.  <pre><code>$ sudo rpm -i nebula-graph-studio-3.10.0.x86_64.rpm\n</code></pre></p> <p>You can also install it to the specified path using the following command:  <pre><code>$ sudo rpm -i nebula-graph-studio-3.10.0.x86_64.rpm --prefix=&lt;path&gt; \n</code></pre></p> <p>When the screen returns the following message, it means that the PRM-based Studio has been successfully started.</p> <pre><code>Start installing NebulaGraph Studio now...\nNebulaGraph Studio has been installed.\nNebulaGraph Studio started automatically.\n</code></pre> </li> <li> <p>When Studio is started, use <code>http://&lt;ip address&gt;:7001</code> to get access to Studio.</p> <p>If you can see the Config Server page on the browser, Studio is started successfully.</p> <p></p> </li> </ol>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#uninstall","title":"Uninstall","text":"<p>You can uninstall Studio using the following command:</p> <pre><code>$ sudo rpm -e nebula-graph-studio-3.10.0.x86_64\n</code></pre> <p>If these lines are returned, PRM-based Studio has been uninstalled.</p> <pre><code>NebulaGraph Studio removed, bye~\n</code></pre>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#exception_handling","title":"Exception handling","text":"<p>If the automatic start fails during the installation process or you want to manually start or stop the service, use the following command:</p> <ul> <li>Start the service manually <pre><code>$ bash /usr/local/nebula-graph-studio/scripts/rpm/start.sh\n</code></pre></li> </ul> <ul> <li>Stop the service manually <pre><code>$ bash /usr/local/nebula-graph-studio/scripts/rpm/stop.sh\n</code></pre></li> </ul> <p>If you encounter an error <code>bind EADDRINUSE 0.0.0.0:7001</code> when starting the service, you can use the following command to check port 7001 usage.</p> <pre><code>$ lsof -i:7001\n</code></pre> <p>If the port is occupied and the process on that port cannot be terminated, you can modify the startup port within the studio configuration and restart the service.</p> <pre><code>//Modify the studio service configuration. The default path to the configuration file is `/usr/local/nebula-graph-studio`.\n$ vi etc/studio-api.yam\n\n//Modify this port number and change it to any \nPort: 7001\n\n//Restart service\n$ systemctl restart nebula-graph-studio.service\n</code></pre>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#deb-based_studio","title":"DEB-based Studio","text":""},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#prerequisites_1","title":"Prerequisites","text":"<p>Before you deploy DEB-based Studio, you must do a check of these:</p> <ul> <li>The NebulaGraph services are deployed and started. For more information, see NebulaGraph Database Manual.</li> </ul> <ul> <li>The Linux distribution is Ubuntu.</li> </ul> <ul> <li> <p>Before the installation starts, the following ports are not occupied.</p> Port Description 7001 Web service provided by Studio </li> </ul> <ul> <li>The path <code>/usr/lib/systemd/system</code> exists in the system. If not, create it manually.</li> </ul>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#install_1","title":"Install","text":"<ol> <li> <p>Select and download the DEB package according to your needs. It is recommended to select the latest version. Common links are as follows:</p> Installation package Checksum NebulaGraph version nebula-graph-studio-3.10.0.x86_64.deb nebula-graph-studio-3.10.0.x86_64.deb.sha256 3.8.0 </li> <li> <p>Use <code>sudo dpkg -i &lt;deb_name&gt;</code> to install DEB package.</p> <p>For example, install Studio 3.10.0, use the following command:</p> <pre><code>$ sudo dpkg -i nebula-graph-studio-3.10.0.x86_64.deb\n</code></pre> </li> <li> <p>When Studio is started, use <code>http://&lt;ip address&gt;:7001</code> to get access to Studio.</p> <p>If you can see the Config Server page on the browser, Studio is started successfully.</p> <p></p> </li> </ol>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#uninstall_1","title":"Uninstall","text":"<p>You can uninstall Studio using the following command:</p> <pre><code>$ sudo dpkg -r nebula-graph-studio\n</code></pre>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#tar-based_studio","title":"tar-based Studio","text":""},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#prerequisites_2","title":"Prerequisites","text":"<p>Before you deploy tar-based Studio, you must do a check of these:</p> <ul> <li>The NebulaGraph services are deployed and started. For more information, see NebulaGraph Database Manual.</li> </ul> <ul> <li> <p>Before the installation starts, the following ports are not occupied.</p> Port Description 7001 Web service provided by Studio </li> </ul>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#install_and_deploy","title":"Install and deploy","text":"<ol> <li> <p>Select and download the tar package according to your needs. It is recommended to select the latest version. Common links are as follows:</p> Installation package Studio version nebula-graph-studio-3.10.0.x86_64.tar.gz 3.10.0 </li> <li> <p>Use <code>tar -xvf</code> to decompress the tar package.</p> <pre><code>$ tar -xvf nebula-graph-studio-3.10.0.x86_64.tar.gz\n</code></pre> </li> <li> <p>Deploy and start nebula-graph-studio.</p> <pre><code>$ cd nebula-graph-studio\n$ ./server\n</code></pre> </li> <li> <p>When Studio is started, use <code>http://&lt;ip address&gt;:7001</code> to get access to Studio.</p> <p>If you can see the Config Server page on the browser, Studio is started successfully.</p> <p></p> </li> </ol>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#stop_service","title":"Stop Service","text":"<p>You can use <code>kill pid</code> to stop the service: <pre><code>$ kill $(lsof -t -i :7001) #stop nebula-graph-studio\n</code></pre></p>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#docker-based_studio","title":"Docker-based Studio","text":""},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#prerequisites_3","title":"Prerequisites","text":"<p>Before you deploy Docker-based Studio, you must do a check of these:</p> <ul> <li>The NebulaGraph services are deployed and started. For more information, see NebulaGraph Database Manual.</li> </ul> <ul> <li>On the machine where Studio will run, Docker Compose is installed and started. For more information, see Docker Compose Documentation.</li> </ul> <ul> <li> <p>Before the installation starts, the following ports are not occupied.</p> Port Description 7001 Web service provided by Studio </li> </ul>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#procedure","title":"Procedure","text":"<p>To deploy and start Docker-based Studio, run the following commands. Here we use NebulaGraph v3.8.0 for demonstration:</p> <ol> <li> <p>Download the configuration files for the deployment.</p> Installation package NebulaGraph version nebula-graph-studio-3.10.0.tar.gz 3.8.0 </li> <li> <p>Create the <code>nebula-graph-studio-3.10.0</code> directory and decompress the installation package to the directory.</p> <pre><code>$ mkdir nebula-graph-studio-3.10.0 -zxvf nebula-graph-studio-3.10.0.gz -C nebula-graph-studio-3.10.0\n</code></pre> </li> <li> <p>Change to the <code>nebula-graph-studio-3.10.0</code> directory.    <pre><code>$ cd nebula-graph-studio-3.10.0\n</code></pre></p> </li> <li> <p>Pull the Docker image of Studio.</p> <pre><code>$ docker-compose pull\n</code></pre> </li> <li> <p>Build and start Docker-based Studio. In this command, <code>-d</code> is to run the containers in the background.</p> <pre><code>$ docker-compose up -d\n</code></pre> <p>If these lines are returned, Docker-based Studio v3.x is deployed and started.</p> <pre><code>Creating docker_web_1      ... done\n</code></pre> </li> <li> <p>When Docker-based Studio is started, use <code>http://&lt;ip address&gt;:7001</code> to get access to Studio.</p> <p>Note</p> <p>Run <code>ifconfig</code> or <code>ipconfig</code> to get the IP address of the machine where Docker-based Studio is running. On the machine running Docker-based Studio, you can use <code>http://localhost:7001</code> to get access to Studio.</p> <p>If you can see the Config Server page on the browser, Docker-based Studio is started successfully.</p> <p></p> </li> </ol>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#helm-based_studio","title":"Helm-based Studio","text":"<p>This section describes how to deploy Studio with Helm.</p>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#prerequisites_4","title":"Prerequisites","text":"<p>Before installing Studio, you need to install the following software and ensure the correct version of the software:</p> Software Requirement Kubernetes &gt;= 1.14 Helm &gt;= 3.2.0"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#install_2","title":"Install","text":"<ol> <li> <p>Use Git to clone the source code of Studio to the host.</p> <pre><code>$ git clone https://github.com/vesoft-inc/nebula-studio.git\n</code></pre> </li> <li> <p>Make the <code>nebula-studio</code> directory the current working directory.</p> <p><code>bash   $ cd nebula-studio</code></p> </li> <li> <p>Assume using release name:<code>my-studio</code>, installed Studio in Helm Chart.</p> <pre><code>$ helm upgrade --install my-studio --set service.type=NodePort --set service.port=30070 deployment/helm\n</code></pre> <p>The configuration parameters of the Helm Chart are described below.</p> Parameter Default value Description replicaCount 0 The number of replicas for Deployment. image.nebulaStudio.name vesoft/nebula-graph-studio The image name of   nebula-graph-studio. image.nebulaStudio.version v3.10.0 The image version of nebula-graph-studio. service.type ClusterIP The service type, which should be one of <code>NodePort</code>, <code>ClusterIP</code>,   and <code>LoadBalancer</code>. service.port 7001 The expose port for nebula-graph-studio's web. service.nodePort 32701 The proxy port for accessing nebula-studio outside kubernetes   cluster. resources.nebulaStudio {} The resource limits/requests for nebula-studio. persistent.storageClassName \"\" The name of storageClass. The default value will be used   if not specified. persistent.size 5Gi The persistent volume size. </li> <li> <p>When Studio is started, use <code>http://&lt;node_address&gt;:30070/</code> to get access to Studio.</p> <p>If you can see the Config Server page on the browser, Studio is started successfully.</p> <p></p> </li> </ol>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#uninstall_2","title":"Uninstall","text":"<pre><code> $ helm uninstall my-studio\n</code></pre>"},{"location":"nebula-studio/deploy-connect/st-ug-deploy/#next_to_do","title":"Next to do","text":"<p>On the Config Server page, connect Docker-based Studio to NebulaGraph. For more information, see Connect to NebulaGraph.</p>"},{"location":"nebula-studio/manage-schema/st-ug-crud-edge-type/","title":"Manage edge types","text":"<p>After a graph space is created in NebulaGraph, you can create edge types. With Studio, you can choose to use the Console page or the Schema page to create, retrieve, update, or delete edge types. This topic introduces how to use the Schema page to operate edge types in a graph space only.</p>"},{"location":"nebula-studio/manage-schema/st-ug-crud-edge-type/#prerequisites","title":"Prerequisites","text":"<p>To operate an edge type on the Schema page of Studio, you must do a check of these:</p> <ul> <li>Studio is connected to NebulaGraph.</li> <li>A graph space is created.</li> <li>Your account has the authority of GOD, ADMIN, or DBA.</li> </ul>"},{"location":"nebula-studio/manage-schema/st-ug-crud-edge-type/#create_an_edge_type","title":"Create an edge type","text":"<ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>In the Current Graph Space field, confirm the name of the graph space. If necessary, you can choose another name to change the graph space.</p> </li> <li> <p>Click the Edge Type tab and click the + Create button.</p> </li> <li> <p>On the Create Edge Type page, do these settings:</p> <ul> <li>Name: Specify an appropriate name for the edge type. In this example, <code>serve</code> is used.</li> </ul> <ul> <li>Comment (Optional): Enter the description for edge type.</li> </ul> <ul> <li> <p>Define Properties (Optional): If necessary, click + Add Property to do these settings:</p> <ul> <li>Enter a property name.</li> </ul> <ul> <li>Select a data type.</li> </ul> <ul> <li>Select whether to allow null values..</li> </ul> <ul> <li>(Optional) Enter the default value.</li> </ul> <ul> <li>(Optional) Enter the description.</li> </ul> </li> </ul> <ul> <li>Set TTL (Time To Live) (Optional): If no index is set for the edge type, you can set the TTL configuration: In the upper left corner of the Set TTL panel, click the check box to expand the panel, and configure <code>TTL_COL</code> and <code>TTL_ DURATION</code> (in seconds). For more information about both parameters, see TTL configuration.</li> </ul> </li> <li> <p>When the preceding settings are completed, in the Equivalent to the following nGQL statement panel, you can see the nGQL statement equivalent to these settings.</p> <p></p> </li> <li> <p>Confirm the settings and then click the + Create button.</p> </li> </ol> <p>When the edge type is created successfully, the Define Properties panel shows all its properties on the list.</p>"},{"location":"nebula-studio/manage-schema/st-ug-crud-edge-type/#edit_an_edge_type","title":"Edit an edge type","text":"<ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>In the Current Graph Space field, confirm the name of the graph space. If necessary, you can choose another name to change the graph space.</p> </li> <li> <p>Click the Edge Type tab, find an edge type and then click the button  in the Operations column.</p> </li> <li> <p>On the Edit page, do these operations:</p> <ul> <li>To edit a comment: Click Edit on the right of <code>Comment</code>.</li> <li>To edit a property: On the Define Properties panel, find a property, click Edit, and then change the data type or the default value.</li> </ul> <ul> <li>To delete a property: On the Define Properties panel, find a property, click Delete.</li> </ul> <ul> <li>To add more properties: On the Define Properties panel, click the Add Property button to add a new property.</li> </ul> <ul> <li>To set the TTL configuration: In the upper left corner of the Set TTL panel, click the check box and then set TTL.</li> </ul> <ul> <li>To delete the TTL configuration: When the Set TTL panel is expanded, in the upper left corner of the panel, click the check box to delete the configuration.</li> </ul> <ul> <li> <p>To edit the TTL configuration: On the Set TTL panel, click Edit and then change the configuration of <code>TTL_COL</code> and <code>TTL_DURATION</code> (in seconds).</p> <p>Note</p> <p>For information about the coexistence problem of TTL and index, see TTL.</p> </li> </ul> </li> </ol>"},{"location":"nebula-studio/manage-schema/st-ug-crud-edge-type/#delete_an_edge_type","title":"Delete an Edge type","text":"<p>Danger</p> <p>Confirm the impact before deleting the Edge type. The deleted data cannot be restored if it is not backup.</p> <ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>In the Current Graph Space field, confirm the name of the graph space. If necessary, you can choose another name to change the graph space.</p> </li> <li> <p>Click the Edge Type tab, find an edge type and then click the button  in the Operations column.</p> </li> <li> <p>Click OK to confirm in the pop-up dialog box.</p> </li> </ol>"},{"location":"nebula-studio/manage-schema/st-ug-crud-edge-type/#next_to_do","title":"Next to do","text":"<p>After the edge type is created, you can use the Console page to insert edge data one by one manually or use the Import page to bulk import edge data.</p>"},{"location":"nebula-studio/manage-schema/st-ug-crud-index/","title":"Manage indexes","text":"<p>You can create an index for a Tag and/or an Edge type. An index lets traversal start from vertices or edges with the same property and it can make a query more efficient. With Studio, you can use the Console page or the Schema page to create, retrieve, and delete indexes. This topic introduces how to use the Schema page to operate an index only.</p> <p>Note</p> <p>You can create an index when a Tag or an Edge Type is created. But an index can decrease the write speed during data import. We recommend that you import data firstly and then create and rebuild an index. For more information, see Index overview.</p>"},{"location":"nebula-studio/manage-schema/st-ug-crud-index/#prerequisites","title":"Prerequisites","text":"<p>To operate an index on the Schema page of Studio, you must do a check of these:</p> <ul> <li>Studio is connected to NebulaGraph.</li> <li>A graph Space, Tags, and Edge Types are created.</li> <li>Your account has the authority of GOD, ADMIN, or DBA.</li> </ul>"},{"location":"nebula-studio/manage-schema/st-ug-crud-index/#create_an_index","title":"Create an index","text":"<ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>In the Current Graph Space field, confirm the name of the graph space. If necessary, you can choose another name to change the graph space.</p> </li> <li> <p>Click the Index tab and then click the + Create button.</p> </li> <li> <p>On the Create page, do these settings:</p> <ul> <li>Index Type: Choose to create an index for a tag or for an edge type. In this example, Edge Type is chosen.</li> </ul> <ul> <li>Associated tag name: Choose a tag name or an edge type name. In this example, follow is chosen.</li> </ul> <ul> <li>Index Name: Specify a name for the new index. In this example, follow_index is used.</li> </ul> <ul> <li>Comment (Optional): Enter the description for index.</li> </ul> <ul> <li> <p>Indexed Properties (Optional): Click Add property, and then, in the dialog box, choose a property. If necessary, repeat this step to choose more properties. You can drag the properties to sort them. In this example, <code>degree</code> is chosen.</p> <p>Note</p> <p>The order of the indexed properties has an effect on the result of the <code>LOOKUP</code> statement. For more information, see nGQL Manual.</p> </li> </ul> </li> <li> <p>When the settings are done, the Equivalent to the following nGQL statement panel shows the statement equivalent to the settings.  </p> <p></p> </li> <li> <p>Confirm the settings and then click the + Create button. When an index is created, the index list shows the new index.</p> </li> </ol>"},{"location":"nebula-studio/manage-schema/st-ug-crud-index/#view_indexes","title":"View indexes","text":"<ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>In the Current Graph Space field, confirm the name of the graph space. If necessary, you can choose another name to change the graph space.</p> </li> <li> <p>Click the Index tab, in the upper left corner, choose an index type, Tag or Edge Type.</p> </li> <li> <p>In the list, find an index and click its row. All its details are shown in the expanded row.</p> </li> </ol>"},{"location":"nebula-studio/manage-schema/st-ug-crud-index/#rebuild_indexes","title":"Rebuild indexes","text":"<ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>In the Current Graph Space field, confirm the name of the graph space. If necessary, you can choose another name to change the graph space.</p> </li> <li> <p>Click the Index tab, in the upper left corner, choose an index type, Tag or Edge Type.</p> </li> <li> <p>Click the Index tab, find an index and then click the button Rebuild in the Operations column.</p> </li> </ol> <p>Note</p> <p>For more Information, see REBUILD INDEX.</p>"},{"location":"nebula-studio/manage-schema/st-ug-crud-index/#delete_an_index","title":"Delete an index","text":"<p>To delete an index on Schema, follow these steps:</p> <ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>In the Current Graph Space field, confirm the name of the graph space. If necessary, you can choose another name to change the graph space.</p> </li> <li> <p>Click the Index tab, find an index and then click the button  in the Operations column.</p> </li> <li> <p>Click OK to confirm in the pop-up dialog box.</p> </li> </ol>"},{"location":"nebula-studio/manage-schema/st-ug-crud-space/","title":"Manage graph spaces","text":"<p>When Studio is connected to NebulaGraph, you can create or delete a graph space. You can use the Console page or the Schema page to do these operations. This article only introduces how to use the Schema page to operate graph spaces in NebulaGraph.</p>"},{"location":"nebula-studio/manage-schema/st-ug-crud-space/#prerequisites","title":"Prerequisites","text":"<p>To operate a graph space on the Schema page of Studio, you must do a check of these:</p> <ul> <li>Studio is connected to NebulaGraph.</li> <li>Your account has the authority of GOD. It means that:<ul> <li>If the authentication is enabled in NebulaGraph, you can use <code>root</code> and any password to sign in to Studio.</li> <li>If the authentication is disabled in NebulaGraph, you must use <code>root</code> and its password to sign in to Studio.</li> </ul> </li> </ul>"},{"location":"nebula-studio/manage-schema/st-ug-crud-space/#create_a_graph_space","title":"Create a graph space","text":"<ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, click Create Space, do these settings:</p> <ul> <li>Name: Specify a name to the new graph space. In this example, <code>basketballplayer</code> is used. The name must be unique in the database.</li> </ul> <ul> <li>Vid Type: The data types of VIDs are restricted to <code>FIXED_STRING(&lt;N&gt;)</code> or <code>INT64</code>. A graph space can only select one VID type. In this example, <code>FIXED_STRING(32)</code> is used. For more information, see VID.</li> </ul> <ul> <li>Comment: Enter the description for graph space. The maximum length is 256 bytes. By default, there will be no comments on a space. But in this example, <code>Statistics of basketball players</code> is used.</li> </ul> <ul> <li>Optional Parameters: Set the values of <code>partition_num</code> and <code>replica_factor</code> respectively. In this example, these parameters are set to <code>100</code> and <code>1</code> respectively. For more information, see <code>CREATE SPACE</code> syntax.</li> </ul> <p>In the Equivalent to the following nGQL statement panel, you can see the statement equivalent to the preceding settings.</p> <pre><code>CREATE SPACE basketballplayer (partition_num = 100, replica_factor = 1, vid_type = FIXED_STRING(32)) COMMENT = \"Statistics of basketball players\"\n</code></pre> </li> <li> <p>Confirm the settings and then click the + Create button. If the graph space is created successfully, you can see it on the graph space list.</p> </li> </ol> <p></p>"},{"location":"nebula-studio/manage-schema/st-ug-crud-space/#delete_a_graph_space","title":"Delete a graph space","text":"<p>Danger</p> <p>Deleting the space will delete all the data in it, and the deleted data cannot be restored if it is not backed up.</p> <ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List, find the space you want to be deleted, and click Delete Graph Space in the Operation column.</p> <p></p> </li> <li> <p>On the dialog box, confirm the information and then click OK. </p> </li> </ol>"},{"location":"nebula-studio/manage-schema/st-ug-crud-space/#next_to_do","title":"Next to do","text":"<p>After a graph space is created, you can create or edit a schema, including:</p> <ul> <li>Operate tags</li> <li>Operate edge types</li> <li>Operate indexes</li> </ul>"},{"location":"nebula-studio/manage-schema/st-ug-crud-tag/","title":"Manage tags","text":"<p>After a graph space is created in NebulaGraph, you can create tags. With Studio, you can use the Console page or the Schema page to create, retrieve, update, or delete tags. This topic introduces how to use the Schema page to operate tags in a graph space only.</p>"},{"location":"nebula-studio/manage-schema/st-ug-crud-tag/#prerequisites","title":"Prerequisites","text":"<p>To operate a tag on the Schema page of Studio, you must do a check of these:</p> <ul> <li>Studio is connected to NebulaGraph.</li> <li>A graph space is created.</li> <li>Your account has the authority of GOD, ADMIN, or DBA.</li> </ul>"},{"location":"nebula-studio/manage-schema/st-ug-crud-tag/#create_a_tag","title":"Create a tag","text":"<ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>In the Current Graph Space field, confirm the name of the graph space. If necessary, you can choose another name to change the graph space.</p> </li> <li> <p>Click the Tag tab and click the + Create button.</p> </li> <li> <p>On the Create page, do these settings:</p> <ul> <li>Name: Specify an appropriate name for the tag. In this example, <code>course</code> is specified.</li> </ul> <ul> <li>Comment (Optional): Enter the description for tag.</li> </ul> <ul> <li> <p>Define Properties (Optional): If necessary, click + Add Property to do these settings:</p> <ul> <li>Enter a property name.</li> </ul> <ul> <li>Select a data type.</li> </ul> <ul> <li>Select whether to allow null values..</li> </ul> <ul> <li>(Optional) Enter the default value.</li> </ul> <ul> <li>(Optional) Enter the description.</li> </ul> <ul> <li>Set TTL (Time To Live) (Optional): If no index is set for the tag, you can set the TTL configuration: In the upper left corner of the Set TTL panel, click the check box to expand the panel, and configure <code>TTL_COL</code> and <code>TTL_ DURATION</code> (in seconds). For more information about both parameters, see TTL configuration.</li> </ul> </li> </ul> </li> <li> <p>When the preceding settings are completed, in the Equivalent to the following nGQL statement panel, you can see the nGQL statement equivalent to these settings.</p> <p></p> </li> <li> <p>Confirm the settings and then click the + Create button. </p> </li> </ol> <p>When the tag is created successfully, the Define Properties panel shows all its properties on the list.</p>"},{"location":"nebula-studio/manage-schema/st-ug-crud-tag/#edit_a_tag","title":"Edit a tag","text":"<ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>In the Current Graph Space field, confirm the name of the graph space. If necessary, you can choose another name to change the graph space.</p> </li> <li> <p>Click the Tag tab, find a tag and then click the button  in the Operations column.</p> </li> <li> <p>On the Edit page, do these operations:</p> <ul> <li>To edit a Comment: Click Edit on the right of <code>Comment</code>.</li> </ul> <ul> <li>To edit a property: On the Define Properties panel, find a property, click Edit, and then change the data type or the default value.</li> </ul> <ul> <li>To delete a property: On the Define Properties panel, find a property, click Delete.</li> </ul> <ul> <li>To add more properties: On the Define Properties panel, click the Add Property button to add a new property.</li> </ul> <ul> <li>To set the TTL configuration: In the upper left corner of the Set TTL panel, click the check box and then set TTL.</li> </ul> <ul> <li>To delete the TTL configuration: When the Set TTL panel is expanded, in the upper left corner of the panel, click the check box to delete the configuration.</li> </ul> <ul> <li> <p>To edit the TTL configuration: On the Set TTL panel, click Edit and then change the configuration of <code>TTL_COL</code> and <code>TTL_DURATION</code> (in seconds).</p> <p>Note</p> <p>For the problem of the coexistence of TTL and index, see TTL.</p> </li> </ul> </li> </ol>"},{"location":"nebula-studio/manage-schema/st-ug-crud-tag/#delete_a_tag","title":"Delete a tag","text":"<p>Danger</p> <p>Confirm the impact before deleting the tag. The deleted data cannot be restored if it is not backup.</p> <ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>In the Current Graph Space field, confirm the name of the graph space. If necessary, you can choose another name to change the graph space.</p> </li> <li> <p>Click the Tag tab, find an tag and then click the button  in the Operations column.</p> </li> <li> <p>Click OK to confirm delete a tag in the pop-up dialog box.</p> </li> </ol>"},{"location":"nebula-studio/manage-schema/st-ug-crud-tag/#next_to_do","title":"Next to do","text":"<p>After the tag is created, you can use the Console page to insert vertex data one by one manually or use the Import page to bulk import vertex data.</p>"},{"location":"nebula-studio/manage-schema/st-ug-view-schema/","title":"View Schema","text":"<p>Users can visually view schemas in NebulaGraph Studio.</p>"},{"location":"nebula-studio/manage-schema/st-ug-view-schema/#steps","title":"Steps","text":"<ol> <li> <p>In the toolbar, click the Schema tab.</p> </li> <li> <p>In the Graph Space List page, find a graph space and then click its name or click Schema in the Operations column.</p> </li> <li> <p>Click View Schema tab and click the Get Schema button.</p> </li> </ol>"},{"location":"nebula-studio/manage-schema/st-ug-view-schema/#other_operations","title":"Other operations","text":"<p>In the Graph Space List page, find a graph space and then perform the following operations in the Operations column:</p> <ul> <li>View Schema DDL: Displays schema creation statements for the graph space, including graph spaces, tags, edge types, and indexes.</li> <li>Clone Graph Space: Clones the schema of the graph space to a new graph space.</li> <li>Delete Graph pace: Deletes the graph space, including the schema and all vertices and edges.</li> </ul>"},{"location":"nebula-studio/quick-start/draft/","title":"Schema drafting","text":"<p>Studio supports the schema drafting function. Users can design their schemas on the canvas to visually display the relationships between vertices and edges, and apply the schema to a specified graph space after the design is completed.</p>"},{"location":"nebula-studio/quick-start/draft/#features","title":"Features","text":"<ul> <li>Design schema visually.</li> <li>Applies schema to a specified graph space.</li> <li>Export the schema as a PNG image.</li> </ul>"},{"location":"nebula-studio/quick-start/draft/#entry","title":"Entry","text":"<p>At the top navigation bar, click  .</p>"},{"location":"nebula-studio/quick-start/draft/#design_schema","title":"Design schema","text":"<p>The following steps take designing the schema of the <code>basketballplayer</code> dataset as an example to demonstrate how to use the schema drafting function.</p> <ol> <li>At the upper left corner of the page, click New.</li> <li>Create a tag by selecting the appropriate color tag under the canvas. You can hold down the left button and drag the tag into the canvas.</li> <li>Click the tag. On the right side of the page, you need to fill in the name of the tag as <code>player</code>, and add two properties <code>name</code> and <code>age</code>.</li> <li>Create a tag again. The name of the tag is <code>team</code>, and the property is <code>name</code>.</li> <li>Connect from the anchor point of the tag <code>player</code> to the anchor point of the tag <code>team</code>. Click the generated edge, fill in the name of the edge type as <code>serve</code>, and add two properties <code>start_year</code> and <code>end_year</code>.</li> <li>Connect from an anchor point of the tag <code>player</code> to another one of its own. Click the generated edge, fill in the name of the edge type as <code>follow</code>, and add a property <code>degree</code>.</li> <li>After the design is complete, click  at the top of the page to change the name of the draft, and then click  at the top right corner to save the draft.</li> </ol> <p></p>"},{"location":"nebula-studio/quick-start/draft/#apply_schema","title":"Apply schema","text":"<ol> <li>Select the draft that you want to import from the Draft list on the left side of the page, and then click Apply to Space at the upper right corner.</li> <li> <p>Import the schema to a new or existing space, and click Confirm.</p> <p>Note</p> <ul> <li>For more information about the parameters for creating a graph space, see CREATE SPACE.</li> <li>If the same schema exists in the graph space, the import operation fails, and the system prompts you to modify the name or change the graph space.</li> </ul> </li> </ol>"},{"location":"nebula-studio/quick-start/draft/#modify_schema","title":"Modify schema","text":"<p>Select the schema draft that you want to modify from the Draft list on the left side of the page. Click  at the upper right corner after the modification.</p> <p>Note</p> <p>The graph space to which the schema has been applied will not be modified synchronously.</p>"},{"location":"nebula-studio/quick-start/draft/#delete_schema","title":"Delete schema","text":"<p>Select the schema draft that you want to delete from the Draft list on the left side of the page, click X at the upper right corner of the thumbnail, and confirm to delete it.</p>"},{"location":"nebula-studio/quick-start/draft/#export_schema","title":"Export Schema","text":"<p>Click  at the upper right corner to export the schema as a PNG image.</p>"},{"location":"nebula-studio/quick-start/st-ug-console/","title":"Console","text":"<p>Studio console interface is shown as follows.</p>"},{"location":"nebula-studio/quick-start/st-ug-console/#entry","title":"Entry","text":"<p>In the top navigation bar, click Console.</p>"},{"location":"nebula-studio/quick-start/st-ug-console/#overview","title":"Overview","text":"<p>The following table lists the functions on the console page.</p> number function descriptions 1 View the schema Display the schemas of the graph spaces. 2 Select a space Select a space in the graph space drop down list. The console does not support using the <code>USE &lt;space_name&gt;</code> statement to switch graph spaces. 3 Favorites Click the  button to expand the favorites. Select a statement, and it automatically populates the input box. 4 History list Click the  button to view the execution history. In the execution history list, click one of the statements, and the statement is automatically populates the input box. The list provides the record of the last 15 statements.Type <code>/</code> in the input box to quickly select a historical query statement. 5 Clean input box Click the  button to clear the content populated in the input box. 6 Run After entering the nGQL statement in the input box, click the  button to start running the statement. 7 Input box The area where the nGQL statement is entered. The statement displays different colors depending on the schemas or character strings. Code auto-completion is supported. You can quickly enter a tag or edge type based on the schema.You can input multiple statements and run them at the same time by using the separator <code>;</code>. Use the symbol <code>//</code> to add comments.Support right-clicking on a selected statement and then performing operations such as cut, copy, or run. 8 Custom parameters display Click the  button to expand the custom parameters for the parameterized query. For details, see Manage parameters. 9 Statement running status After running the nGQL statement, the statement running status is displayed. If the statement runs successfully, the statement is displayed in green. If the statement fails, the statement is displayed in red. 10 Add to favorites Click the  button to save the statement as a favorite. The button for the favorite statement is colored in yellow. 11 Export CSV file or PNG file After running the nGQL statement to return the result, when the result is in the Table window, click the  button to export as a CSV file. Switch to the Graph window and click the  button to export the results as a CSV file or a PNG image. 12 Expand/hide execution results Click the  button to hide the result or click  to expand the result. 13 Close execution results Click the  button to close the result returned by this nGQL statement. 14 Table window Display the results returned by the nGQL statement in a table. 15 Plan window Display the execution plan. If an <code>EXPLAIN</code> or <code>PROFILE</code> statement is executed, the window presents the execution plan in visual form. See the description of the execution plan below. 16 Graph window Display the results returned by the nGQL statement in a graph if the results contain complete vertex and edge information. Click the  button on the right to view the overview panel. 17 AI Assistant You can chat with an AI assistant to convert natural language instructions into nGQL query statements and then copy the nGQL statements into the input box with one click. This feature needs to be set up and enabled in the system settings before use.Note: The schema information of the current graph space is sent to the large language model when you chat with the assistant. Please pay attention to information security.You can click the text2match toggle to switch between general Q&amp;A and query Q&amp;A. The query Q&amp;A can convert the natural language instructions to nGQL query statements."},{"location":"nebula-studio/quick-start/st-ug-console/#execution_plan_descriptions","title":"Execution plan descriptions","text":"<p>The Studio can display the execution plan of the statement. The execution plan descriptions are as follows.</p> <p></p> No. Description 1 An <code>EXPLAIN</code> or <code>PROFILE</code> statement. 2 The operators used by the execution plan, which are sorted according to the execution duration. The top three operators are labeled as red, orange, and yellow, respectively. Clicking on an operator directly selects the corresponding operator in the operator execution flow and displays the operator information.Note: The <code>PROFILE</code> statement actually executes the statement, and the actual execution durations can be obtained and sorted. The <code>EXPLAIN</code> statement does not execute the statement, and all operators are considered to have the same execution duration and are all labeled as red. 3 The operator execution flow. For each operator, the following information is displayed: in-parameters, out-parameters, and total execution duration.The <code>Select</code>, <code>Loop</code>, <code>PassThrough</code>, and <code>Start</code> operators have independent color schemes.The arrows show the direction of data flow and the number of rows. The thicker the arrows, the more rows of data. You can click on the operator to check the details of the operator on the right side. 4 The details of the operator, divided into <code>Profiling data</code> and <code>Operator info</code>.<code>Profiling data</code> shows the performance data of the operator, including the rows of data received, the execution time, the total time, etc.<code>Operator info</code> shows the detailed operation information of the operator. 5 Zoom out, zoom in, or reverse the execution flow. 6 The duration of the statement. 7 Full screen or cancel full screen."},{"location":"nebula-studio/quick-start/st-ug-create-schema/","title":"Create a schema","text":"<p>To batch import data into NebulaGraph, you must have a graph schema. You can create a schema on the Console page or on the Schema page of Studio.</p> <p>Note</p> <ul> <li>Users can use nebula-console to create a schema. For more information, see NebulaGraph Manual and Get started with NebulaGraph.</li> <li>Users can use the Schema drafting function to design schema visually. For more information, see Schema drafting.</li> </ul>"},{"location":"nebula-studio/quick-start/st-ug-create-schema/#prerequisites","title":"Prerequisites","text":"<p>To create a graph schema on Studio, you must do a check of these:</p> <ul> <li>Studio is connected to NebulaGraph.</li> </ul> <ul> <li>Your account has the privilege of GOD, ADMIN, or DBA.</li> </ul> <ul> <li>The schema is designed.</li> </ul> <ul> <li>A graph space is created.</li> </ul> <p>Note</p> <p>If no graph space exists and your account has the GOD privilege, you can create a graph space on the Console page. For more information, see CREATE SPACE.</p>"},{"location":"nebula-studio/quick-start/st-ug-create-schema/#create_a_schema_with_schema","title":"Create a schema with Schema","text":"<ol> <li> <p>Create tags. For more information, see Operate tags.</p> </li> <li> <p>Create edge types. For more information, see Operate edge types.</p> </li> </ol>"},{"location":"nebula-studio/quick-start/st-ug-create-schema/#create_a_schema_with_console","title":"Create a schema with Console","text":"<ol> <li> <p>In the toolbar, click the Console tab.</p> </li> <li> <p>In the Current Graph Space field, choose a graph space name. In this example, basketballplayer is used.</p> <p></p> </li> <li> <p>In the input box, enter these statements one by one and click the button Run.</p> <pre><code>// To create a tag named \"player\", with two property\nnebula&gt; CREATE TAG player(name string, age int);\n\n// To create a tag named \"team\", with one property\nnebula&gt; CREATE TAG team(name string);\n\n// To create an edge type named \"follow\", with one properties\nnebula&gt; CREATE EDGE follow(degree int);\n\n// To create an edge type named \"serve\", with two properties\nnebula&gt; CREATE EDGE serve(start_year int, end_year int);\n</code></pre> </li> </ol> <p>If the preceding statements are executed successfully, the schema is created. You can run the statements as follows to view the schema.</p> <pre><code>// To list all the tags in the current graph space\nnebula&gt; SHOW TAGS;\n\n// To list all the edge types in the current graph space\nnebula&gt; SHOW EDGES;\n\n// To view the definition of the tags and edge types\nDESCRIBE TAG player;\nDESCRIBE TAG team;\nDESCRIBE EDGE follow;\nDESCRIBE EDGE serve;\n</code></pre> <p>If the schema is created successfully, in the result window, you can see the definition of the tags and edge types.</p>"},{"location":"nebula-studio/quick-start/st-ug-create-schema/#next_to_do","title":"Next to do","text":"<p>When a schema is created, you can import data.</p>"},{"location":"nebula-studio/quick-start/st-ug-import-data/","title":"Import data","text":"<p>Studio supports importing data in CSV format into NebulaGraph through an interface.</p>"},{"location":"nebula-studio/quick-start/st-ug-import-data/#prerequisites","title":"Prerequisites","text":"<p>To batch import data, do a check of these:</p> <ul> <li>The schema has been created in NebulaGraph.</li> </ul> <ul> <li>The CSV files meet the demands of the schema.</li> </ul> <ul> <li>The account has GOD, ADMIN, or DBA permissions. For details, see Built-in Roles.</li> </ul>"},{"location":"nebula-studio/quick-start/st-ug-import-data/#entry","title":"Entry","text":"<p>In the top navigation bar, click Import.</p>"},{"location":"nebula-studio/quick-start/st-ug-import-data/#steps","title":"Steps","text":"<p>Importing data is divided into 2 parts, creating a new data source and creating an import task, which will be described in detail next.</p> <p>Note</p> <p>You can also import tasks via the AI Import feature, which is a beta feature that needs to be enabled and configured in the system settings before use.</p>"},{"location":"nebula-studio/quick-start/st-ug-import-data/#create_a_new_data_source","title":"Create a new data source","text":"<p>Click New Data Source in the upper right corner of the page to set the data source and its related settings. Currently, 3 types of data sources are supported.</p> Type of data source Description Cloud storage Add cloud storage as the CSV file source, which only supports cloud services compatible with the Amazon S3 interface. SFTP Add SFTP as the CSV file source. Local file Upload a local CSV file. The file size can not exceed 200 MB, please put the files exceeding the limit into other types of data sources. <p>Note</p> <ul> <li>When uploading a local CSV file, you can select more than one CSV file at one time.</li> <li>After adding a data source, you can click Data Source Management at the top of the page and switch tabs to view the details of different types of data sources, and you can also edit or delete data sources.</li> </ul>"},{"location":"nebula-studio/quick-start/st-ug-import-data/#create_an_import_task","title":"Create an import task","text":"<ol> <li> <p>Click New Import at the top left corner of the page to complete the following settings:</p> <p>Caution</p> <p>Users can also click Import Template to download the sample configuration file <code>example.yaml</code>, configure it and then upload the configuration file. Configure in the same way as NebulaGraph Importer.</p> <ul> <li>Space: The name of the graph space where the data needs to be imported.</li> <li>Task Name: automatically generated by default, can be modified.</li> <li>(optional)More configuration: You can customize the concurrency, batch size, retry times, read concurrency, and import concurrency.</li> <li> <p>Map Tags:</p> <ol> <li>Click Add Tag, and then select the tag within the added tags below.</li> <li>Click Add source file, select Data Source Type and File Path in Data source file, find the file you need to import, and then click Add.</li> <li>In the preview page, set the file separator and whether to carry the table header, and then click Confirm.</li> <li>Select the corresponding column for VID in VID Columns. You can select multiple columns to be merged into a VID, and you can also add a prefix or suffix to the VID.</li> <li>Select the corresponding column for the attribute in the properties box. For properties that can be <code>NULL</code> or have <code>DEFAULT</code> set, you can leave the corresponding column unspecified.</li> <li>Repeat steps 2 to 5 to import all the data files of the Tag selected.</li> <li>Repeat steps 1 to 6 to import all Tag data.</li> </ol> </li> </ul> <ul> <li>Map Edges: Same operation as map tags.</li> </ul> <p></p> </li> <li> <p>After completing the settings, click Import, enter the password for the NebulaGraph account, and confirm.</p> </li> </ol> <p>After the import task is created, you can view the progress of the import task in the Import Data tab, which supports operations such as filtering tasks based on graph space, editing the task, viewing logs, downloading logs, reimporting, downloading configuration files, and deleting tasks.</p>"},{"location":"nebula-studio/quick-start/st-ug-import-data/#import_data_using_ai_import","title":"Import data using AI Import","text":"<p>Note</p> <p>After the import task is completed, check whether the data is imported successfully. If not, it is recommended that you check the task logs on the import page to see whether issues such as timeouts, privacy policy violations, service interruption, or encoding errors occurred.</p> <ol> <li> <p>Click AI Import in the upper left corner of the page to complete the following settings:</p> <ul> <li>File: Select the files for import via AI import. Only local single file or local directory is currently supported. You can select only one local file or directory each time. The file needs to be a plain text file.</li> <li>Import Graph Space: The graph space where the data is to be imported. The schema of the graph space needs to be created in advance.</li> <li>Export NGQL File Path: The path to the exported nGQL file, which usually does not need to be modified.</li> <li>Attach Prompt: You can attach additional prompts to guide the data import process. The precision of the prompts directly influences the accuracy of the import results.</li> </ul> <p>You can view the <code>LLM</code> parameters related to AI import in the configuration file.</p> </li> <li> <p>After completing the settings, click Next to confirm the file for import and the AI URL to be used, and then click Start.</p> </li> </ol> <p>After the import task is created, you can view the progress of the import task on the Import Data tab, which supports operations such as viewing logs, downloading logs, reimporting, and deleting tasks.</p>"},{"location":"nebula-studio/quick-start/st-ug-import-data/#next","title":"Next","text":"<p>After completing the data import, users can access the Console page.</p>"},{"location":"nebula-studio/quick-start/st-ug-plan-schema/","title":"Design a schema","text":"<p>To manipulate graph data in NebulaGraph with Studio, you must have a graph schema. This article introduces how to design a graph schema for NebulaGraph.</p> <p>A graph schema for NebulaGraph must have these essential elements:</p> <ul> <li>Tags (namely vertex types) and their properties.</li> </ul> <ul> <li>Edge types and their properties.</li> </ul> <p>In this article, you can install the sample data set basketballplayer and use it to explore a pre-designed schema.</p> <p>This table gives all the essential elements of the schema.</p> Element Name Property name (Data type) Description Tag player - <code>name</code> (<code>string</code>) - <code>age</code> (<code>int</code>) Represents the player. Tag team - <code>name</code> (<code>string</code>) Represents the team. Edge type serve - <code>start_year</code> (<code>int</code>)  - <code>end_year</code> (<code>int</code>) Represent the players behavior.This behavior connects the player to the team, and the direction is from player to team. Edge type follow - <code>degree</code> (<code>int</code>) Represent the players behavior.This behavior connects the player to the player, and the direction is from a player to a player. <p>This figure shows the relationship (serve/follow) between a player and a team.</p> <p></p>"},{"location":"nebula-studio/troubleshooting/st-ug-config-server-errors/","title":"Connecting to the database error","text":""},{"location":"nebula-studio/troubleshooting/st-ug-config-server-errors/#problem_description","title":"Problem description","text":"<p>According to the connect Studio operation, it prompts failed.</p>"},{"location":"nebula-studio/troubleshooting/st-ug-config-server-errors/#possible_causes_and_solutions","title":"Possible causes and solutions","text":"<p>You can troubleshoot the problem by following the steps below.</p>"},{"location":"nebula-studio/troubleshooting/st-ug-config-server-errors/#step1_confirm_that_the_format_of_the_host_field_is_correct","title":"Step1: Confirm that the format of the Host field is correct","text":"<p>You must fill in the IP address (<code>graph_server_ip</code>) and port of the NebulaGraph database Graph service. If no changes are made, the port defaults to <code>9669</code>. Even if NebulaGraph and Studio are deployed on the current machine, you must use the local IP address instead of <code>127.0.0.1</code>, <code>localhost</code> or <code>0.0.0.0</code>.</p>"},{"location":"nebula-studio/troubleshooting/st-ug-config-server-errors/#step2_confirm_that_the_username_and_password_are_correct","title":"Step2: Confirm that the username and password are correct","text":"<p>If authentication is not enabled, you can use root and any password as the username and its password.</p> <p>If authentication is enabled and different users are created and assigned roles, users in different roles log in with their accounts and passwords.</p>"},{"location":"nebula-studio/troubleshooting/st-ug-config-server-errors/#step3_confirm_that_nebulagraph_service_is_normal","title":"Step3: Confirm that NebulaGraph service is normal","text":"<p>Check NebulaGraph service status. Regarding the operation of viewing services:</p> <ul> <li>If you compile and deploy NebulaGraph on a Linux server, refer to the NebulaGraph service.</li> </ul> <ul> <li>If you use NebulaGraph deployed by Docker Compose and RPM, refer to the NebulaGraph service status and ports.</li> </ul> <p>If the NebulaGraph service is normal, proceed to Step 4 to continue troubleshooting. Otherwise, please restart NebulaGraph service.</p> <p>Note</p> <p>If you used <code>docker-compose up -d</code> to satrt NebulaGraph before, you must run the <code>docker-compose down</code> to stop NebulaGraph.</p>"},{"location":"nebula-studio/troubleshooting/st-ug-config-server-errors/#step4_confirm_the_network_connection_of_the_graph_service_is_normal","title":"Step4: Confirm the network connection of the Graph service is normal","text":"<p>Run a command (for example, telnet  9669) on the Studio machine to confirm whether NebulaGraph's Graph service network connection is normal. <p>If the connection fails, check according to the following steps:</p> <ul> <li>If Studio and NebulaGraph are on the same machine, check if the port is exposed.</li> </ul> <ul> <li>If Studio and NebulaGraph are not on the same machine, check the network configuration of the NebulaGraph server, such as firewall, gateway, and port.</li> </ul> <p>If you cannot connect to the NebulaGraph service after troubleshooting with the above steps, please go to the NebulaGraph forum for consultation.</p>"},{"location":"nebula-studio/troubleshooting/st-ug-connection-errors/","title":"Cannot access to Studio","text":""},{"location":"nebula-studio/troubleshooting/st-ug-connection-errors/#problem_description","title":"Problem description","text":"<p>I follow the document description and visit <code>127.0.0.1:7001</code> or <code>0.0.0.0:7001</code> after starting Studio, why can\u2019t I open the page?</p>"},{"location":"nebula-studio/troubleshooting/st-ug-connection-errors/#possible_causes_and_solutions","title":"Possible causes and solutions","text":"<p>You can troubleshoot the problem by following the steps below.</p>"},{"location":"nebula-studio/troubleshooting/st-ug-connection-errors/#step1_confirm_system_architecture","title":"Step1: Confirm system architecture","text":"<p>It is necessary to confirm whether the machine where the Studio service is deployed is of x86_64 architecture. Currently, Studio only supports x86_64 architecture.</p>"},{"location":"nebula-studio/troubleshooting/st-ug-connection-errors/#step2_check_if_the_studio_service_starts_normally","title":"Step2: Check if the Studio service starts normally","text":"<ul> <li>For Studio deployed with RPM or DEB packages, use <code>systemctl status nebula-graph-studio</code> to see the running status.</li> </ul> <ul> <li>For Studio deployed with tar package, use <code>sudo lsof -i:7001</code> to check port status.</li> </ul> <ul> <li> <p>For Studio deployed with docker, use <code>docker-compose ps</code> to see the running status. Run <code>docker-compose ps</code> to check if the service has started normally.</p> <p>If the service is normal, the return result is as follows. Among them, the <code>State</code> column should all be displayed as <code>Up</code>.</p> <pre><code>    Name                          Command               State               Ports\n------------------------------------------------------------------------------------------------------\nnebula-web-docker_client_1     ./nebula-go-api                  Up      0.0.0.0:32782-&gt;8080/tcp\nnebula-web-docker_importer_1   nebula-importer --port=569 ...   Up      0.0.0.0:32783-&gt;5699/tcp\nnebula-web-docker_nginx_1      /docker-entrypoint.sh ngin ...   Up      0.0.0.0:7001-&gt;7001/tcp, 80/tcp\nnebula-web-docker_web_1        docker-entrypoint.sh npm r ...   Up      0.0.0.0:32784-&gt;7001/tcp\n</code></pre> </li> </ul> <p>If the above result is not returned, stop Studio and restart it first. For details, refer to Deploy Studio.</p> <p>!!! note</p> <pre><code>    If you used `docker-compose up -d` to satrt NebulaGraph before, you must run the `docker-compose down` to stop NebulaGraph.\n</code></pre>"},{"location":"nebula-studio/troubleshooting/st-ug-connection-errors/#step3_confirm_address","title":"Step3: Confirm address","text":"<p>If Studio and the browser are on the same machine, users can use <code>localhost:7001</code>, <code>127.0.0.1:7001</code> or <code>0.0.0.0:7001</code> in the browser to access Studio.</p> <p>If Studio and the browser are not on the same machine, you must enter <code>&lt;studio_server_ip&gt;:7001</code> in the browser. Among them, <code>studio_server_ip</code> refers to the IP address of the machine where the Studio service is deployed.</p>"},{"location":"nebula-studio/troubleshooting/st-ug-connection-errors/#step4_confirm_network_connection","title":"Step4: Confirm network connection","text":"<p>Run <code>curl &lt;studio_server_ip&gt;:7001</code> -I to confirm if it is normal. If it returns <code>HTTP/1.1 200 OK</code>, it means that the network is connected normally.</p> <p>If the connection is refused, check according to the following steps:</p> <p>If the connection fails, check according to the following steps:</p> <ul> <li>If Studio and NebulaGraph are on the same machine, check if the port is exposed.</li> </ul> <ul> <li>If Studio and NebulaGraph are not on the same machine, check the network configuration of the NebulaGraph server, such as firewall, gateway, and port.</li> </ul> <p>If you cannot connect to the NebulaGraph service after troubleshooting with the above steps, please go to the NebulaGraph forum for consultation.</p>"},{"location":"nebula-studio/troubleshooting/st-ug-faq/","title":"FAQ","text":"<p>Why can't I use a function?</p> <p>If you find that a function cannot be used, it is recommended to troubleshoot the problem according to the following steps:</p> <ol> <li> <p>Confirm that NebulaGraph is the latest version. If you use Docker Compose to deploy the NebulaGraph database, it is recommended to run <code>docker-compose pull &amp;&amp; docker-compose up -d</code> to pull the latest Docker image and start the container.</p> </li> <li> <p>Confirm that Studio is the latest version. For more information, refer to check updates.</p> </li> <li> <p>Search the nebula forum, nebula and nebula-studio projects on the GitHub to confirm if there are already similar problems.</p> </li> <li> <p>If none of the above steps solve the problem, you can submit a problem on the forum.</p> </li> </ol>"},{"location":"reuse/source-monitoring-metrics/","title":"Source monitoring metrics","text":""},{"location":"reuse/source-monitoring-metrics/#graph","title":"Graph","text":"Parameter Description <code>num_active_queries</code> The number of changes in the number of active queries. Formula: The number of started queries minus the number of finished queries within a specified time. <code>num_active_sessions</code> The number of changes in the number of active sessions. Formula: The number of logged in sessions minus the number of logged out sessions within a specified time.For example, when querying <code>num_active_sessions.sum.5</code>, if there were 10 sessions logged in and 30 sessions logged out in the last 5 seconds, the value of this metric is <code>-20</code> (10-30). <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions_out_of_max_allowed</code> The number of sessions that failed to authenticate logins because the value of the parameter <code>FLAG_OUT_OF_MAX_ALLOWED_CONNECTIONS</code> was exceeded. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_killed_queries</code> The number of killed queries. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries</code> The number of queries. <code>num_query_errors_leader_changes</code> The number of the raft leader changes due to query errors. <code>num_query_errors</code> The number of query errors. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>num_sentences</code> The number of statements received by the Graphd service. <code>num_slow_queries</code> The number of slow queries. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>slow_query_latency_us</code> The latency of slow queries. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>resp_part_completeness</code> The completeness of the partial success. You need to set <code>accept_partial_success</code> to <code>true</code> in the graph configuration first."},{"location":"reuse/source-monitoring-metrics/#meta","title":"Meta","text":"Parameter Description <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>heartbeat_latency_us</code> The latency of heartbeats. <code>num_heartbeats</code> The number of heartbeats. <code>num_raft_votes</code> The number of votes in Raft. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>num_agent_heartbeats</code> The number of heartbeats for the AgentHBProcessor. <code>agent_heartbeat_latency_us</code> The latency of the AgentHBProcessor. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_send_snapshot</code> The number of times that Raft sends snapshots to other nodes. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>num_start_elect</code> The number of times that Raft starts an election."},{"location":"reuse/source-monitoring-metrics/#storage","title":"Storage","text":"Parameter Description <code>add_edges_latency_us</code> The latency of adding edges. <code>add_vertices_latency_us</code> The latency of adding vertices. <code>commit_log_latency_us</code> The latency of committing logs in Raft. <code>commit_snapshot_latency_us</code> The latency of committing snapshots in Raft. <code>delete_edges_latency_us</code> The latency of deleting edges. <code>delete_vertices_latency_us</code> The latency of deleting vertices. <code>get_neighbors_latency_us</code> The latency of querying neighbor vertices. <code>get_dst_by_src_latency_us</code> The latency of querying the destination vertex by the source vertex. <code>num_get_prop</code> The number of executions for the GetPropProcessor. <code>num_get_neighbors_errors</code> The number of execution errors for the GetNeighborsProcessor. <code>num_get_dst_by_src_errors</code> The number of execution errors for the GetDstBySrcProcessor. <code>get_prop_latency_us</code> The latency of executions for the GetPropProcessor. <code>num_edges_deleted</code> The number of deleted edges. <code>num_edges_inserted</code> The number of inserted edges. <code>num_raft_votes</code> The number of votes in Raft. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Storage service sent to the Meta service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Storaged service sent to the Metad service. <code>num_tags_deleted</code> The number of deleted tags. <code>num_vertices_deleted</code> The number of deleted vertices. <code>num_vertices_inserted</code> The number of inserted vertices. <code>transfer_leader_latency_us</code> The latency of transferring the raft leader. <code>lookup_latency_us</code> The latency of executions for the LookupProcessor. <code>num_lookup_errors</code> The number of execution errors for the LookupProcessor. <code>num_scan_vertex</code> The number of executions for the ScanVertexProcessor. <code>num_scan_vertex_errors</code> The number of execution errors for the ScanVertexProcessor. <code>update_edge_latency_us</code> The latency of executions for the UpdateEdgeProcessor. <code>num_update_vertex</code> The number of executions for the UpdateVertexProcessor. <code>num_update_vertex_errors</code> The number of execution errors for the UpdateVertexProcessor. <code>kv_get_latency_us</code> The latency of executions for the Getprocessor. <code>kv_put_latency_us</code> The latency of executions for the PutProcessor. <code>kv_remove_latency_us</code> The latency of executions for the RemoveProcessor. <code>num_kv_get_errors</code> The number of execution errors for the GetProcessor. <code>num_kv_get</code> The number of executions for the GetProcessor. <code>num_kv_put_errors</code> The number of execution errors for the PutProcessor. <code>num_kv_put</code> The number of executions for the PutProcessor. <code>num_kv_remove_errors</code> The number of execution errors for the RemoveProcessor. <code>num_kv_remove</code> The number of executions for the RemoveProcessor. <code>forward_tranx_latency_us</code> The latency of transmission. <code>scan_edge_latency_us</code> The latency of executions for the ScanEdgeProcessor. <code>num_scan_edge_errors</code> The number of execution errors for the ScanEdgeProcessor. <code>num_scan_edge</code> The number of executions for the ScanEdgeProcessor. <code>scan_vertex_latency_us</code> The latency of executions for the ScanVertexProcessor. <code>num_add_edges</code> The number of times that edges are added. <code>num_add_edges_errors</code> The number of errors when adding edges. <code>num_add_vertices</code> The number of times that vertices are added. <code>num_start_elect</code> The number of times that Raft starts an election. <code>num_add_vertices_errors</code> The number of errors when adding vertices. <code>num_delete_vertices_errors</code> The number of errors when deleting vertices. <code>append_log_latency_us</code> The latency of replicating the log record to a single node by Raft. <code>num_grant_votes</code> The number of times that Raft votes for other nodes. <code>replicate_log_latency_us</code> The latency of replicating the log record to most nodes by Raft. <code>num_delete_tags</code> The number of times that tags are deleted. <code>num_delete_tags_errors</code> The number of errors when deleting tags. <code>num_delete_edges</code> The number of edge deletions. <code>num_delete_edges_errors</code> The number of errors when deleting edges <code>num_send_snapshot</code> The number of times that snapshots are sent. <code>update_vertex_latency_us</code> The latency of executions for the UpdateVertexProcessor. <code>append_wal_latency_us</code> The Raft write latency for a single WAL. <code>num_update_edge</code> The number of executions for the UpdateEdgeProcessor. <code>delete_tags_latency_us</code> The latency of deleting tags. <code>num_update_edge_errors</code> The number of execution errors for the UpdateEdgeProcessor. <code>num_get_neighbors</code> The number of executions for the GetNeighborsProcessor. <code>num_get_dst_by_src</code> The number of executions for the GetDstBySrcProcessor. <code>num_get_prop_errors</code> The number of execution errors for the GetPropProcessor. <code>num_delete_vertices</code> The number of times that vertices are deleted. <code>num_lookup</code> The number of executions for the LookupProcessor. <code>num_sync_data</code> The number of times the Storage service synchronizes data from the Drainer. <code>num_sync_data_errors</code> The number of errors that occur when the Storage service synchronizes data from the Drainer. <code>sync_data_latency_us</code> The latency of the Storage service synchronizing data from the Drainer."},{"location":"reuse/source-monitoring-metrics/#graph_space","title":"Graph space","text":"<p>Note</p> <p>Space-level metrics are created dynamically, so that only when the behavior is triggered in the graph space, the corresponding metric is created and can be queried by the user.</p> Parameter Description <code>num_active_queries</code> The number of queries currently being executed. <code>num_queries</code> The number of queries. <code>num_sentences</code> The number of statements received by the Graphd service. <code>optimizer_latency_us</code> The latency of executing optimizer statements. <code>query_latency_us</code> The latency of queries. <code>num_slow_queries</code> The number of slow queries. <code>num_query_errors</code> The number of query errors. <code>num_query_errors_leader_changes</code> The number of raft leader changes due to query errors. <code>num_killed_queries</code> The number of killed queries. <code>num_aggregate_executors</code> The number of executions for the Aggregation operator. <code>num_sort_executors</code> The number of executions for the Sort operator. <code>num_indexscan_executors</code> The number of executions for index scan operators. <code>num_auth_failed_sessions_bad_username_password</code> The number of sessions where authentication failed due to incorrect username and password. <code>num_auth_failed_sessions</code> The number of sessions in which login authentication failed. <code>num_opened_sessions</code> The number of sessions connected to the server. <code>num_queries_hit_memory_watermark</code> The number of queries reached the memory watermark. <code>num_reclaimed_expired_sessions</code> The number of expired sessions actively reclaimed by the server. <code>num_rpc_sent_to_metad_failed</code> The number of failed RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_metad</code> The number of RPC requests that the Graphd service sent to the Metad service. <code>num_rpc_sent_to_storaged_failed</code> The number of failed RPC requests that the Graphd service sent to the Storaged service. <code>num_rpc_sent_to_storaged</code> The number of RPC requests that the Graphd service sent to the Storaged service. <code>slow_query_latency_us</code> The latency of slow queries."},{"location":"reuse/source_connect-to-nebula-graph/","title":"Source connect to nebula graph","text":"<p>This topic provides basic instruction on how to use the native CLI client NebulaGraph Console to connect to NebulaGraph.</p> <p>Caution</p> <p>When connecting to NebulaGraph for the first time, you must register the Storage Service before querying data.</p> <p>NebulaGraph supports multiple types of clients, including a CLI client, a GUI client, and clients developed in popular programming languages. For more information, see the client list.</p>"},{"location":"reuse/source_connect-to-nebula-graph/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have started NebulaGraph services.</li> </ul> <ul> <li>The machine on which you plan to run NebulaGraph Console has network access to the Graph Service of NebulaGraph.</li> </ul> <ul> <li> <p>The NebulaGraph Console version is compatible with the NebulaGraph version.</p> <p>Note</p> <p>NebulaGraph Console and NebulaGraph of the same version number are the most compatible. There may be compatibility issues when connecting to NebulaGraph with a different version of NebulaGraph Console. The error message <code>incompatible version between client and server</code> is displayed when there is such an issue.</p> </li> </ul>"},{"location":"reuse/source_connect-to-nebula-graph/#steps","title":"Steps","text":"<ol> <li> <p>On the NebulaGraph Console releases page, select a NebulaGraph Console version and click Assets.</p> <p>Note</p> <p>It is recommended to select the latest version.</p> </li> <li> <p>In the Assets area, find the correct binary file for the machine where you want to run NebulaGraph Console and download the file to the machine.</p> </li> <li> <p>(Optional) Rename the binary file to <code>nebula-console</code> for convenience.</p> <p>Note</p> <p>For Windows, rename the file to <code>nebula-console.exe</code>.</p> </li> <li> <p>On the machine to run NebulaGraph Console, grant the execute permission of the nebula-console binary file to the user.</p> <p>Note</p> <p>For Windows, skip this step.</p> <pre><code>$ chmod 111 nebula-console\n</code></pre> </li> <li> <p>In the command line interface, change the working directory to the one where the nebula-console binary file is stored.</p> </li> <li> <p>Run the following command to connect to NebulaGraph.</p> <ul> <li>For Linux or macOS:</li> </ul> <pre><code>$ ./nebula-console -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <ul> <li>For Windows:</li> </ul> <pre><code>&gt; nebula-console.exe -addr &lt;ip&gt; -port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt;\n[-t 120] [-e \"nGQL_statement\" | -f filename.nGQL]\n</code></pre> <p>Parameter descriptions are as follows:</p> Parameter Description <code>-h/-help</code> Shows the help menu. <code>-addr/-address</code> Sets the IP (or hostname) of the Graph service. The default address is 127.0.0.1.  <code>-P/-port</code> Sets the port number of the graphd service. The default port number is 9669. <code>-u/-user</code> Sets the username of your NebulaGraph account. Before enabling authentication, you can use any existing username. The default username is <code>root</code>. <code>-p/-password</code> Sets the password of your NebulaGraph account. Before enabling authentication, you can use any characters as the password. <code>-t/-timeout</code> Sets an integer-type timeout threshold of the connection. The unit is millisecond. The default value is 120. <code>-e/-eval</code> Sets a string-type nGQL statement. The nGQL statement is executed once the connection succeeds. The connection stops after the result is returned. <code>-f/-file</code> Sets the path of an nGQL file. The nGQL statements in the file are executed once the connection succeeds. The result will be returned and the connection stops then. <code>-enable_ssl</code> Enables SSL encryption when connecting to NebulaGraph. <code>-ssl_root_ca_path</code> Sets the storage path of the certification authority file. <code>-ssl_cert_path</code> Sets the storage path of the certificate file. <code>-ssl_private_key_path</code> Sets the storage path of the private key file. <p>For information on more parameters, see the project repository.</p> </li> </ol>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/","title":"Source install nebula graph by rpm or deb","text":"<p>RPM and DEB are common package formats on Linux systems. This topic shows how to quickly install NebulaGraph with the RPM or DEB package.</p> <p>Note</p> <p>The console is not complied or packaged with NebulaGraph server binaries. You can install nebula-console by yourself.</p>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#prerequisites","title":"Prerequisites","text":"<ul> <li>The tool <code>wget</code> is installed.</li> </ul>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#step_1_download_the_package_from_cloud_service","title":"Step 1: Download the package from cloud service","text":"<p>Note</p> <p>NebulaGraph is currently only supported for installation on Linux systems, and only CentOS 7.x, CentOS 8.x, Ubuntu 16.04, Ubuntu 18.04, and Ubuntu 20.04 operating systems are supported. </p> <ul> <li>Download the released version.<p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/&lt;release_version&gt;/nebula-graph-&lt;release_version&gt;.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the release package <code>3.8.0</code> for <code>Centos 7.5</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>Download the release package <code>3.8.0</code> for <code>Ubuntu 1804</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/3.8.0/nebula-graph-3.8.0.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul> <ul> <li> <p>Download the nightly version.</p> <p>Danger</p> <ul> <li>Nightly versions are usually used to test new features. Do not use it in a production environment.</li> <li>Nightly versions may not be built successfully every night. And the names may change from day to day.</li> </ul> <p>URL:</p> <pre><code>//Centos 7\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el7.x86_64.rpm\n\n//Centos 8\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.el8.x86_64.rpm\n\n//Ubuntu 1604\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1604.amd64.deb\n\n//Ubuntu 1804\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu1804.amd64.deb\n\n//Ubuntu 2004\nhttps://oss-cdn.nebula-graph.io/package/nightly/&lt;yyyy.mm.dd&gt;/nebula-graph-&lt;yyyy.mm.dd&gt;-nightly.ubuntu2004.amd64.deb\n</code></pre> <p>For example, download the <code>Centos 7.5</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.el7.x86_64.rpm.sha256sum.txt\n</code></pre> <p>For example, download the <code>Ubuntu 1804</code> package developed and built in <code>2021.11.28</code>:</p> <pre><code>wget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb\nwget https://oss-cdn.nebula-graph.io/package/nightly/2021.11.28/nebula-graph-2021.11.28-nightly.ubuntu1804.amd64.deb.sha256sum.txt\n</code></pre> </li> </ul>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#step_2_install_nebulagraph","title":"Step 2: Install NebulaGraph","text":"<ul> <li> <p>Use the following syntax to install with an RPM package.</p> <pre><code>$ sudo rpm -ivh --prefix=&lt;installation_path&gt; &lt;package_name&gt;\n</code></pre> <p>The option <code>--prefix</code> indicates the installation path. The default path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install an RPM package in the default path for the 3.8.0 version, run the following command.</p> <pre><code>sudo rpm -ivh nebula-graph-3.8.0.el7.x86_64.rpm\n</code></pre> </li> </ul> <ul> <li> <p>Use the following syntax to install with a DEB package.</p> <pre><code>$ sudo dpkg -i &lt;package_name&gt;\n</code></pre> <p>Note</p> <p>Customizing the installation path is not supported when installing NebulaGraph with a DEB package. The default installation path is <code>/usr/local/nebula/</code>.</p> <p>For example, to install a DEB package for the 3.8.0 version, run the following command.</p> <pre><code>sudo dpkg -i nebula-graph-3.8.0.ubuntu1804.amd64.deb\n</code></pre> <p>Note</p> <p>The default installation path is <code>/usr/local/nebula/</code>.</p> </li> </ul>"},{"location":"reuse/source_install-nebula-graph-by-rpm-or-deb/#next_to_do","title":"Next to do","text":"<ul> <li>Start NebulaGraph </li> </ul> <ul> <li>Connect to NebulaGraph</li> </ul>"},{"location":"reuse/source_manage-service/","title":"Source manage service","text":"<p>NebulaGraph supports managing services with scripts. </p>"},{"location":"reuse/source_manage-service/#manage_services_with_script","title":"Manage services with script","text":"<p>You can use the <code>nebula.service</code> script to start, stop, restart, terminate, and check the NebulaGraph services.</p> <p>Note</p> <p><code>nebula.service</code> is stored in the <code>/usr/local/nebula/scripts</code> directory by default. If you have customized the path, use the actual path in your environment.</p>"},{"location":"reuse/source_manage-service/#syntax","title":"Syntax","text":"<pre><code>$ sudo /usr/local/nebula/scripts/nebula.service\n[-v] [-c &lt;config_file_path&gt;]\n&lt;start | stop | restart | kill | status&gt;\n&lt;metad | graphd | storaged | all&gt;\n</code></pre> Parameter Description <code>-v</code> Display detailed debugging information. <code>-c</code> Specify the configuration file path. The default path is <code>/usr/local/nebula/etc/</code>. <code>start</code> Start the target services. <code>stop</code> Stop the target services. <code>restart</code> Restart the target services. <code>kill</code> Terminate the target services. <code>status</code> Check the status of the target services. <code>metad</code> Set the Meta Service as the target service. <code>graphd</code> Set the Graph Service as the target service. <code>storaged</code> Set the Storage Service as the target service. <code>all</code> Set all the NebulaGraph services as the target services."},{"location":"reuse/source_manage-service/#start_nebulagraph","title":"Start NebulaGraph","text":"<p>Run the following command to start NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service start all\n[INFO] Starting nebula-metad...\n[INFO] Done\n[INFO] Starting nebula-graphd...\n[INFO] Done\n[INFO] Starting nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"reuse/source_manage-service/#stop_nebulagraph","title":"Stop NebulaGraph","text":"<p>Danger</p> <p>Do not run <code>kill -9</code> to forcibly terminate the processes. Otherwise, there is a low probability of data loss.</p> <p>Run the following command to stop NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service stop all\n[INFO] Stopping nebula-metad...\n[INFO] Done\n[INFO] Stopping nebula-graphd...\n[INFO] Done\n[INFO] Stopping nebula-storaged...\n[INFO] Done\n</code></pre>"},{"location":"reuse/source_manage-service/#check_the_service_status","title":"Check the service status","text":"<p>Run the following command to check the service status of NebulaGraph.</p> <pre><code>$ sudo /usr/local/nebula/scripts/nebula.service status all\n</code></pre> <ul> <li> <p>NebulaGraph is running normally if the following information is returned.</p> <pre><code>INFO] nebula-metad(33fd35e): Running as 29020, Listening on 9559\n[INFO] nebula-graphd(33fd35e): Running as 29095, Listening on 9669\n[WARN] nebula-storaged after v3.0.0 will not start service until it is added to cluster.\n[WARN] See Manage Storage hosts:ADD HOSTS in https://docs.nebula-graph.io/\n[INFO] nebula-storaged(33fd35e): Running as 29147, Listening on 9779\n</code></pre> <p>Note</p> <p>After starting NebulaGraph, the port of the <code>nebula-storaged</code> process is shown in red. Because the <code>nebula-storaged</code> process waits for the <code>nebula-metad</code> to add the current Storage service during the startup process. The Storage works after it receives the ready signal. Starting from NebulaGraph 3.0.0, the Meta service cannot directly read or write data in the Storage service that you add in the configuration file. The configuration file only registers the Storage service to the Meta service. You must run the <code>ADD HOSTS</code> command to enable the Meta to read and write data in the Storage service. For more information, see Manage Storage hosts.</p> </li> </ul> <ul> <li>If the returned result is similar to the following one, there is a problem. You may also go to the NebulaGraph community for help.<pre><code>[INFO] nebula-metad: Running as 25600, Listening on 9559\n[INFO] nebula-graphd: Exited\n[INFO] nebula-storaged: Running as 25646, Listening on 9779\n</code></pre> </li> </ul> <p>The NebulaGraph services consist of the Meta Service, Graph Service, and Storage Service. The configuration files for all three services are stored in the <code>/usr/local/nebula/etc/</code> directory by default. You can check the configuration files according to the returned result to troubleshoot problems.</p>"},{"location":"reuse/source_manage-service/#next_to_do","title":"Next to do","text":"<p>Connect to NebulaGraph</p>"},{"location":"synchronization-and-migration/2.balance-syntax/","title":"BALANCE syntax","text":"<p>We can submit tasks to load balance Storage services in NebulaGraph. For more information about storage load balancing and examples, see Storage load balance.</p> <p>Note</p> <p>For other job management commands, see Job manager and the JOB statements.</p> <p>The syntax for load balance is described as follows.</p> Syntax Description <code>SUBMIT JOB BALANCE LEADER</code> Starts a job to balance the distribution of all the storage leaders in all graph spaces. It returns the job ID. <p>For details about how to view, stop, and restart a job, see Job manager and the JOB statements.</p>"}]}